% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={The Little Book of C},
  pdfauthor={Duc-Tam Nguyen},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{The Little Book of C}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Version 0.4.0}
\author{Duc-Tam Nguyen}
\date{2025-10-16}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter{Content}\label{content}

\emph{A Friendly Guide from Numbers to Neural Networks}

\begin{itemize}
\tightlist
\item
  \href{https://github.com/little-book-of/algorithms/blob/main/releases/book.pdf}{Download
  PDF} - print-ready
\item
  \href{https://github.com/little-book-of/algorithms/blob/main/releases/book.epub}{Download
  EPUB} - e-reader friendly
\item
  \href{https://github.com/little-book-of/algorithms/blob/main/releases/book.tex}{View
  LaTex} - \texttt{.tex} source
\item
  \href{https://github.com/little-book-of/algorithms}{Source code
  (Github)} - Markdown source
\item
  \href{https://little-book-of.github.io/algorithms}{Read on GitHub
  Pages} - view online
\end{itemize}

Licensed under \textbf{CC BY-NC-SA 4.0}.

\bookmarksetup{startatroot}

\chapter{The Book}\label{the-book}

\bookmarksetup{startatroot}

\chapter{Chapter 1. Getting Started}\label{chapter-1.-getting-started}

\subsection{1. What C Is and Why It Still
Matters}\label{what-c-is-and-why-it-still-matters}

C is the language that sits closest to the machine while still feeling
human to write. It's not the newest or the easiest, but it's one of the
most powerful. Every modern operating system, compiler, and database has
a core written in C, from Linux and Git to Python's interpreter and even
parts of your browser.

Learning C gives you something no other language can: an understanding
of \emph{how computers actually work}. You'll see how memory is managed,
how data moves, how the CPU runs your code, and how everything you write
turns into tiny instructions that the machine understands.

C teaches discipline. There's no garbage collector or safety net. You
decide when to allocate memory, when to free it, and what happens when
you forget. You learn precision and control, the same skills that make
great programmers in any language.

\subsubsection{Tiny Code}\label{tiny-code}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, C World!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run this and you've done what every C programmer starts with, printing
your first line of text to the screen. It's small, but it carries the
spirit of C: direct, explicit, and clear.

\subsubsection{Why It Matters}\label{why-it-matters}

C is the foundation of all systems programming. When you understand it,
higher-level languages make more sense. You'll see why compilers work
the way they do, why memory errors happen, and how performance decisions
ripple through an entire program.

Even if you never write production C code, the mindset it builds,
careful reasoning, attention to detail, respect for the machine, will
shape how you write code in any language.

\subsubsection{Try It Yourself}\label{try-it-yourself}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install a C compiler like \texttt{gcc} or \texttt{clang}.
\item
  Save the code above into a file named \texttt{hello.c}.
\item
  Compile it:

\begin{verbatim}
gcc hello.c -o hello
\end{verbatim}
\item
  Run it:

\begin{verbatim}
./hello
\end{verbatim}
\item
  Modify the message and try printing more lines. You've just built your
  first C program.
\end{enumerate}

\subsection{2. Installing a C Compiler (gcc, clang,
tinycc)}\label{installing-a-c-compiler-gcc-clang-tinycc}

Before you can write and run C programs, you need a compiler. A compiler
is a tool that \emph{translates your human-readable code} into the
machine instructions that your CPU understands. In C, this process is
explicit, you see it, control it, and learn from it.

There are many compilers available, but three are most common:

\begin{itemize}
\tightlist
\item
  GCC (GNU Compiler Collection)**, The standard compiler on Linux and
  macOS, known for reliability and wide support.
\item
  \textbf{Clang}, A modern compiler built for speed, cleaner
  diagnostics, and integration with tools like LLVM.
\item
  \textbf{TinyCC (tcc)}, A super-lightweight compiler that's perfect for
  learning and quick testing.
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-1}

You can check if you already have a compiler installed by running one of
these commands in your terminal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}{-}version}
\FunctionTok{clang} \AttributeTok{{-}{-}version}
\ExtensionTok{tcc} \AttributeTok{{-}{-}version}
\end{Highlighting}
\end{Shaded}

If you see a version number, you're ready. If not, you'll need to
install one.

\subsubsection{Installing on Different
Systems}\label{installing-on-different-systems}

\textbf{Linux (Debian/Ubuntu):}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt update}
\FunctionTok{sudo}\NormalTok{ apt install build{-}essential}
\end{Highlighting}
\end{Shaded}

This installs GCC along with other useful tools like \texttt{make}.

\textbf{macOS (with Xcode Command Line Tools):}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{xcode{-}select} \AttributeTok{{-}{-}install}
\end{Highlighting}
\end{Shaded}

This installs Clang and the developer toolchain.

\textbf{Windows (via Mingw-w64):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to \href{https://www.mingw-w64.org/}{Mingw-w64}.
\item
  Download and install it.
\item
  Add the compiler's \texttt{bin} folder to your system PATH.
\item
  Open \texttt{cmd} or PowerShell and run \texttt{gcc\ -\/-version} to
  confirm.
\end{enumerate}

Or, if you prefer an all-in-one environment, install \textbf{WSL
(Windows Subsystem for Linux)} and use the Linux commands above.

\subsubsection{Why It Matters}\label{why-it-matters-1}

Installing a compiler is your first step toward understanding \emph{how
programs become executables}. In C, there's no hidden build system or
automatic runtime, everything that happens between writing code and
running it is visible. That clarity is part of what makes C such a
powerful learning tool.

When you install your compiler, you're also installing the ability to
explore how software really works.

\subsubsection{Try It Yourself}\label{try-it-yourself-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Open your terminal or command prompt.
\item
  Type \texttt{gcc\ -\/-version} or \texttt{clang\ -\/-version} to
  confirm installation.
\item
  Create a simple file named \texttt{test.c}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Compile it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ test.c }\AttributeTok{{-}o}\NormalTok{ test}
\end{Highlighting}
\end{Shaded}
\item
  Run it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./test}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

If it runs with no output, that's perfect, your compiler is ready.
You've just built your very first executable program from source code.

\subsection{3. Writing and Running Your First
Program}\label{writing-and-running-your-first-program}

Now that your compiler is ready, it's time to write your first real C
program. This is where the magic happens, you'll write plain text,
compile it into machine instructions, and watch your computer follow
your commands exactly.

C doesn't hide what's happening under the hood. Every step, writing,
compiling, linking, running, is visible and under your control.

\subsubsection{Tiny Code}\label{tiny-code-2}

Create a new file named \texttt{hello.c} and type this code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then, compile and run it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

You should see:

\begin{verbatim}
Hello, world!
\end{verbatim}

\subsubsection{Breaking It Down}\label{breaking-it-down}

\begin{itemize}
\item
  \texttt{\#include\ \textless{}stdio.h\textgreater{}} This tells the
  compiler to use the \emph{Standard Input/Output} library, which
  provides the \texttt{printf} function.
\item
  \texttt{int\ main(void)} Every C program starts with a \texttt{main}
  function. It's the entry point, where execution begins.
\item
  \texttt{printf("Hello,\ world!\textbackslash{}n");} This prints text
  to the screen. The \texttt{\textbackslash{}n} means ``newline,'' so
  the next output starts on a new line.
\item
  \texttt{return\ 0;} When \texttt{main} returns 0, it tells the
  operating system that your program finished successfully.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-2}

Your ``Hello, world'' may look simple, but it represents an entire
process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{The compiler} translates your text (\texttt{hello.c}) into
  object code (\texttt{hello.o}).
\item
  \textbf{The linker} combines that code with standard libraries.
\item
  \textbf{The executable} (\texttt{hello}) is pure machine instructions.
\item
  \textbf{The operating system} loads and runs it.
\end{enumerate}

Understanding this flow is what makes C special, it's not just about
writing code, but about knowing \emph{how} code becomes software.

\subsubsection{Try It Yourself}\label{try-it-yourself-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Change the message to \texttt{"Hello,\ C\ learner!"} and recompile.
\item
  Add another line:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"This is my first C program.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  Try leaving out the semicolon, what error does the compiler show?
\item
  Try removing \texttt{\#include\ \textless{}stdio.h\textgreater{}},
  what happens then?
\item
  Experiment and break things. Every error teaches you how C thinks.
\end{enumerate}

You've just written and run your first C program, a direct conversation
between you and the machine. From here, every new piece of code builds
on this simple moment of control and understanding.

\subsection{4. Anatomy of a C Program}\label{anatomy-of-a-c-program}

Now that your first program runs, let's open it up and look inside.
Every C program follows a clear structure, a set of rules that tells
both \emph{you} and the \emph{compiler} what each part means.
Understanding this structure early will help you read, write, and debug
code with confidence.

\subsubsection{Tiny Code}\label{tiny-code-3}

Here's the same program, with comments explaining each piece:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}\PreprocessorTok{      }\CommentTok{// 1. Preprocessor directive}

\CommentTok{// 2. Function definition}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}        \CommentTok{// main: entry point of every C program}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}  \CommentTok{// 3. Statement: prints a message}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}           \CommentTok{// 4. Return statement: signals success}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{The Four Main Parts}\label{the-four-main-parts}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Preprocessor Directives} Lines that begin with \texttt{\#} are
  handled before the code is even compiled. They include or define
  things that your program depends on. Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Functions} Every C program is made of functions. The function
  \texttt{main()} is special, it's where your program starts. You can
  define more functions to organize your code.
\item
  \textbf{Statements} Each instruction inside a function ends with a
  semicolon. These are the steps your program takes, one by one.
\item
  \textbf{Comments} Comments are ignored by the compiler but read by
  humans. Use them to explain \emph{why} your code does something, not
  just \emph{what} it does.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// This is a single{-}line comment}
\CommentTok{/* This is a multi{-}line comment */}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-3}

C is a \emph{structured} language. Every function, statement, and
declaration lives inside a clear boundary. Unlike scripting languages,
there's no automatic setup or hidden runtime, everything you see is
everything that runs.

Learning the anatomy of a C program gives you a mental map:

\begin{itemize}
\tightlist
\item
  You know where execution begins (\texttt{main}).
\item
  You know where code lives (inside functions).
\item
  You know where libraries come from (via includes).
\end{itemize}

Once this map becomes natural, reading even large C programs starts to
feel easy and logical.

\subsubsection{Try It Yourself}\label{try-it-yourself-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a file \texttt{structure.c} with this content:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome to C programming!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Compile and run it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ structure.c }\AttributeTok{{-}o}\NormalTok{ structure}
\ExtensionTok{./structure}
\end{Highlighting}
\end{Shaded}
\item
  Add another function, maybe \texttt{void\ bye(void)} that prints a
  goodbye message, and call it after \texttt{greet()}.
\item
  Try removing \texttt{return\ 0;}, notice how the program still runs,
  but adding it makes your intent clear.
\end{enumerate}

Every C program you'll ever write follows this basic shape. Once you can
recognize these parts, you can start building programs that are longer,
smarter, and closer to the system.

\subsection{5. Using Headers and the
Preprocessor}\label{using-headers-and-the-preprocessor}

Every C program begins before it even starts running, with something
called the \emph{preprocessor}. Before the compiler turns your code into
machine instructions, the preprocessor prepares it: it pulls in files,
replaces macros, and sets up everything your program needs. This step is
what makes \texttt{\#include\ \textless{}stdio.h\textgreater{}} work,
and it's key to understanding how larger C projects are organized.

\subsubsection{Tiny Code}\label{tiny-code-4}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}\PreprocessorTok{   }\CommentTok{// include the standard input/output header}
\PreprocessorTok{\#define PI }\FloatTok{3.14159}\PreprocessorTok{    }\CommentTok{// define a constant macro}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"PI is approximately }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ PI}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

When you compile this program, the preprocessor replaces \texttt{PI}
with \texttt{3.14159} and includes the contents of the file
\texttt{stdio.h} before the compiler even starts.

You can see the preprocessed result by running:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ program.c}
\end{Highlighting}
\end{Shaded}

It will output a much longer version of your code, showing all the lines
that \texttt{stdio.h} added behind the scenes.

\subsubsection{How Headers Work}\label{how-headers-work}

Headers are \textbf{declaration files}. They tell the compiler
\emph{what exists}, like functions, constants, and types, without
actually providing the code (the \emph{definitions}). For example,
\texttt{stdio.h} declares the function \texttt{printf()} so the compiler
knows how to call it.

There are two main ways to include headers:

\begin{itemize}
\item
  \textbf{System headers:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

  The compiler looks for these in standard library directories.
\item
  \textbf{User-defined headers:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"myutils.h"}
\end{Highlighting}
\end{Shaded}

  The compiler looks for these in your project folder first.
\end{itemize}

This separation keeps large programs modular and readable.

\subsubsection{Why It Matters}\label{why-it-matters-4}

The preprocessor is like the ``setup crew'' for your program. It doesn't
run your code, it \emph{prepares} it. By understanding headers and
macros, you can:

\begin{itemize}
\tightlist
\item
  Split big programs into smaller, reusable parts.
\item
  Define constants in one place instead of repeating values.
\item
  Write portable code that compiles on different systems.
\item
  Avoid subtle bugs caused by missing declarations.
\end{itemize}

When you write \texttt{\#include\ \textless{}stdio.h\textgreater{}},
you're tapping into decades of reliable, shared code, one of the
greatest strengths of the C ecosystem.

\subsubsection{Try It Yourself}\label{try-it-yourself-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create two files:

  \textbf{mathutils.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATHUTILS\_H}
\PreprocessorTok{\#define MATHUTILS\_H}

\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

  \textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"mathutils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"The square of }\SpecialCharTok{\%d}\StringTok{ is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ SQUARE}\OperatorTok{(}\NormalTok{n}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\ExtensionTok{./main}
\end{Highlighting}
\end{Shaded}
\item
  Try editing the macro in \texttt{mathutils.h} to add a
  \texttt{CUBE(x)} function, and use it in \texttt{main.c}.
\item
  Then run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ main.c }\KeywordTok{|} \FunctionTok{less}
\end{Highlighting}
\end{Shaded}

  to explore the preprocessed code and see how includes and macros
  expand.
\end{enumerate}

Once you grasp headers and preprocessing, you'll understand how large C
codebases stay organized, and how a simple \texttt{\#include} line can
unlock an entire library of functionality.

\subsection{6. Compiling, Linking, and
Executing}\label{compiling-linking-and-executing}

When you press \emph{Enter} to compile your C program, a lot happens
behind the scenes. Your source code goes through several stages before
it becomes a runnable executable. Understanding these steps is
essential, it turns compilation errors from mysteries into simple,
fixable clues.

\subsubsection{Tiny Code}\label{tiny-code-5}

Let's start with a familiar program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Learning the C build process!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now compile and run it step by step:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Step 1: Compile to object file}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello.o}

\CommentTok{\# Step 2: Link object file into executable}
\FunctionTok{gcc}\NormalTok{ hello.o }\AttributeTok{{-}o}\NormalTok{ hello}

\CommentTok{\# Step 3: Run the program}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Learning the C build process!
\end{verbatim}

\subsubsection{The Four Stages of Building a C
Program}\label{the-four-stages-of-building-a-c-program}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Preprocessing} The preprocessor handles all lines starting
  with \texttt{\#}. It expands macros, includes headers, and prepares
  code for compilation. Command to inspect:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ hello.c }\KeywordTok{|} \FunctionTok{less}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Compilation} The compiler translates the preprocessed code
  into \emph{assembly language}, and then into \emph{object code}. Each
  source file (like \texttt{hello.c}) becomes an object file
  (\texttt{hello.o}). Command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ hello.c}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Linking} The linker combines all object files and libraries
  into one final executable. For example, \texttt{printf} comes from the
  C standard library (\texttt{libc}), so the linker connects your code
  to it. Command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.o }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Execution} Once linked, your binary (\texttt{hello}) is loaded
  by the operating system and executed by the CPU. Command:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-5}

C gives you control over every stage of this process. Most modern
languages hide compilation or linking, but in C, these steps are
transparent and configurable. When something goes wrong, a missing
function, an undefined symbol, or a broken include, you'll know exactly
\emph{which stage} to look at.

Mastering the build process also opens the door to deeper skills:

\begin{itemize}
\tightlist
\item
  Creating reusable libraries (\texttt{.a} or \texttt{.so} files)
\item
  Understanding Makefiles and build automation
\item
  Debugging with symbols and optimized builds
\item
  Writing portable programs that compile cleanly anywhere
\end{itemize}

Every system programmer eventually learns to \emph{think like a
compiler}, and this is where that thinking begins.

\subsubsection{Try It Yourself}\label{try-it-yourself-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Experiment with separate compilation:}

  Create two files:

  \textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  \textbf{greet.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from another file!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Then compile and link:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ greet.c}
\FunctionTok{gcc}\NormalTok{ main.o greet.o }\AttributeTok{{-}o}\NormalTok{ greetprog}
\ExtensionTok{./greetprog}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Try breaking it:} Delete the \texttt{void\ greet(void);} line
  in \texttt{main.c} and recompile, see how the compiler warns you about
  an implicit declaration.
\item
  \textbf{Observe the stages:} Add flags like \texttt{-Wall\ -O2\ -v} to
  see detailed messages from the compiler and linker.
\end{enumerate}

Once you understand compilation and linking, you've unlocked one of the
most powerful parts of C, the ability to control exactly \emph{how} your
software is built, combined, and executed.

\subsection{7. Common Errors and
Warnings}\label{common-errors-and-warnings}

No C programmer avoids errors. In fact, the compiler's messages are your
best teachers. Each warning or error is the compiler's way of saying,
``Something here doesn't make sense yet.'' Learning to read and fix them
early will save you hours later and make debugging a natural part of
your process.

\subsubsection{Tiny Code}\label{tiny-code-6}

Let's look at a few examples:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"The value of a is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try compiling it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ error\_demo.c }\AttributeTok{{-}o}\NormalTok{ error\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
error_demo.c: In function ‘main':
error_demo.c:4:13: error: expected ‘;' before ‘printf'
\end{verbatim}

This means the compiler found a missing semicolon. The message even
tells you where (\texttt{line\ 4}) and why
(\texttt{expected\ \textquotesingle{};\textquotesingle{}\ before\ \textquotesingle{}printf\textquotesingle{}}).

Fix it by adding the missing semicolon:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Then compile again, clean output means success.

\subsubsection{Common Types of Errors}\label{common-types-of-errors}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Syntax Errors} These are the easiest to fix. You've broken a
  grammar rule. Example: missing \texttt{;}, mismatched braces
  \texttt{\{\}}, or incorrect parentheses.
\item
  \textbf{Type Errors} You're using variables or functions in a way that
  doesn't match their type. Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \StringTok{"hello"}\OperatorTok{;} \CommentTok{// error: assigning string to int}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Undeclared Identifiers} You're using a variable or function
  that the compiler hasn't seen yet. Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ number}\OperatorTok{);} \CommentTok{// error: ‘number\textquotesingle{} undeclared}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Linker Errors} Compilation succeeds, but linking fails because
  something is missing. Example:

\begin{verbatim}
undefined reference to `greet'
\end{verbatim}

  This means the compiler saw a declaration but couldn't find the actual
  function definition.
\item
  \textbf{Warnings} Warnings don't stop compilation, but they often
  point to potential bugs. Example:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{warning:}\NormalTok{ variable ‘x}\StringTok{\textquotesingle{} set but not used}
\end{Highlighting}
\end{Shaded}

  Always pay attention to warnings, clean builds (\texttt{no\ warnings})
  are a mark of quality code.
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-6}

Every programmer makes mistakes. What matters is how fast you can
understand what the compiler is saying. In C, error messages are usually
precise and honest, they tell you exactly what broke. By learning to
interpret them, you're training yourself to debug with logic, not luck.

Good habits:

\begin{itemize}
\tightlist
\item
  Compile often, don't wait to write 100 lines before testing.
\item
  Use \texttt{-Wall\ -Wextra} to enable all useful warnings.
\item
  Read errors \emph{top to bottom}, the first one often causes the rest.
\item
  Fix warnings even if the code still runs.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Forgetting a return type:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"No return type!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall}\NormalTok{ test.c}
\end{Highlighting}
\end{Shaded}

  You'll get:

\begin{verbatim}
warning: return type defaults to ‘int'
\end{verbatim}
\item
  \textbf{Using an undeclared variable:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  This will produce:

\begin{verbatim}
error: ‘x' undeclared
\end{verbatim}
\item
  \textbf{Fix each one} until your program compiles cleanly with no
  warnings.
\end{enumerate}

Errors are not failures, they're the compiler's way of guiding you
toward understanding. The more errors you fix, the better you become at
speaking the language of the machine.

\subsection{8. Command Line Basics for C
Developers}\label{command-line-basics-for-c-developers}

C was born in the Unix world, and the command line is its natural home.
If you can move comfortably in the terminal, you'll understand what your
tools are doing, compiling, linking, and running programs directly. This
section gives you the essential commands you'll need to build and
explore C projects like a real systems programmer.

\subsubsection{Tiny Code}\label{tiny-code-7}

Let's start with a quick refresher using a simple file \texttt{hello.c}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from the terminal!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To build and run it from the command line:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello from the terminal!
\end{verbatim}

That's the full cycle: write → compile → run. Now let's look at the
basic tools that make that process smoother.

\subsubsection{Essential Command Line
Tools}\label{essential-command-line-tools}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{\texttt{ls}} -- List files in the current directory

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ls}
\end{Highlighting}
\end{Shaded}

  You'll see files like \texttt{hello.c}, \texttt{hello.o}, or
  \texttt{hello}.
\item
  \textbf{\texttt{pwd}} -- Print the current working directory

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{pwd}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{cd}} -- Change directories

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ projects/c\_programs}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{cat}} -- Display file contents quickly

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{ hello.c}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{rm}} -- Remove files

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{clear}} -- Clear your terminal screen

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{clear}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{man}} -- Read the manual for a command

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{man}\NormalTok{ gcc}
\end{Highlighting}
\end{Shaded}

  Press \texttt{q} to exit.
\item
  \textbf{\texttt{echo}} -- Print a message or variable

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"Compiling C!"}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{touch}} -- Create a new empty file

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{touch}\NormalTok{ main.c}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{gcc}} -- Compile your C source code
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-7}

The command line isn't just for building code, it teaches you how your
tools actually work. In C, there's no hidden environment running behind
a button click. Each command you type does exactly one job, and
understanding those jobs gives you full control.

\begin{itemize}
\tightlist
\item
  You see the \textbf{build process} directly.
\item
  You control \textbf{where outputs go}.
\item
  You can \textbf{chain commands} for automation.
\end{itemize}

This mindset, knowing what happens under the hood, is what makes C
programmers comfortable working close to the machine.

\subsubsection{Try It Yourself}\label{try-it-yourself-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Navigate and build manually:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkdir}\NormalTok{ myfirstc}
\BuiltInTok{cd}\NormalTok{ myfirstc}
\FunctionTok{touch}\NormalTok{ hello.c}
\end{Highlighting}
\end{Shaded}

  Add code with your favorite text editor (like \texttt{nano\ hello.c}),
  then compile and run.
\item
  \textbf{Use compiler flags:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}O2}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    \texttt{-Wall} enables warnings.
  \item
    \texttt{-O2} applies optimization.
  \end{itemize}
\item
  \textbf{Use output redirection:}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./hello} \OperatorTok{\textgreater{}}\NormalTok{ output.txt}
\FunctionTok{cat}\NormalTok{ output.txt}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Explore commands interactively:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{man}\NormalTok{ ls}
\FunctionTok{man}\NormalTok{ gcc}
\end{Highlighting}
\end{Shaded}

  Read a few lines, knowing how to find help is as important as coding
  itself.
\end{enumerate}

C and the command line grew up together. Once you get comfortable typing
and compiling by hand, you'll start to feel how programs, files, and
processes fit together. That's the real start of systems programming,
not just writing code, but \emph{commanding the computer directly}.

\subsection{9. Setting Up a Minimal Project
Structure}\label{setting-up-a-minimal-project-structure}

As your C programs grow, you'll quickly outgrow the single-file
``hello.c'' style. Real projects are made of multiple source files,
headers, and sometimes libraries. A clear folder structure keeps your
work clean, easy to build, and easy to maintain. In this section, you'll
create a small, organized layout, the same structure used by
professionals.

\subsubsection{Tiny Code}\label{tiny-code-8}

Here's a minimal project layout:

\begin{verbatim}
my_project/
├── include/
│   └── greet.h
├── src/
│   └── greet.c
├── main.c
└── Makefile
\end{verbatim}

\textbf{include/greet.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef GREET\_H}
\PreprocessorTok{\#define GREET\_H}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\textbf{src/greet.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"greet.h"}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"greet.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{(}\StringTok{"C Learner"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}Iinclude}
\DataTypeTok{SRC} \CharTok{=}\StringTok{ main.c src/greet.c}
\DataTypeTok{OUT} \CharTok{=}\StringTok{ my\_program}

\DecValTok{$(OUT):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{SRC}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{SRC}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{OUT}\CharTok{)}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OUT}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Now build and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./my\_program}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, C Learner!
\end{verbatim}

\subsubsection{Understanding the
Structure}\label{understanding-the-structure}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{\texttt{include/}} Holds header files (\texttt{.h}),
  declarations of functions, constants, and types. You include these in
  \texttt{.c} files using quotes:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"greet.h"}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{\texttt{src/}} Contains source files (\texttt{.c}) that
  implement functions declared in headers.
\item
  \textbf{\texttt{main.c}} The entry point of your program, this file
  usually just calls functions from \texttt{src/}.
\item
  \textbf{\texttt{Makefile}} Defines how to build the program. You can
  run \texttt{make} instead of typing long \texttt{gcc} commands.
\item
  \textbf{Output binary} The compiled executable (here
  \texttt{my\_program}) stays in the project's root for convenience.
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-8}

A clear structure helps you:

\begin{itemize}
\tightlist
\item
  Keep code modular and reusable
\item
  Separate interface (\texttt{.h}) from implementation (\texttt{.c})
\item
  Make compilation faster and easier to manage
\item
  Avoid name clashes in large projects
\item
  Scale from one file to dozens without confusion
\end{itemize}

Even small C utilities benefit from structure, you'll thank yourself
later when you revisit your code.

\subsubsection{Try It Yourself}\label{try-it-yourself-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create the directories and files shown above.
\item
  Type each file carefully and run \texttt{make}.
\item
  Modify \texttt{greet.c} to print a personalized message, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Welcome back, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

  then rebuild.
\item
  Add another pair of files, \texttt{src/farewell.c} and
  \texttt{include/farewell.h}, with a goodbye function, and call it from
  \texttt{main.c}.
\item
  Run \texttt{make\ clean} to delete the binary and rebuild fresh.
\end{enumerate}

This small structure is the seed of every serious C project. Once you
can organize your files this way, you're ready to grow into larger
systems, libraries, tools, and applications that others can use and
build upon.

\bookmarksetup{startatroot}

\chapter{Chapter 2. Language Basics}\label{chapter-2.-language-basics}

\subsection{11. Data Types and
Variables}\label{data-types-and-variables}

In C, everything begins with types. A \textbf{type} tells the compiler
how much memory to reserve, how to interpret the bits stored there, and
what operations are allowed. Understanding types is the foundation of
writing safe and efficient C programs, it's how you speak the computer's
native language precisely.

\subsubsection{Tiny Code}\label{tiny-code-9}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}              \CommentTok{// integer}
    \DataTypeTok{float}\NormalTok{ height }\OperatorTok{=} \FloatTok{1.75}\OperatorTok{;}       \CommentTok{// floating{-}point number}
    \DataTypeTok{char}\NormalTok{ initial }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}        \CommentTok{// single character}
    \DataTypeTok{double}\NormalTok{ weight }\OperatorTok{=} \FloatTok{68.4}\OperatorTok{;}      \CommentTok{// double{-}precision number}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Height: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ height}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Initial: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ initial}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Weight: }\SpecialCharTok{\%.1lf\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ weight}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Age: 25
Height: 1.75
Initial: A
Weight: 68.4
\end{verbatim}

\subsubsection{Core Built-in Types}\label{core-built-in-types}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1127}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1972}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4648}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2254}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Size (Typical)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Format Specifier
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{char} & 1 byte & Single character & \texttt{\%c} \\
\texttt{int} & 4 bytes & Whole number & \texttt{\%d} \\
\texttt{float} & 4 bytes & Decimal number (single precision) &
\texttt{\%f} \\
\texttt{double} & 8 bytes & Decimal number (double precision) &
\texttt{\%lf} \\
\texttt{void} & -- & No value or type & -- \\
\end{longtable}

\begin{quote}
Sizes may vary depending on system and compiler, but the relationships
remain consistent.
\end{quote}

You can also control how numbers behave using \textbf{modifiers}:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Modifier & Example & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{short} & \texttt{short\ int\ x;} & Smaller integer (often 2
bytes) \\
\texttt{long} & \texttt{long\ int\ y;} & Larger integer (often 8
bytes) \\
\texttt{unsigned} & \texttt{unsigned\ int\ z;} & Only non-negative
values \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
\DataTypeTok{long} \DataTypeTok{long}\NormalTok{ big\_number }\OperatorTok{=} \DecValTok{1234567890123}\BuiltInTok{LL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Declaring and Initializing
Variables}\label{declaring-and-initializing-variables}

A variable is simply a \emph{named piece of memory}. You declare it by
specifying its type and name:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count}\OperatorTok{;}       \CommentTok{// declaration}
\NormalTok{count }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}       \CommentTok{// assignment}
\end{Highlighting}
\end{Shaded}

Or both together:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}   \CommentTok{// initialization}
\end{Highlighting}
\end{Shaded}

Multiple declarations:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ z }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Variables must be declared \emph{before} you use them, and their type
cannot change.

\subsubsection{Why It Matters}\label{why-it-matters-9}

C is a \textbf{statically typed language}, meaning every variable's type
is known at compile time. This makes programs faster and safer, because
the compiler can:

\begin{itemize}
\tightlist
\item
  Catch type mismatches early
\item
  Optimize memory layout
\item
  Predict storage and alignment
\end{itemize}

When you understand data types, you understand how your code maps
directly to the machine's memory.

C forces you to think carefully about \emph{what kind of data} you're
working with, a skill that improves every program you write, in any
language.

\subsubsection{Try It Yourself}\label{try-it-yourself-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a program that stores and prints:

  \begin{itemize}
  \tightlist
  \item
    Your age as an \texttt{int}
  \item
    Your height as a \texttt{float}
  \item
    Your name's first letter as a \texttt{char}
  \end{itemize}
\item
  Add two integers and print the result:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  Try using an \texttt{unsigned\ int} and print what happens if you
  assign a negative value.
\item
  Use \texttt{sizeof()} to inspect how big each type is on your system:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Size of int: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Every number, character, and pointer in C starts here, in the precise
world of types and variables. Once you're fluent in these, memory
layout, structs, and pointers will make perfect sense.

\subsection{12. Constants, Literals, and
Enumerations}\label{constants-literals-and-enumerations}

C programs often rely on values that never change, numbers, characters,
or named constants used throughout your code. Instead of sprinkling
magic numbers everywhere, you can give them meaningful names and keep
your program readable, safe, and easy to maintain.

\subsubsection{Tiny Code}\label{tiny-code-10}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define PI }\FloatTok{3.14159}\PreprocessorTok{           }\CommentTok{// preprocessor constant}
\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ DAYS\_IN\_WEEK }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}  \CommentTok{// read{-}only variable}

\KeywordTok{enum}\NormalTok{ Direction }\OperatorTok{\{}\NormalTok{ NORTH}\OperatorTok{,}\NormalTok{ EAST}\OperatorTok{,}\NormalTok{ SOUTH}\OperatorTok{,}\NormalTok{ WEST }\OperatorTok{\};} \CommentTok{// enumerated constants}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pi: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ PI}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Days in a week: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ DAYS\_IN\_WEEK}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Direction EAST has value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ EAST}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Pi: 3.14
Days in a week: 7
Direction EAST has value: 1
\end{verbatim}

\subsubsection{Constants in C}\label{constants-in-c}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Preprocessor constants (\texttt{\#define})} These are replaced
  \emph{before} compilation. Think of them as text substitutions, not
  variables.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX\_USERS }\DecValTok{100}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Max users: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ MAX\_USERS}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    No memory is used.
  \item
    No type checking, the compiler just replaces the text.
  \end{itemize}
\item
  \textbf{Constant variables (\texttt{const})} These are real variables
  stored in memory but cannot be modified after initialization.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ SPEED\_OF\_LIGHT }\OperatorTok{=} \FloatTok{299792458.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    Type safe.
  \item
    Preferred for constants in modern C code.
  \end{itemize}
\item
  \textbf{Literals} These are fixed values written directly in your
  code:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{42}          \CommentTok{// integer literal}
\FloatTok{3.14}        \CommentTok{// floating{-}point literal}
\CharTok{\textquotesingle{}A\textquotesingle{}}         \CommentTok{// character literal}
\StringTok{"Hello"}     \CommentTok{// string literal}
\BaseNTok{0xFF}        \CommentTok{// hexadecimal literal (255)}
\BaseNTok{075}         \CommentTok{// octal literal (61)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Enumerations}\label{enumerations}

An \textbf{enum} (short for \emph{enumeration}) defines a set of named
integer constants. They make your code self-documenting and prevent
mistakes with raw numbers.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ TrafficLight }\OperatorTok{\{}
\NormalTok{    RED}\OperatorTok{,}     \CommentTok{// 0}
\NormalTok{    YELLOW}\OperatorTok{,}  \CommentTok{// 1}
\NormalTok{    GREEN    }\CommentTok{// 2}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{enum}\NormalTok{ TrafficLight signal }\OperatorTok{=}\NormalTok{ GREEN}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{signal }\OperatorTok{==}\NormalTok{ GREEN}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Go!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You can also assign custom values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Month }\OperatorTok{\{}
\NormalTok{    JAN }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ FEB}\OperatorTok{,}\NormalTok{ MAR}\OperatorTok{,}\NormalTok{ APR}\OperatorTok{,}\NormalTok{ MAY}\OperatorTok{,}\NormalTok{ JUN}\OperatorTok{,}
\NormalTok{    JUL}\OperatorTok{,}\NormalTok{ AUG}\OperatorTok{,}\NormalTok{ SEP}\OperatorTok{,}\NormalTok{ OCT}\OperatorTok{,}\NormalTok{ NOV}\OperatorTok{,}\NormalTok{ DEC}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now \texttt{JAN} starts at 1, and each value increments automatically.

\subsubsection{Why It Matters}\label{why-it-matters-10}

Constants and enums make your code \textbf{clearer and safer}:

\begin{itemize}
\tightlist
\item
  You can change one definition instead of many numbers.
\item
  The compiler can enforce that constants are not modified.
\item
  Enumerations group related values into a meaningful set.
\end{itemize}

Without them, large programs become fragile and full of unexplained
numbers, a maintenance nightmare.

Good C programmers use constants to express \textbf{intent}, not just
values.

\subsubsection{Try It Yourself}\label{try-it-yourself-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Replace every numeric literal in your old programs with a
  \texttt{\#define} or \texttt{const}. Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX\_SCORE }\DecValTok{100}
\DataTypeTok{const} \DataTypeTok{float}\NormalTok{ TAX\_RATE }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}
\item
  Create an \texttt{enum} for days of the week, and print
  \texttt{MONDAY} and \texttt{FRIDAY}.
\item
  Assign custom values in your enum (e.g.~start with
  \texttt{SUNDAY\ =\ 1}).
\item
  Experiment: try changing \texttt{const\ int\ x\ =\ 5;\ x\ =\ 10;} ,
  notice the compiler stops you from modifying it.
\item
  Use \texttt{printf} to print literal values in different formats:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%x}\StringTok{ }\SpecialCharTok{\%o\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{255}\OperatorTok{,} \DecValTok{255}\OperatorTok{,} \DecValTok{255}\OperatorTok{);} \CommentTok{// decimal, hex, octal}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Constants are how you make your C programs \emph{speak clearly}. They
turn numbers into ideas, and that's what transforms code from working to
understandable.

\subsection{13. Operators and
Expressions}\label{operators-and-expressions}

Operators are the building blocks of computation in C. They let you
perform arithmetic, compare values, manipulate bits, and combine logic,
all in concise expressions. Once you understand how operators work and
how they interact through \emph{precedence} and \emph{associativity},
you can write clear, efficient code that behaves exactly as you expect.

\subsubsection{Tiny Code}\label{tiny-code-11}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}   \CommentTok{// addition}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a {-} b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{);}   \CommentTok{// subtraction}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a * b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}   \CommentTok{// multiplication}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a / b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}   \CommentTok{// integer division}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a }\SpecialCharTok{\%\%}\StringTok{ b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}\OperatorTok{);}  \CommentTok{// remainder (modulo)}

\NormalTok{    a }\OperatorTok{+=} \DecValTok{5}\OperatorTok{;} \CommentTok{// same as a = a + 5}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a after += 5: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
a + b = 13
a - b = 7
a * b = 30
a / b = 3
a % b = 1
a after += 5: 15
\end{verbatim}

\subsubsection{Arithmetic Operators}\label{arithmetic-operators}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+} & Addition & \texttt{4\ +\ 3} & 7 \\
\texttt{-} & Subtraction & \texttt{10\ -\ 6} & 4 \\
\texttt{*} & Multiplication & \texttt{2\ *\ 5} & 10 \\
\texttt{/} & Division & \texttt{7\ /\ 2} & 3 (integer division) \\
\texttt{\%} & Modulo (remainder) & \texttt{7\ \%\ 2} & 1 \\
\end{longtable}

\begin{quote}
Tip: If you use floating-point numbers (\texttt{float},
\texttt{double}), division produces decimals.
\end{quote}

\subsubsection{Relational and Logical
Operators}\label{relational-and-logical-operators}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1562}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.3125}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1250}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1719}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0312}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0156}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0312}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1562}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Relational & \texttt{==} & \texttt{a\ ==\ b} & Equal & & & & \\
& \texttt{!=} & \texttt{a\ !=\ b} & Not equal & & & & \\
& \texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{\textless{}=},
\texttt{\textgreater{}=} & \texttt{a\ \textless{}\ b} & Comparison & & &
& \\
Logical & \texttt{\&\&} & \texttt{a\ \&\&\ b} & Logical AND & & & & \\
& \texttt{\textbar{}\ \ \ \ \ \ \ \ \ \ \textbar{}} &
\texttt{a\ \textbar{}\ \ \ \textbar{}\ b} & Logical OR & & & & \\
& \texttt{!} & \texttt{!a} & Logical NOT & & & & \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18} \OperatorTok{\&\&}\NormalTok{ age }\OperatorTok{\textless{}=} \DecValTok{60}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Adult}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Increment and Decrement}\label{increment-and-decrement}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{++}\NormalTok{x}\OperatorTok{);} \CommentTok{// prefix: increments, then uses value (6)}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{++);} \CommentTok{// postfix: uses value, then increments (6)}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}   \CommentTok{// final value is 7}
\end{Highlighting}
\end{Shaded}

\subsubsection{Assignment and Compound
Operators}\label{assignment-and-compound-operators}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Meaning & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{=} & Assignment & \texttt{x\ =\ 10} \\
\texttt{+=} & Add and assign & \texttt{x\ +=\ 2} \\
\texttt{-=} & Subtract and assign & \texttt{x\ -=\ 3} \\
\texttt{*=} & Multiply and assign & \texttt{x\ *=\ 4} \\
\texttt{/=} & Divide and assign & \texttt{x\ /=\ 5} \\
\texttt{\%=} & Modulo and assign & \texttt{x\ \%=\ 6} \\
\end{longtable}

These save typing and make intent clearer.

\subsubsection{Bitwise Operators}\label{bitwise-operators}

C gives you direct access to bits, useful for systems, embedded, or
optimization tasks.

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Operator & Meaning & Example & & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&} & AND & \texttt{a\ \&\ b} & & \\
\texttt{\textbar{}} & OR & \texttt{a\ \textbar{}\ b} & & \\
\texttt{\^{}} & XOR & \texttt{a\ \^{}\ b} & & \\
\texttt{\textasciitilde{}} & NOT & \texttt{\textasciitilde{}a} & & \\
\texttt{\textless{}\textless{}} & Left shift &
\texttt{a\ \textless{}\textless{}\ 1} & & \\
\texttt{\textgreater{}\textgreater{}} & Right shift &
\texttt{a\ \textgreater{}\textgreater{}\ 2} & & \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ mask }\OperatorTok{=} \BaseNTok{0b0010}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ num }\OperatorTok{=} \BaseNTok{0b1011}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ num }\OperatorTok{\&}\NormalTok{ mask}\OperatorTok{;}  \CommentTok{// checks if the 2nd bit is set}
\end{Highlighting}
\end{Shaded}

\subsubsection{Precedence and
Associativity}\label{precedence-and-associativity}

When you write complex expressions, C follows operator precedence rules.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{3} \OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// result is 14, not 20}
\end{Highlighting}
\end{Shaded}

\texttt{*} has higher precedence than \texttt{+}, so it runs first.

Use parentheses to make intentions clear:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \OperatorTok{(}\DecValTok{2} \OperatorTok{+} \DecValTok{3}\OperatorTok{)} \OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// result is 20}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-11}

Operators are where \textbf{logic meets the machine}. They translate
mathematical ideas and control decisions into instructions the CPU
executes directly. Understanding how expressions are built and evaluated
helps you:

\begin{itemize}
\tightlist
\item
  Write compact, efficient code
\item
  Avoid precedence mistakes
\item
  Control exactly what your program computes
\end{itemize}

In low-level work (like bitwise operations or embedded systems),
operator mastery is essential.

\subsubsection{Try It Yourself}\label{try-it-yourself-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a small program that takes two integers and prints their:

  \begin{itemize}
  \tightlist
  \item
    Sum
  \item
    Difference
  \item
    Product
  \item
    Quotient
  \item
    Remainder
  \end{itemize}
\item
  Modify it to print results as floating-point values.
\item
  Use logical operators to test if both numbers are positive.
\item
  Try combining bitwise operations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{5} \OperatorTok{\&} \DecValTok{3}\OperatorTok{);}  \CommentTok{// AND}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{5} \OperatorTok{|} \DecValTok{3}\OperatorTok{);}  \CommentTok{// OR}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{5} \OperatorTok{\^{}} \DecValTok{3}\OperatorTok{);}  \CommentTok{// XOR}
\end{Highlighting}
\end{Shaded}
\item
  Experiment with parentheses and operator order until you can predict
  every result.
\end{enumerate}

Operators are where C's simplicity meets its power, a small set of
symbols that give you total control over computation, logic, and even
raw bits.

\subsection{14. Control Flow: if, else,
switch}\label{control-flow-if-else-switch}

Programs become powerful when they can \emph{decide}, when they can
choose one path or another depending on data or conditions. In C,
\textbf{control flow} statements give you that power. They determine how
your program moves through different parts of your code.

\subsubsection{Tiny Code}\label{tiny-code-12}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ temperature }\OperatorTok{=} \DecValTok{30}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{temperature }\OperatorTok{\textgreater{}} \DecValTok{35}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s too hot!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{temperature }\OperatorTok{\textgreater{}} \DecValTok{25}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s warm.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s cool.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
It's warm.
\end{verbatim}

This is how you express logic in C: by checking conditions and executing
only the code that matches.

\subsubsection{The if and else
Structure}\label{the-if-and-else-structure}

The basic pattern looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{condition}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do something if true}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{another\_condition}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do something else}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// default action}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each \texttt{if} or \texttt{else\ if} checks a \textbf{condition} that
must evaluate to \texttt{true} (non-zero) or \texttt{false} (zero).

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{85}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: A}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{80}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: B}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: C or below}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Comparison and Boolean
Logic}\label{comparison-and-boolean-logic}

C doesn't have a built-in \texttt{bool} type in older standards, but
since C99, you can include it:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\DataTypeTok{bool}\NormalTok{ is\_ready }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{is\_ready}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Let\textquotesingle{}s go!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Behind the scenes, \texttt{true} is just \texttt{1} and \texttt{false}
is \texttt{0}.

\subsubsection{Nested if Statements}\label{nested-if-statements}

You can nest decisions for more complex logic:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Positive even number}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Positive odd number}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Just be careful, too much nesting makes code harder to read. When logic
gets complex, consider reorganizing or using a \texttt{switch}
statement.

\subsubsection{The switch Statement}\label{the-switch-statement}

\texttt{switch} is a clean way to test one variable against several
fixed values.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{day}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Monday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Tuesday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Wednesday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Another day}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Wednesday
\end{verbatim}

Each \texttt{case} label marks a potential branch. \texttt{break} stops
the switch from ``falling through'' into the next case.

You can group multiple cases:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{ch}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}a\textquotesingle{}}\OperatorTok{:}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Letter A detected}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{The Ternary Operator}\label{the-ternary-operator}

For quick decisions, you can use the \textbf{conditional operator}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{)} \OperatorTok{?} \StringTok{"Adult"} \OperatorTok{:} \StringTok{"Minor"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is equivalent to:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Adult}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Minor}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-12}

Control flow gives your programs \textbf{intelligence}. Instead of
running straight through, your code reacts to input, conditions, and
data. C's branching statements are simple but flexible, they're the
building blocks of everything from sorting algorithms to operating
system schedulers.

When you understand how to control execution, you can shape your
program's logic precisely.

\subsubsection{Try It Yourself}\label{try-it-yourself-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a program that:

  \begin{itemize}
  \tightlist
  \item
    Reads an integer from the user.
  \item
    Prints whether it's positive, negative, or zero.
  \end{itemize}
\item
  Extend it:

  \begin{itemize}
  \tightlist
  \item
    If it's positive, print whether it's even or odd.
  \end{itemize}
\item
  Use a \texttt{switch} statement:

  \begin{itemize}
  \tightlist
  \item
    Ask for a number 1--7.
  \item
    Print the day of the week that matches.
  \end{itemize}
\item
  Try replacing your \texttt{if} statements with a ternary operator
  where it makes sense.
\end{enumerate}

Control flow is how you \emph{think} in code, it's how you teach your
program to make decisions just like you do.

\subsection{15. Loops: for, while,
do-while}\label{loops-for-while-do-while}

Sometimes you need your program to repeat something, a calculation, a
print statement, or a check, again and again. Instead of copying the
same line of code many times, you use \textbf{loops}. Loops make your
program efficient, compact, and able to handle dynamic data of any size.

\subsubsection{\texorpdfstring{The \texttt{for}
Loop}{The for Loop}}\label{the-for-loop}

A \texttt{for} loop repeats a block of code a fixed number of times.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\NormalTok{initialization}\OperatorTok{;}\NormalTok{ condition}\OperatorTok{;}\NormalTok{ update}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// repeated statements}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Explanation:

\begin{itemize}
\tightlist
\item
  \textbf{Initialization} runs once at the start (\texttt{int\ i\ =\ 0})
\item
  \textbf{Condition} is checked before every loop
  (\texttt{i\ \textless{}\ 10})
\item
  \textbf{Update} runs after each iteration (\texttt{i++})
\item
  The loop stops when the condition becomes false
\end{itemize}

\subsubsection{\texorpdfstring{The \texttt{while}
Loop}{The while Loop}}\label{the-while-loop}

The \texttt{while} loop repeats \textbf{while} a condition remains true.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"n = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\NormalTok{    n}\OperatorTok{{-}{-};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This loop executes as long as \texttt{n} is greater than zero.

\subsubsection{\texorpdfstring{The \texttt{do-while}
Loop}{The do-while Loop}}\label{the-do-while-loop}

The \texttt{do-while} loop guarantees at least one execution, because
the condition is checked \emph{after} the body.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running once! i = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{    i}\OperatorTok{++;}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textless{}} \DecValTok{1}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

It's useful for input validation or repeating tasks until the user
chooses to stop.

\subsubsection{Breaking and Continuing}\label{breaking-and-continuing}

Sometimes you want to \textbf{skip} or \textbf{stop} partway through a
loop.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;}   \CommentTok{// skip this iteration}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{8}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}      \CommentTok{// stop the loop}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 3 4 6 7
\end{verbatim}

\subsubsection{Nested Loops}\label{nested-loops}

You can place one loop inside another to handle grids, tables, or
multiple dimensions.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{2}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i=}\SpecialCharTok{\%d}\StringTok{, j=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
\end{verbatim}

\subsubsection{Tiny Code}\label{tiny-code-13}

Here's a complete program that demonstrates all three types of loops and
control flow features:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// for loop}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"for loop:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// while loop}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"while loop:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"n = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\NormalTok{        n}\OperatorTok{{-}{-};}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// do{-}while loop}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"do{-}while loop:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\NormalTok{        x}\OperatorTok{++;}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textless{}} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// break and continue}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"break and continue demo:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;} \CommentTok{// skip 5}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{8}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}    \CommentTok{// stop at 8}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// nested loop}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{nested loops:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{2}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{,}\SpecialCharTok{\%d}\StringTok{) "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ loops\_demo.c }\AttributeTok{{-}o}\NormalTok{ loops\_demo}
\ExtensionTok{./loops\_demo}
\end{Highlighting}
\end{Shaded}

You'll see all types of loops in action.

\subsubsection{Why It Matters}\label{why-it-matters-13}

Loops are the \textbf{engine of repetition} in every C program. They
make it possible to:

\begin{itemize}
\tightlist
\item
  Process arrays, files, and lists of data
\item
  Run algorithms that iterate until a condition is met
\item
  Automate repetitive tasks efficiently
\end{itemize}

In C, loops are close to how the CPU itself operates, each iteration is
a direct cycle of logic and computation. By mastering them, you control
how your program moves, stops, and repeats, the heartbeat of every
algorithm.

\subsubsection{Try It Yourself}\label{try-it-yourself-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a \texttt{for} loop that prints numbers 1 through 100.
\item
  Add an \texttt{if} inside it to print only even numbers.
\item
  Write a \texttt{while} loop that counts down from 10 to 1.
\item
  Create a nested loop that prints a 3×3 multiplication table.
\item
  Try an infinite loop safely:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Press Ctrl+C to stop}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// or add a condition to exit}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Once you're comfortable with loops, you can build patterns, algorithms,
and data processors, all by controlling how many times code repeats and
under what conditions.

\subsection{16. Functions and
Parameters}\label{functions-and-parameters}

Functions are how you break a program into smaller, reusable pieces.
Each function performs one specific task, you call it when needed, pass
in data (parameters), and get something back (a return value). Functions
make your code organized, testable, and easier to understand.

\subsubsection{The Structure of a
Function}\label{the-structure-of-a-function}

A function in C has four main parts:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{return\_type function\_name}\OperatorTok{(}\NormalTok{parameter\_list}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// body of the function}
    \ControlFlowTok{return}\NormalTok{ value}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{int} is the return type
\item
  \texttt{add} is the name
\item
  \texttt{(int\ a,\ int\ b)} are parameters
\item
  \texttt{return\ a\ +\ b;} sends a result back to the caller
\end{itemize}

\subsubsection{Declaring and Defining
Functions}\label{declaring-and-defining-functions}

In C, you must \emph{declare} a function before using it. The
declaration tells the compiler what to expect.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);} \CommentTok{// declaration (prototype)}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \CommentTok{// definition}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Result: 7
\end{verbatim}

\subsubsection{Passing Parameters}\label{passing-parameters}

When you call a function, the arguments are passed \emph{by value}, a
copy of each value is made. Changing parameters inside the function does
\textbf{not} affect the original variables.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ change}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    change}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);} \CommentTok{// still 5}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you want to modify the original variable, use \textbf{pointers}
(you'll explore this in Chapter 3):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ change}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{x}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Return Values}\label{return-values}

A function can return a value using \texttt{return}. The type of the
returned value must match the function's declared return type.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ average}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To return nothing, use \texttt{void}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-14}

Here's a complete program that combines multiple functions and
parameters:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{// function declarations}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{);}

\CommentTok{// main function}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{(}\StringTok{"C Learner"}\OperatorTok{);}

    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ subtract}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
    \DataTypeTok{double}\NormalTok{ quotient }\OperatorTok{=}\NormalTok{ divide}\OperatorTok{(}\FloatTok{10.0}\OperatorTok{,} \FloatTok{5.0}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Difference: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Quotient: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ quotient}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// function definitions}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error: division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \FloatTok{0.0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ functions\_demo.c }\AttributeTok{{-}o}\NormalTok{ functions\_demo}
\ExtensionTok{./functions\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, C Learner!
Sum: 15
Difference: 5
Quotient: 2.00
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-14}

Functions are the \textbf{building blocks} of every program. They let
you:

\begin{itemize}
\tightlist
\item
  Break large problems into smaller steps
\item
  Reuse code instead of rewriting it
\item
  Test each part independently
\item
  Make programs easier to read and maintain
\end{itemize}

In C, you'll use functions for everything, from arithmetic helpers to
memory allocators, system calls, and modular libraries.

\subsubsection{Try It Yourself}\label{try-it-yourself-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that returns the larger of two numbers.
\item
  Create a \texttt{void} function that prints a welcome message.
\item
  Add a \texttt{multiply()} function and call it from \texttt{main()}.
\item
  Modify the program to read numbers from user input and pass them as
  parameters.
\item
  Experiment by removing the declaration at the top, see what compiler
  error appears, then fix it.
\end{enumerate}

Functions are how C programs \emph{grow}. Each one is a small tool, and
together, they become complete systems.

\subsection{17. Scope and Lifetime of
Variables}\label{scope-and-lifetime-of-variables}

Every variable in C exists within a specific \emph{scope} (where it can
be accessed) and has a \emph{lifetime} (how long it exists in memory).
Understanding both is essential to avoid common bugs, from name
conflicts to mysterious ``garbage values.'' Once you know where and how
variables live, you'll start thinking like the compiler.

\subsubsection{Variable Scope}\label{variable-scope}

\textbf{Scope} defines \emph{where} a variable can be seen or used in
your code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Block scope (local variables)} Declared inside a function or
  block \texttt{\{\ ...\ \}}. Accessible only within that block.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ example}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}  \CommentTok{// local to this function}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  You can't access \texttt{x} outside of \texttt{example()}.
\item
  \textbf{File scope (global variables)} Declared outside of all
  functions. Accessible anywhere in the file after declaration.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// global variable}

\DataTypeTok{void}\NormalTok{ increment}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    counter}\OperatorTok{++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Function parameter scope} Parameters behave like local
  variables, visible only within the function.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Block shadowing} Inner variables can temporarily ``hide''
  outer ones:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}  \CommentTok{// shadows the outer x}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// prints 10}
\OperatorTok{\}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// prints 5}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Variable Lifetime}\label{variable-lifetime}

\textbf{Lifetime} determines \emph{how long} a variable stays in memory.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Automatic (default)} Local variables are created when a
  function starts and destroyed when it ends.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ demo}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ temp }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}  \CommentTok{// exists only while demo() runs}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Static} Declared with the \texttt{static} keyword, they keep
  their value between function calls.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ counter}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}  \CommentTok{// initialized only once}
\NormalTok{    count}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

  Every call to \texttt{counter()} increases the same variable.
\item
  \textbf{Dynamic} Created manually using \texttt{malloc()} or
  \texttt{calloc()}, they live until you \texttt{free()} them. (You'll
  learn this in Chapter 3.)
\item
  \textbf{Global} Exist for the entire duration of the program.
\end{enumerate}

\subsubsection{Storage Classes in C}\label{storage-classes-in-c}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1471}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1912}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1471}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1912}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.3235}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Keyword
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Storage
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Scope
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Lifetime
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{auto} & Stack & Block & Function call & Default for locals \\
\texttt{register} & CPU Register & Block & Function call & Hint to
optimize speed \\
\texttt{static} & Static Memory & Block/File & Program & Retains
value \\
\texttt{extern} & Static Memory & Global & Program & Declared
elsewhere \\
\end{longtable}

\subsubsection{Tiny Code}\label{tiny-code-15}

Here's a full program showing scope and lifetime in action:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ global\_var }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// global scope}

\DataTypeTok{void}\NormalTok{ demo\_scope}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ local\_var }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// block scope}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ persistent }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// retains value between calls}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Global: }\SpecialCharTok{\%d}\StringTok{, Local: }\SpecialCharTok{\%d}\StringTok{, Static: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ global\_var}\OperatorTok{,}\NormalTok{ local\_var}\OperatorTok{,}\NormalTok{ persistent}\OperatorTok{);}
\NormalTok{    persistent}\OperatorTok{++;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"First call:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    demo\_scope}\OperatorTok{();}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Second call:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    demo\_scope}\OperatorTok{();}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Accessing global variable in main: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ global\_var}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ scope\_demo.c }\AttributeTok{{-}o}\NormalTok{ scope\_demo}
\ExtensionTok{./scope\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
First call:
Global: 10, Local: 5, Static: 0

Second call:
Global: 10, Local: 5, Static: 1

Accessing global variable in main: 10
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-15}

Scope and lifetime are the \textbf{invisible structure} beneath your
code. They define what data is available where, and for how long.
Without understanding them, you'll face bugs like:

\begin{itemize}
\tightlist
\item
  Uninitialized values after a function returns
\item
  Variables mysteriously resetting
\item
  Conflicts between local and global names
\end{itemize}

Once you know how the compiler manages variables, you can reason about
memory, performance, and correctness with confidence.

\subsubsection{Try It Yourself}\label{try-it-yourself-15}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function with a static counter and call it three times.
  Observe how the count persists.
\item
  Add a global variable, modify it from two different functions, and
  print the result.
\item
  Create nested blocks with variables of the same name, see how
  shadowing behaves.
\item
  Move a variable outside a function and mark it \texttt{static}. Try
  accessing it from another function, what happens?
\item
  Rewrite your earlier ``calculator'' example using global and local
  variables to see the difference.
\end{enumerate}

When you understand scope and lifetime, you gain control over how your
program's data moves, lives, and dies, a skill every true C programmer
needs.

\subsection{18. Return Values and Function
Signatures}\label{return-values-and-function-signatures}

Functions not only perform tasks but often \emph{communicate results}
back to the caller. They do this through \textbf{return values}. Every C
function has a \textbf{signature}, a declaration that defines its return
type, name, and parameters. Getting comfortable with signatures and
return values helps you write clean, predictable, and modular programs.

\subsubsection{Function Signatures
Explained}\label{function-signatures-explained}

A function signature looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{return\_type function\_name}\OperatorTok{(}\NormalTok{parameter\_list}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

It tells the compiler:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{What kind of value} the function returns (\texttt{int},
  \texttt{double}, \texttt{void}, etc.)
\item
  \textbf{What the function is called}
\item
  \textbf{What arguments} it expects and their types
\end{enumerate}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ max}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This says: ``\texttt{max} is a function that takes two integers and
returns an integer.''

\subsubsection{Returning Values}\label{returning-values}

You use the \texttt{return} keyword to send a value back from a
function.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The type of the value you return must match the function's declared
return type.

If a function doesn't need to return anything, declare it as
\texttt{void}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

A \texttt{void} function can still perform actions, it just doesn't
produce a result.

\subsubsection{Multiple Return Points}\label{multiple-return-points}

You can return early if certain conditions are met.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error: division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is common for error handling or input validation.

\subsubsection{Returning Different Data
Types}\label{returning-different-data-types}

You can return any type, not just integers.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ average}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{char}\NormalTok{ first\_letter}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{word}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ word}\OperatorTok{[}\DecValTok{0}\OperatorTok{];}
\OperatorTok{\}}

\DataTypeTok{\_Bool}\NormalTok{ is\_even}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For more complex data, you'll later learn how to return pointers or
structs.

\subsubsection{Tiny Code}\label{tiny-code-16}

Here's a complete example showing several return types and signatures:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{// function declarations}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{bool}\NormalTok{ is\_even}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{(}\StringTok{"C Programmer"}\OperatorTok{);}

    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{7}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
    \DataTypeTok{double}\NormalTok{ quotient }\OperatorTok{=}\NormalTok{ divide}\OperatorTok{(}\FloatTok{10.0}\OperatorTok{,} \FloatTok{4.0}\OperatorTok{);}
    \DataTypeTok{bool}\NormalTok{ check }\OperatorTok{=}\NormalTok{ is\_even}\OperatorTok{(}\NormalTok{sum}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Quotient: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ quotient}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Is sum even? }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ check }\OperatorTok{?} \StringTok{"Yes"} \OperatorTok{:} \StringTok{"No"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// function definitions}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Cannot divide by zero.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \FloatTok{0.0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{bool}\NormalTok{ is\_even}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ return\_demo.c }\AttributeTok{{-}o}\NormalTok{ return\_demo}
\ExtensionTok{./return\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, C Programmer!
Sum: 10
Quotient: 2.50
Is sum even? Yes
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-16}

Return values are how functions \emph{communicate}. By designing clear
and meaningful signatures:

\begin{itemize}
\tightlist
\item
  You make your code \textbf{predictable}, every function has a defined
  purpose and output.
\item
  The compiler can \textbf{check correctness}, mismatched types raise
  warnings.
\item
  You can \textbf{compose} functions, one function's return becomes
  another's input.
\end{itemize}

In large systems, consistent signatures and meaningful return types form
the backbone of good API design.

\subsubsection{Try It Yourself}\label{try-it-yourself-16}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function \texttt{max(a,\ b)} that returns the larger of two
  integers.
\item
  Write a function \texttt{to\_upper(char\ c)} that returns an uppercase
  version of a character.
\item
  Modify a \texttt{divide()} function to return \texttt{-1} if division
  by zero occurs.
\item
  Create a \texttt{sum\_to\_n(int\ n)} that returns the sum of all
  numbers from 1 to \texttt{n}.
\item
  Try using a \texttt{void} function that prints the result of another
  function call.
\end{enumerate}

Return values give your functions purpose, they turn simple actions into
reusable building blocks that make your programs expressive, modular,
and alive.

\subsection{19. Static vs Dynamic Linking of Code
Units}\label{static-vs-dynamic-linking-of-code-units}

When your program grows beyond a single file, you begin linking multiple
\emph{code units} together, functions and data that live in different
files. This linking step decides how your program combines and shares
code. There are two main ways to do it in C: \textbf{static linking} and
\textbf{dynamic linking}. Understanding both is essential for building
real-world software.

\subsubsection{The Big Picture}\label{the-big-picture}

When you compile a C program:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Each \texttt{.c} file becomes an \textbf{object file} (\texttt{.o}).
\item
  The \textbf{linker} combines all object files and libraries into one
  executable.
\item
  Depending on how you link, that executable may contain:

  \begin{itemize}
  \tightlist
  \item
    All required code inside (static linking), or
  \item
    References to shared libraries on the system (dynamic linking).
  \end{itemize}
\end{enumerate}

\subsubsection{Static Linking}\label{static-linking}

\textbf{Static linking} copies all the necessary library code directly
into your program at build time.

Example command:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c mathutils.c }\AttributeTok{{-}o}\NormalTok{ app\_static}
\end{Highlighting}
\end{Shaded}

Everything from \texttt{mathutils.c} gets \emph{embedded} inside
\texttt{app\_static}.

\textbf{Pros:}

\begin{itemize}
\tightlist
\item
  No external dependencies at runtime
\item
  Faster startup (everything is self-contained)
\item
  Easier deployment
\end{itemize}

\textbf{Cons:}

\begin{itemize}
\tightlist
\item
  Larger executable file
\item
  Updating a library means recompiling the program
\end{itemize}

\subsubsection{Dynamic Linking}\label{dynamic-linking}

\textbf{Dynamic linking} (or \emph{shared linking}) links your program
to shared libraries (\texttt{.so} on Linux, \texttt{.dll} on Windows) at
runtime instead of embedding them.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ app\_dynamic }\AttributeTok{{-}lm}
\end{Highlighting}
\end{Shaded}

Here, \texttt{-lm} tells the linker to use the shared \textbf{math
library} (\texttt{libm.so}).

Your program keeps the library \emph{separate}, loading it when
executed.

\textbf{Pros:}

\begin{itemize}
\tightlist
\item
  Smaller executables
\item
  Libraries can be updated independently
\item
  Multiple programs share the same library in memory
\end{itemize}

\textbf{Cons:}

\begin{itemize}
\tightlist
\item
  Requires the correct library to be available at runtime
\item
  Slightly slower startup
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-17}

Let's demonstrate static vs dynamic linking using a simple math utility.

\textbf{mathutils.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{mathutils.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATHUTILS\_H}
\PreprocessorTok{\#define MATHUTILS\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"mathutils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{4}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Add: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Multiply: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ multiply}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Static Linking Build:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c mathutils.c }\AttributeTok{{-}o}\NormalTok{ static\_app}
\ExtensionTok{./static\_app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Add: 9
Multiply: 20
\end{verbatim}

\textbf{Dynamic Linking Build (using shared library):}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c} \AttributeTok{{-}fPIC}\NormalTok{ mathutils.c }\AttributeTok{{-}o}\NormalTok{ mathutils.o}
\FunctionTok{gcc} \AttributeTok{{-}shared} \AttributeTok{{-}o}\NormalTok{ libmathutils.so mathutils.o}
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}lmathutils} \AttributeTok{{-}o}\NormalTok{ dynamic\_app}
\BuiltInTok{export} \VariableTok{LD\_LIBRARY\_PATH}\OperatorTok{=}\NormalTok{.}
\ExtensionTok{./dynamic\_app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Add: 9
Multiply: 20
\end{verbatim}

Now your executable depends on the shared \texttt{libmathutils.so}, the
same library could be used by many other programs.

\subsubsection{Why It Matters}\label{why-it-matters-17}

Linking determines \textbf{how your software connects and shares code}.
It affects:

\begin{itemize}
\tightlist
\item
  Performance and memory usage
\item
  Deployment and portability
\item
  How easily your program updates when libraries change
\end{itemize}

Static linking is great for small, standalone tools. Dynamic linking is
better for large systems, shared components, or when you rely on system
libraries (like \texttt{libc}, \texttt{libm}, \texttt{pthread}).

Understanding linking makes you a systems thinker, you'll know how the
pieces of your program fit together at the binary level.

\subsubsection{Try It Yourself}\label{try-it-yourself-17}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create \texttt{mathutils.c} and \texttt{mathutils.h} as above.
\item
  Compile statically and dynamically; compare file sizes using
  \texttt{ls\ -lh}.
\item
  Move \texttt{libmathutils.so} out of the directory and run
  \texttt{./dynamic\_app}, notice the missing library error.
\item
  Add \texttt{export\ LD\_LIBRARY\_PATH=.} and run again.
\item
  Modify \texttt{multiply()} to print a message, recompile \emph{only}
  the shared library and see the change take effect instantly.
\end{enumerate}

Static vs dynamic linking is where your C programs move from ``source
code'' to real-world software, how your logic becomes part of an
executable that lives, loads, and runs on any machine.

\subsection{20. Practice: Build a Simple
Calculator}\label{practice-build-a-simple-calculator}

Now that you've learned about functions, variables, loops, control flow,
and linking, it's time to bring everything together. You'll build a
simple calculator that performs basic arithmetic using clean modular
code. This small project will reinforce everything from Chapters 11--19,
data types, operators, control flow, and reusable functions.

\subsubsection{Project Overview}\label{project-overview}

You'll write a calculator that:

\begin{itemize}
\tightlist
\item
  Prompts the user for two numbers and an operator
\item
  Performs the corresponding operation (+, -, *, /)
\item
  Handles division by zero safely
\item
  Repeats until the user chooses to quit
\end{itemize}

You'll structure it using multiple functions and a clean main loop.

\subsubsection{Tiny Code}\label{tiny-code-18}

\textbf{calculator.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{// Function declarations}
\DataTypeTok{double}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ print\_menu}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{double}\NormalTok{ num1}\OperatorTok{,}\NormalTok{ num2}\OperatorTok{,}\NormalTok{ result}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ op}\OperatorTok{;}
    \DataTypeTok{bool}\NormalTok{ running }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"=== Simple C Calculator ===}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{running}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        print\_menu}\OperatorTok{();}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter an operator (+, {-}, *, /) or q to quit: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{" }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{op}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{op }\OperatorTok{==} \CharTok{\textquotesingle{}q\textquotesingle{}} \OperatorTok{||}\NormalTok{ op }\OperatorTok{==} \CharTok{\textquotesingle{}Q\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            running }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \OperatorTok{\}}

\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter first number: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{num1}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter second number: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{num2}\OperatorTok{);}

        \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{op}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{case} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{:}
\NormalTok{                result }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\NormalTok{num1}\OperatorTok{,}\NormalTok{ num2}\OperatorTok{);}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
                \ControlFlowTok{break}\OperatorTok{;}
            \ControlFlowTok{case} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{:}
\NormalTok{                result }\OperatorTok{=}\NormalTok{ subtract}\OperatorTok{(}\NormalTok{num1}\OperatorTok{,}\NormalTok{ num2}\OperatorTok{);}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
                \ControlFlowTok{break}\OperatorTok{;}
            \ControlFlowTok{case} \CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{:}
\NormalTok{                result }\OperatorTok{=}\NormalTok{ multiply}\OperatorTok{(}\NormalTok{num1}\OperatorTok{,}\NormalTok{ num2}\OperatorTok{);}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
                \ControlFlowTok{break}\OperatorTok{;}
            \ControlFlowTok{case} \CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{:}
                \ControlFlowTok{if} \OperatorTok{(}\NormalTok{num2 }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                    printf}\OperatorTok{(}\StringTok{"Error: Division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
                \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{                    result }\OperatorTok{=}\NormalTok{ divide}\OperatorTok{(}\NormalTok{num1}\OperatorTok{,}\NormalTok{ num2}\OperatorTok{);}
\NormalTok{                    printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
                \OperatorTok{\}}
                \ControlFlowTok{break}\OperatorTok{;}
            \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Unknown operator: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ op}\OperatorTok{);}
        \OperatorTok{\}}

\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Function definitions}
\DataTypeTok{double}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print\_menu}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Choose an operation:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  +  Addition}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  {-}  Subtraction}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  *  Multiplication}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  /  Division}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  q  Quit}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ calculator.c }\AttributeTok{{-}o}\NormalTok{ calculator}
\ExtensionTok{./calculator}
\end{Highlighting}
\end{Shaded}

Example session:

\begin{verbatim}
=== Simple C Calculator ===
Choose an operation:
  +  Addition
  -  Subtraction
  *  Multiplication
  /  Division
  q  Quit

Enter an operator (+, -, *, /) or q to quit: +
Enter first number: 5
Enter second number: 3
Result: 8.00

Enter an operator (+, -, *, /) or q to quit: /
Enter first number: 10
Enter second number: 0
Error: Division by zero!

Enter an operator (+, -, *, /) or q to quit: q
Goodbye!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-18}

This simple project combines nearly everything you've learned in Chapter
2:

\begin{itemize}
\tightlist
\item
  \textbf{Data types} for representing numbers
\item
  \textbf{Operators} for performing calculations
\item
  \textbf{Control flow} for making decisions
\item
  \textbf{Loops} for repeated interaction
\item
  \textbf{Functions} for modular design
\end{itemize}

You've now moved beyond syntax, you've built a working, reusable C
program that interacts with real users.

\subsubsection{Try It Yourself}\label{try-it-yourself-18}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add a new operator \texttt{\%} for modulo (integer remainder).
\item
  Create separate files:

  \begin{itemize}
  \tightlist
  \item
    \texttt{calculator.c} for \texttt{main()}
  \item
    \texttt{mathutils.c} and \texttt{mathutils.h} for the arithmetic
    functions Then compile using:
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ calculator.c mathutils.c }\AttributeTok{{-}o}\NormalTok{ calculator}
\end{Highlighting}
\end{Shaded}
\item
  Extend the calculator to remember the last result and reuse it if the
  user enters a single operand.
\item
  Add input validation (e.g., check if \texttt{scanf} actually reads a
  number).
\item
  For a challenge, implement power (\texttt{\^{}}) or square root
  (\texttt{sqrt}) using \texttt{\textless{}math.h\textgreater{}}.
\end{enumerate}

This calculator marks the end of your \textbf{Language Basics} journey,
from variables and control flow to full, interactive programs. In the
next chapter, you'll dive into memory: how C stores your data, manages
it, and lets you control it directly.

\bookmarksetup{startatroot}

\chapter{Chapter 3. Working with
Memory}\label{chapter-3.-working-with-memory}

\subsection{21. Understanding Memory Layout (Stack, Heap, Data,
Code)}\label{understanding-memory-layout-stack-heap-data-code}

Before you can master pointers or dynamic memory, you need to understand
\textbf{how memory is organized} in a running C program. C gives you a
level of control that few languages allow, but to use it safely, you
must know where your data lives and how long it stays there.

\subsubsection{The Memory Segments}\label{the-memory-segments}

When a program runs, its memory is divided into several key sections:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2258}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5565}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2177}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Segment
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example Data
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Code (Text)} & Stores compiled machine instructions & Functions,
program logic \\
\textbf{Data (Static)} & Stores global and static variables with
initialized values & \texttt{int\ count\ =\ 5;} \\
\textbf{BSS (Uninitialized Data)} & Holds global/static variables that
start as zero or are uninitialized & \texttt{int\ buffer{[}256{]};} \\
\textbf{Heap} & Used for dynamic memory allocation (\texttt{malloc},
\texttt{calloc}) & Large, runtime-created data \\
\textbf{Stack} & Stores local variables, function parameters, return
addresses & Function calls, recursion \\
\end{longtable}

These segments are managed differently by the operating system, and each
has a different \textbf{lifetime} and \textbf{scope}.

\subsubsection{Tiny Code}\label{tiny-code-19}

Here's a small program that prints the memory addresses of different
variables to show where they live:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\CommentTok{// Global variable (Data segment)}
\DataTypeTok{int}\NormalTok{ global\_var }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}

\CommentTok{// Uninitialized global variable (BSS segment)}
\DataTypeTok{int}\NormalTok{ global\_bss}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ show\_addresses}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Local variable (Stack)}
    \DataTypeTok{int}\NormalTok{ local\_var }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

    \CommentTok{// Static variable (Data segment)}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ static\_var }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}

    \CommentTok{// Dynamic variable (Heap)}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{heap\_var }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \OperatorTok{*}\NormalTok{heap\_var }\OperatorTok{=} \DecValTok{30}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Code (function) address:     }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)}\NormalTok{show\_addresses}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Global variable address:     }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{global\_var}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Uninitialized global address:}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{global\_bss}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Static variable address:     }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{static\_var}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Stack variable address:      }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{local\_var}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Heap variable address:       }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)}\NormalTok{heap\_var}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{heap\_var}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    show\_addresses}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ memory\_layout.c }\AttributeTok{{-}o}\NormalTok{ memory\_layout}
\ExtensionTok{./memory\_layout}
\end{Highlighting}
\end{Shaded}

Example output (addresses vary by system):

\begin{verbatim}
Code (function) address:     0x561ce7348169
Global variable address:     0x561ce7546014
Uninitialized global address:0x561ce7546018
Static variable address:     0x561ce7546020
Stack variable address:      0x7ffc94b65a5c
Heap variable address:       0x561ce774b2a0
\end{verbatim}

Notice how the stack address is much higher than the heap, the stack
usually grows \emph{downward}, and the heap grows \emph{upward} in
memory.

\subsubsection{How It All Works}\label{how-it-all-works}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Code segment}

  \begin{itemize}
  \tightlist
  \item
    Contains compiled instructions.
  \item
    Usually marked as read-only to prevent accidental modification.
  \end{itemize}
\item
  \textbf{Data segment}

  \begin{itemize}
  \tightlist
  \item
    Holds global and static variables initialized with values.
  \item
    Exists for the entire program duration.
  \end{itemize}
\item
  \textbf{BSS (Block Started by Symbol)}

  \begin{itemize}
  \tightlist
  \item
    Holds uninitialized global/static variables.
  \item
    Automatically zero-initialized at runtime.
  \end{itemize}
\item
  \textbf{Stack}

  \begin{itemize}
  \tightlist
  \item
    Used for local variables and function calls.
  \item
    Automatically managed, grows and shrinks as functions are called and
    return.
  \end{itemize}
\item
  \textbf{Heap}

  \begin{itemize}
  \tightlist
  \item
    Allocated manually at runtime.
  \item
    Requires explicit management (\texttt{malloc} and \texttt{free}).
  \end{itemize}
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-19}

Every time you write a variable, you're deciding, whether consciously or
not, \emph{where} in memory it lives. Understanding this layout helps
you:

\begin{itemize}
\tightlist
\item
  Debug memory errors (segmentation faults, leaks, corruption).
\item
  Reason about performance and function calls.
\item
  Write correct code when using \texttt{malloc}, \texttt{free}, and
  pointers.
\item
  Build real systems software like allocators or kernels.
\end{itemize}

Without this mental model, C memory bugs feel mysterious; with it, they
become logical and fixable.

\subsubsection{Try It Yourself}\label{try-it-yourself-19}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add more global, local, and static variables to the example and print
  their addresses.
\item
  Allocate two blocks with \texttt{malloc()} and compare their
  addresses, the heap grows upward.
\item
  Call \texttt{show\_addresses()} multiple times and notice how the
  stack variable's address changes each call.
\item
  Move a variable from global to local and observe how its memory
  segment changes.
\item
  Draw a diagram showing stack, heap, data, and code regions for your
  system.
\end{enumerate}

Understanding memory layout is your first real step into
\textbf{systems-level C}, it's how you begin to see your code not just
as text, but as \textbf{structured bytes living inside memory}.

\subsection{22. Pointers and Addresses}\label{pointers-and-addresses}

Pointers are at the heart of C programming. They give you direct access
to memory, the power to read, write, and manipulate data stored anywhere
in your program. Understanding pointers transforms how you think about
variables, functions, and data structures.

You can't truly master C without mastering pointers.

\subsubsection{What Is a Pointer?}\label{what-is-a-pointer}

A \textbf{pointer} is a variable that stores the \emph{address} of
another variable. Think of it as a reference to a specific spot in
memory.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;} \CommentTok{// pointer to int, stores the address of value}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\&value} gives the memory address of \texttt{value}.
\item
  \texttt{ptr} \emph{holds} that address.
\item
  \texttt{*ptr} lets you \emph{access} the value stored there (this is
  called \emph{dereferencing}).
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-20}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ number }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{number}\OperatorTok{;}  \CommentTok{// pointer stores address of number}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value of number: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ number}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Address of number: }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{number}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer p holds address: }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value through pointer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}

    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}  \CommentTok{// modify the value via the pointer}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New value of number: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ number}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ pointer\_basics.c }\AttributeTok{{-}o}\NormalTok{ pointer\_basics}
\ExtensionTok{./pointer\_basics}
\end{Highlighting}
\end{Shaded}

Output (addresses vary):

\begin{verbatim}
Value of number: 10
Address of number: 0x7ffc8f4c9c4c
Pointer p holds address: 0x7ffc8f4c9c4c
Value through pointer: 10
New value of number: 20
\end{verbatim}

\subsubsection{Pointer Declaration and
Dereferencing}\label{pointer-declaration-and-dereferencing}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1410}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8590}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int\ *p;} & Pointer to an integer \\
\texttt{char\ *c;} & Pointer to a character \\
\texttt{float\ *f;} & Pointer to a float \\
\texttt{p\ =\ \&x;} & Assigns address of variable \texttt{x} to pointer
\texttt{p} \\
\texttt{*p} & Accesses (dereferences) the value stored at the address
held by \texttt{p} \\
\end{longtable}

Dereferencing works both ways:

\begin{itemize}
\tightlist
\item
  Reading the value: \texttt{x\ =\ *p;}
\item
  Writing to the address: \texttt{*p\ =\ 99;}
\end{itemize}

\subsubsection{Null Pointers}\label{null-pointers}

A pointer that points to nothing should be set to \texttt{NULL}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{ptr }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer is not initialized.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Dereferencing a null pointer (\texttt{*ptr} when \texttt{ptr\ ==\ NULL})
causes a \textbf{segmentation fault}, one of the most common C errors.

\subsubsection{Pointer to Pointer}\label{pointer-to-pointer}

You can have pointers that store addresses of other pointers.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{**}\NormalTok{pp }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{**}\NormalTok{pp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This concept appears in multi-dimensional arrays and function pointers.

\subsubsection{Why It Matters}\label{why-it-matters-20}

Pointers are what make C powerful:

\begin{itemize}
\tightlist
\item
  They enable \textbf{dynamic memory allocation} (\texttt{malloc},
  \texttt{calloc}, \texttt{free}).
\item
  They allow \textbf{arrays, strings, and structures} to be passed
  efficiently.
\item
  They are the foundation for \textbf{linked lists, trees, and system
  calls}.
\end{itemize}

But they also demand precision. A single misused pointer can cause
crashes or memory corruption.

Mastering pointers means mastering both control and responsibility over
memory.

\subsubsection{Try It Yourself}\label{try-it-yourself-20}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that declares an integer and prints both its value and
  address.
\item
  Create a pointer to that integer and modify the variable's value
  through the pointer.
\item
  Try declaring \texttt{int\ *p\ =\ NULL;} and check it before
  dereferencing.
\item
  Print a pointer to a pointer (\texttt{int\ **}) and see how the
  addresses relate.
\item
  For fun, declare two variables and make one pointer swap their values
  using dereferencing.
\end{enumerate}

Once you truly understand pointers, the rest of C, arrays, structs,
dynamic memory, even function calls, begins to make sense. They are the
bridge between your code and the machine's actual memory.

\subsection{23. Arrays and Pointer
Arithmetic}\label{arrays-and-pointer-arithmetic}

An \textbf{array} is a block of consecutive memory cells that hold
elements of the same type. Arrays and pointers are deeply connected in
C, in fact, an array's name often behaves like a pointer to its first
element. Understanding how arrays and pointer arithmetic work together
is key to writing fast, memory-efficient programs.

\subsubsection{Declaring and Using
Arrays}\label{declaring-and-using-arrays}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{,} \DecValTok{40}\OperatorTok{,} \DecValTok{50}\OperatorTok{\};}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"numbers[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
numbers[0] = 10
numbers[1] = 20
numbers[2] = 30
numbers[3] = 40
numbers[4] = 50
\end{verbatim}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{numbers} is an array of five integers.
\item
  Each element is stored \textbf{next to each other in memory}.
\item
  The compiler knows each \texttt{int} takes the same number of bytes,
  so it can find \texttt{numbers{[}i{]}} quickly using pointer
  arithmetic.
\end{itemize}

\subsubsection{Array Name as a Pointer}\label{array-name-as-a-pointer}

When you use an array's name (without an index), it acts as a pointer to
its first element.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}  \CommentTok{// same as \&numbers[0]}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{),} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{2}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 3
\end{verbatim}

Each time you add 1 to the pointer, it moves forward by one element,
\textbf{not one byte}, but one \emph{object} of that type.

\subsubsection{Tiny Code}\label{tiny-code-21}

Here's a complete example showing array access and pointer arithmetic:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{10}\OperatorTok{\};}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{;} \CommentTok{// arr decays to pointer to arr[0]}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Accessing with array index:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"arr[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Accessing with pointer arithmetic:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"*(ptr + }\SpecialCharTok{\%d}\StringTok{) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,} \OperatorTok{*(}\NormalTok{ptr }\OperatorTok{+}\NormalTok{ i}\OperatorTok{));}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Addresses in memory:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"\&arr[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ array\_pointer.c }\AttributeTok{{-}o}\NormalTok{ array\_pointer}
\ExtensionTok{./array\_pointer}
\end{Highlighting}
\end{Shaded}

Output (addresses will differ):

\begin{verbatim}
Accessing with array index:
arr[0] = 2
arr[1] = 4
arr[2] = 6
arr[3] = 8
arr[4] = 10

Accessing with pointer arithmetic:
*(ptr + 0) = 2
*(ptr + 1) = 4
*(ptr + 2) = 6
*(ptr + 3) = 8
*(ptr + 4) = 10

Addresses in memory:
&arr[0] = 0x7ffcc73f9a60
&arr[1] = 0x7ffcc73f9a64
&arr[2] = 0x7ffcc73f9a68
&arr[3] = 0x7ffcc73f9a6c
&arr[4] = 0x7ffcc73f9a70
\end{verbatim}

You can see that each element sits \textbf{4 bytes apart} (typical size
of \texttt{int}).

\subsubsection{Pointer Arithmetic Rules}\label{pointer-arithmetic-rules}

When you move pointers, C automatically scales by the size of the type
they point to:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Expression & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{p\ +\ 1} & Move to the next element \\
\texttt{p\ -\ 1} & Move to the previous element \\
\texttt{*(p\ +\ i)} & Access the i-th element after the current one \\
\texttt{p2\ -\ p1} & Returns the number of elements between two
pointers \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{start }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{end }\OperatorTok{=}\NormalTok{ arr }\OperatorTok{+} \DecValTok{5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Array length: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ end }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{);} \CommentTok{// prints 5}
\end{Highlighting}
\end{Shaded}

\subsubsection{Common Pitfalls}\label{common-pitfalls}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Out-of-bounds access} Accessing memory beyond an array's valid
  range leads to \emph{undefined behavior}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \DecValTok{99}\OperatorTok{;} \CommentTok{// invalid! array has only indices 0{-}4}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Array decay} Arrays ``decay'' to pointers when passed to
  functions, they lose size information. You must pass the length
  manually.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_array}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ len}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Pointer confusion} Remember that \texttt{arr{[}i{]}} and
  \texttt{*(arr\ +\ i)} mean the same thing. Mixing them is fine, but be
  consistent for readability.
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-21}

Arrays and pointers form the \textbf{foundation of C data structures}.
You'll use them to build:

\begin{itemize}
\tightlist
\item
  Strings (arrays of \texttt{char})
\item
  Matrices (arrays of arrays)
\item
  Linked lists and trees (via pointer arithmetic)
\end{itemize}

Once you're comfortable thinking of arrays as \emph{contiguous memory
blocks} accessed through pointers, you can start designing your own data
structures like a real systems programmer.

\subsubsection{Try It Yourself}\label{try-it-yourself-21}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that prints an array using only pointers (no
  \texttt{{[}{]}} syntax).
\item
  Create an array of \texttt{char} and print it as a string and as
  separate characters.
\item
  Declare an array of 10 numbers, then use pointers to sum them.
\item
  Print the address difference between two elements.
\item
  Create a two-dimensional array and print it with nested loops.
\end{enumerate}

Arrays and pointers are two sides of the same coin in C. Once you
understand their connection, you'll see how powerful, and elegant,
direct memory access can be.

\subsection{24. Strings as Character
Arrays}\label{strings-as-character-arrays}

In C, a \textbf{string} is simply an array of characters ending with a
special null character
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. Unlike
higher-level languages, C doesn't have a built-in string type, just
arrays and pointers. This simplicity gives you full control over text
data but also demands care: every string operation must respect memory
limits and null terminators.

\subsubsection{How Strings Work}\label{how-strings-work}

A string like \texttt{"Hello"} in C is represented internally as:

\begin{longtable}[]{@{}lllllll@{}}
\toprule\noalign{}
Character & H & e & l & l & o & \texttt{\textbackslash{}0} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Index & 0 & 1 & 2 & 3 & 4 & 5 \\
\end{longtable}

The \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}
(ASCII 0) marks the end of the string, it's how functions like
\texttt{printf} or \texttt{strlen} know where to stop.

\subsubsection{Declaring Strings}\label{declaring-strings}

There are two common ways to declare strings:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ greeting1}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}        \CommentTok{// automatic null terminator}
\DataTypeTok{char}\NormalTok{ greeting2}\OperatorTok{[}\DecValTok{6}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}o\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{\};} \CommentTok{// explicit}
\DataTypeTok{char} \OperatorTok{*}\NormalTok{greeting3 }\OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}         \CommentTok{// pointer to string literal}
\end{Highlighting}
\end{Shaded}

\texttt{greeting1} is a mutable array you can modify. \texttt{greeting3}
points to a \textbf{read-only} string literal stored in memory,
modifying it causes undefined behavior.

\subsubsection{Tiny Code}\label{tiny-code-22}

Here's a complete example that explores string declarations, iteration,
and basic operations:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[]} \OperatorTok{=} \StringTok{"C language"}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ msg}\OperatorTok{;} \CommentTok{// pointer to the first character}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"String: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Length: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{msg}\OperatorTok{));}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Characters one by one:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ msg}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{!=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"msg[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%c}\StringTok{ (address: }\SpecialCharTok{\%p}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \OperatorTok{(}\DataTypeTok{void} \OperatorTok{*)\&}\NormalTok{msg}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Access via pointer arithmetic:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \OperatorTok{*(}\NormalTok{ptr }\OperatorTok{+}\NormalTok{ i}\OperatorTok{)} \OperatorTok{!=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"*(ptr + }\SpecialCharTok{\%d}\StringTok{) = }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,} \OperatorTok{*(}\NormalTok{ptr }\OperatorTok{+}\NormalTok{ i}\OperatorTok{));}
    \OperatorTok{\}}

    \CommentTok{// Modify string safely}
\NormalTok{    msg}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}C\textquotesingle{}}\OperatorTok{;}
\NormalTok{    msg}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Modified string: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ strings\_demo.c }\AttributeTok{{-}o}\NormalTok{ strings\_demo}
\ExtensionTok{./strings\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
String: C language
Length: 10

Characters one by one:
msg[0] = C (address: 0x7ffd29c4a0a0)
msg[1] =   (address: 0x7ffd29c4a0a1)
msg[2] = l (address: 0x7ffd29c4a0a2)
...

Access via pointer arithmetic:
*(ptr + 0) = C
*(ptr + 1) =  
*(ptr + 2) = l
...

Modified string: C+anguage
\end{verbatim}

\subsubsection{Common String Operations}\label{common-string-operations}

C provides several standard functions in
\texttt{\textless{}string.h\textgreater{}}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2533}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4533}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2933}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{strlen(s)} & Get string length (excluding
\texttt{\textbackslash{}0}) & \texttt{strlen("Hi")\ ==\ 2} \\
\texttt{strcpy(dest,\ src)} & Copy string &
\texttt{strcpy(name,\ "Bob");} \\
\texttt{strcat(dest,\ src)} & Concatenate strings &
\texttt{strcat(full,\ last);} \\
\texttt{strcmp(a,\ b)} & Compare strings (\texttt{0} if equal) &
\texttt{strcmp("a","b")} \\
\texttt{strchr(s,\ c)} & Find first occurrence of character &
\texttt{strchr(word,\ \textquotesingle{}a\textquotesingle{})} \\
\texttt{strstr(s,\ sub)} & Find substring &
\texttt{strstr(text,\ "find")} \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ a}\OperatorTok{[}\DecValTok{20}\OperatorTok{]} \OperatorTok{=} \StringTok{"Hello, "}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ b}\OperatorTok{[]} \OperatorTok{=} \StringTok{"World!"}\OperatorTok{;}
\NormalTok{strcat}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);} \CommentTok{// "Hello, World!"}
\end{Highlighting}
\end{Shaded}

\subsubsection{Pointers and Strings}\label{pointers-and-strings}

Because a string's name decays into a pointer, you can pass strings
directly to functions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{(}\StringTok{"C Learner"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\texttt{const\ char\ *} prevents accidental modification of the string
literal.
\end{quote}

\subsubsection{Common Pitfalls}\label{common-pitfalls-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Forgetting
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}T\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}s\textquotesingle{}}\OperatorTok{,}\CharTok{\textquotesingle{}t\textquotesingle{}}\OperatorTok{\};} \CommentTok{// missing terminator, unsafe}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Buffer overflows:} Copying more characters than fit in the
  destination buffer leads to undefined behavior.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ dest}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{dest}\OperatorTok{,} \StringTok{"Too long!"}\OperatorTok{);} \CommentTok{// dangerous}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Modifying string literals:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{s }\OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}
\NormalTok{s}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}Y\textquotesingle{}}\OperatorTok{;} \CommentTok{// crash or undefined behavior}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-22}

Strings are the foundation of \textbf{text processing, file handling,
and user interfaces} in C. Because they're just arrays of characters,
understanding strings forces you to think about:

\begin{itemize}
\tightlist
\item
  \textbf{Memory layout}
\item
  \textbf{Null termination}
\item
  \textbf{Buffer size and safety}
\end{itemize}

Once you internalize how C handles text at the byte level, you'll be
ready to build real parsers, file readers, and command-line tools.

\subsubsection{Try It Yourself}\label{try-it-yourself-22}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function \texttt{void\ reverse(char\ *s)} that reverses a
  string in place.
\item
  Implement your own version of \texttt{strlen}.
\item
  Create a program that counts vowels in a string.
\item
  Concatenate two user-input strings using \texttt{strcat}.
\item
  Experiment by printing a string without
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}},
  observe what happens.
\end{enumerate}

Strings in C are both elegant and dangerous, a true test of precision.
Once you master them, you'll understand how text truly exists in memory,
one byte at a time.

\subsection{25. Dynamic Memory Allocation (malloc, calloc, realloc,
free)}\label{dynamic-memory-allocation-malloc-calloc-realloc-free}

Static arrays have fixed size, but real programs often need flexible
data that grows or shrinks at runtime. Dynamic memory allocation lets
you \textbf{request}, \textbf{use}, and \textbf{release} memory manually
while your program is running. It's one of the most powerful and
error-prone parts of C.

\subsubsection{The Idea}\label{the-idea}

C provides four key functions from
\texttt{\textless{}stdlib.h\textgreater{}} for dynamic memory
management:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2941}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7059}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{malloc(size)} & Allocates a block of memory \\
\texttt{calloc(n,\ size)} & Allocates and clears memory for \texttt{n}
elements \\
\texttt{realloc(ptr,\ size)} & Changes the size of a previously
allocated block \\
\texttt{free(ptr)} & Releases memory back to the system \\
\end{longtable}

These return a \textbf{pointer} to the allocated memory, or
\texttt{NULL} if allocation fails.

\subsubsection{Basic Example}\label{basic-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}  \CommentTok{// allocate space for one int}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Memory allocation failed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}  \CommentTok{// store a value in allocated memory}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}  \CommentTok{// release the memory}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ malloc\_demo.c }\AttributeTok{{-}o}\NormalTok{ malloc\_demo}
\ExtensionTok{./malloc\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 42
\end{verbatim}

\subsubsection{Allocating Arrays
Dynamically}\label{allocating-arrays-dynamically}

You can allocate arrays at runtime using \texttt{malloc()} or
\texttt{calloc()}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter number of elements: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}

\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Out of memory.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Initialize and print}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{*} \DecValTok{10}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}

\NormalTok{free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
Enter number of elements: 5
0 10 20 30 40
\end{verbatim}

\texttt{malloc()} leaves memory uninitialized, while \texttt{calloc()}
clears it to zero:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ calloc}\OperatorTok{(}\NormalTok{n}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));} \CommentTok{// all elements start at 0}
\end{Highlighting}
\end{Shaded}

\subsubsection{Changing Memory Size with
realloc()}\label{changing-memory-size-with-realloc}

When you need to resize an allocated block, say, double an array's
capacity, use \texttt{realloc()}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ arr}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{2}\OperatorTok{;}\NormalTok{ arr}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DecValTok{3}\OperatorTok{;}

\CommentTok{// grow array to 5 elements}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{temp }\OperatorTok{=}\NormalTok{ realloc}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,} \DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{temp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Reallocation failed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\NormalTok{arr }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}

\NormalTok{arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\NormalTok{arr}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \DecValTok{5}\OperatorTok{;}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}

\NormalTok{free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 3 4 5
\end{verbatim}

\texttt{realloc()} tries to expand the existing block if possible; if
not, it allocates a new block, copies the data, and frees the old one
automatically.

\subsubsection{Tiny Code}\label{tiny-code-23}

Here's a complete program combining \texttt{malloc}, \texttt{calloc},
\texttt{realloc}, and \texttt{free}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{nums }\OperatorTok{=}\NormalTok{ calloc}\OperatorTok{(}\NormalTok{n}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{nums }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Initial allocation failed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \CommentTok{// Fill array}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=} \OperatorTok{(}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{*} \DecValTok{5}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Initial values: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// Resize}
\NormalTok{    n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{new\_nums }\OperatorTok{=}\NormalTok{ realloc}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,}\NormalTok{ n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{new\_nums }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Reallocation failed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{nums}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    nums }\OperatorTok{=}\NormalTok{ new\_nums}\OperatorTok{;}

    \CommentTok{// Fill new slots}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=} \OperatorTok{(}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{*} \DecValTok{5}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"After realloc: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{nums}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Initial values: 5 10 15
After realloc: 5 10 15 20 25
\end{verbatim}

\subsubsection{Memory Allocation
Diagram}\label{memory-allocation-diagram}

\begin{verbatim}
Stack   →   grows downward
Heap    →   grows upward
Data    →   global/static variables
Code    →   program instructions
\end{verbatim}

Each call to \texttt{malloc} reserves space on the \textbf{heap}, which
stays allocated until explicitly freed.

\subsubsection{Why It Matters}\label{why-it-matters-23}

Dynamic memory is the \textbf{backbone of all real systems programming}.
Without it, you can't build:

\begin{itemize}
\tightlist
\item
  Variable-sized arrays
\item
  Linked lists, trees, graphs
\item
  Caches and databases
\item
  File readers and parsers
\end{itemize}

It's also where most C bugs happen, dangling pointers, leaks, double
frees, and buffer overruns, so disciplined management is crucial.

\subsubsection{Try It Yourself}\label{try-it-yourself-23}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Allocate an array of 10 integers, fill it, print it, and free it.
\item
  Use \texttt{calloc} instead of \texttt{malloc} and observe the zero
  initialization.
\item
  Resize the array from 10 to 20 elements using \texttt{realloc}.
\item
  Forget to call \texttt{free()} and then run your program with
  \textbf{Valgrind}, see the memory leak report.
\item
  Write a function \texttt{int\ *make\_array(int\ n)} that allocates and
  returns a pointer to a new array.
\end{enumerate}

Dynamic allocation is where you start managing memory \emph{by hand}.
Done right, it gives you incredible control and efficiency, done wrong,
it's chaos. Master it carefully: it's the essence of being a C
programmer.

\subsection{26. Memory Leaks and Undefined
Behavior}\label{memory-leaks-and-undefined-behavior}

C gives you total control over memory, which means you can do anything
you want, including things that \emph{should never be done}. Two of the
biggest dangers are \textbf{memory leaks} (when memory is never
released) and \textbf{undefined behavior} (when the program does
something unpredictable). Learning to avoid these is the key to writing
stable, safe, and correct C programs.

\subsubsection{What Is a Memory Leak?}\label{what-is-a-memory-leak}

A \textbf{memory leak} happens when you allocate memory on the heap and
never free it. The memory stays reserved even though you can't access it
anymore.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ leak}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{data }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{100} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));} \CommentTok{// allocated}
\NormalTok{    data}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}
    \CommentTok{// forgot to free(data); memory is now lost}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{leak()} runs many times, your program consumes more and more
memory until it crashes or slows down. In long-running programs (like
servers), this is deadly.

\textbf{Rule:} Every \texttt{malloc}, \texttt{calloc}, or
\texttt{realloc} must eventually be paired with a matching
\texttt{free()}.

\subsubsection{Tiny Code}\label{tiny-code-24}

Let's see leaks and fixes in action.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ with\_leak}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"with\_leak: allocated 5 ints, but not freed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ without\_leak}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"without\_leak: freeing memory.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    with\_leak}\OperatorTok{();}
\NormalTok{    without\_leak}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run with \textbf{Valgrind} (a memory checker):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ leaks\_demo.c }\AttributeTok{{-}o}\NormalTok{ leaks\_demo}
\FunctionTok{valgrind}\NormalTok{ ./leaks\_demo}
\end{Highlighting}
\end{Shaded}

Valgrind output (simplified):

\begin{verbatim}
==1234== HEAP SUMMARY:
==1234==    definitely lost: 20 bytes in 1 blocks
==1234==    indirectly lost: 0 bytes in 0 blocks
==1234== LEAK SUMMARY:
==1234==    1 blocks definitely lost
\end{verbatim}

You can see the first function leaked memory, while the second freed it
properly.

\subsubsection{Dangling Pointers}\label{dangling-pointers}

A \textbf{dangling pointer} points to memory that has been freed or is
otherwise invalid.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// ❌ undefined behavior}
\end{Highlighting}
\end{Shaded}

After \texttt{free(p)}, the pointer \texttt{p} still holds the old
address, but that memory no longer belongs to you. Accessing it may
crash, or appear to work, or corrupt data, you can't rely on it.

Always nullify freed pointers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Double Free}\label{double-free}

Freeing the same memory twice also leads to undefined behavior:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \CommentTok{// ❌ double free error}
\end{Highlighting}
\end{Shaded}

Most modern OSes detect this and abort, but it's still a critical bug.

\subsubsection{Use-After-Free}\label{use-after-free}

This is one of the worst kinds of memory errors. It happens when you
access memory after it's been freed.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{7}\OperatorTok{;} \CommentTok{// ❌ use{-}after{-}free}
\end{Highlighting}
\end{Shaded}

The compiler won't catch this, but Valgrind will warn you.

\subsubsection{Uninitialized Memory}\label{uninitialized-memory}

Reading memory you never wrote to is also undefined:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);} \CommentTok{// ❌ uninitialized read}
\end{Highlighting}
\end{Shaded}

\texttt{malloc()} does \textbf{not} zero out memory, use
\texttt{calloc()} if you need cleared data.

\subsubsection{Common Causes of Undefined
Behavior}\label{common-causes-of-undefined-behavior}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3659}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Consequence
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Out-of-bounds access & \texttt{arr{[}10{]}} in a 5-element array &
Corrupts memory \\
Use-after-free & Dereferencing freed pointer & Crash or silent
corruption \\
Null pointer dereference & \texttt{*NULL} & Crash \\
Division by zero & \texttt{x\ /\ 0} & Crash \\
Invalid pointer arithmetic & \texttt{(int\ *)0\ +\ 1} & Undefined \\
Modifying string literal &
\texttt{char\ *s\ =\ "hi";\ s{[}0{]}=\textquotesingle{}H\textquotesingle{};}
& Crash \\
\end{longtable}

\subsubsection{Why It Matters}\label{why-it-matters-24}

Undefined behavior is not ``just a bug.'' It means \textbf{anything} can
happen:

\begin{itemize}
\tightlist
\item
  Your program may seem fine but fail later.
\item
  Compiler optimizations may remove or reorder code unexpectedly.
\item
  The same code might work on one system and crash on another.
\end{itemize}

In C, correctness is your responsibility. You must know when memory is
valid, who owns it, and when to free it.

\subsubsection{Defensive Techniques}\label{defensive-techniques}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Always check \texttt{malloc()} return values.}
\item
  \textbf{Initialize pointers to \texttt{NULL}.}
\item
  \textbf{Set pointers to \texttt{NULL} after freeing.}
\item
  \textbf{Use Valgrind} (Linux) or \textbf{AddressSanitizer} (Clang/GCC)
  to detect leaks and invalid access.
\item
  \textbf{Prefer small, testable functions}, easier to verify memory
  ownership.
\item
  \textbf{Avoid mixing stack and heap memory} unless you're certain of
  lifetimes.
\end{enumerate}

\subsubsection{Try It Yourself}\label{try-it-yourself-24}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program that intentionally leaks memory. Run it under
  Valgrind.
\item
  Fix the leak by calling \texttt{free()} properly.
\item
  Create a dangling pointer and observe what happens (on some systems it
  crashes, on others not).
\item
  Experiment with \texttt{calloc()} to see how zero-initialized memory
  behaves.
\item
  Write a function that allocates memory and returns it, then ensure the
  caller frees it.
\end{enumerate}

\subsubsection{Final Thought}\label{final-thought}

Memory errors are the hardest bugs to track because they may not appear
right away. But once you understand \textbf{ownership}, who allocates
and who frees, memory in C becomes predictable, even elegant. This
discipline is what separates casual C users from real systems
programmers.

\subsection{27. const and volatile
Qualifiers}\label{const-and-volatile-qualifiers}

C gives you fine-grained control over how variables are used through
\textbf{type qualifiers}. Two of the most important are \texttt{const}
and \texttt{volatile}. They look simple but play a crucial role in
writing safe, predictable, and efficient code, especially in systems
programming, embedded systems, and multithreaded environments.

\subsubsection{\texorpdfstring{The \texttt{const}
Qualifier}{The const Qualifier}}\label{the-const-qualifier}

\texttt{const} means \emph{read-only}: once a variable is initialized,
you cannot modify it.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{x }\OperatorTok{=} \DecValTok{20}\OperatorTok{;} \CommentTok{// ❌ error: assignment of read{-}only variable}
\end{Highlighting}
\end{Shaded}

It's a promise to the compiler, and to other programmers, that the value
won't change.

\texttt{const} can be applied to many things:

\begin{itemize}
\tightlist
\item
  Variables
\item
  Function parameters
\item
  Pointers
\item
  Return types
\end{itemize}

\subsubsection{const with Pointers}\label{const-with-pointers}

\texttt{const} with pointers can be tricky but follows consistent rules.
The position of \texttt{const} determines what cannot change.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2838}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7162}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Declaration
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{const\ int\ *p;} & Pointer to \textbf{constant data}, data can't
change \\
\texttt{int\ *const\ p;} & \textbf{Constant pointer}, pointer can't
change, data can \\
\texttt{const\ int\ *const\ p;} & Both pointer and data are constant \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\DataTypeTok{const} \DataTypeTok{int} \OperatorTok{*}\NormalTok{p1 }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;}   \CommentTok{// cannot modify *p1}
\DataTypeTok{int} \OperatorTok{*}\DataTypeTok{const}\NormalTok{ p2 }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;}   \CommentTok{// cannot reassign p2}
\DataTypeTok{const} \DataTypeTok{int} \OperatorTok{*}\DataTypeTok{const}\NormalTok{ p3 }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;} \CommentTok{// cannot change *p3 or p3}
\end{Highlighting}
\end{Shaded}

\subsubsection{const in Function
Parameters}\label{const-in-function-parameters}

Marking parameters as \texttt{const} helps prevent accidental
modification and enables compiler optimizations.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_message}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{msg} is read-only; the function can't modify the string it
points to.

\subsubsection{Tiny Code}\label{tiny-code-25}

Here's a program demonstrating \texttt{const} in action:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ show}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// *ptr = 10; // ❌ not allowed}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{const} \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{num}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\DataTypeTok{const}\NormalTok{ q }\OperatorTok{=} \OperatorTok{\&}\NormalTok{num}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"num = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}

    \CommentTok{// *p = 10; // ❌ cannot modify value through const pointer}
    \OperatorTok{*}\NormalTok{q }\OperatorTok{=} \DecValTok{15}\OperatorTok{;}   \CommentTok{// ✅ data modifiable through q}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"num after q change = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}

\NormalTok{    show}\OperatorTok{(\&}\NormalTok{num}\OperatorTok{);} \CommentTok{// function accepts const pointer}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ const\_demo.c }\AttributeTok{{-}o}\NormalTok{ const\_demo}
\ExtensionTok{./const\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
num = 5
num after q change = 15
Value: 15
\end{verbatim}

\subsubsection{\texorpdfstring{The \texttt{volatile}
Qualifier}{The volatile Qualifier}}\label{the-volatile-qualifier}

\texttt{volatile} tells the compiler that a variable \textbf{can change
at any time}, even if your code doesn't modify it. It prevents the
compiler from optimizing out reads or writes.

Use \texttt{volatile} when:

\begin{itemize}
\tightlist
\item
  A variable can be changed by \textbf{hardware} (e.g., memory-mapped
  I/O registers).
\item
  A variable can be modified by \textbf{another thread} or
  \textbf{signal handler}.
\item
  You need to force an \textbf{actual memory read} each time, not a
  cached value.
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{volatile} \DataTypeTok{int}\NormalTok{ sensor\_value}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{sensor\_value }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// without volatile, compiler might optimize this loop away}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{sensor\_value} might be updated by hardware;
\texttt{volatile} ensures each check re-reads memory instead of reusing
a cached register value.

\subsubsection{Combining const and
volatile}\label{combining-const-and-volatile}

Yes, you can use both together, a value that can change unexpectedly,
but your code cannot modify it.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{volatile} \DataTypeTok{int}\NormalTok{ status\_register }\OperatorTok{=} \BaseNTok{0x1234}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is common in embedded systems, where a hardware register's bits may
change due to external events.

\subsubsection{Why It Matters}\label{why-it-matters-25}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{const}} improves safety and clarity: makes interfaces
  self-documenting and helps the compiler catch mistakes.
\item
  \textbf{\texttt{volatile}} preserves correctness in concurrent or
  hardware-driven systems.
\item
  Together, they let you balance optimization with precision, critical
  in low-level C programming.
\end{itemize}

If you misuse or forget them:

\begin{itemize}
\tightlist
\item
  You risk accidental modification of data (\texttt{const}).
\item
  You risk the compiler removing critical reads/writes
  (\texttt{volatile}).
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-25}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a program that tries to modify a \texttt{const\ int} through a
  pointer, observe the compiler error.
\item
  Declare a variable as \texttt{volatile\ int\ counter} and increment it
  in a loop.

  \begin{itemize}
  \tightlist
  \item
    Then remove \texttt{volatile} and inspect the generated assembly
    with \texttt{gcc\ -S}.
  \end{itemize}
\item
  Create a function with \texttt{const\ char\ *msg} and try to modify
  it, see why it's prohibited.
\item
  Experiment with \texttt{const\ int\ *p} vs \texttt{int\ *const\ p} to
  understand their difference.
\item
  Combine both: \texttt{const\ volatile\ int\ flag;} and print it in a
  loop.
\end{enumerate}

In C, \texttt{const} and \texttt{volatile} are more than just keywords,
they're contracts. They tell the compiler exactly how memory can be
used, which helps both humans and machines reason safely about your
code.

\subsection{28. Function Pointers and
Callbacks}\label{function-pointers-and-callbacks}

Functions in C are values too, they live in memory and have addresses
just like variables. A \textbf{function pointer} is a pointer that
stores the address of a function, allowing you to call that function
indirectly. This idea powers callbacks, event systems, custom sorters,
and plug-in architectures in C.

\subsubsection{What Is a Function
Pointer?}\label{what-is-a-function-pointer}

Just like \texttt{int\ *} points to an integer, a \textbf{function
pointer} points to a function.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{return\_type }\OperatorTok{(*}\NormalTok{pointer\_name}\OperatorTok{)(}\NormalTok{parameter\_types}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int} \OperatorTok{(*}\NormalTok{func\_ptr}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{)} \OperatorTok{=}\NormalTok{ add}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can call the function through the pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ func\_ptr}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{);} \CommentTok{// same as add(2, 3)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-26}

Here's a complete example showing how to declare, assign, and call
function pointers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ sub}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ operate}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{(*}\NormalTok{op}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ op}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));} \CommentTok{// call through pointer}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{(*}\NormalTok{f}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);} \CommentTok{// declaration}

\NormalTok{    f }\OperatorTok{=}\NormalTok{ add}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Add via pointer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ f}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}

\NormalTok{    f }\OperatorTok{=}\NormalTok{ sub}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Subtract via pointer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ f}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Using callback function:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    operate}\OperatorTok{(}\DecValTok{4}\OperatorTok{,} \DecValTok{6}\OperatorTok{,}\NormalTok{ mul}\OperatorTok{);} \CommentTok{// pass function pointer as argument}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ func\_pointer\_demo.c }\AttributeTok{{-}o}\NormalTok{ func\_pointer\_demo}
\ExtensionTok{./func\_pointer\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Add via pointer: 8
Subtract via pointer: 2

Using callback function:
Result: 24
\end{verbatim}

\subsubsection{Function Pointers in
Arrays}\label{function-pointers-in-arrays}

You can also store multiple function pointers in an array, useful for
building tables of operations.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{(*}\NormalTok{ops}\OperatorTok{[}\DecValTok{3}\OperatorTok{])(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{)} \OperatorTok{=} \OperatorTok{\{}\NormalTok{add}\OperatorTok{,}\NormalTok{ sub}\OperatorTok{,}\NormalTok{ mul}\OperatorTok{\};}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"ops[}\SpecialCharTok{\%d}\StringTok{](4, 2) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ ops}\OperatorTok{[}\NormalTok{i}\OperatorTok{](}\DecValTok{4}\OperatorTok{,} \DecValTok{2}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
ops[0](4, 2) = 6
ops[1](4, 2) = 2
ops[2](4, 2) = 8
\end{verbatim}

This pattern underlies dispatch tables, interpreters, and virtual
function systems in C.

\subsubsection{Callbacks}\label{callbacks}

A \textbf{callback} is a function you pass as an argument to another
function, letting the callee ``call back'' into user code. This pattern
is essential in event-driven and modular designs.

Example: a simple iterator that accepts a callback

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ for\_each}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{,} \DataTypeTok{void} \OperatorTok{(*}\NormalTok{callback}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{))} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        callback}\OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print\_square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{\^{}2 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
\NormalTok{    for\_each}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,} \DecValTok{5}\OperatorTok{,}\NormalTok{ print\_square}\OperatorTok{);} \CommentTok{// pass callback}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1^2 = 1
2^2 = 4
3^2 = 9
4^2 = 16
5^2 = 25
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-26}

Function pointers let you:

\begin{itemize}
\tightlist
\item
  Select behavior at runtime (dynamic dispatch).
\item
  Pass logic into libraries without recompiling them.
\item
  Build frameworks, event handlers, interpreters, and plug-ins.
\item
  Replace huge switch-case structures with elegant dispatch tables.
\end{itemize}

They are also how C implements:

\begin{itemize}
\tightlist
\item
  \texttt{qsort()} and \texttt{bsearch()} comparison functions,
\item
  signal handlers (\texttt{signal(SIGINT,\ handler)}), and
\item
  system callbacks in GUIs or kernels.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-26}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write three arithmetic functions and store them in an array of
  function pointers.
\item
  Build a \texttt{calculate(a,\ b,\ char\ op)} function that picks the
  right function pointer based on \texttt{op}.
\item
  Implement a callback-style loop that calls a user-defined function for
  each array element.
\item
  Pass a function pointer to \texttt{qsort()} from
  \texttt{\textless{}stdlib.h\textgreater{}} to sort integers in
  descending order.
\item
  Write a small menu system that calls the right function based on user
  choice.
\end{enumerate}

Function pointers and callbacks give your programs flexibility and
abstraction without sacrificing speed. They're how C achieves dynamic
behavior, the bridge between data and executable logic.

\subsection{29. Deep vs Shallow Copies}\label{deep-vs-shallow-copies}

When you assign one variable to another in C, you're often copying
\emph{addresses}, not \emph{actual data}. This distinction between
\textbf{shallow copies} and \textbf{deep copies} becomes critical when
working with pointers, arrays, and dynamically allocated structures.
Understanding it helps you prevent memory corruption, double frees, and
mysterious bugs.

\subsubsection{The Core Idea}\label{the-core-idea}

\begin{itemize}
\tightlist
\item
  A \textbf{shallow copy} duplicates only the pointer, both variables
  refer to the \emph{same memory}.
\item
  A \textbf{deep copy} duplicates the \emph{data itself}, each variable
  owns its own independent memory.
\end{itemize}

\subsubsection{Simple Analogy}\label{simple-analogy}

Think of shallow vs deep copy like two houses:

\begin{itemize}
\tightlist
\item
  \textbf{Shallow copy:} You hand someone your house key. You both open
  the same door.
\item
  \textbf{Deep copy:} You build a new house that looks identical, but is
  separate.
\end{itemize}

\subsubsection{Shallow Copy Example}\label{shallow-copy-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{original }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{original}\OperatorTok{,} \StringTok{"Hello"}\OperatorTok{);}

    \CommentTok{// Shallow copy}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{copy }\OperatorTok{=}\NormalTok{ original}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before change: }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ original}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{);}

\NormalTok{    copy}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}J\textquotesingle{}}\OperatorTok{;} \CommentTok{// modify one}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After change: }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ original}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{original}\OperatorTok{);}
    \CommentTok{// free(copy); // ❌ would cause double free error!}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before change: Hello | Hello
After change: Jello | Jello
\end{verbatim}

Explanation:

\begin{itemize}
\tightlist
\item
  \texttt{copy} points to the \emph{same memory} as \texttt{original}.
\item
  Changing one changes both.
\item
  You must only \texttt{free()} it once, freeing both is a bug.
\end{itemize}

\subsubsection{Deep Copy Example}\label{deep-copy-example}

A deep copy allocates new memory and copies the data over.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{original }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{original}\OperatorTok{,} \StringTok{"Hello"}\OperatorTok{);}

    \CommentTok{// Deep copy}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{copy }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{original}\OperatorTok{)} \OperatorTok{+} \DecValTok{1}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{copy}\OperatorTok{,}\NormalTok{ original}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before change: }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ original}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{);}

\NormalTok{    copy}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}J\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After change: }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ original}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{original}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{copy}\OperatorTok{);} \CommentTok{// ✅ both safely freed}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before change: Hello | Hello
After change: Hello | Jello
\end{verbatim}

Now the two strings are completely independent, a true deep copy.

\subsubsection{Shallow vs Deep in
Structs}\label{shallow-vs-deep-in-structs}

Consider this structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Person}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If you assign one \texttt{Person} to another:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
\NormalTok{a}\OperatorTok{.}\NormalTok{name }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{20}\OperatorTok{);}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{a}\OperatorTok{.}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}

\NormalTok{b }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;} \CommentTok{// shallow copy}
\NormalTok{b}\OperatorTok{.}\NormalTok{name}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}M\textquotesingle{}}\OperatorTok{;} \CommentTok{// modifies a.name too!}
\end{Highlighting}
\end{Shaded}

Both \texttt{a} and \texttt{b} point to the same memory. To make a deep
copy:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}\OperatorTok{.}\NormalTok{name }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{a}\OperatorTok{.}\NormalTok{name}\OperatorTok{)} \OperatorTok{+} \DecValTok{1}\OperatorTok{);}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{b}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ a}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now they're independent.

\subsubsection{Tiny Code}\label{tiny-code-27}

Here's a full program demonstrating both copies with structs:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Person}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ print\_person}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{label}\OperatorTok{,}\NormalTok{ Person p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{: name=}\SpecialCharTok{\%s}\StringTok{ age=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ label}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{age}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Person p1}\OperatorTok{;}
\NormalTok{    p1}\OperatorTok{.}\NormalTok{name }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{20}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{p1}\OperatorTok{.}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}
\NormalTok{    p1}\OperatorTok{.}\NormalTok{age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}

    \CommentTok{// Shallow copy}
\NormalTok{    Person p2 }\OperatorTok{=}\NormalTok{ p1}\OperatorTok{;}
\NormalTok{    print\_person}\OperatorTok{(}\StringTok{"Before"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{);}
\NormalTok{    p2}\OperatorTok{.}\NormalTok{name}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}M\textquotesingle{}}\OperatorTok{;} \CommentTok{// modifies same memory}
\NormalTok{    print\_person}\OperatorTok{(}\StringTok{"After shallow copy"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{);}

    \CommentTok{// Deep copy}
\NormalTok{    Person p3}\OperatorTok{;}
\NormalTok{    p3}\OperatorTok{.}\NormalTok{name }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{p1}\OperatorTok{.}\NormalTok{name}\OperatorTok{)} \OperatorTok{+} \DecValTok{1}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{p3}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{    p3}\OperatorTok{.}\NormalTok{age }\OperatorTok{=}\NormalTok{ p1}\OperatorTok{.}\NormalTok{age}\OperatorTok{;}

\NormalTok{    p3}\OperatorTok{.}\NormalTok{name}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}C\textquotesingle{}}\OperatorTok{;} \CommentTok{// independent copy}
\NormalTok{    print\_person}\OperatorTok{(}\StringTok{"After deep copy"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{);}
\NormalTok{    print\_person}\OperatorTok{(}\StringTok{"Deep copy result"}\OperatorTok{,}\NormalTok{ p3}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{p1}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{p3}\OperatorTok{.}\NormalTok{name}\OperatorTok{);} \CommentTok{// ✅ safe}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before: name=Alice age=25
After shallow copy: name=Mlice age=25
After deep copy: name=Mlice age=25
Deep copy result: name=Clice age=25
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-27}

Shallow and deep copies determine \textbf{ownership} of memory:

\begin{itemize}
\tightlist
\item
  If two variables share the same pointer (shallow), freeing one
  invalidates the other.
\item
  Deep copies isolate data, preventing interference but using more
  memory.
\end{itemize}

Getting this wrong leads to:

\begin{itemize}
\tightlist
\item
  Double free or dangling pointer errors
\item
  Memory leaks
\item
  Corrupted data in complex structures
\end{itemize}

Understanding these concepts is crucial for:

\begin{itemize}
\tightlist
\item
  Managing dynamic arrays and linked lists
\item
  Designing APIs that safely return or duplicate data
\item
  Writing custom copy constructors for structs
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-27}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a struct with dynamically allocated fields (e.g.,
  \texttt{name}, \texttt{address}) and write two copy functions:
  \texttt{copy\_shallow()} and \texttt{copy\_deep()}.
\item
  Modify one copy and observe the difference.
\item
  Call \texttt{free()} in the wrong order and note what happens.
\item
  Use Valgrind to verify that deep copies are properly freed.
\item
  Extend the concept to an array of structs, implement deep copy for
  each element.
\end{enumerate}

When you understand deep vs shallow copies, you control \textbf{how
memory ownership moves} in your program, a foundation for safe, modular,
and leak-free C design.

\subsection{30. Practice: Manual Memory
Management}\label{practice-manual-memory-management}

Now that you've learned how memory works, stack vs heap, allocation,
freeing, leaks, deep vs shallow copies, it's time to practice
\textbf{controlling memory manually}. This exercise ties together
\texttt{malloc}, \texttt{free}, pointers, and struct management in a
real, runnable program.

You'll build a small system that stores and manipulates dynamically
allocated records, a tiny simulation of how databases or object systems
manage memory in C.

\subsubsection{Goal}\label{goal}

Create a simple ``student record manager'' that can:

\begin{itemize}
\tightlist
\item
  Dynamically allocate memory for each student's name.
\item
  Store and print student data.
\item
  Free all allocated memory cleanly at the end.
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-28}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ gpa}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Student}\OperatorTok{;}

\NormalTok{Student }\OperatorTok{*}\NormalTok{create\_student}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ age}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ gpa}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Student }\OperatorTok{*}\NormalTok{s }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Student}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Memory allocation failed for Student.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{name }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{name}\OperatorTok{)} \OperatorTok{+} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{s}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Memory allocation failed for name.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{s}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{age }\OperatorTok{=}\NormalTok{ age}\OperatorTok{;}
\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{gpa }\OperatorTok{=}\NormalTok{ gpa}\OperatorTok{;}

    \ControlFlowTok{return}\NormalTok{ s}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Student }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Name: }\SpecialCharTok{\%{-}10s}\StringTok{ | Age: }\SpecialCharTok{\%d}\StringTok{ | GPA: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{age}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{gpa}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_student}\OperatorTok{(}\NormalTok{Student }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    free}\OperatorTok{(}\NormalTok{s}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"=== Manual Memory Management Demo ===}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// Create three students dynamically}
\NormalTok{    Student }\OperatorTok{*}\NormalTok{a }\OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \FloatTok{3.8}\BuiltInTok{f}\OperatorTok{);}
\NormalTok{    Student }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Bob"}\OperatorTok{,} \DecValTok{22}\OperatorTok{,} \FloatTok{3.4}\BuiltInTok{f}\OperatorTok{);}
\NormalTok{    Student }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Carol"}\OperatorTok{,} \DecValTok{19}\OperatorTok{,} \FloatTok{3.9}\BuiltInTok{f}\OperatorTok{);}

    \CommentTok{// Print their details}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{b}\OperatorTok{);}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}

    \CommentTok{// Modify dynamically allocated memory}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{b}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,} \StringTok{"Bobby"}\OperatorTok{);}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{gpa }\OperatorTok{=} \FloatTok{3.6}\BuiltInTok{f}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{After update:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{b}\OperatorTok{);}

    \CommentTok{// Free memory}
\NormalTok{    free\_student}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}
\NormalTok{    free\_student}\OperatorTok{(}\NormalTok{b}\OperatorTok{);}
\NormalTok{    free\_student}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{All memory released.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ manual\_memory.c }\AttributeTok{{-}o}\NormalTok{ manual\_memory}
\ExtensionTok{./manual\_memory}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
=== Manual Memory Management Demo ===
Name: Alice      | Age: 20 | GPA: 3.80
Name: Bob        | Age: 22 | GPA: 3.40
Name: Carol      | Age: 19 | GPA: 3.90

After update:
Name: Bobby      | Age: 22 | GPA: 3.60

All memory released.
\end{verbatim}

\subsubsection{How It Works}\label{how-it-works}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Dynamic Allocation:} Each \texttt{Student} and its
  \texttt{name} field are created on the heap with \texttt{malloc()}.
  You control exactly when they exist and when to destroy them.
\item
  \textbf{Ownership:}

  \begin{itemize}
  \tightlist
  \item
    The program owns each student's memory.
  \item
    Each \texttt{create\_student()} call must later be matched by
    \texttt{free\_student()}.
  \end{itemize}
\item
  \textbf{Memory Safety:}

  \begin{itemize}
  \tightlist
  \item
    Every \texttt{malloc} result is checked.
  \item
    Freed memory is properly released before exit.
  \end{itemize}
\end{enumerate}

\subsubsection{Expanding the Example}\label{expanding-the-example}

Try these modifications:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Dynamic Array of Students}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Student }\OperatorTok{**}\NormalTok{students }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Student }\OperatorTok{*));}
\NormalTok{students}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Ava"}\OperatorTok{,} \DecValTok{21}\OperatorTok{,} \FloatTok{3.7}\BuiltInTok{f}\OperatorTok{);}
\NormalTok{students}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Ben"}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \FloatTok{3.5}\BuiltInTok{f}\OperatorTok{);}
\NormalTok{students}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=}\NormalTok{ create\_student}\OperatorTok{(}\StringTok{"Cleo"}\OperatorTok{,} \DecValTok{23}\OperatorTok{,} \FloatTok{3.9}\BuiltInTok{f}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

  Iterate through them and print all details, then free each one.
\item
  \textbf{Reallocation (grow list)} Use \texttt{realloc()} to increase
  your array's capacity when adding more students dynamically.
\item
  \textbf{Deep Copy Function} Implement:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Student }\OperatorTok{*}\NormalTok{copy\_student}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Student }\OperatorTok{*}\NormalTok{src}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

  which performs a deep copy by allocating new memory for both the
  struct and its name.
\item
  \textbf{Leak Detection} Run your program with
  \texttt{valgrind\ ./manual\_memory}, confirm that all memory is freed
  cleanly.
\end{enumerate}

\subsubsection{Why It Matters}\label{why-it-matters-28}

This small example mirrors what real C systems do:

\begin{itemize}
\tightlist
\item
  Allocate complex data on demand.
\item
  Manage lifetime explicitly.
\item
  Clean up correctly.
\end{itemize}

Everything from operating systems to databases and compilers depends on
this discipline. Once you can manage small dynamic structures like this
confidently, you're ready to build larger systems safely, from
allocators to object pools to file caches.

\subsubsection{Try It Yourself}\label{try-it-yourself-28}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a new field (\texttt{major}) and handle it dynamically.
\item
  Add an array of grades and compute averages.
\item
  Convert your static list into a dynamically resizable array using
  \texttt{realloc}.
\item
  Intentionally omit a \texttt{free()} call, then detect the leak with
  Valgrind.
\item
  Write a \texttt{destroy\_all()} function that frees an array of
  students safely.
\end{enumerate}

You've now completed \textbf{Chapter 3: Working with Memory}. You
understand how data lives, moves, and disappears in C, and you've
practiced taking full control over it. From here, you'll learn how to
\textbf{structure} that data elegantly using \texttt{struct},
\texttt{union}, and real-world data abstractions in Chapter 4.

\bookmarksetup{startatroot}

\chapter{Chapter 4. Structuring Data}\label{chapter-4.-structuring-data}

\subsection{31. Structures and Nested
Structures}\label{structures-and-nested-structures}

Real-world programs often deal with groups of related data, not just
single variables. For example, a person has a name, an age, and an
address. Instead of juggling separate variables, you can \textbf{combine
them into a single structure} using \texttt{struct}.

\texttt{struct} is one of the most powerful features in C, it lets you
define your own data types that group information logically and
efficiently.

\subsubsection{What Is a Structure?}\label{what-is-a-structure}

A \textbf{structure} is a user-defined type that holds variables of
different kinds under one name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ height}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This declares a \emph{template} for a \texttt{Person} object. It doesn't
create actual data yet, just the blueprint.

\subsubsection{Declaring and Using
Structures}\label{declaring-and-using-structures}

You can now create variables of this new type:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ height}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Person p1 }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \FloatTok{1.65}\BuiltInTok{f}\OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Name: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{.}\NormalTok{age}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Height: }\SpecialCharTok{\%.2f}\StringTok{ m}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{.}\NormalTok{height}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Name: Alice
Age: 25
Height: 1.65 m
\end{verbatim}

\subsubsection{Accessing Members}\label{accessing-members}

Use the dot operator \texttt{.} to access fields of a structure
variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p1}\OperatorTok{.}\NormalTok{age }\OperatorTok{=} \DecValTok{26}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Updated age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p1}\OperatorTok{.}\NormalTok{age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you have a pointer to a structure, use the arrow operator
\texttt{-\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p1}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Pointer access: }\SpecialCharTok{\%s}\StringTok{ is }\SpecialCharTok{\%d}\StringTok{ years old.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ptr}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ ptr}\OperatorTok{{-}\textgreater{}}\NormalTok{age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Pointer access: Alice is 26 years old.
\end{verbatim}

\subsubsection{Initializing and Copying
Structures}\label{initializing-and-copying-structures}

You can initialize a struct directly:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Person p2 }\OperatorTok{=} \OperatorTok{\{.}\NormalTok{name }\OperatorTok{=} \StringTok{"Bob"}\OperatorTok{,} \OperatorTok{.}\NormalTok{age }\OperatorTok{=} \DecValTok{30}\OperatorTok{,} \OperatorTok{.}\NormalTok{height }\OperatorTok{=} \FloatTok{1.75}\BuiltInTok{f}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Structures can be assigned and copied by value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Person copy }\OperatorTok{=}\NormalTok{ p2}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Copy: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ copy}\OperatorTok{.}\NormalTok{age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This performs a \textbf{shallow copy}, all fields are copied, but if any
contain pointers, they'll still refer to the same memory (you'll learn
how to make deep copies later).

\subsubsection{Nested Structures}\label{nested-structures}

Structures can contain other structures. This helps you organize complex
data clearly.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ month}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Date birthdate}\OperatorTok{;} \CommentTok{// nested structure}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Student s }\OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{.}\NormalTok{name }\OperatorTok{=} \StringTok{"Carol"}\OperatorTok{,}
        \OperatorTok{.}\NormalTok{id }\OperatorTok{=} \DecValTok{1234}\OperatorTok{,}
        \OperatorTok{.}\NormalTok{birthdate }\OperatorTok{=} \OperatorTok{\{}\DecValTok{15}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{2003}\OperatorTok{\}}
    \OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ (ID }\SpecialCharTok{\%d}\StringTok{) was born on }\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%04d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}
\NormalTok{           s}\OperatorTok{.}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Carol (ID 1234) was born on 15/08/2003
\end{verbatim}

You access nested fields with the dot operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s}\OperatorTok{.}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{year }\OperatorTok{=} \DecValTok{2004}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Structures and Functions}\label{structures-and-functions}

You can pass structs to functions by value or by pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_person}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Person p}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ update\_age}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ new\_age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ update\_age}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ new\_age}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{age }\OperatorTok{=}\NormalTok{ new\_age}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Passing a pointer is more efficient, especially for large structures.

\subsubsection{Tiny Code}\label{tiny-code-29}

Here's a full example combining everything above:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ month}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Person }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ height}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Date birthdate}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_person}\OperatorTok{(}\DataTypeTok{const} \KeywordTok{struct}\NormalTok{ Person }\OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{, }\SpecialCharTok{\%d}\StringTok{ years old, born on }\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%04d}\StringTok{, height }\SpecialCharTok{\%.2f}\StringTok{m}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           p}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{age}\OperatorTok{,}
\NormalTok{           p}\OperatorTok{{-}\textgreater{}}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{year}\OperatorTok{,}
\NormalTok{           p}\OperatorTok{{-}\textgreater{}}\NormalTok{height}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Person person }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{25}\OperatorTok{,} \FloatTok{1.68}\BuiltInTok{f}\OperatorTok{,} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{1999}\OperatorTok{\}\};}

\NormalTok{    print\_person}\OperatorTok{(\&}\NormalTok{person}\OperatorTok{);}

\NormalTok{    person}\OperatorTok{.}\NormalTok{age}\OperatorTok{++;}
\NormalTok{    person}\OperatorTok{.}\NormalTok{birthdate}\OperatorTok{.}\NormalTok{year}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After update:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    print\_person}\OperatorTok{(\&}\NormalTok{person}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Alice, 25 years old, born on 01/02/1999, height 1.68m
After update:
Alice, 26 years old, born on 01/02/2000, height 1.68m
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-29}

Structures let you:

\begin{itemize}
\tightlist
\item
  Combine related data into logical units.
\item
  Model real-world entities directly in code.
\item
  Pass data efficiently between functions.
\item
  Build higher-level data abstractions like lists, trees, or objects.
\end{itemize}

They're the foundation of all complex C systems, files, network packets,
kernel data, even database rows are built on top of \texttt{struct}.

\subsubsection{Try It Yourself}\label{try-it-yourself-29}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{Book} structure with \texttt{title}, \texttt{author},
  and \texttt{year}.
\item
  Write a function to print all details of a \texttt{Book}.
\item
  Create a nested structure \texttt{Library} that contains multiple
  books.
\item
  Access a nested field (e.g., the title of the first book).
\item
  Modify the \texttt{Library} through a pointer using the
  \texttt{-\textgreater{}} operator.
\end{enumerate}

Structures are how C lets you \textbf{model the world}, compact,
explicit, and fast. Next, you'll learn about \textbf{unions} and how C
lets different data types share the same memory space efficiently.

\subsection{32. Unions and Type Reuse}\label{unions-and-type-reuse}

Sometimes you need a variable that can hold \emph{different types of
data} at different times, but you don't want to waste memory keeping all
of them active at once. That's where \textbf{unions} come in.

A \texttt{union} lets multiple fields share the \emph{same memory
location}. It's a space-saving feature and a powerful tool for
implementing type flexibility, variant data, and even low-level binary
manipulation.

\subsubsection{What Is a Union?}\label{what-is-a-union}

A \textbf{union} is like a structure, but instead of giving each member
its own memory, \emph{all members share the same memory block}. Only one
field is valid at any moment.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{union}\NormalTok{ Data }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ c}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Here, \texttt{i}, \texttt{f}, and \texttt{c} share the same storage. The
size of the union is equal to the size of its \emph{largest} member.

\subsubsection{Using a Union}\label{using-a-union}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{union}\NormalTok{ Data }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ c}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{union}\NormalTok{ Data d}\OperatorTok{;}

\NormalTok{    d}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"d.i = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}

\NormalTok{    d}\OperatorTok{.}\NormalTok{f }\OperatorTok{=} \FloatTok{3.14}\BuiltInTok{f}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"d.f = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{f}\OperatorTok{);}

\NormalTok{    d}\OperatorTok{.}\NormalTok{c }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"d.c = }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{c}\OperatorTok{);}

    \CommentTok{// The last assignment overwrites the previous ones}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After d.c = \textquotesingle{}A\textquotesingle{}, d.i = }\SpecialCharTok{\%d}\StringTok{ (corrupted)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
d.i = 42
d.f = 3.14
d.c = A
After d.c = 'A', d.i = 1094795585
\end{verbatim}

Notice how writing to one member affects the others, because they occupy
the same memory.

\subsubsection{Memory Layout
Illustration}\label{memory-layout-illustration}

\begin{verbatim}
+------------------+
| Shared Memory    |  <- same location for all fields
| (size = largest) |
+------------------+
| i: 4 bytes       |
| f: 4 bytes       |
| c: 1 byte        |
+------------------+
\end{verbatim}

All fields overlap in the same storage area.

\subsubsection{Tiny Code}\label{tiny-code-30}

Let's see a practical example where a union saves memory.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{union}\NormalTok{ Value }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{union}\NormalTok{ Value v}\OperatorTok{;}

\NormalTok{    v}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"As int: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}

\NormalTok{    v}\OperatorTok{.}\NormalTok{f }\OperatorTok{=} \FloatTok{3.14}\BuiltInTok{f}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"As float: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{.}\NormalTok{f}\OperatorTok{);}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{v}\OperatorTok{.}\NormalTok{str}\OperatorTok{,} \StringTok{"Hello"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"As string: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{.}\NormalTok{str}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Union size: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{v}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
As int: 42
As float: 3.14
As string: Hello
Union size: 20 bytes
\end{verbatim}

Even though it contains an \texttt{int}, a \texttt{float}, and a
\texttt{char{[}20{]}}, the total size is only 20 bytes, the size of the
largest member.

\subsubsection{Tagged Unions (Type-Safe
Pattern)}\label{tagged-unions-type-safe-pattern}

In practice, you often use a \textbf{tag} (an enum or integer) to
remember which member is active, this is known as a \emph{tagged union}
or \emph{discriminated union}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{enum}\NormalTok{ Type }\OperatorTok{\{}\NormalTok{ INT}\OperatorTok{,}\NormalTok{ FLOAT}\OperatorTok{,}\NormalTok{ STRING }\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Variant }\OperatorTok{\{}
    \KeywordTok{enum}\NormalTok{ Type type}\OperatorTok{;}
    \KeywordTok{union} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
        \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
    \OperatorTok{\}}\NormalTok{ data}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_variant}\OperatorTok{(}\DataTypeTok{const} \KeywordTok{struct}\NormalTok{ Variant }\OperatorTok{*}\NormalTok{v}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{v}\OperatorTok{{-}\textgreater{}}\NormalTok{type}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case}\NormalTok{ INT}\OperatorTok{:}\NormalTok{   printf}\OperatorTok{(}\StringTok{"INT: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{{-}\textgreater{}}\NormalTok{data}\OperatorTok{.}\NormalTok{i}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ FLOAT}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"FLOAT: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{{-}\textgreater{}}\NormalTok{data}\OperatorTok{.}\NormalTok{f}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ STRING}\OperatorTok{:}\NormalTok{printf}\OperatorTok{(}\StringTok{"STRING: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{{-}\textgreater{}}\NormalTok{data}\OperatorTok{.}\NormalTok{str}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Variant v}\OperatorTok{;}

\NormalTok{    v}\OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ STRING}\OperatorTok{;}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{v}\OperatorTok{.}\NormalTok{data}\OperatorTok{.}\NormalTok{str}\OperatorTok{,} \StringTok{"C Language"}\OperatorTok{);}
\NormalTok{    print\_variant}\OperatorTok{(\&}\NormalTok{v}\OperatorTok{);}

\NormalTok{    v}\OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ INT}\OperatorTok{;}
\NormalTok{    v}\OperatorTok{.}\NormalTok{data}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{123}\OperatorTok{;}
\NormalTok{    print\_variant}\OperatorTok{(\&}\NormalTok{v}\OperatorTok{);}

\NormalTok{    v}\OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ FLOAT}\OperatorTok{;}
\NormalTok{    v}\OperatorTok{.}\NormalTok{data}\OperatorTok{.}\NormalTok{f }\OperatorTok{=} \FloatTok{9.81}\BuiltInTok{f}\OperatorTok{;}
\NormalTok{    print\_variant}\OperatorTok{(\&}\NormalTok{v}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
STRING: C Language
INT: 123
FLOAT: 9.81
\end{verbatim}

This is how you combine the flexibility of unions with the safety of
knowing which field is currently valid.

\subsubsection{Why It Matters}\label{why-it-matters-30}

Unions are crucial for:

\begin{itemize}
\tightlist
\item
  \textbf{Saving memory}, only one field exists at a time.
\item
  \textbf{Implementing variant data types}, e.g., JSON values,
  expression trees, network packets.
\item
  \textbf{Working with hardware registers}, map one register into
  multiple view types.
\item
  \textbf{Binary serialization}, reinterpret raw bytes as various data
  forms.
\end{itemize}

In low-level systems, they enable compact and flexible representations
that C is famous for.

\subsubsection{Try It Yourself}\label{try-it-yourself-30}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a union \texttt{Number} with \texttt{int}, \texttt{float}, and
  \texttt{double}.

  \begin{itemize}
  \tightlist
  \item
    Print its size and observe which member determines it.
  \end{itemize}
\item
  Implement a tagged union \texttt{Message} with types TEXT, BINARY, and
  COMMAND.
\item
  Create a struct with an enum tag and a union, simulate how file
  formats (like PNG chunks) are parsed.
\item
  Write a function that prints the active union field using the tag.
\item
  Modify the previous example to store an array of tagged unions.
\end{enumerate}

In C, \textbf{unions give you memory control and flexibility} that few
languages allow. They're the foundation for advanced constructs like
variant types, polymorphic structs, and even message protocols, used
everywhere from the Linux kernel to embedded firmware.

\subsection{33. Typedef and Code
Clarity}\label{typedef-and-code-clarity}

C gives you the power to create your own type names using the
\texttt{typedef} keyword. It doesn't create new types at runtime,
instead, it creates \textbf{aliases} that make your code cleaner, more
expressive, and easier to maintain.

If \texttt{struct}, \texttt{enum}, or pointer syntax ever feels
cluttered, \texttt{typedef} is your best friend.

\subsubsection{\texorpdfstring{What Is
\texttt{typedef}?}{What Is typedef?}}\label{what-is-typedef}

\texttt{typedef} gives an existing type a new name. It's like a
\emph{nickname} for a complex or frequently used declaration.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef}\NormalTok{ existing\_type new\_name}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ ulong}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{ulong} can be used wherever you'd normally write
\texttt{unsigned\ long}.

\subsubsection{Basic Examples}\label{basic-examples}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \DataTypeTok{int}\NormalTok{ Score}\OperatorTok{;}
\KeywordTok{typedef} \DataTypeTok{char}\NormalTok{ Letter}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Score math }\OperatorTok{=} \DecValTok{95}\OperatorTok{;}
\NormalTok{    Letter grade }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Math: }\SpecialCharTok{\%d}\StringTok{, Grade: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ math}\OperatorTok{,}\NormalTok{ grade}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Math: 95, Grade: A
\end{verbatim}

It doesn't change how the compiler treats the variable, just makes the
code more readable.

\subsubsection{Typedef with Pointers}\label{typedef-with-pointers}

Pointer declarations can get messy. With \texttt{typedef}, you can
simplify them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{int}\OperatorTok{*}\NormalTok{ IntPtr}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    IntPtr p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;} \CommentTok{// same as int *p = \&x;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 10
\end{verbatim}

\begin{quote}
\textbf{Tip:} Be careful, \texttt{IntPtr\ a,\ b;} means \emph{both}
\texttt{a} and \texttt{b} are pointers, unlike plain
\texttt{int\ *a,\ b;}.
\end{quote}

\subsubsection{Typedef with Structures}\label{typedef-with-structures}

\texttt{typedef} shines with \texttt{struct}, \texttt{union}, and
\texttt{enum} declarations. Without typedef:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Point p1 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

With typedef:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}

\NormalTok{Point p1 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

No more need to repeat the word \texttt{struct} everywhere.

\subsubsection{Combining Struct and
Typedef}\label{combining-struct-and-typedef}

You can define and alias a struct in one line:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Person }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Person}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person p }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{25}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

instead of:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Person p }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{25}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\subsubsection{Typedef with Function
Pointers}\label{typedef-with-function-pointers}

Function pointer syntax can be hard to read, typedef simplifies it
dramatically.

Without typedef:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{(*}\NormalTok{operation}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

With typedef:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{int} \OperatorTok{(*}\NormalTok{Operation}\OperatorTok{)(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Operation op }\OperatorTok{=}\NormalTok{ add}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ op}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{Operation} is a clean alias for a pointer to a function that
takes two ints and returns an int.

\subsubsection{Tiny Code}\label{tiny-code-31}

Here's a full example showing typedefs for structs, pointers, and
function types:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Person}\OperatorTok{;}

\KeywordTok{typedef}\NormalTok{ Person}\OperatorTok{*}\NormalTok{ PersonPtr}\OperatorTok{;}
\KeywordTok{typedef} \DataTypeTok{void} \OperatorTok{(*}\NormalTok{Printer}\OperatorTok{)(}\DataTypeTok{const}\NormalTok{ Person}\OperatorTok{*);}

\DataTypeTok{void}\NormalTok{ print\_person}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Person }\OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%d}\StringTok{ years old)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{age}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Person p }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Alice"}\OperatorTok{,} \DecValTok{25}\OperatorTok{\};}
\NormalTok{    PersonPtr ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;}
\NormalTok{    Printer print }\OperatorTok{=}\NormalTok{ print\_person}\OperatorTok{;}

\NormalTok{    print}\OperatorTok{(}\NormalTok{ptr}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Alice (25 years old)
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-31}

\texttt{typedef} improves:

\begin{itemize}
\tightlist
\item
  \textbf{Clarity:} Long or complex declarations become readable.
\item
  \textbf{Consistency:} Standardize naming (e.g., \texttt{size\_t},
  \texttt{uint32\_t}).
\item
  \textbf{Maintainability:} Changing underlying types is easier, one
  typedef change updates all uses.
\item
  \textbf{Abstraction:} Hides implementation details, especially in
  headers.
\end{itemize}

It's especially useful in large projects and system APIs, where naming
conventions define clean boundaries.

\subsubsection{Common Typedef Patterns}\label{common-typedef-patterns}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2763}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7237}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Standard aliases & \texttt{typedef\ unsigned\ int\ uint;} \\
Struct abstraction & \texttt{typedef\ struct\ Node\ Node;} \\
Function pointer type &
\texttt{typedef\ void\ (*Handler)(int\ signal);} \\
Handle-like pattern & \texttt{typedef\ struct\ File*\ FileHandle;} \\
Platform types &
\texttt{typedef\ long\ long\ int64;\ typedef\ unsigned\ int\ uint32;} \\
\end{longtable}

\subsubsection{Try It Yourself}\label{try-it-yourself-31}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define a \texttt{typedef} for \texttt{unsigned\ long\ long} called
  \texttt{u64}.
\item
  Create a \texttt{typedef\ struct} called \texttt{Book} with fields for
  title and pages.
\item
  Define a \texttt{typedef} for a function pointer
  \texttt{Comparator(int,\ int)}.
\item
  Write a program that passes a \texttt{Comparator} to a sorting
  function.
\item
  Modify one typedef and observe how the code compiles cleanly without
  further edits.
\end{enumerate}

\texttt{typedef} may look simple, but it's one of the most powerful
readability tools in C. It lets you design your own vocabulary for your
system, a small step toward writing clean, self-documenting code that
scales.

\subsection{34. Bitfields and Memory
Packing}\label{bitfields-and-memory-packing}

C lets you control data layout down to the \emph{bit level} using
\textbf{bitfields}. They allow you to store small values compactly
inside a struct, perfect for flags, configuration registers, or
communication protocols. Combined with \emph{packing}, you can squeeze
data into minimal space while still keeping it easy to manipulate
symbolically.

\subsubsection{What Is a Bitfield?}\label{what-is-a-bitfield}

A \textbf{bitfield} lets you define the exact number of bits to allocate
for a field inside a \texttt{struct}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Flags }\OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ is\_visible }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ is\_enabled }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ has\_error  }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Here, each field uses just \textbf{1 bit} instead of a full 4-byte
\texttt{int}. That means 8 such flags fit comfortably in one byte.

\subsubsection{Declaring and Using
Bitfields}\label{declaring-and-using-bitfields}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Status }\OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ connected }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ error     }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ active    }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ reserved  }\OperatorTok{:} \DecValTok{5}\OperatorTok{;} \CommentTok{// padding bits}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Status s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Connected: }\SpecialCharTok{\%u}\StringTok{, Active: }\SpecialCharTok{\%u\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{connected}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{active}\OperatorTok{);}
\NormalTok{    s}\OperatorTok{.}\NormalTok{error }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Error now: }\SpecialCharTok{\%u\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{error}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Connected: 1, Active: 1
Error now: 1
\end{verbatim}

Even though there are 4 fields, the entire struct typically occupies
only 1 byte.

\subsubsection{Tiny Code}\label{tiny-code-32}

Here's a complete example demonstrating packed flags and printing bit
values:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ DeviceStatus }\OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ powered\_on }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ connected  }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ has\_error  }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ battery\_low}\OperatorTok{:} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ reserved   }\OperatorTok{:} \DecValTok{4}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_bits}\OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{char}\NormalTok{ byte}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textgreater{}=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-})}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\NormalTok{byte }\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ i}\OperatorTok{)} \OperatorTok{\&} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ DeviceStatus d }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Size of DeviceStatus: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{d}\OperatorTok{));}

    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{raw }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{*)\&}\NormalTok{d}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Binary layout: "}\OperatorTok{);}
\NormalTok{    print\_bits}\OperatorTok{(*}\NormalTok{raw}\OperatorTok{);}

\NormalTok{    d}\OperatorTok{.}\NormalTok{has\_error }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Updated binary: "}\OperatorTok{);}
\NormalTok{    print\_bits}\OperatorTok{(*}\NormalTok{raw}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output (may vary by platform):

\begin{verbatim}
Size of DeviceStatus: 1 bytes
Binary layout: 00000011
Updated binary: 00000111
\end{verbatim}

\subsubsection{Nested Bitfields Example}\label{nested-bitfields-example}

You can even use bitfields inside nested structs to create compact yet
expressive data models:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Sensor }\OperatorTok{\{}
    \DataTypeTok{unsigned}\NormalTok{ id       }\OperatorTok{:} \DecValTok{4}\OperatorTok{;}  \CommentTok{// 0–15}
    \DataTypeTok{unsigned}\NormalTok{ type     }\OperatorTok{:} \DecValTok{3}\OperatorTok{;}  \CommentTok{// 0–7}
    \DataTypeTok{unsigned}\NormalTok{ active   }\OperatorTok{:} \DecValTok{1}\OperatorTok{;}  \CommentTok{// boolean}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Device }\OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Sensor sensors}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Each sensor entry now fits neatly into a single byte.

\subsubsection{Memory Packing}\label{memory-packing}

By default, compilers may insert \textbf{padding bytes} to align fields
for faster access. If you want tighter packing, for example, when saving
binary data to a file or sending over a network, you can request packed
structs.

Compiler directives differ by system:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#pragma pack(push, 1)}
\KeywordTok{struct}\NormalTok{ Packet }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ type}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ length}\OperatorTok{;}
    \DataTypeTok{short}\NormalTok{ checksum}\OperatorTok{;}
\OperatorTok{\};}
\PreprocessorTok{\#pragma pack(pop)}
\end{Highlighting}
\end{Shaded}

Now the struct is tightly packed without alignment padding between
fields.

\subsubsection{Bitfields in Real
Systems}\label{bitfields-in-real-systems}

Bitfields are used everywhere in systems programming:

\begin{itemize}
\tightlist
\item
  \textbf{Hardware control registers:} Represent on/off bits for
  devices.
\item
  \textbf{Network protocols:} Flags in TCP, UDP, or IP headers.
\item
  \textbf{Compression and serialization:} Compact representation of
  status or metadata.
\item
  \textbf{Embedded systems:} Save every byte of RAM in microcontrollers.
\end{itemize}

\subsubsection{Limitations}\label{limitations}

\begin{itemize}
\tightlist
\item
  Bitfield ordering (which bit is ``first'') is
  \textbf{implementation-dependent}, varies by compiler and platform.
\item
  They cannot cross word boundaries reliably across architectures.
\item
  Bitfields cannot be directly addressed by pointers (\texttt{\&field}
  not allowed).
\item
  Endianness matters if transmitting across different systems.
\end{itemize}

\begin{quote}
For portable bit-level control (especially in networking), many
engineers use explicit bitwise operators instead.
\end{quote}

\subsubsection{Manual Bitwise Control}\label{manual-bitwise-control}

Sometimes you'll prefer manual masks and shifts:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{unsigned} \DataTypeTok{char}\NormalTok{ flags }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{flags }\OperatorTok{|=} \OperatorTok{(}\DecValTok{1} \OperatorTok{\textless{}\textless{}} \DecValTok{0}\OperatorTok{);} \CommentTok{// set bit 0}
\NormalTok{flags }\OperatorTok{|=} \OperatorTok{(}\DecValTok{1} \OperatorTok{\textless{}\textless{}} \DecValTok{2}\OperatorTok{);} \CommentTok{// set bit 2}
\NormalTok{flags }\OperatorTok{\&=} \OperatorTok{\textasciitilde{}(}\DecValTok{1} \OperatorTok{\textless{}\textless{}} \DecValTok{0}\OperatorTok{);} \CommentTok{// clear bit 0}
\end{Highlighting}
\end{Shaded}

This approach is more portable and explicit, but less readable for large
sets of flags.

\subsubsection{Why It Matters}\label{why-it-matters-32}

Bitfields give you \textbf{compact control} over memory layout and
binary representation. They're critical in:

\begin{itemize}
\tightlist
\item
  Embedded firmware
\item
  Network stacks
\item
  Kernel drivers
\item
  Compression libraries
\end{itemize}

They make your code expressive \emph{and} efficient, as long as you
understand alignment and portability issues.

\subsubsection{Try It Yourself}\label{try-it-yourself-32}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define a struct \texttt{Permissions} with 1-bit fields for
  \texttt{read}, \texttt{write}, and \texttt{execute}.
\item
  Print its size and check how compact it is.
\item
  Use a bitfield struct to represent a simplified TCP header (flags like
  SYN, ACK, FIN).
\item
  Use \texttt{\#pragma\ pack(1)} and observe the size difference.
\item
  Write functions to set, clear, and toggle bits using bitwise
  operators.
\end{enumerate}

Bitfields are where C meets the hardware. They let you talk to the
machine not just in bytes, but in \textbf{bits}, the true language of
computers. Next, you'll revisit enumerations and see how they complement
these compact structures by giving symbolic meaning to values.

\subsection{35. Enumerations Revisited}\label{enumerations-revisited}

You've seen \texttt{enum} briefly when learning about constants, but now
it's time to use it as a \textbf{first-class design tool}. Enumerations
give names to sets of integer values, making code easier to read,
maintain, and debug. They also pair beautifully with \texttt{struct},
\texttt{union}, and \texttt{bitfield} patterns from the previous
sections.

\subsubsection{What Is an Enumeration?}\label{what-is-an-enumeration}

An \textbf{enumeration} (\texttt{enum}) defines a type whose values are
limited to a specific list of named constants.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Color }\OperatorTok{\{}
\NormalTok{    RED}\OperatorTok{,}
\NormalTok{    GREEN}\OperatorTok{,}
\NormalTok{    BLUE}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Under the hood, \texttt{enum\ Color} is an integer type --- \texttt{RED}
= 0, \texttt{GREEN} = 1, \texttt{BLUE} = 2 by default.

\subsubsection{Basic Usage}\label{basic-usage}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{enum}\NormalTok{ Direction }\OperatorTok{\{}
\NormalTok{    NORTH}\OperatorTok{,}
\NormalTok{    EAST}\OperatorTok{,}
\NormalTok{    SOUTH}\OperatorTok{,}
\NormalTok{    WEST}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{enum}\NormalTok{ Direction d }\OperatorTok{=}\NormalTok{ EAST}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Current direction: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Current direction: 1
\end{verbatim}

Even though \texttt{EAST} prints as \texttt{1}, using a named constant
makes your code far more meaningful.

\subsubsection{Assigning Custom Values}\label{assigning-custom-values}

You can specify explicit integer values, useful for compatibility or
mapping to real-world codes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ ErrorCode }\OperatorTok{\{}
\NormalTok{    OK }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}
\NormalTok{    FILE\_NOT\_FOUND }\OperatorTok{=} \DecValTok{404}\OperatorTok{,}
\NormalTok{    SERVER\_ERROR }\OperatorTok{=} \DecValTok{500}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

If you skip a value, enumeration continues counting from the last
number:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Level }\OperatorTok{\{}
\NormalTok{    LOW }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}
\NormalTok{    MEDIUM}\OperatorTok{,}
\NormalTok{    HIGH}
\OperatorTok{\};}
\CommentTok{// HIGH = 3}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-33}

A small program that uses enums for clear program flow:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{enum}\NormalTok{ Status }\OperatorTok{\{}
\NormalTok{    SUCCESS }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}
\NormalTok{    WARNING }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}
\NormalTok{    ERROR }\OperatorTok{=} \DecValTok{2}
\OperatorTok{\};}

\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ status\_to\_string}\OperatorTok{(}\KeywordTok{enum}\NormalTok{ Status s}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case}\NormalTok{ SUCCESS}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"Success"}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ WARNING}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"Warning"}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ ERROR}\OperatorTok{:}   \ControlFlowTok{return} \StringTok{"Error"}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}      \ControlFlowTok{return} \StringTok{"Unknown"}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{enum}\NormalTok{ Status s }\OperatorTok{=}\NormalTok{ WARNING}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Status: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ status\_to\_string}\OperatorTok{(}\NormalTok{s}\OperatorTok{),}\NormalTok{ s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Status: Warning (1)
\end{verbatim}

This pattern, \texttt{enum} + \texttt{switch}, is everywhere in C
projects: error handling, state machines, network protocols, and more.

\subsubsection{Enumerations with
Structs}\label{enumerations-with-structs}

Combine \texttt{enum} with \texttt{struct} for self-describing data:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{enum}\NormalTok{ ShapeType }\OperatorTok{\{}
\NormalTok{    CIRCLE}\OperatorTok{,}
\NormalTok{    RECTANGLE}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Shape }\OperatorTok{\{}
    \KeywordTok{enum}\NormalTok{ ShapeType type}\OperatorTok{;}
    \KeywordTok{union} \OperatorTok{\{}
        \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;} \OperatorTok{\};}
        \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{float}\NormalTok{ width}\OperatorTok{,}\NormalTok{ height}\OperatorTok{;} \OperatorTok{\};}
    \OperatorTok{\};}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_shape}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Shape s}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{s}\OperatorTok{.}\NormalTok{type }\OperatorTok{==}\NormalTok{ CIRCLE}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Circle with radius }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{radius}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Rectangle }\SpecialCharTok{\%.2f}\StringTok{x}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{width}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{height}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Shape c }\OperatorTok{=} \OperatorTok{\{}\NormalTok{CIRCLE}\OperatorTok{,} \OperatorTok{.}\NormalTok{radius }\OperatorTok{=} \FloatTok{2.5}\BuiltInTok{f}\OperatorTok{\};}
    \KeywordTok{struct}\NormalTok{ Shape r }\OperatorTok{=} \OperatorTok{\{}\NormalTok{RECTANGLE}\OperatorTok{,} \OperatorTok{.}\NormalTok{width }\OperatorTok{=} \FloatTok{3.0}\BuiltInTok{f}\OperatorTok{,} \OperatorTok{.}\NormalTok{height }\OperatorTok{=} \FloatTok{4.0}\BuiltInTok{f}\OperatorTok{\};}
\NormalTok{    print\_shape}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    print\_shape}\OperatorTok{(}\NormalTok{r}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Circle with radius 2.50
Rectangle 3.00x4.00
\end{verbatim}

This pairing of \texttt{enum} + \texttt{union} is a common pattern in
real-world systems, known as a \textbf{tagged union}.

\subsubsection{Scoped Enums in Modern C
(C23)}\label{scoped-enums-in-modern-c-c23}

C23 introduces a cleaner way to scope enum names:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ class Mode }\OperatorTok{\{}\NormalTok{ READ}\OperatorTok{,}\NormalTok{ WRITE}\OperatorTok{,}\NormalTok{ APPEND }\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This avoids name collisions and allows better type checking --- similar
to \texttt{enum\ class} in C++. (Some compilers may not support this
yet, but it's worth knowing.)

\subsubsection{Why It Matters}\label{why-it-matters-33}

Enumerations bring \textbf{semantic clarity} to your code:

\begin{itemize}
\tightlist
\item
  Replace ``magic numbers'' with meaningful names.
\item
  Simplify debugging and logging.
\item
  Enable compile-time checking, you can't assign invalid constants
  easily.
\item
  Combine cleanly with structs, unions, and bitfields to express state
  machines or protocols.
\end{itemize}

They also improve portability, your program logic is described by
\textbf{intent}, not arbitrary numbers.

\subsubsection{Try It Yourself}\label{try-it-yourself-33}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define an enum \texttt{TrafficLight\ \{\ RED,\ YELLOW,\ GREEN\ \}} and
  print messages based on its value.
\item
  Create an enum \texttt{FileType\ \{\ TEXT,\ BINARY,\ UNKNOWN\ \}} and
  use it inside a \texttt{struct\ FileInfo}.
\item
  Extend your tagged-union pattern: add \texttt{TRIANGLE} to the
  \texttt{Shape} enum.
\item
  Write a \texttt{switch} statement that maps \texttt{enum\ ErrorCode}
  to error messages.
\item
  Experiment with explicitly setting values and skipping a few, observe
  the auto-increment behavior.
\end{enumerate}

Enumerations make your programs \emph{speak in concepts, not numbers}.
They are the key to clarity, readability, and robust design, the bridge
between human meaning and machine representation.

\subsection{36. Linked Lists from
Scratch}\label{linked-lists-from-scratch}

Now that you understand how to group data with \texttt{struct}, it's
time to make it \textbf{dynamic}. A \textbf{linked list} is one of the
most fundamental data structures in C, built entirely with pointers and
structs. It teaches you how memory, pointers, and iteration really work.

\subsubsection{What Is a Linked List?}\label{what-is-a-linked-list}

A \textbf{linked list} is a collection of nodes, where each node stores:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Data (of any type you choose), and
\item
  A pointer to the next node.
\end{enumerate}

Unlike arrays, linked lists aren't fixed in size, you can add or remove
nodes anytime without reallocating large blocks of memory.

\subsubsection{Basic Node Structure}\label{basic-node-structure}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This defines a ``node'' that holds an integer and a pointer to the next
node in the list. If \texttt{next} is \texttt{NULL}, it's the end of the
list.

\subsubsection{Creating and Traversing a Linked
List}\label{creating-and-traversing-a-linked-list}

Let's build a simple three-node list:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Create three nodes dynamically}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{a }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Node}\OperatorTok{));}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Node}\OperatorTok{));}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Node}\OperatorTok{));}

\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ c}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{30}\OperatorTok{;}\NormalTok{ c}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

    \CommentTok{// Traverse and print}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{current }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{current }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ current}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);}
\NormalTok{        current }\OperatorTok{=}\NormalTok{ current}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// Free memory}
\NormalTok{    free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}\NormalTok{ free}\OperatorTok{(}\NormalTok{b}\OperatorTok{);}\NormalTok{ free}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 20 30
\end{verbatim}

\subsubsection{Tiny Code: Build, Insert,
Delete}\label{tiny-code-build-insert-delete}

Let's make it reusable, define helper functions for common operations.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\NormalTok{Node}\OperatorTok{*}\NormalTok{ create\_node}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ append}\OperatorTok{(}\NormalTok{Node }\OperatorTok{**}\NormalTok{head}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{new\_node }\OperatorTok{=}\NormalTok{ create\_node}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{head }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
        \OperatorTok{*}\NormalTok{head }\OperatorTok{=}\NormalTok{ new\_node}\OperatorTok{;}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{cur }\OperatorTok{=} \OperatorTok{*}\NormalTok{head}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{cur}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}\NormalTok{ cur }\OperatorTok{=}\NormalTok{ cur}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
\NormalTok{    cur}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ new\_node}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print\_list}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Node }\OperatorTok{*}\NormalTok{head}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{const}\NormalTok{ Node }\OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ head}\OperatorTok{;}\NormalTok{ p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ p }\OperatorTok{=}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ {-}\textgreater{} "}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"NULL}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ delete\_list}\OperatorTok{(}\NormalTok{Node }\OperatorTok{*}\NormalTok{head}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{head}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        Node }\OperatorTok{*}\NormalTok{next }\OperatorTok{=}\NormalTok{ head}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
\NormalTok{        free}\OperatorTok{(}\NormalTok{head}\OperatorTok{);}
\NormalTok{        head }\OperatorTok{=}\NormalTok{ next}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{head }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    append}\OperatorTok{(\&}\NormalTok{head}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\NormalTok{    append}\OperatorTok{(\&}\NormalTok{head}\OperatorTok{,} \DecValTok{10}\OperatorTok{);}
\NormalTok{    append}\OperatorTok{(\&}\NormalTok{head}\OperatorTok{,} \DecValTok{15}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Linked list contents:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    print\_list}\OperatorTok{(}\NormalTok{head}\OperatorTok{);}

\NormalTok{    delete\_list}\OperatorTok{(}\NormalTok{head}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Linked list contents:
5 -> 10 -> 15 -> NULL
\end{verbatim}

\subsubsection{Why Use Linked Lists?}\label{why-use-linked-lists}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic size:} Easily grow or shrink as needed.
\item
  \textbf{Efficient insertions and deletions:} No need to shift elements
  as in arrays.
\item
  \textbf{Great for learning memory handling:} You directly allocate and
  free each node.
\end{itemize}

But they also have trade-offs:

\begin{itemize}
\tightlist
\item
  Slower random access (must traverse from the head).
\item
  Slightly higher memory usage due to pointer fields.
\end{itemize}

\subsubsection{Variants You'll Meet
Later}\label{variants-youll-meet-later}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Singly Linked List} & Each node points to the next one (like
above). \\
\textbf{Doubly Linked List} & Each node has \texttt{prev} and
\texttt{next} pointers. \\
\textbf{Circular Linked List} & The last node links back to the
first. \\
\textbf{Sentinel List} & Uses dummy head/tail nodes to simplify
logic. \\
\end{longtable}

\subsubsection{Why It Matters}\label{why-it-matters-34}

Linked lists are a window into \textbf{manual memory management}, you
handle creation, traversal, and cleanup. They're used in:

\begin{itemize}
\tightlist
\item
  Kernels (e.g., Linux \texttt{list\_head})
\item
  Compilers (symbol tables, token streams)
\item
  Dynamic containers (queues, allocators)
\end{itemize}

You're not just learning a data structure, you're learning how to think
in pointers.

\subsubsection{Try It Yourself}\label{try-it-yourself-34}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement a function \texttt{int\ length(Node\ *head)} that counts the
  number of nodes.
\item
  Write \texttt{insert\_front()} and \texttt{insert\_after()} functions.
\item
  Implement a \texttt{find()} function that returns a pointer to a node
  with a given value.
\item
  Modify the \texttt{delete\_list()} function to print which node is
  being freed.
\item
  Extend the struct to include a \texttt{char\ name{[}20{]}} and print
  both the name and value.
\end{enumerate}

You've now built one of the most essential dynamic structures in
computer science, entirely from scratch. Next, you'll build on this
foundation to create \textbf{stacks} and \textbf{queues}, two of the
most common and useful data abstractions in systems programming.

\subsection{37. Stacks and Queues with
Structs}\label{stacks-and-queues-with-structs}

You've learned how to build a \textbf{linked list}, now you'll use that
foundation to create two classic data structures: \textbf{Stacks} (LIFO,
Last In, First Out) and \textbf{Queues} (FIFO, First In, First Out).
Both are essential for real-world programs, from parsing expressions to
managing tasks and kernel scheduling.

\subsubsection{1. The Stack}\label{the-stack}

A \textbf{stack} is like a pile of plates. You add to the top
(\emph{push}), and remove from the top (\emph{pop}).

Operations:

\begin{itemize}
\tightlist
\item
  \texttt{push(x)} → add an item to the top
\item
  \texttt{pop()} → remove the top item
\item
  \texttt{peek()} → look at the top item without removing it
\end{itemize}

\subsubsection{Stack Implementation Using Linked
List}\label{stack-implementation-using-linked-list}

Each stack node holds data and a pointer to the next node.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{top}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Stack}\OperatorTok{;}

\NormalTok{Stack}\OperatorTok{*}\NormalTok{ create\_stack}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Stack }\OperatorTok{*}\NormalTok{s }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Stack}\OperatorTok{));}
\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{top }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ s}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ push}\OperatorTok{(}\NormalTok{Stack }\OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{top}\OperatorTok{;}
\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{top }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ pop}\OperatorTok{(}\NormalTok{Stack }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{s}\OperatorTok{{-}\textgreater{}}\NormalTok{top}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Stack underflow!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{temp }\OperatorTok{=}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{top}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ val }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{;}
\NormalTok{    s}\OperatorTok{{-}\textgreater{}}\NormalTok{top }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
\NormalTok{    free}\OperatorTok{(}\NormalTok{temp}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ val}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ peek}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Stack }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{top }\OperatorTok{?}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{top}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{:} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_stack}\OperatorTok{(}\NormalTok{Stack }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{s}\OperatorTok{{-}\textgreater{}}\NormalTok{top}\OperatorTok{)}\NormalTok{ pop}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Stack }\OperatorTok{*}\NormalTok{s }\OperatorTok{=}\NormalTok{ create\_stack}\OperatorTok{();}
\NormalTok{    push}\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \DecValTok{10}\OperatorTok{);}
\NormalTok{    push}\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \DecValTok{20}\OperatorTok{);}
\NormalTok{    push}\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \DecValTok{30}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Top: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ peek}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Popped: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pop}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Popped: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pop}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Top now: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ peek}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}

\NormalTok{    free\_stack}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Top: 30
Popped: 30
Popped: 20
Top now: 10
\end{verbatim}

\subsubsection{Why Use a Stack?}\label{why-use-a-stack}

Stacks are used in:

\begin{itemize}
\tightlist
\item
  Function calls (the \emph{call stack})
\item
  Undo/redo systems
\item
  Parsing expressions (e.g., evaluating \texttt{(2\ +\ 3)\ *\ 4})
\item
  Depth-first search (DFS) in graphs
\end{itemize}

\subsubsection{2. The Queue}\label{the-queue}

A \textbf{queue} is like a line at a store. You add to the back
(\emph{enqueue}), and remove from the front (\emph{dequeue}).

Operations:

\begin{itemize}
\tightlist
\item
  \texttt{enqueue(x)} → add to the end
\item
  \texttt{dequeue()} → remove from the front
\end{itemize}

\subsubsection{Queue Implementation Using Linked
List}\label{queue-implementation-using-linked-list}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{front}\OperatorTok{;}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{rear}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Queue}\OperatorTok{;}

\NormalTok{Queue}\OperatorTok{*}\NormalTok{ create\_queue}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Queue }\OperatorTok{*}\NormalTok{q }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Queue}\OperatorTok{));}
\NormalTok{    q}\OperatorTok{{-}\textgreater{}}\NormalTok{front }\OperatorTok{=}\NormalTok{ q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ q}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ enqueue}\OperatorTok{(}\NormalTok{Queue }\OperatorTok{*}\NormalTok{q}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        q}\OperatorTok{{-}\textgreater{}}\NormalTok{front }\OperatorTok{=}\NormalTok{ q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}
\NormalTok{    q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ dequeue}\OperatorTok{(}\NormalTok{Queue }\OperatorTok{*}\NormalTok{q}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{q}\OperatorTok{{-}\textgreater{}}\NormalTok{front }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Queue underflow!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{temp }\OperatorTok{=}\NormalTok{ q}\OperatorTok{{-}\textgreater{}}\NormalTok{front}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ val }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{;}
\NormalTok{    q}\OperatorTok{{-}\textgreater{}}\NormalTok{front }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{q}\OperatorTok{{-}\textgreater{}}\NormalTok{front }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)}
\NormalTok{        q}\OperatorTok{{-}\textgreater{}}\NormalTok{rear }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

\NormalTok{    free}\OperatorTok{(}\NormalTok{temp}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ val}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print\_queue}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Queue }\OperatorTok{*}\NormalTok{q}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{Node }\OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ q}\OperatorTok{{-}\textgreater{}}\NormalTok{front}\OperatorTok{;}\NormalTok{ p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ p }\OperatorTok{=}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_queue}\OperatorTok{(}\NormalTok{Queue }\OperatorTok{*}\NormalTok{q}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{q}\OperatorTok{{-}\textgreater{}}\NormalTok{front}\OperatorTok{)}\NormalTok{ dequeue}\OperatorTok{(}\NormalTok{q}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{q}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Queue }\OperatorTok{*}\NormalTok{q }\OperatorTok{=}\NormalTok{ create\_queue}\OperatorTok{();}
\NormalTok{    enqueue}\OperatorTok{(}\NormalTok{q}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    enqueue}\OperatorTok{(}\NormalTok{q}\OperatorTok{,} \DecValTok{2}\OperatorTok{);}
\NormalTok{    enqueue}\OperatorTok{(}\NormalTok{q}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Queue: "}\OperatorTok{);}
\NormalTok{    print\_queue}\OperatorTok{(}\NormalTok{q}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Dequeued: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ dequeue}\OperatorTok{(}\NormalTok{q}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Dequeued: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ dequeue}\OperatorTok{(}\NormalTok{q}\OperatorTok{));}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Remaining: "}\OperatorTok{);}
\NormalTok{    print\_queue}\OperatorTok{(}\NormalTok{q}\OperatorTok{);}

\NormalTok{    free\_queue}\OperatorTok{(}\NormalTok{q}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Queue: 1 2 3 
Dequeued: 1
Dequeued: 2
Remaining: 3
\end{verbatim}

\subsubsection{Stack vs Queue Summary}\label{stack-vs-queue-summary}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2055}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4384}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3562}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stack
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Access Order & LIFO (Last In, First Out) & FIFO (First In, First Out) \\
Main Operations & push / pop & enqueue / dequeue \\
Used For & Recursion, parsing, backtracking & Task scheduling,
buffering \\
Example & Undo system & Printer jobs \\
\end{longtable}

\subsubsection{Tiny Code Exercise: Dual
Queue-Stack}\label{tiny-code-exercise-dual-queue-stack}

Here's a minimal snippet that lets you switch between stack and queue
mode:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ STACK\_MODE}\OperatorTok{,}\NormalTok{ QUEUE\_MODE }\OperatorTok{\}}\NormalTok{ Mode}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You could use the same linked list logic but change whether new nodes
are added at the head (stack) or tail (queue).

\subsubsection{Why It Matters}\label{why-it-matters-35}

Stack and queue behavior underlie \textbf{every major system
abstraction}:

\begin{itemize}
\tightlist
\item
  CPU scheduling
\item
  IO buffering
\item
  Event loops
\item
  Expression parsing
\item
  Recursive algorithms
\end{itemize}

Building them in raw C solidifies your understanding of
\textbf{pointer-based data structures} and \textbf{memory ownership}.

\subsubsection{Try It Yourself}\label{try-it-yourself-35}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement \texttt{is\_empty()} for both stack and queue.
\item
  Extend the queue to handle strings instead of ints.
\item
  Add a function \texttt{reverse\_queue()} using a stack.
\item
  Implement a ``bounded queue'' that has a fixed maximum size.
\item
  Write a small program simulating customer arrivals using a queue.
\end{enumerate}

Stacks and queues are the \textbf{control flow primitives of memory and
time}. Next, you'll combine them with hashing and function pointers to
build your own \textbf{hash table}, the basis for efficient lookups and
symbol tables in C.

\subsection{38. Hash Tables and Function
Pointers}\label{hash-tables-and-function-pointers}

Hash tables are among the most important data structures in computing,
fast, flexible, and foundational. They give you \textbf{average O(1)}
lookup, insertion, and deletion by mapping \emph{keys} to \emph{values}
through a hash function. In this section, you'll build a simple hash
table from scratch in C using \textbf{structs}, \textbf{arrays}, and
\textbf{function pointers} for hash and comparison operations.

\subsubsection{What Is a Hash Table?}\label{what-is-a-hash-table}

A \textbf{hash table} stores data as key--value pairs. When you insert a
key:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The \textbf{hash function} converts it into an integer index.
\item
  The data is stored in that slot of an array.
\item
  When you search later, the key is hashed again to find the same index.
\end{enumerate}

If multiple keys map to the same slot, that's called a
\textbf{collision}, handled by \emph{chaining} (linked lists) or
\emph{open addressing}.

\subsubsection{Simple Design}\label{simple-design}

We'll use \textbf{chaining}, each slot in the table is a linked list of
key--value pairs that share the same hash.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Entry}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Entry }\OperatorTok{**}\NormalTok{buckets}\OperatorTok{;} \CommentTok{// array of linked lists}
    \DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ HashTable}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Hash Function}\label{hash-function}

A basic string hash function (the djb2 algorithm):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stddef.h\textgreater{}}

\DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ hash\_string}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{str}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ hash }\OperatorTok{=} \DecValTok{5381}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ c}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{c }\OperatorTok{=} \OperatorTok{*}\NormalTok{str}\OperatorTok{++))}
\NormalTok{        hash }\OperatorTok{=} \OperatorTok{((}\NormalTok{hash }\OperatorTok{\textless{}\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{+}\NormalTok{ hash}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;} \CommentTok{// hash * 33 + c}
    \ControlFlowTok{return}\NormalTok{ hash}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code: Hash Table
Implementation}\label{tiny-code-hash-table-implementation}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Entry}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Entry }\OperatorTok{**}\NormalTok{buckets}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ HashTable}\OperatorTok{;}

\DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ hash\_string}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{str}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ hash }\OperatorTok{=} \DecValTok{5381}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ c}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{c }\OperatorTok{=} \OperatorTok{*}\NormalTok{str}\OperatorTok{++))}
\NormalTok{        hash }\OperatorTok{=} \OperatorTok{((}\NormalTok{hash }\OperatorTok{\textless{}\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{+}\NormalTok{ hash}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ hash}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{HashTable}\OperatorTok{*}\NormalTok{ create\_table}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    HashTable }\OperatorTok{*}\NormalTok{t }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{HashTable}\OperatorTok{));}
\NormalTok{    t}\OperatorTok{{-}\textgreater{}}\NormalTok{size }\OperatorTok{=}\NormalTok{ size}\OperatorTok{;}
\NormalTok{    t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets }\OperatorTok{=}\NormalTok{ calloc}\OperatorTok{(}\NormalTok{size}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Entry}\OperatorTok{*));}
    \ControlFlowTok{return}\NormalTok{ t}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{Entry}\OperatorTok{*}\NormalTok{ create\_entry}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Entry }\OperatorTok{*}\NormalTok{e }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Entry}\OperatorTok{));}
\NormalTok{    e}\OperatorTok{{-}\textgreater{}}\NormalTok{key }\OperatorTok{=}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{key}\OperatorTok{);}
\NormalTok{    e}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{    e}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ e}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ insert}\OperatorTok{(}\NormalTok{HashTable }\OperatorTok{*}\NormalTok{t}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ index }\OperatorTok{=}\NormalTok{ hash\_string}\OperatorTok{(}\NormalTok{key}\OperatorTok{)} \OperatorTok{\%}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{size}\OperatorTok{;}
\NormalTok{    Entry }\OperatorTok{*}\NormalTok{new\_entry }\OperatorTok{=}\NormalTok{ create\_entry}\OperatorTok{(}\NormalTok{key}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{    new\_entry}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets}\OperatorTok{[}\NormalTok{index}\OperatorTok{];}
\NormalTok{    t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets}\OperatorTok{[}\NormalTok{index}\OperatorTok{]} \OperatorTok{=}\NormalTok{ new\_entry}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{Entry}\OperatorTok{*}\NormalTok{ search}\OperatorTok{(}\NormalTok{HashTable }\OperatorTok{*}\NormalTok{t}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ index }\OperatorTok{=}\NormalTok{ hash\_string}\OperatorTok{(}\NormalTok{key}\OperatorTok{)} \OperatorTok{\%}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{size}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{Entry }\OperatorTok{*}\NormalTok{e }\OperatorTok{=}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets}\OperatorTok{[}\NormalTok{index}\OperatorTok{];}\NormalTok{ e}\OperatorTok{;}\NormalTok{ e }\OperatorTok{=}\NormalTok{ e}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{e}\OperatorTok{{-}\textgreater{}}\NormalTok{key}\OperatorTok{,}\NormalTok{ key}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{return}\NormalTok{ e}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_table}\OperatorTok{(}\NormalTok{HashTable }\OperatorTok{*}\NormalTok{t}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        Entry }\OperatorTok{*}\NormalTok{e }\OperatorTok{=}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
        \ControlFlowTok{while} \OperatorTok{(}\NormalTok{e}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            Entry }\OperatorTok{*}\NormalTok{next }\OperatorTok{=}\NormalTok{ e}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
\NormalTok{            free}\OperatorTok{(}\NormalTok{e}\OperatorTok{{-}\textgreater{}}\NormalTok{key}\OperatorTok{);}
\NormalTok{            free}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\NormalTok{            e }\OperatorTok{=}\NormalTok{ next}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\NormalTok{    free}\OperatorTok{(}\NormalTok{t}\OperatorTok{{-}\textgreater{}}\NormalTok{buckets}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    HashTable }\OperatorTok{*}\NormalTok{table }\OperatorTok{=}\NormalTok{ create\_table}\OperatorTok{(}\DecValTok{8}\OperatorTok{);}

\NormalTok{    insert}\OperatorTok{(}\NormalTok{table}\OperatorTok{,} \StringTok{"apple"}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\NormalTok{    insert}\OperatorTok{(}\NormalTok{table}\OperatorTok{,} \StringTok{"banana"}\OperatorTok{,} \DecValTok{7}\OperatorTok{);}
\NormalTok{    insert}\OperatorTok{(}\NormalTok{table}\OperatorTok{,} \StringTok{"orange"}\OperatorTok{,} \DecValTok{10}\OperatorTok{);}

\NormalTok{    Entry }\OperatorTok{*}\NormalTok{result }\OperatorTok{=}\NormalTok{ search}\OperatorTok{(}\NormalTok{table}\OperatorTok{,} \StringTok{"banana"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{result}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"banana = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Key not found}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free\_table}\OperatorTok{(}\NormalTok{table}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
banana = 7
\end{verbatim}

\subsubsection{Using Function Pointers for
Genericity}\label{using-function-pointers-for-genericity}

We can make the hash table generic by letting users provide custom hash
and compare functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{unsigned} \DataTypeTok{long} \OperatorTok{(*}\NormalTok{HashFunc}\OperatorTok{)(}\DataTypeTok{const} \DataTypeTok{void}\OperatorTok{*);}
\KeywordTok{typedef} \DataTypeTok{int} \OperatorTok{(*}\NormalTok{CompareFunc}\OperatorTok{)(}\DataTypeTok{const} \DataTypeTok{void}\OperatorTok{*,} \DataTypeTok{const} \DataTypeTok{void}\OperatorTok{*);}
\end{Highlighting}
\end{Shaded}

Then we embed them in the struct:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Entry }\OperatorTok{**}\NormalTok{buckets}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{;}
\NormalTok{    HashFunc hash}\OperatorTok{;}
\NormalTok{    CompareFunc compare}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ GenericTable}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This lets you reuse the same table for strings, integers, or structs,
just provide the right hash and compare functions.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ hash\_int}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{void} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{p}\OperatorTok{)} \OperatorTok{*} \DecValTok{2654435761}\BuiltInTok{u}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-36}

Hash tables power:

\begin{itemize}
\tightlist
\item
  \textbf{Compilers} (symbol tables, variable scopes)
\item
  \textbf{Databases and caches} (key-value stores)
\item
  \textbf{Operating systems} (file descriptor maps, kernel objects)
\item
  \textbf{Network stacks} (routing tables, ARP caches)
\end{itemize}

They balance \textbf{speed}, \textbf{simplicity}, and \textbf{control},
the heart of efficient system design in C.

\subsubsection{Common Pitfalls}\label{common-pitfalls-2}

\begin{itemize}
\tightlist
\item
  Forgetting to handle collisions (loses data).
\item
  Failing to free all nodes → memory leaks.
\item
  Using poor hash functions → clustering, performance drops.
\item
  Not resizing when full → reduced efficiency.
\end{itemize}

A well-designed hash table grows dynamically (doubling capacity and
rehashing when load exceeds a threshold).

\subsubsection{Try It Yourself}\label{try-it-yourself-36}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Modify the table to \textbf{update} existing keys instead of always
  inserting new ones.
\item
  Implement a \textbf{delete(key)} function that removes an entry.
\item
  Write a version with \textbf{integer keys}.
\item
  Implement \textbf{rehash()} that doubles table size when 75\% full.
\item
  Replace function pointers with macros for performance comparison.
\end{enumerate}

Hash tables are where C shows its full power: raw pointers, function
indirection, and dynamic memory, all working together for blazing-fast
lookups. Next, you'll take these ideas further and explore how to
simulate \textbf{object-oriented design in C} using structs, function
pointers, and encapsulation.

\subsection{39. Minimal Object-Oriented Design in
C}\label{minimal-object-oriented-design-in-c}

C doesn't have classes or inheritance, but it gives you
\textbf{structs}, \textbf{function pointers}, and \textbf{encapsulation
through conventions}. With these, you can build \emph{object-oriented
style} systems that are simple, fast, and explicit. You'll learn how to
design data structures that ``own'' both \textbf{data and behavior},
like lightweight objects.

\subsubsection{The Core Idea}\label{the-core-idea-1}

In object-oriented design, an object combines:

\begin{itemize}
\tightlist
\item
  \textbf{Data} → the state
\item
  \textbf{Functions} → the operations
\end{itemize}

In C, you can achieve this by placing \textbf{function pointers inside
structs}, and treating them as ``methods.''

\subsubsection{A Simple Example: A Counter
Object}\label{a-simple-example-a-counter-object}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Counter Counter}\OperatorTok{;} \CommentTok{// forward declaration}

\KeywordTok{struct}\NormalTok{ Counter }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}

    \CommentTok{// methods (function pointers)}
    \DataTypeTok{void} \OperatorTok{(*}\NormalTok{inc}\OperatorTok{)(}\NormalTok{Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{);}
    \DataTypeTok{void} \OperatorTok{(*}\NormalTok{reset}\OperatorTok{)(}\NormalTok{Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{);}
    \DataTypeTok{void} \OperatorTok{(*}\NormalTok{print}\OperatorTok{)(}\DataTypeTok{const}\NormalTok{ Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{);}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ counter\_inc}\OperatorTok{(}\NormalTok{Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ self}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{++;} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ counter\_reset}\OperatorTok{(}\NormalTok{Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ self}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ counter\_print}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Counter }\OperatorTok{*}\NormalTok{self}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ self}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);} \OperatorTok{\}}

\NormalTok{Counter}\OperatorTok{*}\NormalTok{ new\_counter}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Counter }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Counter}\OperatorTok{));}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{inc }\OperatorTok{=}\NormalTok{ counter\_inc}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{reset }\OperatorTok{=}\NormalTok{ counter\_reset}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{print }\OperatorTok{=}\NormalTok{ counter\_print}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ c}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_counter}\OperatorTok{(}\NormalTok{Counter }\OperatorTok{*}\NormalTok{c}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{c}\OperatorTok{);} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Counter }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ new\_counter}\OperatorTok{();}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{inc}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{inc}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{print}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{reset}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{print}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
\NormalTok{    free\_counter}\OperatorTok{(}\NormalTok{c}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 2
Value: 0
\end{verbatim}

Here, \texttt{Counter} behaves like a small class: it stores both the
\textbf{state} (\texttt{value}) and its \textbf{methods} (\texttt{inc},
\texttt{reset}, \texttt{print}).

\subsubsection{How It Works}\label{how-it-works-1}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Concept (OOP) & Equivalent in C \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Class & \texttt{struct} definition \\
Object & An instance (\texttt{malloc}ed struct) \\
Method & Function pointer \\
Constructor & \texttt{new\_...()} function \\
Destructor & \texttt{free\_...()} function \\
this & Pointer to the struct (\texttt{self}) \\
\end{longtable}

\subsubsection{Example: Shape Interface
(Polymorphism)}\label{example-shape-interface-polymorphism}

You can simulate polymorphism, the ability to call the same function
name on different types, using function pointers.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}math.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Shape Shape}\OperatorTok{;}
\KeywordTok{struct}\NormalTok{ Shape }\OperatorTok{\{}
    \DataTypeTok{double} \OperatorTok{(*}\NormalTok{area}\OperatorTok{)(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{self}\OperatorTok{);}
    \DataTypeTok{void} \OperatorTok{(*}\NormalTok{print}\OperatorTok{)(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{self}\OperatorTok{);}
\OperatorTok{\};}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Shape base}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Circle}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Shape base}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ width}\OperatorTok{,}\NormalTok{ height}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Rectangle}\OperatorTok{;}

\DataTypeTok{double}\NormalTok{ circle\_area}\OperatorTok{(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Circle }\OperatorTok{*}\NormalTok{c }\OperatorTok{=} \OperatorTok{(}\NormalTok{Circle}\OperatorTok{*)}\NormalTok{s}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ M\_PI }\OperatorTok{*}\NormalTok{ c}\OperatorTok{{-}\textgreater{}}\NormalTok{radius }\OperatorTok{*}\NormalTok{ c}\OperatorTok{{-}\textgreater{}}\NormalTok{radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ circle\_print}\OperatorTok{(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Circle }\OperatorTok{*}\NormalTok{c }\OperatorTok{=} \OperatorTok{(}\NormalTok{Circle}\OperatorTok{*)}\NormalTok{s}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Circle (r=}\SpecialCharTok{\%.2f}\StringTok{) area=}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ c}\OperatorTok{{-}\textgreater{}}\NormalTok{radius}\OperatorTok{,}\NormalTok{ circle\_area}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ rect\_area}\OperatorTok{(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Rectangle }\OperatorTok{*}\NormalTok{r }\OperatorTok{=} \OperatorTok{(}\NormalTok{Rectangle}\OperatorTok{*)}\NormalTok{s}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ r}\OperatorTok{{-}\textgreater{}}\NormalTok{width }\OperatorTok{*}\NormalTok{ r}\OperatorTok{{-}\textgreater{}}\NormalTok{height}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ rect\_print}\OperatorTok{(}\NormalTok{Shape }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Rectangle }\OperatorTok{*}\NormalTok{r }\OperatorTok{=} \OperatorTok{(}\NormalTok{Rectangle}\OperatorTok{*)}\NormalTok{s}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Rectangle (}\SpecialCharTok{\%.2f}\StringTok{x}\SpecialCharTok{\%.2f}\StringTok{) area=}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           r}\OperatorTok{{-}\textgreater{}}\NormalTok{width}\OperatorTok{,}\NormalTok{ r}\OperatorTok{{-}\textgreater{}}\NormalTok{height}\OperatorTok{,}\NormalTok{ rect\_area}\OperatorTok{(}\NormalTok{s}\OperatorTok{));}
\OperatorTok{\}}

\NormalTok{Shape}\OperatorTok{*}\NormalTok{ new\_circle}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ r}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Circle }\OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Circle}\OperatorTok{));}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{radius }\OperatorTok{=}\NormalTok{ r}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{.}\NormalTok{area }\OperatorTok{=}\NormalTok{ circle\_area}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{.}\NormalTok{print }\OperatorTok{=}\NormalTok{ circle\_print}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{Shape}\OperatorTok{*)}\NormalTok{c}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{Shape}\OperatorTok{*}\NormalTok{ new\_rectangle}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ w}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ h}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Rectangle }\OperatorTok{*}\NormalTok{r }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Rectangle}\OperatorTok{));}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{width }\OperatorTok{=}\NormalTok{ w}\OperatorTok{;}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{height }\OperatorTok{=}\NormalTok{ h}\OperatorTok{;}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{.}\NormalTok{area }\OperatorTok{=}\NormalTok{ rect\_area}\OperatorTok{;}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{.}\NormalTok{print }\OperatorTok{=}\NormalTok{ rect\_print}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{Shape}\OperatorTok{*)}\NormalTok{r}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Shape }\OperatorTok{*}\NormalTok{s1 }\OperatorTok{=}\NormalTok{ new\_circle}\OperatorTok{(}\FloatTok{2.5}\OperatorTok{);}
\NormalTok{    Shape }\OperatorTok{*}\NormalTok{s2 }\OperatorTok{=}\NormalTok{ new\_rectangle}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{,} \FloatTok{4.0}\OperatorTok{);}

\NormalTok{    s1}\OperatorTok{{-}\textgreater{}}\NormalTok{print}\OperatorTok{(}\NormalTok{s1}\OperatorTok{);}
\NormalTok{    s2}\OperatorTok{{-}\textgreater{}}\NormalTok{print}\OperatorTok{(}\NormalTok{s2}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{s1}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{s2}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Circle (r=2.50) area=19.63
Rectangle (3.00x4.00) area=12.00
\end{verbatim}

Both shapes share the same ``interface'' (\texttt{area}, \texttt{print})
but behave differently, classic polymorphism.

\subsubsection{Why This Works}\label{why-this-works}

Every ``object'' stores pointers to its \textbf{methods}, so you can
call them without knowing the exact type. The first field
(\texttt{base}) in derived structs allows casting between the parent
(\texttt{Shape*}) and child (\texttt{Circle*}, \texttt{Rectangle*}).
This mimics \emph{inheritance by composition}.

\subsubsection{Benefits}\label{benefits}

\begin{itemize}
\tightlist
\item
  Provides \textbf{clear separation} between interface and
  implementation.
\item
  Enables \textbf{runtime dispatch} (function behavior depends on type).
\item
  Keeps code modular, functions can operate on abstract ``objects.''
\item
  Used in major C projects like the Linux kernel, GTK, and SQLite.
\end{itemize}

\subsubsection{Limitations}\label{limitations-1}

\begin{itemize}
\tightlist
\item
  No true type safety, casts can go wrong.
\item
  No automatic destructors or constructors (you must manage memory).
\item
  No inheritance syntax, everything is explicit.
\end{itemize}

But these are also \emph{strengths}: nothing is hidden, and everything
is under your control.

\subsubsection{Try It Yourself}\label{try-it-yourself-37}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a new shape: \texttt{Triangle} with base and height.
\item
  Write a function \texttt{print\_all(Shape\ **arr,\ int\ n)} that
  prints all shapes in an array.
\item
  Add a \texttt{destroy(Shape\ *s)} method pointer and implement
  type-specific cleanup.
\item
  Extend the \texttt{Counter} struct with a \texttt{decrement} method.
\item
  Try designing a small ``interface'' for \texttt{Animal} →
  \texttt{Dog}, \texttt{Cat} with a \texttt{speak()} function.
\end{enumerate}

With structs and function pointers, C becomes a minimal but powerful
\textbf{object system}. You now have everything needed to design
reusable, modular code, without losing the clarity and efficiency that
make C timeless.

Next, you'll finish this chapter by putting all these ideas together:
building a small, \textbf{real-world system in C}, your own \textbf{Tiny
Library System}, with data structures, memory management, and modular
design.

\subsection{40. Practice: Build a Tiny Library
System}\label{practice-build-a-tiny-library-system}

You've now learned every building block, structs, pointers, dynamic
memory, linked lists, enums, and even object-style design with function
pointers. It's time to combine them into a real mini-project: a
\textbf{Tiny Library System}. This will be a full, runnable C program
that manages books, authors, and borrowing records using everything
you've learned so far.

\subsubsection{Goal}\label{goal-1}

Implement a minimal system that can:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Store book records dynamically
\item
  Add new books
\item
  Search books by title
\item
  Borrow and return books
\item
  Clean up all memory correctly
\end{enumerate}

We'll use:

\begin{itemize}
\tightlist
\item
  \texttt{struct} for data models
\item
  \texttt{enum} for status tracking
\item
  linked lists for storage
\item
  \texttt{typedef} and function pointers for clarity
\end{itemize}

\subsubsection{Data Structures}\label{data-structures}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    AVAILABLE}\OperatorTok{,}
\NormalTok{    BORROWED}
\OperatorTok{\}}\NormalTok{ BookStatus}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Book }\OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{title}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{author}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ year}\OperatorTok{;}
\NormalTok{    BookStatus status}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Book }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Book}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Book }\OperatorTok{*}\NormalTok{head}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Library}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Each book is one node in a linked list. The library owns the head
pointer.

\subsubsection{Core Functions}\label{core-functions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Book}\OperatorTok{*}\NormalTok{ create\_book}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{title}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{author}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ year}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Book }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Book}\OperatorTok{));}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{title }\OperatorTok{=}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{title}\OperatorTok{);}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{author }\OperatorTok{=}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{author}\OperatorTok{);}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{year }\OperatorTok{=}\NormalTok{ year}\OperatorTok{;}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{=}\NormalTok{ AVAILABLE}\OperatorTok{;}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ add\_book}\OperatorTok{(}\NormalTok{Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{,}\NormalTok{ Book }\OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    b}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head}\OperatorTok{;}
\NormalTok{    lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head }\OperatorTok{=}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{Book}\OperatorTok{*}\NormalTok{ find\_book}\OperatorTok{(}\NormalTok{Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{title}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\NormalTok{Book }\OperatorTok{*}\NormalTok{cur }\OperatorTok{=}\NormalTok{ lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head}\OperatorTok{;}\NormalTok{ cur }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ cur }\OperatorTok{=}\NormalTok{ cur}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{cur}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{,}\NormalTok{ title}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{return}\NormalTok{ cur}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ borrow\_book}\OperatorTok{(}\NormalTok{Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{title}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Book }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ find\_book}\OperatorTok{(}\NormalTok{lib}\OperatorTok{,}\NormalTok{ title}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Book not found: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ title}\OperatorTok{);}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{==}\NormalTok{ BORROWED}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Book already borrowed: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{);}
    \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{=}\NormalTok{ BORROWED}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You borrowed: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ return\_book}\OperatorTok{(}\NormalTok{Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{title}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Book }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ find\_book}\OperatorTok{(}\NormalTok{lib}\OperatorTok{,}\NormalTok{ title}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Book not found: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ title}\OperatorTok{);}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{==}\NormalTok{ AVAILABLE}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Book already returned: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{);}
    \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{=}\NormalTok{ AVAILABLE}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You returned: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ list\_books}\OperatorTok{(}\DataTypeTok{const}\NormalTok{ Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{{-}{-}{-} Library Catalog {-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{const}\NormalTok{ Book }\OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head}\OperatorTok{;}\NormalTok{ b }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ b }\OperatorTok{=}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%{-}20s}\StringTok{ | }\SpecialCharTok{\%{-}15s}\StringTok{ | }\SpecialCharTok{\%d}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{               b}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{author}\OperatorTok{,}\NormalTok{ b}\OperatorTok{{-}\textgreater{}}\NormalTok{year}\OperatorTok{,}
\NormalTok{               b}\OperatorTok{{-}\textgreater{}}\NormalTok{status }\OperatorTok{==}\NormalTok{ AVAILABLE }\OperatorTok{?} \StringTok{"Available"} \OperatorTok{:} \StringTok{"Borrowed"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ free\_library}\OperatorTok{(}\NormalTok{Library }\OperatorTok{*}\NormalTok{lib}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Book }\OperatorTok{*}\NormalTok{cur }\OperatorTok{=}\NormalTok{ lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{cur}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        Book }\OperatorTok{*}\NormalTok{next }\OperatorTok{=}\NormalTok{ cur}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{;}
\NormalTok{        free}\OperatorTok{(}\NormalTok{cur}\OperatorTok{{-}\textgreater{}}\NormalTok{title}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{cur}\OperatorTok{{-}\textgreater{}}\NormalTok{author}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{cur}\OperatorTok{);}
\NormalTok{        cur }\OperatorTok{=}\NormalTok{ next}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    lib}\OperatorTok{{-}\textgreater{}}\NormalTok{head }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code, Full Program}\label{tiny-code-full-program}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Library lib }\OperatorTok{=} \OperatorTok{\{}\NormalTok{NULL}\OperatorTok{\};}

\NormalTok{    add\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,}\NormalTok{ create\_book}\OperatorTok{(}\StringTok{"The C Programming Language"}\OperatorTok{,} \StringTok{"Kernighan \& Ritchie"}\OperatorTok{,} \DecValTok{1988}\OperatorTok{));}
\NormalTok{    add\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,}\NormalTok{ create\_book}\OperatorTok{(}\StringTok{"Clean Code"}\OperatorTok{,} \StringTok{"Robert C. Martin"}\OperatorTok{,} \DecValTok{2008}\OperatorTok{));}
\NormalTok{    add\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,}\NormalTok{ create\_book}\OperatorTok{(}\StringTok{"Algorithms in C"}\OperatorTok{,} \StringTok{"Sedgewick"}\OperatorTok{,} \DecValTok{1998}\OperatorTok{));}

\NormalTok{    list\_books}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{);}

\NormalTok{    borrow\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,} \StringTok{"Clean Code"}\OperatorTok{);}
\NormalTok{    borrow\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,} \StringTok{"Clean Code"}\OperatorTok{);}  \CommentTok{// test duplicate borrow}
\NormalTok{    return\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,} \StringTok{"Clean Code"}\OperatorTok{);}

\NormalTok{    borrow\_book}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{,} \StringTok{"Algorithms in C"}\OperatorTok{);}
\NormalTok{    list\_books}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{);}

\NormalTok{    free\_library}\OperatorTok{(\&}\NormalTok{lib}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ library\_system.c }\AttributeTok{{-}o}\NormalTok{ library\_system}
\ExtensionTok{./library\_system}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
--- Library Catalog ---
Algorithms in C      | Sedgewick       | 1998 | Available
Clean Code           | Robert C. Martin | 2008 | Available
The C Programming Language | Kernighan & Ritchie | 1988 | Available
------------------------

You borrowed: Clean Code
Book already borrowed: Clean Code
You returned: Clean Code
You borrowed: Algorithms in C

--- Library Catalog ---
Algorithms in C      | Sedgewick       | 1998 | Borrowed
Clean Code           | Robert C. Martin | 2008 | Available
The C Programming Language | Kernighan & Ritchie | 1988 | Available
------------------------
\end{verbatim}

\subsubsection{What You Just Practiced}\label{what-you-just-practiced}

You've combined everything from this chapter:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Concept & How You Used It \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Structs} & For \texttt{Book} and \texttt{Library} models \\
\textbf{Enums} & For \texttt{BookStatus} \\
\textbf{Dynamic memory} & \texttt{malloc}, \texttt{free},
\texttt{strdup} \\
\textbf{Linked lists} & Dynamic collection of books \\
\textbf{Pointers} & Passing references between functions \\
\textbf{Encapsulation} & Each function hides internal details \\
\end{longtable}

\subsubsection{Why It Matters}\label{why-it-matters-37}

This ``tiny library'' is a microcosm of systems programming: you're
managing memory, defining abstractions, and building a dynamic system
with clear data ownership. From here, you can scale to databases,
caches, or in-memory key-value stores, all built on the same principles.

\subsubsection{Try It Yourself}\label{try-it-yourself-38}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \texttt{id} and \texttt{genre} fields to \texttt{Book}.
\item
  Implement \texttt{remove\_book(title)} to delete a node safely.
\item
  Add a command interface (read from stdin) for interactive use.
\item
  Save and load the library to a file using \texttt{fwrite} and
  \texttt{fread}.
\item
  Write a function to count how many books are borrowed vs available.
\end{enumerate}

You've completed \textbf{Chapter 4: Structuring Data}, the heart of
understanding how C organizes the world. Next, you'll move from
in-memory structures to \textbf{input, output, and files}, learning how
to interact with the outside world through the standard I/O library in
Chapter 5.

\bookmarksetup{startatroot}

\chapter{Chapter 5. Input, Output and
Files}\label{chapter-5.-input-output-and-files}

\subsection{41. Standard I/O and
printf/scanf}\label{standard-io-and-printfscanf}

Input and output are how your programs talk to the outside world. In C,
almost everything goes through the \textbf{Standard I/O library},
defined in \texttt{\textless{}stdio.h\textgreater{}}. You've already met
\texttt{printf()} in ``Hello, C World'', now you'll learn how all these
functions fit together, how they work, and how to use them safely.

\subsubsection{The Standard Streams}\label{the-standard-streams}

Every C program starts with \textbf{three standard streams}
automatically open:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1067}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.6000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2933}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Stream
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example Function
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{stdin} & Standard input (keyboard, or redirected file) &
\texttt{scanf()}, \texttt{fgets()} \\
\texttt{stdout} & Standard output (screen) & \texttt{printf()},
\texttt{puts()} \\
\texttt{stderr} & Standard error (screen, for diagnostics) &
\texttt{fprintf(stderr,\ ...)} \\
\end{longtable}

You can redirect these streams in the terminal:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textless{}}\NormalTok{ input.txt }\OperatorTok{\textgreater{}}\NormalTok{ output.txt }\DecValTok{2}\OperatorTok{\textgreater{}}\NormalTok{ errors.log}
\end{Highlighting}
\end{Shaded}

\subsubsection{Printing with printf()}\label{printing-with-printf}

\texttt{printf()} formats and prints data to \texttt{stdout}. Its power
lies in \textbf{format specifiers}, which describe the type and layout
of what to print.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Format & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int & \texttt{\%d} & \texttt{printf("\%d",\ 42);} \\
float & \texttt{\%f} & \texttt{printf("\%.2f",\ 3.1415);} \\
char & \texttt{\%c} &
\texttt{printf("\%c",\ \textquotesingle{}A\textquotesingle{});} \\
string & \texttt{\%s} & \texttt{printf("\%s",\ "Hello");} \\
pointer & \texttt{\%p} & \texttt{printf("\%p",\ ptr);} \\
hexadecimal & \texttt{\%x} & \texttt{printf("\%x",\ 255);} \\
\end{longtable}

You can control width, precision, and alignment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%{-}10s}\StringTok{ | }\SpecialCharTok{\%6.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,} \StringTok{"Price"}\OperatorTok{,} \FloatTok{3.5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Price      |   3.50
\end{verbatim}

\subsubsection{Tiny Code: Print
Everything}\label{tiny-code-print-everything}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f }\OperatorTok{=} \FloatTok{3.1415}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ c }\OperatorTok{=} \CharTok{\textquotesingle{}C\textquotesingle{}}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{s }\OperatorTok{=} \StringTok{"Hello, C!"}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Integer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Float: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ f}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Char: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ c}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"String: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer: }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{void}\OperatorTok{*)}\NormalTok{s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Integer: 42
Float: 3.14
Char: C
String: Hello, C!
Pointer: 0x7ffeed001234
\end{verbatim}

\subsubsection{Reading with scanf()}\label{reading-with-scanf}

\texttt{scanf()} reads formatted input from \texttt{stdin}. It's like
\texttt{printf()} in reverse, you tell it the format, and it fills your
variables.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ height}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter age and height: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%f}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{,} \OperatorTok{\&}\NormalTok{height}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"You are }\SpecialCharTok{\%d}\StringTok{ years old and }\SpecialCharTok{\%.1f}\StringTok{ meters tall.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{,}\NormalTok{ height}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Input:

\begin{verbatim}
25 1.75
\end{verbatim}

Output:

\begin{verbatim}
You are 25 years old and 1.8 meters tall.
\end{verbatim}

\begin{quote}
\textbf{Always use the \texttt{\&} operator} for non-array variables ---
it passes the memory address where the value should be stored.
\end{quote}

\subsubsection{Safer Input: fgets() and
sscanf()}\label{safer-input-fgets-and-sscanf}

\texttt{scanf()} is risky for strings, it doesn't prevent buffer
overflow. Safer pattern: use \texttt{fgets()} to read a full line, then
parse it.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter your name: "}\OperatorTok{);}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{buf}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;} \CommentTok{// remove newline}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Combining printf and
scanf}\label{combining-printf-and-scanf}

You can build interactive console tools easily:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ year}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your name: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%49s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);} \CommentTok{// limit input to 49 chars + null}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your birth year: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{year}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hi }\SpecialCharTok{\%s}\StringTok{! You are about }\SpecialCharTok{\%d}\StringTok{ years old.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{,} \DecValTok{2025} \OperatorTok{{-}}\NormalTok{ year}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Enter your name: Alice
Enter your birth year: 2000
Hi Alice! You are about 25 years old.
\end{verbatim}

\subsubsection{Formatted Output to Files and
Strings}\label{formatted-output-to-files-and-strings}

You can redirect formatted output anywhere, not just the screen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error: invalid input.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \CommentTok{// print to stderr}

\DataTypeTok{char}\NormalTok{ buffer}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\NormalTok{sprintf}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{,} \StringTok{"Pi = }\SpecialCharTok{\%.3f}\StringTok{"}\OperatorTok{,} \FloatTok{3.14159}\OperatorTok{);} \CommentTok{// print to string}
\NormalTok{puts}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Pi = 3.142
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-38}

\texttt{printf()} and \texttt{scanf()} are the \textbf{workhorses of
console I/O}. They teach you:

\begin{itemize}
\tightlist
\item
  How data moves between memory and streams.
\item
  How to control numeric precision and layout.
\item
  How input and output interact with the terminal or files.
\end{itemize}

Every C system, from tiny microcontrollers to full operating systems,
uses these same foundations.

\subsubsection{Try It Yourself}\label{try-it-yourself-39}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print a table of numbers with two columns: number and its square.
\item
  Read three integers using \texttt{scanf} and print their average.
\item
  Use \texttt{fgets} and \texttt{sscanf} to safely parse
  \texttt{"42\ 3.14"} into int and float.
\item
  Write a small quiz app: ask a question, read input, print ``Correct''
  or ``Try again''.
\item
  Experiment with printing to \texttt{stderr}, redirect errors to a
  file.
\end{enumerate}

Mastering standard I/O is like mastering your program's \textbf{voice},
it's how your C code speaks and listens. Next, you'll move deeper into
file handling, learning how to open, read, and write files with file
pointers in Section 42.

\subsection{\texorpdfstring{42. File Pointers and \texttt{fopen} /
\texttt{fclose}}{42. File Pointers and fopen / fclose}}\label{file-pointers-and-fopen-fclose}

Files let your C programs remember things beyond runtime. Unlike
standard input and output, which disappear when the program ends, files
provide \textbf{persistent storage}, you can read and write data between
runs.

This section introduces the key file-handling API in C:
\texttt{fopen()}, \texttt{fclose()}, \texttt{fprintf()},
\texttt{fscanf()}, and their relatives.

\subsubsection{The Big Picture}\label{the-big-picture-1}

File I/O in C uses a \texttt{FILE\ *} pointer to represent an open file.
You don't manipulate the disk directly, instead, you read and write
through a buffered file stream managed by the runtime.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This returns a pointer to a \texttt{FILE} object if successful, or
\texttt{NULL} if the file can't be opened.

\subsubsection{File Modes}\label{file-modes}

When opening a file, you specify a \textbf{mode}, what you intend to do
with it.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Mode & Meaning & Behavior \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{"r"} & read & Fails if file doesn't exist \\
\texttt{"w"} & write & Creates new or truncates existing \\
\texttt{"a"} & append & Opens or creates; writes go to end \\
\texttt{"r+"} & read/write & Must exist \\
\texttt{"w+"} & read/write & Truncates if exists \\
\texttt{"a+"} & read/write & Appends; reading starts at beginning \\
\end{longtable}

\subsubsection{Tiny Code: Write and Read a
File}\label{tiny-code-write-and-read-a-file}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"example.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"Hello, file world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"C makes you closer to the machine.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"example.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to reopen file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"{-}{-}{-} File Content {-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
--- File Content ---
Hello, file world!
C makes you closer to the machine.
\end{verbatim}

\subsubsection{How It Works}\label{how-it-works-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{fopen()} creates a connection to a file.
\item
  \texttt{fprintf()} writes formatted text, just like \texttt{printf()}
  but to a file stream.
\item
  \texttt{fclose()} flushes buffers and closes the file.
\item
  Reopen with \texttt{"r"} mode to read what you wrote.
\end{enumerate}

You can also mix with \texttt{fscanf()} to read formatted data.

\subsubsection{Checking for Errors}\label{checking-for-errors}

Always check file operations for errors. Use \texttt{if\ (!fp)} after
\texttt{fopen()}, and use \texttt{perror()} to print the reason.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"missing.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example output:

\begin{verbatim}
Error opening file: No such file or directory
\end{verbatim}

\subsubsection{\texorpdfstring{Reading Formatted Data with
\texttt{fscanf}}{Reading Formatted Data with fscanf}}\label{reading-formatted-data-with-fscanf}

You can parse text files using \texttt{fscanf()}, just like
\texttt{scanf()}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"numbers.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

    \DataTypeTok{int}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fscanf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{a}\OperatorTok{,} \OperatorTok{\&}\NormalTok{b}\OperatorTok{)} \OperatorTok{==} \DecValTok{2}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{numbers.txt} contains:

\begin{verbatim}
2 3
10 15
7 9
\end{verbatim}

Output:

\begin{verbatim}
2 + 3 = 5
10 + 15 = 25
7 + 9 = 16
\end{verbatim}

\subsubsection{File Position and
Rewinding}\label{file-position-and-rewinding}

You can move around a file using:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fseek}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ SEEK\_SET}\OperatorTok{);}  \CommentTok{// go to beginning}
\NormalTok{fseek}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ SEEK\_END}\OperatorTok{);}  \CommentTok{// go to end}
\NormalTok{rewind}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}              \CommentTok{// reset to start}
\end{Highlighting}
\end{Shaded}

To know where you are:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{long}\NormalTok{ pos }\OperatorTok{=}\NormalTok{ ftell}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Current position: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pos}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Writing Binary Data}\label{writing-binary-data}

Text files are human-readable; binary files store raw bytes. You'll use
\texttt{fwrite()} and \texttt{fread()} for that (covered more in the
next section).

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\};}
\NormalTok{fwrite}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{4}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-39}

File I/O is the bridge between your C program and the real world:

\begin{itemize}
\tightlist
\item
  Configuration and log files
\item
  Database storage
\item
  Caches and serialization
\item
  Operating system utilities (copy, move, grep, etc.)
\end{itemize}

It teaches \textbf{resource management}, always \texttt{fopen()} and
\texttt{fclose()} in pairs, check errors, and handle failures
gracefully.

\subsubsection{Try It Yourself}\label{try-it-yourself-40}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that asks for your name and saves it to
  \texttt{user.txt}.
\item
  Append a timestamp each time the program runs.
\item
  Read all lines and count how many times your program has been
  executed.
\item
  Modify the example to reverse all lines read from a file.
\item
  Handle missing files gracefully using \texttt{perror()}.
\end{enumerate}

You now know how to open, read, and write text files safely. Next,
you'll go deeper into \textbf{binary files}, where data moves in raw
bytes, perfect for storing structs and arrays efficiently.

\subsection{43. Reading and Writing Binary
Files}\label{reading-and-writing-binary-files}

Text files are easy to read but not always efficient. Binary files, on
the other hand, store raw bytes exactly as they exist in memory, no
formatting, no conversions. They're ideal for saving arrays, structs, or
any data that must be written and read back quickly without loss or
rounding.

\subsubsection{Text vs Binary}\label{text-vs-binary}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1111}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Text File
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Binary File
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Format & Human-readable (ASCII) & Raw bytes \\
Size & Larger (extra characters, newlines) & Smaller (compact form) \\
Read/Write & \texttt{fprintf}, \texttt{fscanf}, \texttt{fgets} &
\texttt{fwrite}, \texttt{fread} \\
Use Case & Logs, config, reports & Structs, images, executables,
serialized data \\
\end{longtable}

When you open a file for binary I/O, add \textbf{\texttt{b}} to the
mode:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);} \CommentTok{// write binary}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);} \CommentTok{// read binary}
\end{Highlighting}
\end{Shaded}

\subsubsection{Writing Binary Data}\label{writing-binary-data-1}

Let's write an array of integers directly to disk.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{,} \DecValTok{40}\OperatorTok{,} \DecValTok{50}\OperatorTok{\};}
    \DataTypeTok{size\_t}\NormalTok{ count }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{)} \OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"numbers.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    fwrite}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),}\NormalTok{ count}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Wrote }\SpecialCharTok{\%zu}\StringTok{ integers to numbers.bin}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This writes 5 integers (4 bytes each on most systems) directly to disk
as raw bytes, no text conversion.

\subsubsection{Reading Binary Data}\label{reading-binary-data}

Now let's read them back:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"numbers.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ fread}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{5}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Read }\SpecialCharTok{\%zu}\StringTok{ integers:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Wrote 5 integers to numbers.bin
Read 5 integers:
10 20 30 40 50
\end{verbatim}

\subsubsection{Writing and Reading
Structs}\label{writing-and-reading-structs}

You can store whole structures directly using the same pattern.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ price}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ title}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Book}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Book b1 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \FloatTok{9.99}\OperatorTok{,} \StringTok{"The C Book"}\OperatorTok{\};}
\NormalTok{    Book b2 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \FloatTok{15.49}\OperatorTok{,} \StringTok{"Algorithms in C"}\OperatorTok{\};}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"books.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\NormalTok{    fwrite}\OperatorTok{(\&}\NormalTok{b1}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Book}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fwrite}\OperatorTok{(\&}\NormalTok{b2}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Book}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"books.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\NormalTok{    Book b}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{b}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Book}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ | }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ b}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ b}\OperatorTok{.}\NormalTok{title}\OperatorTok{,}\NormalTok{ b}\OperatorTok{.}\NormalTok{price}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 | The C Book | 9.99
2 | Algorithms in C | 15.49
\end{verbatim}

\subsubsection{Handling Endianness}\label{handling-endianness}

Binary files depend on the CPU's byte order (endianness). If you write
on a \textbf{little-endian} machine and read on a \textbf{big-endian}
one, bytes may appear reversed.

For portable formats, you can:

\begin{itemize}
\tightlist
\item
  Use standardized serialization (like Protocol Buffers or MessagePack).
\item
  Convert manually using bit shifts or network-byte-order functions
  (\texttt{htonl}, \texttt{ntohl}).
\end{itemize}

Example for manual conversion:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ to\_big\_endian}\OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{((}\NormalTok{x }\OperatorTok{\&} \BaseNTok{0xFF}\OperatorTok{)} \OperatorTok{\textless{}\textless{}} \DecValTok{24}\OperatorTok{)} \OperatorTok{|}
           \OperatorTok{((}\NormalTok{x }\OperatorTok{\&} \BaseNTok{0xFF00}\OperatorTok{)} \OperatorTok{\textless{}\textless{}} \DecValTok{8}\OperatorTok{)} \OperatorTok{|}
           \OperatorTok{((}\NormalTok{x }\OperatorTok{\&} \BaseNTok{0xFF0000}\OperatorTok{)} \OperatorTok{\textgreater{}\textgreater{}} \DecValTok{8}\OperatorTok{)} \OperatorTok{|}
           \OperatorTok{((}\NormalTok{x }\OperatorTok{\textgreater{}\textgreater{}} \DecValTok{24}\OperatorTok{)} \OperatorTok{\&} \BaseNTok{0xFF}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Appending Binary Data}\label{appending-binary-data}

You can append more records with mode \texttt{"ab"}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Book b3 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \FloatTok{21.75}\OperatorTok{,} \StringTok{"Advanced C"}\OperatorTok{\};}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"books.bin"}\OperatorTok{,} \StringTok{"ab"}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{b3}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Book}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Binary File Utilities}\label{binary-file-utilities}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Function & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{fwrite(ptr,\ size,\ count,\ file)} & Write binary data \\
\texttt{fread(ptr,\ size,\ count,\ file)} & Read binary data \\
\texttt{fseek(file,\ offset,\ origin)} & Move position \\
\texttt{ftell(file)} & Get current position \\
\texttt{rewind(file)} & Go back to start \\
\end{longtable}

\subsubsection{Why It Matters}\label{why-it-matters-40}

Binary I/O is essential for:

\begin{itemize}
\tightlist
\item
  Saving large datasets efficiently
\item
  Game save files, multimedia formats, or scientific data
\item
  Databases and memory-mapped storage
\item
  Embedded and system-level tools
\end{itemize}

It's the foundation of \textbf{serialization}, transforming data in
memory into bytes that can travel or persist.

\subsubsection{Try It Yourself}\label{try-it-yourself-41}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Save an array of \texttt{double} values and read them back.
\item
  Modify the struct example to include an \texttt{enum} field and test
  the binary result.
\item
  Implement a function \texttt{count\_records(filename)} that counts how
  many structs are stored.
\item
  Use \texttt{fseek()} to jump to the third record and print only that
  one.
\item
  Write both text and binary versions of the same file and compare
  sizes.
\end{enumerate}

Binary I/O connects C's low-level power to real-world storage
efficiency. Next, you'll expand this further by understanding
\textbf{standard streams}, how to use \texttt{stdin}, \texttt{stdout},
and \texttt{stderr} to build flexible, composable command-line tools.

\subsection{\texorpdfstring{44. Working with \texttt{stdin},
\texttt{stdout}, and
\texttt{stderr}}{44. Working with stdin, stdout, and stderr}}\label{working-with-stdin-stdout-and-stderr}

Every C program automatically starts with three open streams connected
to your environment, the keyboard, the terminal screen, and the error
console. They are the \textbf{standard I/O streams} that make your
programs flexible and scriptable.

Understanding these three streams is crucial for writing tools that can
interact with files, pipes, and other programs, the essence of
Unix-style design.

\subsubsection{The Three Standard
Streams}\label{the-three-standard-streams}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.0889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4222}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Stream
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical Device
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example Use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{stdin} & Standard Input & Keyboard (or file via
\texttt{\textless{}}) & \texttt{scanf}, \texttt{fgets} \\
\texttt{stdout} & Standard Output & Screen (or file via
\texttt{\textgreater{}}) & \texttt{printf}, \texttt{puts},
\texttt{fprintf(stdout,\ …)} \\
\texttt{stderr} & Standard Error & Screen (separate from stdout) &
\texttt{fprintf(stderr,\ …)} \\
\end{longtable}

These are all of type \texttt{FILE\ *}. You can treat them like normal
file pointers, reading, writing, or redirecting them.

\subsubsection{Basic Example}\label{basic-example-1}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your name: "}\OperatorTok{);}
\NormalTok{    fgets}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{name}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}

\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{,} \StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Note: This is an example error message.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Enter your name: Alice
Hello, Alice
Note: This is an example error message.
\end{verbatim}

\subsubsection{Redirection in the Shell}\label{redirection-in-the-shell}

You can redirect each stream separately:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textless{}}\NormalTok{ input.txt }\OperatorTok{\textgreater{}}\NormalTok{ output.txt }\DecValTok{2}\OperatorTok{\textgreater{}}\NormalTok{ errors.log}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}} replaces \texttt{stdin} (read input from file)
\item
  \texttt{\textgreater{}} replaces \texttt{stdout} (write normal output
  to file)
\item
  \texttt{2\textgreater{}} replaces \texttt{stderr} (write errors to
  file)
\end{itemize}

You can also combine them:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textgreater{}}\NormalTok{ all\_output.txt }\DecValTok{2}\OperatorTok{\textgreater{}\&}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

This merges both output and error streams into one file.

\subsubsection{Reading from stdin}\label{reading-from-stdin}

You can build programs that process input dynamically, one line at a
time:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter text (Ctrl+D to stop):}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You said: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now your program behaves like a Unix filter, it can read from a file, a
pipe, or a keyboard input interchangeably.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"hello"} \KeywordTok{|} \ExtensionTok{./program}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
You said: hello
\end{verbatim}

\subsubsection{Writing to stdout and
stderr}\label{writing-to-stdout-and-stderr}

\texttt{stdout} is for normal program output, while \texttt{stderr} is
for error messages or logs.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{,} \StringTok{"Everything is fine.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Warning: something might be wrong.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You can suppress normal output but keep errors:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textgreater{}}\NormalTok{ /dev/null}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Warning: something might be wrong.
\end{verbatim}

\subsubsection{Tiny Code: Word Counter Using
stdin/stdout}\label{tiny-code-word-counter-using-stdinstdout}

This small program mimics a simplified version of the Unix \texttt{wc}
command.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}ctype.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ ch}\OperatorTok{,}\NormalTok{ words }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{ch }\OperatorTok{=}\NormalTok{ getchar}\OperatorTok{())} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{isspace}\OperatorTok{(}\NormalTok{ch}\OperatorTok{))}
\NormalTok{            in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{in\_word}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            in\_word }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{            words}\OperatorTok{++;}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Word count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ words}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{echo} \StringTok{"C is small but powerful"} \KeywordTok{|} \ExtensionTok{./wordcount}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Word count: 4
\end{verbatim}

\subsubsection{Mixing stdout and stderr}\label{mixing-stdout-and-stderr}

Sometimes you need to log progress to \texttt{stderr} while outputting
results to \texttt{stdout}. That way, logs don't pollute the actual
data.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Processing item }\SpecialCharTok{\%d}\StringTok{...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{);}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{,} \StringTok{"Item }\SpecialCharTok{\%d}\StringTok{ processed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Redirect logs separately:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textgreater{}}\NormalTok{ result.txt }\DecValTok{2}\OperatorTok{\textgreater{}}\NormalTok{ log.txt}
\end{Highlighting}
\end{Shaded}

\subsubsection{Flushing Buffers}\label{flushing-buffers}

Output streams are \textbf{buffered}, data isn't written until the
buffer is full or flushed. To ensure output appears immediately:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}  \CommentTok{// flush output buffer}
\end{Highlighting}
\end{Shaded}

This is useful for interactive programs.

\subsubsection{Why It Matters}\label{why-it-matters-41}

These three streams give your program flexibility:

\begin{itemize}
\tightlist
\item
  Work interactively (keyboard/screen)
\item
  Work in batch (file input/output)
\item
  Chain with other tools using pipes
\end{itemize}

They are the foundation of the \textbf{Unix philosophy}: small programs
that do one thing well and can be composed together.

\subsubsection{Try It Yourself}\label{try-it-yourself-42}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that reads from stdin and prints only lines containing
  a given keyword.
\item
  Print errors to stderr if no keyword is provided.
\item
  Redirect input and output from files using \texttt{\textless{}} and
  \texttt{\textgreater{}}.
\item
  Add progress messages to stderr and redirect them to a separate log.
\item
  Combine everything into a small ``filter'' tool that processes text
  from pipelines.
\end{enumerate}

With \texttt{stdin}, \texttt{stdout}, and \texttt{stderr}, your C
programs become tools that fit seamlessly into real workflows, able to
interact with files, other programs, and users alike. Next, you'll
explore \textbf{buffered I/O}, understanding how the C library optimizes
performance through read and write buffers using \texttt{fgets},
\texttt{fputs}, and more.

\subsection{\texorpdfstring{45. Buffered I/O with \texttt{fgets} and
\texttt{fputs}}{45. Buffered I/O with fgets and fputs}}\label{buffered-io-with-fgets-and-fputs}

When your program reads and writes data, it doesn't always go directly
to disk or the terminal, instead, it uses \textbf{buffers}. Buffers are
small chunks of memory that temporarily hold data, improving performance
by reducing how often the system has to perform slow I/O operations.

C's Standard I/O library (\texttt{\textless{}stdio.h\textgreater{}})
handles this automatically for you. In this section, you'll learn how
buffering works and how to use \texttt{fgets}, \texttt{fputs}, and
related functions to manage it effectively.

\subsubsection{What Is Buffered I/O?}\label{what-is-buffered-io}

Instead of reading or writing one character at a time, the C library:

\begin{itemize}
\tightlist
\item
  Fills a buffer (for input) or
\item
  Collects a batch of characters (for output)
\end{itemize}

When the buffer is full or flushed, data moves between your program and
the file or terminal.

This is why sometimes \texttt{printf()} output doesn't appear
immediately, it's waiting in a buffer until a newline or flush occurs.

\subsubsection{\texorpdfstring{Input:
\texttt{fgets()}}{Input: fgets()}}\label{input-fgets}

\texttt{fgets()} reads a full line from a stream (including spaces) and
stores it in a string.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{fgets}\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{str}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{,} \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{stream}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{str}: where to store the line
\item
  \texttt{size}: maximum number of characters to read (including
  \texttt{\textbackslash{}0})
\item
  \texttt{stream}: where to read from (e.g.~\texttt{stdin} or a file
  pointer)
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter a sentence: "}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You said: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input:

\begin{verbatim}
C is beautiful.
\end{verbatim}

Output:

\begin{verbatim}
You said: C is beautiful.
\end{verbatim}

If the input exceeds the buffer, \texttt{fgets} stops reading after
\texttt{size\ -\ 1} characters to prevent overflow, and automatically
null-terminates the string.

\subsubsection{\texorpdfstring{Output:
\texttt{fputs()}}{Output: fputs()}}\label{output-fputs}

\texttt{fputs()} writes a string to a stream.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fputs}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{str}\OperatorTok{,} \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{stream}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Open failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    fputs}\OperatorTok{(}\StringTok{"Buffered I/O makes C fast.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fputs}\OperatorTok{(}\StringTok{"fgets and fputs are line{-}based tools.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Wrote to output.txt}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output file:

\begin{verbatim}
Buffered I/O makes C fast.
fgets and fputs are line-based tools.
\end{verbatim}

\subsubsection{\texorpdfstring{Why \texttt{fgets} Is Safer Than
\texttt{scanf("\%s",\ …)}}{Why fgets Is Safer Than scanf("\%s", \ldots)}}\label{why-fgets-is-safer-than-scanfs}

\begin{itemize}
\tightlist
\item
  \texttt{fgets()} respects buffer boundaries
\item
  It reads spaces and tabs correctly
\item
  It prevents undefined behavior from overflows
\end{itemize}

Avoid this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{);} \CommentTok{// stops at first space and may overflow}
\end{Highlighting}
\end{Shaded}

Prefer this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fgets}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Writing to \texttt{stdout} or
\texttt{stderr} with
\texttt{fputs}}{Writing to stdout or stderr with fputs}}\label{writing-to-stdout-or-stderr-with-fputs}

\texttt{fputs()} works on any output stream, not just files.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fputs}\OperatorTok{(}\StringTok{"Message to screen.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ stdout}\OperatorTok{);}
\NormalTok{fputs}\OperatorTok{(}\StringTok{"Error to stderr!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ stderr}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can even redirect these in the shell:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program} \OperatorTok{\textgreater{}}\NormalTok{ result.txt }\DecValTok{2}\OperatorTok{\textgreater{}}\NormalTok{ error.log}
\end{Highlighting}
\end{Shaded}

\subsubsection{Reading Files Line by
Line}\label{reading-files-line-by-line}

Here's how to read a file safely using \texttt{fgets()}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"poem.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{200}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code: Copy a File}\label{tiny-code-copy-a-file}

A minimal file copier using \texttt{fgets} and \texttt{fputs}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{in }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"input.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"copy.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{in }\OperatorTok{||} \OperatorTok{!}\NormalTok{out}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"File error"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{256}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),}\NormalTok{ in}\OperatorTok{))}
\NormalTok{        fputs}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,}\NormalTok{ out}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{in}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{out}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Copied successfully.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Buffer Flushing}\label{buffer-flushing}

Sometimes you need to manually flush output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is useful for interactive programs that must show messages
immediately.

To disable buffering entirely (e.g., for logging):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setbuf}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-42}

Buffered I/O balances \textbf{speed} and \textbf{safety}:

\begin{itemize}
\tightlist
\item
  \texttt{fgets} protects against overflow
\item
  \texttt{fputs} ensures efficient output
\item
  Buffering minimizes slow disk and console calls
\end{itemize}

It's what makes C both low-level and performant without forcing you to
manage every byte yourself.

\subsubsection{Try It Yourself}\label{try-it-yourself-43}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that reads lines from stdin and writes them to a new
  file.
\item
  Count how many lines you read before EOF.
\item
  Print each line with line numbers using \texttt{fgets} and
  \texttt{printf}.
\item
  Experiment with buffer sizes, try 16 vs 256 bytes and note the
  performance difference.
\item
  Flush output after every line for an interactive logging program.
\end{enumerate}

\texttt{fgets} and \texttt{fputs} give you a safe, line-based foundation
for file and console I/O. Next, you'll learn how to \textbf{handle
errors correctly} using \texttt{errno}, \texttt{perror}, and
\texttt{strerror}, essential tools for writing reliable system programs
in C.

\subsection{\texorpdfstring{46. Error Checking with \texttt{errno} and
\texttt{perror}}{46. Error Checking with errno and perror}}\label{error-checking-with-errno-and-perror}

Even the best-written C programs can encounter errors, missing files,
permission issues, division by zero, or failed memory allocations.
Unlike some languages that throw exceptions, C reports errors
\textbf{manually} using return values and a global variable named
\textbf{\texttt{errno}}.

Understanding how to use \texttt{errno}, \texttt{perror()}, and
\texttt{strerror()} is essential for writing \textbf{robust,
production-grade} C programs that fail gracefully and informatively.

\subsubsection{\texorpdfstring{The Idea Behind
\texttt{errno}}{The Idea Behind errno}}\label{the-idea-behind-errno}

\texttt{errno} is a global integer (declared in
\texttt{\textless{}errno.h\textgreater{}}) that stores an \textbf{error
code} whenever a library function fails.

\begin{itemize}
\tightlist
\item
  On success, most functions leave \texttt{errno} unchanged.
\item
  On failure, they typically set \texttt{errno} and return an error
  value (often \texttt{NULL}, \texttt{-1}, or \texttt{0} depending on
  the function).
\item
  You must check the return value first, only then should you inspect
  \texttt{errno}.
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"missing.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error code: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ errno}\OperatorTok{);}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"fopen failed"}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Error code: 2
fopen failed: No such file or directory
\end{verbatim}

\subsubsection{\texorpdfstring{Common \texttt{errno}
Codes}{Common errno Codes}}\label{common-errno-codes}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Code & Name & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2 & \texttt{ENOENT} & No such file or directory \\
13 & \texttt{EACCES} & Permission denied \\
12 & \texttt{ENOMEM} & Not enough memory \\
22 & \texttt{EINVAL} & Invalid argument \\
17 & \texttt{EEXIST} & File already exists \\
5 & \texttt{EIO} & Input/output error \\
111 & \texttt{ECONNREFUSED} & Connection refused (network) \\
\end{longtable}

Include \texttt{\textless{}errno.h\textgreater{}} to use these symbolic
names:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{errno }\OperatorTok{==}\NormalTok{ ENOENT}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"File missing.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Using
\texttt{perror()}}{Using perror()}}\label{using-perror}

\texttt{perror()} prints a human-readable error message to
\texttt{stderr}, based on the current value of \texttt{errno}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{perror}\OperatorTok{(}\StringTok{"File open error"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"ghost.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Unable to open file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Unable to open file: No such file or directory
\end{verbatim}

\subsubsection{\texorpdfstring{Using
\texttt{strerror()}}{Using strerror()}}\label{using-strerror}

If you want to use the error message in your own formatted output, use
\texttt{strerror()} from \texttt{\textless{}string.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"/root/secret.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error (}\SpecialCharTok{\%d}\StringTok{): }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ errno}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Error (13): Permission denied
\end{verbatim}

\subsubsection{Tiny Code: Robust File
Reader}\label{tiny-code-robust-file-reader}

Here's a simple file reader that checks for errors at every step:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}filename\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error opening }\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{128}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{ferror}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error reading file: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./readfile}\NormalTok{ poem.txt}
\end{Highlighting}
\end{Shaded}

If the file is missing:

\begin{verbatim}
Error opening poem.txt: No such file or directory
\end{verbatim}

\subsubsection{\texorpdfstring{Clearing and Resetting
\texttt{errno}}{Clearing and Resetting errno}}\label{clearing-and-resetting-errno}

Some functions may set \texttt{errno} even if they succeed later. To be
safe, you can clear it before a call:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\NormalTok{errno }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"file.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)}\NormalTok{ perror}\OperatorTok{(}\StringTok{"fopen"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This ensures you don't read a leftover error from an earlier operation.

\subsubsection{Checking Other System
Errors}\label{checking-other-system-errors}

\texttt{errno} isn't limited to file I/O, it applies to many system
calls and library functions:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"/dev/full"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);} \CommentTok{// special Linux device that fails on write}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fputc}\OperatorTok{(}\CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{,}\NormalTok{ f}\OperatorTok{)} \OperatorTok{==}\NormalTok{ EOF}\OperatorTok{)}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"Write failed"}\OperatorTok{);}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Write failed: No space left on device
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-43}

\texttt{errno} and its helpers (\texttt{perror}, \texttt{strerror}) make
your programs \emph{explain themselves} when things go wrong. This is
vital for:

\begin{itemize}
\tightlist
\item
  System tools that must report specific error causes
\item
  Debugging production code
\item
  Writing portable, maintainable programs
\end{itemize}

Good C developers never just ``fail silently.''

\subsubsection{Try It Yourself}\label{try-it-yourself-44}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open a file that doesn't exist, then create it and try again.
\item
  Simulate a read error by using \texttt{ferror()} after reading a
  closed file.
\item
  Try writing to a directory (\texttt{fopen("/tmp",\ "w")}) and inspect
  \texttt{errno}.
\item
  Print all known error codes and messages using a loop and
  \texttt{strerror()}.
\item
  Write a small ``safe\_open'' function that wraps \texttt{fopen} with
  error reporting.
\end{enumerate}

With error handling mastered, you now know how to make C programs both
informative and reliable. Next, you'll explore \textbf{command-line
arguments (\texttt{argc}, \texttt{argv})}, the gateway to building
flexible, scriptable tools that process user input dynamically.

\subsection{\texorpdfstring{47. Command-Line Arguments (\texttt{argc},
\texttt{argv})}{47. Command-Line Arguments (argc, argv)}}\label{command-line-arguments-argc-argv}

Every C program can receive input directly from the \textbf{command
line}, no \texttt{scanf}, no \texttt{fgets}, just arguments passed when
you run the executable. This is how professional C tools (like
\texttt{gcc}, \texttt{ls}, and \texttt{grep}) receive filenames,
options, and flags.

\subsubsection{The Function Signature}\label{the-function-signature}

Your \texttt{main} function can take \textbf{two parameters}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Parameter & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{argc} & Argument count (number of command-line arguments) \\
\texttt{argv} & Argument vector (array of C strings, each argument) \\
\end{longtable}

\texttt{argv{[}0{]}} is the program name itself, and
\texttt{argv{[}1{]}} onward are the user-provided arguments.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./hello}\NormalTok{ world test}
\end{Highlighting}
\end{Shaded}

Then:

\begin{itemize}
\tightlist
\item
  \texttt{argc\ ==\ 3}
\item
  \texttt{argv{[}0{]}\ =\ "./hello"}
\item
  \texttt{argv{[}1{]}\ =\ "world"}
\item
  \texttt{argv{[}2{]}\ =\ "test"}
\end{itemize}

\subsubsection{Tiny Code: Print Command-Line
Arguments}\label{tiny-code-print-command-line-arguments}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Argument count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argc}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"argv[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./args}\NormalTok{ foo bar 123}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Argument count: 4
argv[0] = ./args
argv[1] = foo
argv[2] = bar
argv[3] = 123
\end{verbatim}

\subsubsection{Checking for Missing
Arguments}\label{checking-for-missing-arguments}

If your program needs arguments, check \texttt{argc} before accessing
them.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}filename\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Opening file: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./fileop}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Usage: ./fileop <filename>
\end{verbatim}

Run again:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./fileop}\NormalTok{ data.txt}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Opening file: data.txt
\end{verbatim}

\subsubsection{Converting String Arguments to
Numbers}\label{converting-string-arguments-to-numbers}

All command-line arguments are \textbf{strings}. To use them as numbers,
convert using:

\begin{itemize}
\tightlist
\item
  \texttt{atoi()} -- string to int
\item
  \texttt{atof()} -- string to float
\item
  \texttt{strtol()} / \texttt{strtod()} -- safer and more flexible
  alternatives
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}a\textgreater{} \textless{}b\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \DataTypeTok{int}\NormalTok{ b }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./sum}\NormalTok{ 10 25}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 + 25 = 35
\end{verbatim}

\subsubsection{Handling Options (Flags)}\label{handling-options-flags}

You can build simple command-line tools that handle options manually:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ verbose }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \StringTok{"{-}v"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{            verbose }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{verbose}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Verbose mode on}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Run quietly}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./tool} \AttributeTok{{-}v}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Verbose mode on
\end{verbatim}

\subsubsection{Tiny Code: Mini File Echo
Tool}\label{tiny-code-mini-file-echo-tool}

This program prints the content of a file passed as an argument:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}file\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{128}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./echo}\NormalTok{ mytext.txt}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-44}

\texttt{argc} and \texttt{argv} make your C programs scriptable and
composable:

\begin{itemize}
\tightlist
\item
  Automate tasks from the command line
\item
  Integrate with shell scripts or pipelines
\item
  Process multiple input files
\item
  Implement command-line flags and options
\end{itemize}

Every real-world C utility, from \texttt{ls} to \texttt{gcc}, depends on
this pattern.

\subsubsection{Try It Yourself}\label{try-it-yourself-45}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a program that takes a list of integers and prints their sum.
\item
  Add a \texttt{-r} flag to reverse the order of printed arguments.
\item
  Build a ``greet'' tool:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./greet}\NormalTok{ Alice Bob Charlie}
\end{Highlighting}
\end{Shaded}

  → \texttt{Hello,\ Alice!\ Hello,\ Bob!\ Hello,\ Charlie!}
\item
  Write a ``compare'' tool that checks if two file names are identical.
\item
  Combine \texttt{argc} and file I/O: copy one file to another with

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./copy}\NormalTok{ source.txt dest.txt}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

With command-line arguments, your C programs evolve from static
exercises to \textbf{flexible, real-world tools}. Next, you'll explore
\textbf{reading configuration files}, a powerful way to let your
programs adapt automatically without recompilation.

\subsection{48. Reading Configuration
Files}\label{reading-configuration-files}

As your C programs grow, hardcoding settings like file paths,
thresholds, or user preferences becomes limiting. Configuration files
let your program read settings at runtime, a critical capability for
tools, servers, and embedded systems.

You'll learn how to read and parse configuration files using standard
I/O and string handling.

\subsubsection{The Goal}\label{the-goal}

A configuration file might look like this:

\begin{verbatim}
port=8080
host=localhost
max_clients=100
log_file=server.log
\end{verbatim}

Your program should:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open the file
\item
  Read it line by line
\item
  Split each line into \texttt{key} and \texttt{value}
\item
  Store or use those values
\end{enumerate}

\subsubsection{Step 1. Define a Structure for
Config}\label{step-1.-define-a-structure-for-config}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_LINE }\DecValTok{128}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ port}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ host}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ max\_clients}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ log\_file}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Config}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This \texttt{Config} struct will hold parsed values.

\subsubsection{Step 2. Implement the
Parser}\label{step-2.-implement-the-parser}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ load\_config}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Config }\OperatorTok{*}\NormalTok{cfg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open config file"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\NormalTok{MAX\_LINE}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{        line}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;} \CommentTok{// remove newline}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{line}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{==} \CharTok{\textquotesingle{}\#\textquotesingle{}} \OperatorTok{||}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{line}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{continue}\OperatorTok{;} \CommentTok{// skip comments and blanks}

        \DataTypeTok{char}\NormalTok{ key}\OperatorTok{[}\DecValTok{64}\OperatorTok{],}\NormalTok{ value}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sscanf}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \StringTok{"\%63[\^{}=]=}\SpecialCharTok{\%63s}\StringTok{"}\OperatorTok{,}\NormalTok{ key}\OperatorTok{,}\NormalTok{ value}\OperatorTok{)} \OperatorTok{==} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \StringTok{"port"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{                cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{port }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
            \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \StringTok{"host"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{                strncpy}\OperatorTok{(}\NormalTok{cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{host}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{host}\OperatorTok{));}
            \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \StringTok{"max\_clients"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{                cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{max\_clients }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
            \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \StringTok{"log\_file"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{                strncpy}\OperatorTok{(}\NormalTok{cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{log\_file}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{cfg}\OperatorTok{{-}\textgreater{}}\NormalTok{log\_file}\OperatorTok{));}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This function:

\begin{itemize}
\tightlist
\item
  Reads each line
\item
  Ignores comments and empty lines
\item
  Extracts key-value pairs using \texttt{sscanf()}
\item
  Updates fields in \texttt{Config}
\end{itemize}

\subsubsection{Step 3. Use the
Configuration}\label{step-3.-use-the-configuration}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Config cfg }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    load\_config}\OperatorTok{(}\StringTok{"config.txt"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{cfg}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Server settings:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Host: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cfg}\OperatorTok{.}\NormalTok{host}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Port: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cfg}\OperatorTok{.}\NormalTok{port}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Max clients: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cfg}\OperatorTok{.}\NormalTok{max\_clients}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Log file: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cfg}\OperatorTok{.}\NormalTok{log\_file}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run with a \texttt{config.txt} file:

\begin{verbatim}
host=127.0.0.1
port=9090
max_clients=250
log_file=/tmp/server.log
\end{verbatim}

Output:

\begin{verbatim}
Server settings:
Host: 127.0.0.1
Port: 9090
Max clients: 250
Log file: /tmp/server.log
\end{verbatim}

\subsubsection{Tiny Code: Default
Fallbacks}\label{tiny-code-default-fallbacks}

You can initialize sensible defaults before reading the file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Config cfg }\OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{.}\NormalTok{port }\OperatorTok{=} \DecValTok{8080}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{host }\OperatorTok{=} \StringTok{"localhost"}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{max\_clients }\OperatorTok{=} \DecValTok{100}\OperatorTok{,}
    \OperatorTok{.}\NormalTok{log\_file }\OperatorTok{=} \StringTok{"server.log"}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This ensures your program still works even if the file is missing some
values.

\subsubsection{Step 4. Optional: Handle Quoted
Values}\label{step-4.-optional-handle-quoted-values}

If you expect values with spaces (like \texttt{name="My\ Server"}), you
can modify parsing logic:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{sscanf}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \StringTok{"\%63[\^{}=]=}\SpecialCharTok{\textbackslash{}"}\StringTok{\%63[\^{}}\SpecialCharTok{\textbackslash{}"}\StringTok{]}\SpecialCharTok{\textbackslash{}"}\StringTok{"}\OperatorTok{,}\NormalTok{ key}\OperatorTok{,}\NormalTok{ value}\OperatorTok{)} \OperatorTok{==} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// handle quoted strings}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Optional: Generic
Storage}\label{step-5.-optional-generic-storage}

For more flexible systems, you can use a hash table or array of
key-value pairs instead of fixed fields:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ key}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ value}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ KVPair}\OperatorTok{;}

\NormalTok{KVPair settings}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

This allows loading arbitrary keys without recompiling the program.

\subsubsection{Why It Matters}\label{why-it-matters-45}

Configuration files let you:

\begin{itemize}
\tightlist
\item
  \textbf{Separate code from data}, no need to recompile to change
  behavior
\item
  \textbf{Adapt to environments}, dev, test, production
\item
  \textbf{Make your program reusable} by others
\end{itemize}

They're used everywhere, from \texttt{.ini} and \texttt{.conf} files to
complex YAML/JSON formats in modern systems.

\subsubsection{Try It Yourself}\label{try-it-yourself-46}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add support for \texttt{\#} comments and empty lines (skip them
  safely).
\item
  Make the parser print a warning for unknown keys.
\item
  Add a function \texttt{save\_config()} that writes the struct back to
  a file.
\item
  Add \texttt{reload\_config()} to update settings at runtime.
\item
  Implement your own \texttt{.ini} format parser supporting
  \texttt{{[}section{]}} headers.
\end{enumerate}

With configuration files, your C programs gain flexibility and
real-world usability, they can adapt, reload, and persist settings just
like professional systems software. Next, you'll learn how to
\textbf{serialize and deserialize structs to disk}, the next level of
persistent data handling in Section 49.

\subsection{49. Serializing Structs to
Disk}\label{serializing-structs-to-disk}

So far, you've worked with text files, configuration files, and basic
binary data. Now it's time to combine those ideas into something more
powerful, \textbf{serialization}: saving complete C structs to disk and
restoring them later, exactly as they were in memory.

This is the foundation for databases, caches, and persistent state in
operating systems and games.

\subsubsection{What Is Serialization?}\label{what-is-serialization}

\textbf{Serialization} means converting in-memory data into a format
that can be stored or transmitted (like a file).
\textbf{Deserialization} is the reverse: reconstructing that data from
the file.

In C, this often means writing structs directly as binary data with
\texttt{fwrite()} and reading them back with \texttt{fread()}.

\subsubsection{Step 1. Define a Struct to
Store}\label{step-1.-define-a-struct-to-store}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ price}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Product}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Each field is fixed-size, which makes it safe to write directly to disk
as binary.

\subsubsection{Step 2. Write Structs to
Disk}\label{step-2.-write-structs-to-disk}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ save\_products}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Product }\OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ count}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open file for writing"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    fwrite}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),}\NormalTok{ count}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. Read Structs from
Disk}\label{step-3.-read-structs-from-disk}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{size\_t}\NormalTok{ load\_products}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Product }\OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ max\_count}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open file for reading"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ fread}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),}\NormalTok{ max\_count}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code: Complete
Example}\label{tiny-code-complete-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ price}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Product}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ save\_products}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Product }\OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ count}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open file"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    fwrite}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),}\NormalTok{ count}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{size\_t}\NormalTok{ load\_products}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Product }\OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ max\_count}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}
    \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ fread}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),}\NormalTok{ max\_count}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Product products}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Notebook"}\OperatorTok{,} \FloatTok{2.99}\OperatorTok{\},}
        \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Pencil"}\OperatorTok{,} \FloatTok{0.49}\OperatorTok{\},}
        \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \StringTok{"Backpack"}\OperatorTok{,} \FloatTok{25.00}\OperatorTok{\}}
    \OperatorTok{\};}

\NormalTok{    save\_products}\OperatorTok{(}\StringTok{"store.bin"}\OperatorTok{,}\NormalTok{ products}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Products saved.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    Product loaded}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
    \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ load\_products}\OperatorTok{(}\StringTok{"store.bin"}\OperatorTok{,}\NormalTok{ loaded}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Loaded }\SpecialCharTok{\%zu}\StringTok{ products:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ | }\SpecialCharTok{\%{-}10s}\StringTok{ | $}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ loaded}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{id}\OperatorTok{,}\NormalTok{ loaded}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ loaded}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{price}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Products saved.
Loaded 3 products:
1 | Notebook   | $2.99
2 | Pencil     | $0.49
3 | Backpack   | $25.00
\end{verbatim}

\subsubsection{Step 4. Appending
Records}\label{step-4.-appending-records}

You can add more data without overwriting by using append mode
\texttt{"ab"}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Product p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{4}\OperatorTok{,} \StringTok{"Eraser"}\OperatorTok{,} \FloatTok{0.99}\OperatorTok{\};}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"store.bin"}\OperatorTok{,} \StringTok{"ab"}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Random Access to
Records}\label{step-5.-random-access-to-records}

You can use \texttt{fseek()} to jump to a specific record (useful for
updating or reading one record at a time).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"store.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
\NormalTok{fseek}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{)} \OperatorTok{*} \DecValTok{1}\OperatorTok{,}\NormalTok{ SEEK\_SET}\OperatorTok{);}  \CommentTok{// skip first record}
\NormalTok{Product p}\OperatorTok{;}
\NormalTok{fread}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Product}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Record 2: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Portability
Considerations}\label{step-6.-portability-considerations}

Serialization like this is \textbf{machine-dependent} because of:

\begin{itemize}
\tightlist
\item
  \textbf{Endianness} (byte order of integers/floats)
\item
  \textbf{Structure padding} (compiler alignment)
\item
  \textbf{Data type sizes}
\end{itemize}

To make it portable:

\begin{itemize}
\tightlist
\item
  Use \texttt{\#pragma\ pack(1)} or \texttt{\_\_attribute\_\_((packed))}
  to disable padding.
\item
  Convert integers to a standard byte order (e.g., use \texttt{htonl()}
  and \texttt{ntohl()}).
\item
  Consider text-based or portable formats like CSV, JSON, or protobuf
  for cross-platform storage.
\end{itemize}

\subsubsection{Step 7. Text-Based Alternative
(Human-Readable)}\label{step-7.-text-based-alternative-human-readable}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ save\_as\_text}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,}\NormalTok{ Product }\OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ count}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%d}\StringTok{,}\SpecialCharTok{\%s}\StringTok{,}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{id}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{price}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This produces:

\begin{verbatim}
1,Notebook,2.99
2,Pencil,0.49
3,Backpack,25.00
\end{verbatim}

Easy to read, but slower to parse and less space-efficient.

\subsubsection{Why It Matters}\label{why-it-matters-46}

Serialization makes your C programs \emph{stateful}, they can save
progress, store data, or recover after restarts. It's the basis for:

\begin{itemize}
\tightlist
\item
  Databases and key-value stores
\item
  Save files in games
\item
  Checkpointing in scientific software
\item
  System daemons and caches
\end{itemize}

You're now handling \textbf{real persistence} in C.

\subsubsection{Try It Yourself}\label{try-it-yourself-47}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a function \texttt{add\_product()} that appends new records
  safely.
\item
  Implement \texttt{list\_products()} that prints all products from
  file.
\item
  Add a ``delete by id'' operation by copying all but one record to a
  new file.
\item
  Experiment with structure padding (\texttt{sizeof(Product)} may not be
  what you expect).
\item
  Add a checksum field to detect corrupted data.
\end{enumerate}

You now know how to persist structured data in binary or text form.
Next, you'll close Chapter 5 by combining all this knowledge, writing a
\textbf{log reader and writer} system that records events, rotates
files, and safely replays logs on startup.

\subsection{50. Practice: Build a Log Reader and
Writer}\label{practice-build-a-log-reader-and-writer}

You've explored text and binary I/O, buffering, error handling, and
configuration. Now it's time to bring everything together in one
real-world practice project, a \textbf{Log Reader and Writer} in C.

This system will let you write structured logs to a file and later read
them back, a foundation for tools like servers, daemons, and debugging
utilities.

\subsubsection{Project Overview}\label{project-overview-1}

You'll build a minimal logging system with two main parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Logger (Writer):}

  \begin{itemize}
  \tightlist
  \item
    Appends log messages to a file with timestamps and levels (INFO,
    WARN, ERROR).
  \item
    Handles file opening, writing, and safe closure.
  \end{itemize}
\item
  \textbf{Reader:}

  \begin{itemize}
  \tightlist
  \item
    Reads log entries line by line.
  \item
    Filters by log level or keyword.
  \end{itemize}
\end{enumerate}

This project teaches structured file I/O, formatted output, parsing, and
simple text search, all in clean C.

\subsubsection{Step 1. Define the Log
Format}\label{step-1.-define-the-log-format}

A log line will look like this:

\begin{verbatim}
[2025-10-15 21:00:32] [INFO] Server started
[2025-10-15 21:01:05] [WARN] High CPU usage
[2025-10-15 21:02:10] [ERROR] Connection failed
\end{verbatim}

Each entry includes:

\begin{itemize}
\tightlist
\item
  Timestamp
\item
  Level (INFO/WARN/ERROR)
\item
  Message
\end{itemize}

\subsubsection{Step 2. Implement the
Logger}\label{step-2.-implement-the-logger}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdarg.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    INFO}\OperatorTok{,}
\NormalTok{    WARN}\OperatorTok{,}
\NormalTok{    ERROR}
\OperatorTok{\}}\NormalTok{ LogLevel}\OperatorTok{;}

\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ level\_to\_string}\OperatorTok{(}\NormalTok{LogLevel level}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{level}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case}\NormalTok{ INFO}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"INFO"}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ WARN}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"WARN"}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ ERROR}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"ERROR"}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:} \ControlFlowTok{return} \StringTok{"UNKNOWN"}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ write\_log}\OperatorTok{(}\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp}\OperatorTok{,}\NormalTok{ LogLevel level}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{fmt}\OperatorTok{,} \OperatorTok{...)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}

    \CommentTok{// Timestamp}
    \DataTypeTok{time\_t}\NormalTok{ t }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
    \KeywordTok{struct}\NormalTok{ tm }\OperatorTok{*}\NormalTok{tm\_info }\OperatorTok{=}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{);}
    \DataTypeTok{char}\NormalTok{ timebuf}\OperatorTok{[}\DecValTok{32}\OperatorTok{];}
\NormalTok{    strftime}\OperatorTok{(}\NormalTok{timebuf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{timebuf}\OperatorTok{),} \StringTok{"\%Y{-}\%m{-}}\SpecialCharTok{\%d}\StringTok{ \%H:\%M:\%S"}\OperatorTok{,}\NormalTok{ tm\_info}\OperatorTok{);}

    \CommentTok{// Format message}
    \DataTypeTok{va\_list}\NormalTok{ args}\OperatorTok{;}
\NormalTok{    va\_start}\OperatorTok{(}\NormalTok{args}\OperatorTok{,}\NormalTok{ fmt}\OperatorTok{);}

\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"[}\SpecialCharTok{\%s}\StringTok{] [}\SpecialCharTok{\%s}\StringTok{] "}\OperatorTok{,}\NormalTok{ timebuf}\OperatorTok{,}\NormalTok{ level\_to\_string}\OperatorTok{(}\NormalTok{level}\OperatorTok{));}
\NormalTok{    vfprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,}\NormalTok{ fmt}\OperatorTok{,}\NormalTok{ args}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fflush}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);} \CommentTok{// flush immediately for safety}

\NormalTok{    va\_end}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. Example Writer
Program}\label{step-3.-example-writer-program}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{log }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"system.log"}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{log}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open log file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    write\_log}\OperatorTok{(}\NormalTok{log}\OperatorTok{,}\NormalTok{ INFO}\OperatorTok{,} \StringTok{"System started"}\OperatorTok{);}
\NormalTok{    write\_log}\OperatorTok{(}\NormalTok{log}\OperatorTok{,}\NormalTok{ WARN}\OperatorTok{,} \StringTok{"Low disk space on /dev/sda1"}\OperatorTok{);}
\NormalTok{    write\_log}\OperatorTok{(}\NormalTok{log}\OperatorTok{,}\NormalTok{ ERROR}\OperatorTok{,} \StringTok{"Failed to connect to database"}\OperatorTok{);}
\NormalTok{    write\_log}\OperatorTok{(}\NormalTok{log}\OperatorTok{,}\NormalTok{ INFO}\OperatorTok{,} \StringTok{"Shutdown complete"}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{log}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{verbatim}
[2025-10-15 21:00:32] [INFO] System started
[2025-10-15 21:00:35] [WARN] Low disk space on /dev/sda1
[2025-10-15 21:00:38] [ERROR] Failed to connect to database
[2025-10-15 21:01:00] [INFO] Shutdown complete
\end{verbatim}

\subsubsection{Step 4. Implement the
Reader}\label{step-4.-implement-the-reader}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ read\_logs}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filter}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Cannot open log file"}\OperatorTok{);}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{256}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{filter }\OperatorTok{==}\NormalTok{ NULL }\OperatorTok{||}\NormalTok{ strstr}\OperatorTok{(}\NormalTok{line}\OperatorTok{,}\NormalTok{ filter}\OperatorTok{))}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example usage:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"All logs:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    read\_logs}\OperatorTok{(}\StringTok{"system.log"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Only errors:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    read\_logs}\OperatorTok{(}\StringTok{"system.log"}\OperatorTok{,} \StringTok{"ERROR"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
All logs:
[2025-10-15 21:00:32] [INFO] System started
[2025-10-15 21:00:35] [WARN] Low disk space on /dev/sda1
[2025-10-15 21:00:38] [ERROR] Failed to connect to database
[2025-10-15 21:01:00] [INFO] Shutdown complete

Only errors:
[2025-10-15 21:00:38] [ERROR] Failed to connect to database
\end{verbatim}

\subsubsection{Step 5. Add Command-Line
Interface}\label{step-5.-add-command-line-interface}

Combine both features using \texttt{argc} and \texttt{argv}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ [write|read] [message/filter]}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"write"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{log }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"system.log"}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{log}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"open"}\OperatorTok{);}
            \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        write\_log}\OperatorTok{(}\NormalTok{log}\OperatorTok{,}\NormalTok{ INFO}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ argc }\OperatorTok{\textgreater{}} \DecValTok{2} \OperatorTok{?}\NormalTok{ argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{:} \StringTok{"Generic log entry"}\OperatorTok{);}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{log}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"read"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filter }\OperatorTok{=}\NormalTok{ argc }\OperatorTok{\textgreater{}} \DecValTok{2} \OperatorTok{?}\NormalTok{ argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{:}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{        read\_logs}\OperatorTok{(}\StringTok{"system.log"}\OperatorTok{,}\NormalTok{ filter}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Invalid command. Use write or read.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./logger}\NormalTok{ write }\StringTok{"Hello world"}
\ExtensionTok{./logger}\NormalTok{ read}
\ExtensionTok{./logger}\NormalTok{ read ERROR}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Handling Errors
Gracefully}\label{step-6.-handling-errors-gracefully}

\begin{itemize}
\tightlist
\item
  Always check return values from \texttt{fopen}, \texttt{fgets}, and
  \texttt{fprintf}.
\item
  Use \texttt{perror()} for system-level diagnostics.
\item
  Flush frequently or close properly to ensure logs persist after
  crashes.
\end{itemize}

\subsubsection{Step 7. Optional
Enhancements}\label{step-7.-optional-enhancements}

\begin{itemize}
\tightlist
\item
  Add log rotation (rename or truncate after N lines).
\item
  Add log levels (only write logs above a threshold).
\item
  Implement \texttt{save\_config()} to define a log file path and
  verbosity from a config file.
\item
  Add timestamps in UTC or with milliseconds for precision.
\item
  Write logs in binary format for higher speed, then parse later.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-47}

Logging is a \textbf{core system capability}. This project reinforces:

\begin{itemize}
\tightlist
\item
  Structured file I/O
\item
  Error handling (\texttt{errno}, \texttt{perror})
\item
  String parsing and filtering
\item
  Command-line tool design
\end{itemize}

Every C-based system, from embedded devices to Linux daemons, relies on
some form of logging.

\subsubsection{Try It Yourself}\label{try-it-yourself-48}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{LogLevel} threshold (ignore logs below WARN).
\item
  Implement a \texttt{rotate\_logs()} that renames \texttt{system.log}
  to \texttt{system.log.1} when it exceeds 100 lines.
\item
  Add timestamps in UTC instead of localtime.
\item
  Use \texttt{argv} to let users specify a custom log file name.
\item
  Store logs both to file and to \texttt{stderr} simultaneously.
\end{enumerate}

This completes \textbf{Chapter 5: Input, Output, and Files}, a milestone
in your journey. You can now handle text, binary, streams, and
persistent data with safety and clarity. Next, you'll step into
\textbf{Chapter 6: Compilation and the Build Process}, where source code
transforms into executable binaries through preprocessing, compilation,
linking, and automation.

\bookmarksetup{startatroot}

\chapter{Chapter 6. Compilation and the build
process}\label{chapter-6.-compilation-and-the-build-process}

\subsection{51. From Source to Executable: The Compilation
Pipeline}\label{from-source-to-executable-the-compilation-pipeline}

Every time you run

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

you're launching a complex, multi-stage process that transforms
human-readable C code into a machine-executable binary. Understanding
this \textbf{compilation pipeline} is the heart of becoming a real
systems programmer.

Let's unpack what happens between your \texttt{.c} file and the final
executable.

\subsubsection{Step 1. The Four Stages}\label{step-1.-the-four-stages}

A C compiler (like \texttt{gcc} or \texttt{clang}) performs four major
stages internally:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1684}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.0526}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1684}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1579}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.4526}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Stage
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tool
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Input
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Output
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Preprocessing & \texttt{cpp} & \texttt{hello.c} & expanded source &
Handles \texttt{\#include}, \texttt{\#define}, and macros \\
2. Compilation & \texttt{cc1} & expanded source & \texttt{hello.s} &
Translates C into assembly \\
3. Assembly & \texttt{as} & \texttt{hello.s} & \texttt{hello.o} &
Converts assembly into machine code \\
4. Linking & \texttt{ld} & \texttt{.o} + libraries & \texttt{hello} &
Combines everything into a runnable program \\
\end{longtable}

You can stop at any step with compiler flags to see what's happening.

\subsubsection{Tiny Code: Observe Each
Stage}\label{tiny-code-observe-each-stage}

Let's use a simple program:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// hello.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run these commands to inspect each stage:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. Preprocessing}
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello.i}

\CommentTok{\# 2. Compilation to Assembly}
\FunctionTok{gcc} \AttributeTok{{-}S}\NormalTok{ hello.i }\AttributeTok{{-}o}\NormalTok{ hello.s}

\CommentTok{\# 3. Assembly to Object File}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ hello.s }\AttributeTok{{-}o}\NormalTok{ hello.o}

\CommentTok{\# 4. Linking}
\FunctionTok{gcc}\NormalTok{ hello.o }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

Now check what each file looks like:

\begin{itemize}
\tightlist
\item
  \texttt{hello.i}: C code with headers expanded
\item
  \texttt{hello.s}: Human-readable assembly instructions
\item
  \texttt{hello.o}: Machine code (binary object)
\item
  \texttt{hello}: Final executable
\end{itemize}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, C!
\end{verbatim}

\subsubsection{\texorpdfstring{Step 2. Preprocessing
(\texttt{\#include}, \texttt{\#define},
\texttt{\#if})}{Step 2. Preprocessing (\#include, \#define, \#if)}}\label{step-2.-preprocessing-include-define-if}

The preprocessor handles all lines starting with \texttt{\#}. It's
purely textual, no code execution yet.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello.i}
\end{Highlighting}
\end{Shaded}

Open \texttt{hello.i} and you'll see thousands of lines from
\texttt{stdio.h} inserted into your code. It also replaces macros and
removes comments.

This is the stage where your \textbf{headers}, \textbf{macros}, and
\textbf{conditional compilation} come to life.

\subsubsection{Step 3. Compilation (to
Assembly)}\label{step-3.-compilation-to-assembly}

Next, the compiler translates your preprocessed C code into
\textbf{assembly language} for your target CPU.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}S}\NormalTok{ hello.i }\AttributeTok{{-}o}\NormalTok{ hello.s}
\end{Highlighting}
\end{Shaded}

Open \texttt{hello.s} to peek at low-level instructions like:

\begin{verbatim}
mov     edi, OFFSET FLAT:.LC0
call    puts
\end{verbatim}

These are CPU-specific, on x86, ARM, or RISC-V, they'll differ. This
stage also performs \textbf{optimization}, \textbf{type checking}, and
\textbf{error detection}.

\subsubsection{Step 4. Assembly (to Object
File)}\label{step-4.-assembly-to-object-file}

The assembler converts the \texttt{.s} file into raw machine
instructions and data structures, producing a \textbf{relocatable object
file}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ hello.s }\AttributeTok{{-}o}\NormalTok{ hello.o}
\end{Highlighting}
\end{Shaded}

You can inspect it with:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{objdump} \AttributeTok{{-}d}\NormalTok{ hello.o}
\end{Highlighting}
\end{Shaded}

Each function in your code becomes a \textbf{symbol} in this object
file.

\subsubsection{Step 5. Linking}\label{step-5.-linking}

The linker (\texttt{ld}) combines object files and libraries into a
single executable.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.o }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

If your program uses external functions (like \texttt{printf}), the
linker locates them in system libraries (e.g.,
\texttt{/usr/lib/libc.so}) and records their addresses.

The result: one self-contained executable ready to run.

\subsubsection{Step 6. Inspect the Final
Binary}\label{step-6.-inspect-the-final-binary}

Use tools like:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{file}\NormalTok{ hello}
\FunctionTok{nm}\NormalTok{ hello }\KeywordTok{|} \FunctionTok{head}
\ExtensionTok{readelf} \AttributeTok{{-}h}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

These reveal:

\begin{itemize}
\tightlist
\item
  File type (ELF, Mach-O, etc.)
\item
  Defined and undefined symbols
\item
  Sections like \texttt{.text}, \texttt{.data}, \texttt{.bss}
\end{itemize}

You're now seeing your C code at the machine level.

\subsubsection{Step 7. Cleanup and
Automation}\label{step-7.-cleanup-and-automation}

While it's educational to run each step manually, most of the time
you'll rely on:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

or a \texttt{Makefile} to orchestrate multiple files (we'll cover that
in Section 55).

\subsubsection{Tiny Code: Multi-File
Example}\label{tiny-code-multi-file-example}

Let's build a two-file program manually:

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"greet.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{(}\StringTok{"C programmer"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{greet.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{greet.h}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Compile and link manually:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ greet.c}
\FunctionTok{gcc}\NormalTok{ main.o greet.o }\AttributeTok{{-}o}\NormalTok{ app}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, C programmer!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-48}

Understanding the compilation pipeline helps you:

\begin{itemize}
\tightlist
\item
  Debug tricky build errors (\texttt{undefined\ reference},
  \texttt{multiple\ definition}, etc.)
\item
  Control optimization and debugging symbols
\item
  Inspect intermediate stages for learning or tuning performance
\item
  Build your own lightweight build systems or compilers
\end{itemize}

This is how \textbf{source code becomes machine reality}, step by step,
precisely defined.

\subsubsection{Try It Yourself}\label{try-it-yourself-49}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate all intermediate files (\texttt{.i}, \texttt{.s},
  \texttt{.o}) for a few programs and inspect them.
\item
  Experiment with \texttt{gcc\ -O0}, \texttt{-O2}, and \texttt{-O3} and
  observe how assembly changes.
\item
  Add \texttt{-g} and explore the binary with \texttt{gdb}.
\item
  Build a program that spans multiple \texttt{.c} files.
\item
  Use \texttt{nm} and \texttt{objdump} to trace how symbols move through
  the stages.
\end{enumerate}

Next, you'll explore the \textbf{preprocessor and macros}, the engine
behind includes, constants, and compile-time code generation.

\subsection{52. The Preprocessor and
Macros}\label{the-preprocessor-and-macros}

Before your C code is ever compiled, it passes through a powerful
text-handling stage called the \textbf{preprocessor}. This is where
headers are included, macros are expanded, and conditional compilation
happens.

The preprocessor doesn't ``understand'' C, it performs text substitution
and file inclusion, preparing your code for the compiler.

\subsubsection{Step 1. What the Preprocessor
Does}\label{step-1.-what-the-preprocessor-does}

Every line that starts with \texttt{\#} is a \textbf{preprocessor
directive}. Common ones include:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Directive & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\#include} & Insert contents of a header file \\
\texttt{\#define} & Define a macro or constant \\
\texttt{\#undef} & Remove a macro definition \\
\texttt{\#if}, \texttt{\#ifdef}, \texttt{\#ifndef} & Conditional
compilation \\
\texttt{\#else}, \texttt{\#elif}, \texttt{\#endif} & Branch logic for
the preprocessor \\
\texttt{\#error} & Stop compilation with a message \\
\texttt{\#pragma} & Compiler-specific instruction \\
\end{longtable}

\subsubsection{Tiny Code: See It in
Action}\label{tiny-code-see-it-in-action}

Create \texttt{macro.c}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\PreprocessorTok{\#define CIRCLE\_AREA}\OperatorTok{(}\PreprocessorTok{r}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{PI }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{r}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{r}\OperatorTok{))}
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"PI = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ PI}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Area of circle (r=2): }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ CIRCLE\_AREA}\OperatorTok{(}\DecValTok{2}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Square of 5: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ SQUARE}\OperatorTok{(}\DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ macro.c }\AttributeTok{{-}o}\NormalTok{ macro}
\ExtensionTok{./macro}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
PI = 3.14
Area of circle (r=2): 12.57
Square of 5: 25
\end{verbatim}

\subsubsection{Step 2. Expanding Macros}\label{step-2.-expanding-macros}

You can inspect the preprocessor output before compilation:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}E}\NormalTok{ macro.c }\AttributeTok{{-}o}\NormalTok{ macro.i}
\end{Highlighting}
\end{Shaded}

Open \texttt{macro.i}, you'll see all \texttt{\#include} files expanded
and macros replaced with their values.

This is a great way to \textbf{debug macro behavior} or check how large
standard headers expand.

\subsubsection{Step 3. Function-Like
Macros}\label{step-3.-function-like-macros}

Macros can look like functions, but they are \textbf{expanded inline},
meaning no call overhead, but also no type safety.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ADD}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{+}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ADD}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}  \CommentTok{// becomes ((2) + (3))}
\end{Highlighting}
\end{Shaded}

Be careful with missing parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define BAD\_ADD}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ a }\OperatorTok{+}\PreprocessorTok{ b}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{2} \OperatorTok{*}\NormalTok{ BAD\_ADD}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));} \CommentTok{// expands to 2 * 3 + 4 → 10, not 14}
\end{Highlighting}
\end{Shaded}

Always wrap parameters and entire expressions in parentheses.

\subsubsection{Step 4. Stringizing and Token
Pasting}\label{step-4.-stringizing-and-token-pasting}

Macros can manipulate text using special operators.

\textbf{Stringizing (\texttt{\#})} turns an argument into a string
literal:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PRINT\_EXPR}\OperatorTok{(}\PreprocessorTok{expr}\OperatorTok{)}\PreprocessorTok{ printf}\OperatorTok{(\#}\PreprocessorTok{expr }\StringTok{" = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ expr}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{PRINT\_EXPR}\OperatorTok{(}\NormalTok{x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{);}  \CommentTok{// prints: x + y = 15}
\end{Highlighting}
\end{Shaded}

\textbf{Token Pasting (\texttt{\#\#})} concatenates tokens:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAKE\_VAR}\OperatorTok{(}\PreprocessorTok{name}\OperatorTok{,}\PreprocessorTok{ num}\OperatorTok{)}\PreprocessorTok{ name}\OperatorTok{\#\#}\PreprocessorTok{num}
\DataTypeTok{int}\NormalTok{ MAKE\_VAR}\OperatorTok{(}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{)} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}  \CommentTok{// becomes int counter1 = 42;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Conditional
Compilation}\label{step-5.-conditional-compilation}

You can include or exclude code based on conditions:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DEBUG }\DecValTok{1}

\PreprocessorTok{\#if DEBUG}
    \PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}\PreprocessorTok{ printf}\OperatorTok{(}\StringTok{"DEBUG: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{)}
\PreprocessorTok{\#else}
    \PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Starting program"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running main logic}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with or without \texttt{-DDEBUG=1}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}DDEBUG}\OperatorTok{=}\NormalTok{1 log.c }\AttributeTok{{-}o}\NormalTok{ log}
\end{Highlighting}
\end{Shaded}

You can also use:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef DEBUG}
\PreprocessorTok{\#ifndef RELEASE}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Header Guards}\label{step-6.-header-guards}

Prevent multiple inclusions of the same header file by using
preprocessor guards:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MY\_HEADER\_H}
\PreprocessorTok{\#define MY\_HEADER\_H}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If \texttt{MY\_HEADER\_H} is already defined, the contents are skipped.
This prevents duplicate definitions across multiple includes.

\subsubsection{Step 7. Built-in Macros}\label{step-7.-built-in-macros}

The compiler defines a few handy macros automatically:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Macro & Expands To \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\_\_FILE\_\_} & current filename \\
\texttt{\_\_LINE\_\_} & current line number \\
\texttt{\_\_DATE\_\_} & compilation date \\
\texttt{\_\_TIME\_\_} & compilation time \\
\texttt{\_\_func\_\_} & current function name (C99+) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Error at }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{ in }\SpecialCharTok{\%s}\StringTok{()}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_FILE\_\_}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{,}\NormalTok{ \_\_func\_\_}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Error at macro.c:10 in main()
\end{verbatim}

\subsubsection{Tiny Code: Debug Macro}\label{tiny-code-debug-macro}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DEBUG\_PRINT}\OperatorTok{(}\PreprocessorTok{fmt}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"[}\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{] "}\PreprocessorTok{ fmt }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_VA\_ARGS\_\_}\OperatorTok{)}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    DEBUG\_PRINT}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
[macro.c:5] x = 10
\end{verbatim}

This is how logging frameworks are implemented in C using macros.

\subsubsection{Step 8. Undefining and
Redefining}\label{step-8.-undefining-and-redefining}

You can remove a macro with \texttt{\#undef}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#undef PI}
\PreprocessorTok{\#define PI }\FloatTok{3.14}
\end{Highlighting}
\end{Shaded}

This is often used in large projects to avoid macro name collisions
between libraries.

\subsubsection{Why It Matters}\label{why-it-matters-49}

The preprocessor gives C flexibility and power at \textbf{compile time},
enabling:

\begin{itemize}
\tightlist
\item
  Cross-platform builds (conditional compilation)
\item
  Debug logging systems
\item
  Inline performance optimizations
\item
  Simplified configuration management
\end{itemize}

It's also a double-edged sword, overusing macros can make code hard to
debug and maintain. Modern C favors \textbf{inline functions} for most
use cases (see Section 54), but macros remain indispensable for
low-level systems work.

\subsubsection{Try It Yourself}\label{try-it-yourself-50}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a macro that swaps two variables without a temporary.
\item
  Implement a \texttt{LOG(level,\ msg)} macro that prints messages only
  if \texttt{level\ \textgreater{}=\ MIN\_LOG\_LEVEL}.
\item
  Use \texttt{\_\_DATE\_\_} and \texttt{\_\_TIME\_\_} to print build
  information.
\item
  Add header guards to all your \texttt{.h} files and test multiple
  inclusions.
\item
  Try \texttt{gcc\ -E} on different programs to understand how
  preprocessing changes the source.
\end{enumerate}

In the next section, you'll go deeper into \textbf{conditional
compilation}, controlling which parts of your program are built based on
platform, features, or debugging needs.

\subsection{\texorpdfstring{53. Conditional Compilation (\texttt{\#if},
\texttt{\#ifdef},
\texttt{\#ifndef})}{53. Conditional Compilation (\#if, \#ifdef, \#ifndef)}}\label{conditional-compilation-if-ifdef-ifndef}

Conditional compilation lets you \textbf{control which code gets
compiled}, not at runtime, but at compile time. This is how C programs
adapt to different operating systems, architectures, or build
configurations without changing source files manually.

Think of it as logic for the compiler's \emph{eyes only}.

\subsubsection{Step 1. Why Conditional Compilation
Exists}\label{step-1.-why-conditional-compilation-exists}

Large C programs often need to handle differences such as:

\begin{itemize}
\tightlist
\item
  Platform (Windows, Linux, macOS, embedded)
\item
  Compiler (gcc, clang, MSVC)
\item
  Debug vs release builds
\item
  Optional features or experimental modules
\end{itemize}

Instead of maintaining multiple versions of the same file, you can use
conditional directives to selectively include or exclude code.

\subsubsection{Step 2. The Core
Directives}\label{step-2.-the-core-directives}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Directive & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\#if\ \textless{}expr\textgreater{}} & Compile code if
expression is true \\
\texttt{\#ifdef\ \textless{}macro\textgreater{}} & Compile if macro is
defined \\
\texttt{\#ifndef\ \textless{}macro\textgreater{}} & Compile if macro is
not defined \\
\texttt{\#else} & Alternate block \\
\texttt{\#elif\ \textless{}expr\textgreater{}} & Else-if for
preprocessor \\
\texttt{\#endif} & Marks the end of a conditional block \\
\end{longtable}

These work only during \textbf{preprocessing}, before compilation
starts.

\subsubsection{Tiny Code: Platform-Specific
Compilation}\label{tiny-code-platform-specific-compilation}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#ifdef \_WIN32}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on Windows}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_linux\_\_}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on Linux}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_APPLE\_\_}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on macOS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Unknown platform}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run on your system. The output will depend on which
predefined macros your compiler sets automatically.

\subsubsection{Step 3. Enabling and Disabling
Features}\label{step-3.-enabling-and-disabling-features}

You can define flags at compile time with \texttt{-D}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}DDEBUG}\NormalTok{ log.c }\AttributeTok{{-}o}\NormalTok{ log}
\end{Highlighting}
\end{Shaded}

In your code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug mode: extra checks enabled}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

No recompilation needed to switch, just re-run \texttt{gcc} with or
without \texttt{-DDEBUG}.

You can also assign values:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}DVERSION}\OperatorTok{=}\NormalTok{2 main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

Then:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if VERSION \textgreater{}= 2}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New feature enabled!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Step 4. Guarding Code with
\texttt{\#ifndef}}{Step 4. Guarding Code with \#ifndef}}\label{step-4.-guarding-code-with-ifndef}

This is one of the most common idioms in C headers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef CONFIG\_H}
\PreprocessorTok{\#define CONFIG\_H}

\PreprocessorTok{\#define MAX\_CLIENTS }\DecValTok{100}
\PreprocessorTok{\#define TIMEOUT\_MS }\DecValTok{3000}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

It ensures that if \texttt{config.h} is included multiple times, it only
gets processed once. Every header in the C standard library uses this
pattern.

\subsubsection{Step 5. Excluding Experimental
Code}\label{step-5.-excluding-experimental-code}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ENABLE\_EXPERIMENTAL }\DecValTok{0}

\PreprocessorTok{\#if ENABLE\_EXPERIMENTAL}
\DataTypeTok{void}\NormalTok{ experimental\_feature}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running experimental feature}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If \texttt{ENABLE\_EXPERIMENTAL} is set to \texttt{0}, this code is
completely removed before compilation, it doesn't even exist in the
object file.

\subsubsection{Tiny Code: Debug Mode
Example}\label{tiny-code-debug-mode-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define DEBUG\_MODE }\DecValTok{1}

\DataTypeTok{void}\NormalTok{ compute}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if DEBUG\_MODE}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"[DEBUG] compute() called with x=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\PreprocessorTok{\#endif}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    compute}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output when \texttt{DEBUG\_MODE} is 1:

\begin{verbatim}
[DEBUG] compute() called with x=5
Result: 25
\end{verbatim}

Set \texttt{DEBUG\_MODE} to 0, recompile, and the \texttt{{[}DEBUG{]}}
message disappears entirely.

\subsubsection{\texorpdfstring{Step 6. Using \texttt{\#elif} and
\texttt{\#else}}{Step 6. Using \#elif and \#else}}\label{step-6.-using-elif-and-else}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define OS }\DecValTok{2}

\PreprocessorTok{\#if OS == 1}
    \PreprocessorTok{\#define OS\_NAME }\StringTok{"Windows"}
\PreprocessorTok{\#elif OS == 2}
    \PreprocessorTok{\#define OS\_NAME }\StringTok{"Linux"}
\PreprocessorTok{\#else}
    \PreprocessorTok{\#define OS\_NAME }\StringTok{"Unknown"}
\PreprocessorTok{\#endif}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"OS: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ OS\_NAME}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
OS: Linux
\end{verbatim}

\subsubsection{Step 7. Combining with Logical
Operators}\label{step-7.-combining-with-logical-operators}

You can use \texttt{\&\&}, \texttt{\textbar{}\textbar{}}, and \texttt{!}
in preprocessor conditions.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if defined(DEBUG) \&\& !defined(RELEASE)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug build only}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

You can even use numeric comparisons:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if VERSION \textgreater{}= 3}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Version 3+ detected}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Forcing Compilation
Errors}\label{step-8.-forcing-compilation-errors}

Sometimes you want to stop compilation if a required macro is missing:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef API\_KEY}
\PreprocessorTok{\#error "API\_KEY not defined! Please compile with {-}DAPI\_KEY=your\_key"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This is useful for configuration validation at build time.

\subsubsection{Step 9. Compiler-Specific
Macros}\label{step-9.-compiler-specific-macros}

Compilers automatically define macros to identify themselves and the
environment.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Macro & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\_\_GNUC\_\_} & Defined by GCC \\
\texttt{\_\_clang\_\_} & Defined by Clang \\
\texttt{\_MSC\_VER} & Defined by MSVC \\
\texttt{\_\_x86\_64\_\_} & 64-bit architecture \\
\texttt{\_\_arm\_\_}, \texttt{\_\_aarch64\_\_} & ARM architectures \\
\texttt{\_\_STDC\_\_} & Conforms to ANSI C standard \\
\end{longtable}

You can use these to write portable, adaptive code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef \_\_clang\_\_}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Compiled with Clang}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif defined(\_\_GNUC\_\_)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Compiled with GCC}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code: Portable Sleep
Function}\label{tiny-code-portable-sleep-function}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#ifdef \_WIN32}
    \PreprocessorTok{\#include }\ImportTok{\textless{}windows.h\textgreater{}}
    \PreprocessorTok{\#define SLEEP}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ Sleep}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}
\PreprocessorTok{\#else}
    \PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
    \PreprocessorTok{\#define SLEEP}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ }\NormalTok{usleep}\OperatorTok{((}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\DecValTok{1000}\OperatorTok{)}
\PreprocessorTok{\#endif}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Waiting...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    SLEEP}\OperatorTok{(}\DecValTok{1000}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Done!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This compiles cleanly on both Windows and Linux with no code changes.

\subsubsection{Why It Matters}\label{why-it-matters-50}

Conditional compilation makes your C code:

\begin{itemize}
\tightlist
\item
  \textbf{Portable}, same code runs on multiple systems
\item
  \textbf{Configurable}, features can be toggled at build time
\item
  \textbf{Maintainable}, no need for multiple codebases
\item
  \textbf{Efficient}, excluded code doesn't even enter the binary
\end{itemize}

In system software and embedded development, this is indispensable.

\subsubsection{Try It Yourself}\label{try-it-yourself-51}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that prints a different greeting depending on the OS.
\item
  Use \texttt{\#if} and \texttt{\#error} to enforce that only one of
  \texttt{DEBUG} or \texttt{RELEASE} can be defined.
\item
  Write a header that defines constants for different CPU architectures.
\item
  Add a feature flag (\texttt{ENABLE\_LOGGING}) that can be turned
  on/off via \texttt{gcc\ -D}.
\item
  Use \texttt{\#ifdef} and \texttt{\#ifndef} to create a lightweight
  build-time configuration system.
\end{enumerate}

In the next section, you'll take the next step toward clean,
maintainable C code by learning about \textbf{inline functions} and
\textbf{header hygiene}, modern, safer replacements for many macro
patterns.

\subsection{54. Inline Functions and Header
Hygiene}\label{inline-functions-and-header-hygiene}

In early C, programmers often relied on macros for performance and
reuse. But macros have big drawbacks, no type checking, no debugging
symbols, and messy error messages.

\textbf{Inline functions} were introduced to solve this problem. They
combine the efficiency of macros with the safety of real functions.

This section also covers \textbf{header hygiene}, or how to write clean,
reusable \texttt{.h} files that scale safely across large projects.

\subsubsection{Step 1. What Does ``Inline''
Mean?}\label{step-1.-what-does-inline-mean}

Normally, calling a function like \texttt{add(a,\ b)} incurs a small
overhead, the CPU jumps to the function and back. Inlining means the
compiler \textbf{replaces the call with the function's code directly},
avoiding that jump.

You can suggest this with the \texttt{inline} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

When used properly, it's as fast as a macro but behaves like a real
function.

\subsubsection{Step 2. Comparing Macros vs Inline
Functions}\label{step-2.-comparing-macros-vs-inline-functions}

\textbf{Macro version:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ADD}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{+}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{Inline version:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Macro:}

\begin{itemize}
\tightlist
\item
  No type checking
\item
  May cause multiple evaluations (e.g., \texttt{ADD(x++,\ y++)})
\item
  Harder to debug
\end{itemize}

\textbf{Inline function:}

\begin{itemize}
\tightlist
\item
  Type-checked
\item
  Single evaluation
\item
  Can be stepped through in a debugger
\end{itemize}

\subsubsection{Step 3. Declaring Inline Functions in
Headers}\label{step-3.-declaring-inline-functions-in-headers}

When defining inline functions in header files, add \texttt{static} to
avoid multiple-definition errors:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// math\_utils.h}
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ max}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}}\NormalTok{ b}\OperatorTok{)} \OperatorTok{?}\NormalTok{ a }\OperatorTok{:}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This ensures each \texttt{.c} file that includes the header gets its own
copy, avoiding linker conflicts.

\subsubsection{Tiny Code: Inline
Utilities}\label{tiny-code-inline-utilities}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"cube(}\SpecialCharTok{\%d}\StringTok{) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ cube}\OperatorTok{(}\NormalTok{n}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
cube(3) = 27
\end{verbatim}

The compiler will expand \texttt{cube(3)} directly into
\texttt{3\ *\ 3\ *\ 3}, no function call overhead.

\subsubsection{Step 4. Inline and the
Compiler}\label{step-4.-inline-and-the-compiler}

\texttt{inline} is a \emph{hint} to the compiler, not a command. The
compiler decides whether inlining actually improves performance.

You can force inlining (non-portably) with attributes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\_\_attribute\_\_}\OperatorTok{((}\NormalTok{always\_inline}\OperatorTok{))} \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ fast\_add}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{x }\OperatorTok{+=}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But it's best to let the optimizer choose. Inlining too much can
increase binary size (known as ``code bloat'').

\subsubsection{Step 5. Inline and
Linkage}\label{step-5.-inline-and-linkage}

Inline functions behave differently depending on whether they're
declared \texttt{static}, \texttt{extern}, or plain \texttt{inline}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2533}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7467}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Keyword Combination
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{static\ inline} & Visible only in this translation unit (safe
for headers) \\
\texttt{extern\ inline} & Shared across translation units (rarely
needed) \\
\texttt{inline} (alone) & Behavior depends on compiler and standard
version \\
\end{longtable}

Stick with \texttt{static\ inline} for header-defined helpers.

\subsubsection{Step 6. Inline vs Macros: Debug
Example}\label{step-6.-inline-vs-macros-debug-example}

\textbf{Macro:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PRINT}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ x}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Error output when debugging might show:

\begin{verbatim}
macro.c: In function 'main': macro.c:5: error: expected ';'
\end{verbatim}

\textbf{Inline:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ print}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now you get a clean message:

\begin{verbatim}
error: too few arguments to function 'print'
\end{verbatim}

Inlining makes error handling and debugging much cleaner.

\subsubsection{Step 7. Header Hygiene, The Rules of Clean
Headers}\label{step-7.-header-hygiene-the-rules-of-clean-headers}

Headers define your program's public interface. Poorly written headers
cause multiple-definition errors, redefinition warnings, and broken
builds.

Follow these guidelines:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Use header guards}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MYLIB\_H}
\PreprocessorTok{\#define MYLIB\_H}
\CommentTok{// contents}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Keep headers minimal} Only include what's necessary, use
  forward declarations when possible.
\item
  \textbf{Don't put function definitions unless they're
  \texttt{static\ inline}.}
\item
  \textbf{Never use \texttt{using\ namespace}, global variables, or
  large macros} in headers.
\item
  \textbf{Group related declarations together}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{} \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}
\DataTypeTok{void}\NormalTok{ move}\OperatorTok{(}\NormalTok{Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Include standard headers only when required}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}\PreprocessorTok{  }\CommentTok{// only if you use FILE*}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Tiny Code: Clean Header + Implementation
Example}\label{tiny-code-clean-header-implementation-example}

\textbf{mathlib.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATHLIB\_H}
\PreprocessorTok{\#define MATHLIB\_H}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}

\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ print\_point}\OperatorTok{(}\NormalTok{Point p}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\textbf{mathlib.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"mathlib.h"}

\DataTypeTok{void}\NormalTok{ print\_point}\OperatorTok{(}\NormalTok{Point p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"mathlib.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{    print\_point}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c mathlib.c }\AttributeTok{{-}o}\NormalTok{ demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
(2, 3)
Sum = 7
\end{verbatim}

This structure mirrors real-world C libraries, headers for declarations,
\texttt{.c} files for definitions, and inline helpers where performance
matters.

\subsubsection{Step 8. Inline and Optimization
Flags}\label{step-8.-inline-and-optimization-flags}

Use \texttt{-O2} or higher optimization to let the compiler inline
aggressively:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}O2}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

At \texttt{-O0} (no optimization), even inline functions may not be
expanded.

\subsubsection{Step 9. Inline in C99 and
Beyond}\label{step-9.-inline-in-c99-and-beyond}

Inline semantics were standardized in \textbf{C99}. Older compilers
(pre-C99) treated inline inconsistently. Always compile with
\texttt{-std=c99} or later for predictable behavior:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c99 main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-51}

Inline functions give you:

\begin{itemize}
\tightlist
\item
  Performance like macros
\item
  Type safety and cleaner debugging
\item
  Reusable logic in headers
\item
  Safer and smaller helper functions
\end{itemize}

They are a modern C programmer's best tool for writing efficient yet
maintainable code.

\subsubsection{Try It Yourself}\label{try-it-yourself-52}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace three of your macros from previous exercises with inline
  functions.
\item
  Benchmark your program with and without \texttt{-O2} to see the
  difference.
\item
  Write a header-only math library using \texttt{static\ inline}
  functions.
\item
  Add header guards and check with multiple includes.
\item
  Use \texttt{objdump\ -d} to confirm whether your inline code actually
  got expanded.
\end{enumerate}

Next, you'll automate your growing C projects with \textbf{Makefiles and
build systems}, the tools that manage compilation, linking, and
dependencies efficiently.

\subsection{55. Makefiles and Build
Automation}\label{makefiles-and-build-automation}

Compiling one or two C files by hand is fine, but real projects quickly
grow to dozens or hundreds of files. Typing long \texttt{gcc} commands
every time becomes tedious, error-prone, and inconsistent across
environments.

That's where \textbf{Makefiles} come in. They automate the build
process, track dependencies, and rebuild only what changed.

Let's build a complete understanding of how to use \texttt{make} and
write simple but powerful Makefiles.

\subsubsection{\texorpdfstring{Step 1. What Is
\texttt{make}?}{Step 1. What Is make?}}\label{step-1.-what-is-make}

\texttt{make} is a tool that reads a file called \textbf{Makefile} and
executes the build rules it defines.

Each rule describes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A \textbf{target} (the thing you want to build)
\item
  Its \textbf{dependencies} (what it needs)
\item
  The \textbf{commands} to build it
\end{enumerate}

Basic syntax:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{target:}\DataTypeTok{ dependencies}
\NormalTok{\textless{}TAB\textgreater{}command}
\end{Highlighting}
\end{Shaded}

Yes, the indentation \textbf{must} be a real tab, not spaces.

\subsubsection{Step 2. The Simplest
Makefile}\label{step-2.-the-simplest-makefile}

Suppose your project has:

\begin{verbatim}
main.c
math.c
math.h
\end{verbatim}

\textbf{Makefile:}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{app:}\DataTypeTok{ main.c math.c}
\ErrorTok{    }\NormalTok{gcc main.c math.c {-}o app}
\end{Highlighting}
\end{Shaded}

Build:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
gcc main.c math.c -o app
\end{verbatim}

Run:

\begin{verbatim}
./app
\end{verbatim}

Now if you run \texttt{make} again, nothing happens, because
\texttt{make} sees that the output (\texttt{app}) is newer than the
sources. That's the magic of dependency tracking.

\subsubsection{Step 3. Split into Compilation
Steps}\label{step-3.-split-into-compilation-steps}

A better version builds \texttt{.o} files separately:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{app:}\DataTypeTok{ main.o math.o}
\ErrorTok{    }\NormalTok{gcc main.o math.o {-}o app}

\DecValTok{main.o:}\DataTypeTok{ main.c math.h}
\ErrorTok{    }\NormalTok{gcc {-}c main.c}

\DecValTok{math.o:}\DataTypeTok{ math.c math.h}
\ErrorTok{    }\NormalTok{gcc {-}c math.c}
\end{Highlighting}
\end{Shaded}

Now when you change only \texttt{math.c}, only \texttt{math.o}
recompiles.

\subsubsection{Tiny Code: Minimal
Project}\label{tiny-code-minimal-project}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"2 + 3 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{app:}\DataTypeTok{ main.o math.o}
\ErrorTok{    }\NormalTok{gcc main.o math.o {-}o app}

\DecValTok{main.o:}\DataTypeTok{ main.c math.h}
\ErrorTok{    }\NormalTok{gcc {-}c main.c}

\DecValTok{math.o:}\DataTypeTok{ math.c math.h}
\ErrorTok{    }\NormalTok{gcc {-}c math.c}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f *.o app}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./app}
\FunctionTok{make}\NormalTok{ clean}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Use Variables}\label{step-4.-use-variables}

Makefiles support variables to avoid repetition:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}Wextra {-}std=c99}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ main.o math.o}

\DecValTok{app:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o app}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{\$\textless{}} = first dependency
\item
  \texttt{\$@} = target name
\item
  \texttt{\%.o:\ \%.c} = pattern rule (applies to all matching files)
\end{itemize}

\subsubsection{Step 5. Add Debug and Release
Modes}\label{step-5.-add-debug-and-release-modes}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{DEBUG\_FLAGS} \CharTok{=}\StringTok{ {-}g {-}O0}
\DataTypeTok{RELEASE\_FLAGS} \CharTok{=}\StringTok{ {-}O2}

\DataTypeTok{OBJ} \CharTok{=}\StringTok{ main.o math.o}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{all:}\DataTypeTok{ release}

\DecValTok{debug:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{DEBUG\_FLAGS}\CharTok{)}
\DecValTok{debug:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{release:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{RELEASE\_FLAGS}\CharTok{)}
\DecValTok{release:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Build in debug mode:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ debug}
\end{Highlighting}
\end{Shaded}

Build optimized release:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ release}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Automatic
Dependencies}\label{step-6.-automatic-dependencies}

You can have \texttt{gcc} generate dependency files automatically:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}MMD} \AttributeTok{{-}c}\NormalTok{ main.c}
\end{Highlighting}
\end{Shaded}

This creates \texttt{main.d} which tracks included headers. You can
include these files in your Makefile for automatic rebuilds:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{{-}include} \CharTok{$(}\DataTypeTok{OBJ}\KeywordTok{:}\SpecialStringTok{.o}\KeywordTok{=}\SpecialStringTok{.d}\CharTok{)}
\end{Highlighting}
\end{Shaded}

That's how professional build systems keep dependencies accurate.

\subsubsection{Step 7. Phony Targets}\label{step-7.-phony-targets}

Targets that don't produce actual files should be marked \textbf{phony}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{.PHONY:}\DataTypeTok{ clean all debug release}
\end{Highlighting}
\end{Shaded}

This prevents file name collisions (e.g., if a file named \texttt{clean}
exists).

\subsubsection{Step 8. Organize Larger
Projects}\label{step-8.-organize-larger-projects}

For multi-directory projects:

\begin{verbatim}
src/
 ├── main.c
 ├── util.c
include/
 ├── util.h
\end{verbatim}

You can structure your Makefile like:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{SRC} \CharTok{=}\StringTok{ src/main.c src/util.c}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{SRC}\KeywordTok{:}\SpecialStringTok{.c}\KeywordTok{=}\SpecialStringTok{.o}\CharTok{)}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Iinclude {-}Wall}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{-Iinclude} tells the compiler where to find header files.

\subsubsection{Step 9. Use Built-in
Rules}\label{step-9.-use-built-in-rules}

\texttt{make} already knows how to build \texttt{.o} from \texttt{.c}. A
minimalist Makefile can be:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{app:}\DataTypeTok{ main.o math.o}
\ErrorTok{    }\NormalTok{gcc }\CharTok{$\^{}}\NormalTok{ {-}o }\CharTok{$@}
\end{Highlighting}
\end{Shaded}

Where \texttt{\$\^{}} expands to all dependencies
(\texttt{main.o\ math.o}).

\subsubsection{Step 10. Tiny Code: Library Build
Example}\label{step-10.-tiny-code-library-build-example}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ util.o io.o}
\DataTypeTok{LIB} \CharTok{=}\StringTok{ libtools.a}

\DecValTok{$(LIB):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\NormalTok{ar rcs }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{LIB}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Build your static library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Now link it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}ltools} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-52}

Makefiles give you:

\begin{itemize}
\tightlist
\item
  \textbf{Reproducible builds}, same commands every time
\item
  \textbf{Incremental recompilation}, only changed files rebuild
\item
  \textbf{Multiple configurations}, debug, release, test
\item
  \textbf{Extensibility}, can run scripts, code generation, packaging,
  etc.
\end{itemize}

Every serious C project, from the Linux kernel to tiny embedded tools,
relies on \texttt{make} or its descendants (like CMake, Ninja, Meson).

\subsubsection{Try It Yourself}\label{try-it-yourself-53}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a project with 3 \texttt{.c} files and 2 \texttt{.h} files.
\item
  Write a Makefile that supports \texttt{make\ debug},
  \texttt{make\ release}, and \texttt{make\ clean}.
\item
  Add a \texttt{make\ install} target that copies the binary to
  \texttt{/usr/local/bin}.
\item
  Use variables like \texttt{CC}, \texttt{CFLAGS}, and pattern rules to
  simplify your file list.
\item
  Run \texttt{make\ -n} to preview commands without executing them.
\end{enumerate}

In the next section, you'll learn how to \textbf{link multiple files and
libraries}, understanding object files, symbols, and how your code
connects together during the build process.

\subsection{56. Linking Multiple Files}\label{linking-multiple-files}

When a program grows beyond one \texttt{.c} file, the compiler must
combine them into a single executable. This process, \textbf{linking},
is what joins all your functions, variables, and library references into
one binary.

You've already seen snippets of it with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o math.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

But now we'll go deeper into \emph{how} linking works and what happens
when things go wrong.

\subsubsection{Step 1. The Two Compilation
Phases}\label{step-1.-the-two-compilation-phases}

Every C build has two main phases:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Compilation} -- each \texttt{.c} file becomes a \texttt{.o}
  (object file).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main.o}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ math.c }\AttributeTok{{-}o}\NormalTok{ math.o}
\end{Highlighting}
\end{Shaded}

  Each \texttt{.o} file contains \emph{machine code} and \emph{symbol
  tables} (lists of what it defines and what it needs).
\item
  \textbf{Linking} -- the linker (\texttt{ld}) merges all \texttt{.o}
  files and libraries into an executable:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o math.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

If any symbol is missing (like an undefined function), the linker fails.

\subsubsection{Step 2. What Are
Symbols?}\label{step-2.-what-are-symbols}

Symbols are names the compiler uses to track functions and global
variables. There are two kinds:

\begin{itemize}
\tightlist
\item
  \textbf{Defined symbols} -- functions or variables provided by this
  file.
\item
  \textbf{Undefined symbols} -- things it \emph{needs} from another
  file.
\end{itemize}

Example:

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and link:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ math.c}
\FunctionTok{gcc}\NormalTok{ main.o math.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
5
\end{verbatim}

If you forget to link \texttt{math.o}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

You'll get:

\begin{verbatim}
undefined reference to `add'
\end{verbatim}

\subsubsection{Step 3. Using Header Files for
Declarations}\label{step-3.-using-header-files-for-declarations}

Each \texttt{.c} file should declare (not define) external functions in
a header:

\textbf{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_H}
\PreprocessorTok{\#define MATH\_H}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Then include it in both \texttt{main.c} and \texttt{math.c}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}
\end{Highlighting}
\end{Shaded}

This ensures consistency between the declaration and definition.

\subsubsection{Step 4. Linking Object Files and
Libraries}\label{step-4.-linking-object-files-and-libraries}

You can link any number of \texttt{.o} files:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o math.o util.o io.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

You can also link with libraries:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}lm} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

(\texttt{-lm} links the math library that provides functions like
\texttt{sqrt}, \texttt{sin}, etc.)

The \texttt{-l} flag searches \texttt{/usr/lib} and \texttt{/lib} by
default.

Custom library example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}L.} \AttributeTok{{-}lmyutils} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Here, \texttt{-L.} adds the current directory to the library search
path, and \texttt{-lmyutils} links \texttt{libmyutils.a} or
\texttt{libmyutils.so}.

\subsubsection{Step 5. The Order of Linking
Matters}\label{step-5.-the-order-of-linking-matters}

The linker reads from \textbf{left to right}. If a symbol is used before
its definition appears, it might fail.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}lm}\NormalTok{ main.o }\AttributeTok{{-}o}\NormalTok{ app    }\CommentTok{\# ❌ wrong order}
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}lm} \AttributeTok{{-}o}\NormalTok{ app    }\CommentTok{\# ✅ correct}
\end{Highlighting}
\end{Shaded}

Always list libraries \textbf{after} the object files that need them.

\subsubsection{Step 6. Splitting and Linking a Multi-File
Project}\label{step-6.-splitting-and-linking-a-multi-file-project}

\begin{verbatim}
project/
├── main.c
├── math.c
├── io.c
├── math.h
├── io.h
└── Makefile
\end{verbatim}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ main.o math.o io.o}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Now, just run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

The Makefile takes care of compiling and linking everything in order.

\subsubsection{Tiny Code: Building a Small Modular
Program}\label{tiny-code-building-a-small-modular-program}

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_H}
\PreprocessorTok{\#define MATH\_H}
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"square(3) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ square}\OperatorTok{(}\DecValTok{3}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"cube(2) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cube}\OperatorTok{(}\DecValTok{2}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build manually:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ math.c }\AttributeTok{{-}o}\NormalTok{ math.o}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main.o}
\FunctionTok{gcc}\NormalTok{ main.o math.o }\AttributeTok{{-}o}\NormalTok{ app}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
square(3) = 9
cube(2) = 8
\end{verbatim}

\subsubsection{Step 7. Static vs Dynamic
Linking}\label{step-7.-static-vs-dynamic-linking}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & File & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Static & \texttt{.a} & Code is copied into the executable \\
Dynamic & \texttt{.so} & Code is shared at runtime via system
libraries \\
\end{longtable}

Static linking:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}L.} \AttributeTok{{-}lmath} \AttributeTok{{-}static} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Dynamic linking (default):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}L.} \AttributeTok{{-}lmath} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Dynamic executables are smaller and share libraries across programs.

\subsubsection{Step 8. Inspecting Linked
Binaries}\label{step-8.-inspecting-linked-binaries}

To see which symbols are defined or missing:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nm}\NormalTok{ main.o }\KeywordTok{|} \FunctionTok{head}
\end{Highlighting}
\end{Shaded}

Or for a full binary:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{objdump} \AttributeTok{{-}t}\NormalTok{ app }\KeywordTok{|} \FunctionTok{less}
\FunctionTok{ldd}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

\texttt{ldd} shows which shared libraries the program depends on.

\subsubsection{Step 9. Common Linking
Errors}\label{step-9.-common-linking-errors}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2895}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3421}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3684}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Error
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{undefined\ reference\ to\ \textless{}symbol\textgreater{}} &
Missing \texttt{.o} or library & Add all object files or correct
\texttt{-l} flags \\
\texttt{multiple\ definition\ of\ \textless{}symbol\textgreater{}} &
Same function defined in multiple files & Use \texttt{extern} in
declarations \\
\texttt{cannot\ find\ -lfoo} & Missing library file & Check \texttt{-L}
paths or install dev package \\
\texttt{relocation\ truncated} & Mismatched architectures & Ensure all
files are built for same target \\
\end{longtable}

\subsubsection{Step 10. Inline vs External
Linking}\label{step-10.-inline-vs-external-linking}

Inline functions defined as \texttt{static\ inline} in headers do
\emph{not} require linking, each \texttt{.c} file gets its own copy. But
normal functions in \texttt{.c} files must be linked exactly once.

\subsubsection{Why It Matters}\label{why-it-matters-53}

Linking is where your program becomes \emph{whole}. It teaches you:

\begin{itemize}
\tightlist
\item
  How \texttt{.o} and \texttt{.h} files interact
\item
  How libraries integrate with your binaries
\item
  How to debug missing symbols and multiple definitions
\item
  How modular design affects build architecture
\end{itemize}

Understanding the linker is essential for building scalable, multi-file
systems, from small utilities to entire kernels.

\subsubsection{Try It Yourself}\label{try-it-yourself-54}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a program with 3 \texttt{.c} files and 3 \texttt{.h} files.
\item
  Intentionally omit one object file and observe the linker error.
\item
  Use \texttt{nm} to inspect which functions each \texttt{.o} defines
  and references.
\item
  Build a static library (\texttt{ar\ rcs\ libutils.a\ util.o}) and link
  it manually.
\item
  Use \texttt{ldd} to list shared libraries your compiled program
  depends on.
\end{enumerate}

Next, you'll learn how to create and use \textbf{static and shared
libraries}, the modular building blocks that every serious C project
relies on for reusability and scalability.

\subsection{57. Static and Shared
Libraries}\label{static-and-shared-libraries}

In large C projects, you often want to \textbf{reuse code} across
multiple programs, without copying the same \texttt{.c} files
everywhere. That's exactly what \textbf{libraries} are for.

A \textbf{library} is a collection of precompiled object files
(\texttt{.o}) packaged together. There are two main kinds:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1842}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1184}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1974}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Extension
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Loaded
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical Use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Static Library & \texttt{.a} & At compile time & Simpler, self-contained
executables \\
Shared Library & \texttt{.so} & At runtime & Smaller binaries, reusable
system-wide \\
\end{longtable}

Let's see how to build and use both.

\subsubsection{\texorpdfstring{Step 1. Build a Static Library
(\texttt{.a})}{Step 1. Build a Static Library (.a)}}\label{step-1.-build-a-static-library-.a}

A static library is just an archive of object files.

Example project:

\begin{verbatim}
math.c
string_utils.c
main.c
\end{verbatim}

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{string\_utils.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ str\_eq}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ strcmp}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{string\_utils.h}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ str\_eq}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Compile the object files:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ math.c string\_utils.c}
\end{Highlighting}
\end{Shaded}

Create a static library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ar}\NormalTok{ rcs libmylib.a math.o string\_utils.o}
\end{Highlighting}
\end{Shaded}

Now you have \texttt{libmylib.a}, your first static library.

\subsubsection{Step 2. Link the Library}\label{step-2.-link-the-library}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}
\PreprocessorTok{\#include }\ImportTok{"string\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"3 + 4 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Equal? }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ str\_eq}\OperatorTok{(}\StringTok{"abc"}\OperatorTok{,} \StringTok{"abc"}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Link it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}lmylib} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
3 + 4 = 7
Equal? 1
\end{verbatim}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{-L.} tells the compiler to look in the current directory
\item
  \texttt{-lmylib} links against \texttt{libmylib.a}
\end{itemize}

The \texttt{.a} file is copied into your executable, you can now delete
it and your program will still run.

\subsubsection{Step 3. Inspect the Static
Library}\label{step-3.-inspect-the-static-library}

List its contents:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ar} \AttributeTok{{-}t}\NormalTok{ libmylib.a}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
math.o
string_utils.o
\end{verbatim}

Extract a file:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ar} \AttributeTok{{-}x}\NormalTok{ libmylib.a math.o}
\end{Highlighting}
\end{Shaded}

You can think of \texttt{.a} files like a ``.zip'' of \texttt{.o}
modules.

\subsubsection{\texorpdfstring{Step 4. Build a Shared Library
(\texttt{.so})}{Step 4. Build a Shared Library (.so)}}\label{step-4.-build-a-shared-library-.so}

A shared library is loaded dynamically at runtime, not compiled into the
executable. They're what you see in \texttt{/usr/lib} as \texttt{.so}
(Linux) or \texttt{.dll} (Windows).

Build one:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}fPIC} \AttributeTok{{-}c}\NormalTok{ math.c string\_utils.c}
\FunctionTok{gcc} \AttributeTok{{-}shared} \AttributeTok{{-}o}\NormalTok{ libmylib.so math.o string\_utils.o}
\end{Highlighting}
\end{Shaded}

Now you have a shared library:

\begin{verbatim}
libmylib.so
\end{verbatim}

\texttt{-fPIC} means ``position-independent code'', required for shared
libraries.

\subsubsection{Step 5. Link a Program Against
It}\label{step-5.-link-a-program-against-it}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}lmylib} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

If you get:

\begin{verbatim}
error while loading shared libraries: libmylib.so: cannot open shared object file
\end{verbatim}

You need to add the current directory to the runtime library path:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{export} \VariableTok{LD\_LIBRARY\_PATH}\OperatorTok{=}\NormalTok{.}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
3 + 4 = 7
Equal? 1
\end{verbatim}

\subsubsection{Step 6. Verify the Linking
Type}\label{step-6.-verify-the-linking-type}

Check whether your program is statically or dynamically linked:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ldd}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Output for dynamic linking:

\begin{verbatim}
libmylib.so => ./libmylib.so (0x00007f8e8b...)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (...)
\end{verbatim}

For static linking, \texttt{libmylib.a} won't appear, it's baked into
the executable.

\subsubsection{Step 7. Installing Libraries
System-Wide}\label{step-7.-installing-libraries-system-wide}

To make your library accessible globally:

Copy the \texttt{.so} file to \texttt{/usr/local/lib}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ cp libmylib.so /usr/local/lib}
\FunctionTok{sudo}\NormalTok{ ldconfig}
\end{Highlighting}
\end{Shaded}

Copy headers to \texttt{/usr/local/include}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ cp math.h string\_utils.h /usr/local/include}
\end{Highlighting}
\end{Shaded}

Now you can compile anywhere with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}lmylib} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Versioning Shared
Libraries}\label{step-8.-versioning-shared-libraries}

Real-world shared libraries include version numbers for compatibility:

\begin{verbatim}
libmylib.so.1.0.0
libmylib.so -> libmylib.so.1.0.0  (symlink)
\end{verbatim}

You can set this during build:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}shared} \AttributeTok{{-}Wl,{-}soname,libmylib.so.1} \AttributeTok{{-}o}\NormalTok{ libmylib.so.1.0.0 math.o string\_utils.o}
\FunctionTok{ln} \AttributeTok{{-}sf}\NormalTok{ libmylib.so.1.0.0 libmylib.so}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code: Combined
Example}\label{tiny-code-combined-example}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}fPIC}
\DataTypeTok{OBJS} \CharTok{=}\StringTok{ math.o string\_utils.o}
\DataTypeTok{TARGET\_STATIC} \CharTok{=}\StringTok{ libmylib.a}
\DataTypeTok{TARGET\_SHARED} \CharTok{=}\StringTok{ libmylib.so}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET\_STATIC}\CharTok{)}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET\_SHARED}\CharTok{)}

\DecValTok{$(TARGET\_STATIC):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
\ErrorTok{    }\NormalTok{ar rcs }\CharTok{$@} \CharTok{$\^{}}

\DecValTok{$(TARGET\_SHARED):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)}\NormalTok{ {-}shared {-}o }\CharTok{$@} \CharTok{$\^{}}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET\_STATIC}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET\_SHARED}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Build:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Link app:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}lmylib} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\VariableTok{LD\_LIBRARY\_PATH}\OperatorTok{=}\NormalTok{. }\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Static vs Shared
Tradeoffs}\label{step-9.-static-vs-shared-tradeoffs}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Static (\texttt{.a}) & Shared (\texttt{.so}) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Linking & At compile time & At runtime \\
File size & Larger executable & Smaller executable \\
Update & Recompile required & Replace \texttt{.so} file \\
Portability & Fully self-contained & Needs library present \\
Speed & Slightly faster & Slight load delay \\
\end{longtable}

For small tools or embedded systems, use static. For large or updatable
software, prefer shared.

\subsubsection{Step 10. Inspecting Library
Symbols}\label{step-10.-inspecting-library-symbols}

To see what functions are exported:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nm} \AttributeTok{{-}D}\NormalTok{ libmylib.so }\KeywordTok{|} \FunctionTok{grep}\NormalTok{ add}
\end{Highlighting}
\end{Shaded}

To check dynamic symbol resolution:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{objdump} \AttributeTok{{-}T}\NormalTok{ libmylib.so }\KeywordTok{|} \FunctionTok{head}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-54}

Libraries make your C code modular, maintainable, and reusable. They are
the foundation of every serious C ecosystem, from \texttt{libc} to
OpenSSL to SDL.

Once you understand how to build and link your own \texttt{.a} and
\texttt{.so} files, you can:

\begin{itemize}
\tightlist
\item
  Ship APIs others can use
\item
  Organize large codebases cleanly
\item
  Understand how system libraries integrate into every program you
  compile
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-55}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a small math library (\texttt{libmathx.a},
  \texttt{libmathx.so}).
\item
  Create a header-only helper and test it in multiple programs.
\item
  Try mixing static and shared libraries in one build.
\item
  Inspect your shared library with \texttt{ldd} and \texttt{nm}.
\item
  Version your \texttt{.so} file using symbolic links and test
  compatibility.
\end{enumerate}

Next, you'll explore how \textbf{compiler flags and optimization levels}
affect performance, safety, and debugging, learning how to tune
\texttt{gcc} for both development and release builds.

\subsection{58. Compiler Flags and Optimization
Levels}\label{compiler-flags-and-optimization-levels}

Once your program compiles and links correctly, the next step is
mastering \textbf{compiler flags}, the switches that control warnings,
debugging info, optimization, and performance.

Using the right flags can make your C code \textbf{safer},
\textbf{faster}, and \textbf{easier to debug}.

Let's go through the essential \texttt{gcc} and \texttt{clang} options
every C developer should know.

\subsubsection{Step 1. The Basic Compilation
Command}\label{step-1.-the-basic-compilation-command}

The most common compile command looks like:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

This compiles \texttt{main.c} into an executable called \texttt{main}
using \textbf{default settings}, minimal warnings, no optimization, and
no debug info.

For serious development, you'll want more control.

\subsubsection{Step 2. Warning Flags}\label{step-2.-warning-flags}

Warnings are the compiler's early-warning system. They catch mistakes
before they become bugs.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-Wall} & Enable most common warnings \\
\texttt{-Wextra} & Enable additional, stricter warnings \\
\texttt{-Werror} & Treat warnings as errors \\
\texttt{-Wpedantic} & Enforce strict ISO C compliance \\
\texttt{-Wshadow} & Warn if a local variable hides another variable \\
\texttt{-Wconversion} & Warn about implicit type conversions \\
\texttt{-Wunused} & Warn about unused variables or functions \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}Werror}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

If your code has:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You'll get:

\begin{verbatim}
warning: 'x' is used uninitialized
\end{verbatim}

With \texttt{-Werror}, that warning becomes a build-stopping error, a
good habit for clean codebases.

\subsubsection{Step 3. Debugging Flags}\label{step-3.-debugging-flags}

Debugging information allows tools like \texttt{gdb} or \texttt{lldb} to
map machine code back to your C source.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-g} & Include debug symbols (file names, line numbers) \\
\texttt{-ggdb} & Include GNU-specific symbols for gdb \\
\texttt{-O0} & Disable optimization (makes debugging easier) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g} \AttributeTok{{-}O0}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

Now run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./main}
\end{Highlighting}
\end{Shaded}

You'll be able to inspect variables and step through source lines.

\subsubsection{Step 4. Optimization
Levels}\label{step-4.-optimization-levels}

Optimization tells the compiler how aggressively to transform your code
for speed or size.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-O0} & No optimization (fast compile, easy to debug) \\
\texttt{-O1} & Basic optimization \\
\texttt{-O2} & General speed optimization (default for most builds) \\
\texttt{-O3} & Aggressive optimization (may increase size) \\
\texttt{-Os} & Optimize for size \\
\texttt{-Ofast} & Ignore strict standards for speed (dangerous) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}O2}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

Compare sizes:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}O0}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ slow}
\FunctionTok{gcc} \AttributeTok{{-}O2}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ fast}
\FunctionTok{ls} \AttributeTok{{-}lh}\NormalTok{ slow fast}
\end{Highlighting}
\end{Shaded}

\texttt{fast} will be smaller and run faster, the compiler reorders
code, inlines functions, and removes dead logic.

\subsubsection{Step 5. Profiling and Instrumentation
Flags}\label{step-5.-profiling-and-instrumentation-flags}

Profiling helps measure which parts of your program consume the most CPU
time.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4810}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5190}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Flag
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-pg} & Generate profiling data for \texttt{gprof} \\
\texttt{-fprofile-generate} / \texttt{-fprofile-use} & Use
profile-guided optimization (PGO) \\
\texttt{-ftime-report} & Show how long each compilation phase took \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\ExtensionTok{./main}
\ExtensionTok{gprof}\NormalTok{ main gmon.out }\OperatorTok{\textgreater{}}\NormalTok{ report.txt}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Standards Compliance
Flags}\label{step-6.-standards-compliance-flags}

The C language evolves, you can specify which version to follow.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-std=c89} & ANSI C (1989) \\
\texttt{-std=c99} & Modern C with \texttt{inline}, \texttt{bool},
\texttt{//\ comments} \\
\texttt{-std=c11} & Adds \texttt{\_Generic}, \texttt{\_Thread\_local},
safer atomics \\
\texttt{-std=c17} & Minor cleanup \\
\texttt{-std=c23} & Latest (adds \texttt{typeof}, safer macros, etc.) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c99 }\AttributeTok{{-}Wall}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

Always choose a consistent standard for your project.

\subsubsection{Step 7. Platform and Architecture
Flags}\label{step-7.-platform-and-architecture-flags}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7917}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Flag
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-m32} / \texttt{-m64} & Compile for 32-bit or 64-bit
architecture \\
\texttt{-march=native} & Optimize for the host CPU \\
\texttt{-fPIC} & Position-independent code (required for shared
libraries) \\
\texttt{-static} & Fully static linking \\
\texttt{-DNAME=value} & Define a macro (same as \texttt{\#define} in
code) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}DDEBUG}\OperatorTok{=}\NormalTok{1 }\AttributeTok{{-}O2} \AttributeTok{{-}m64}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Linking Flags}\label{step-8.-linking-flags}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-L\textless{}dir\textgreater{}} & Add library search path \\
\texttt{-l\textless{}name\textgreater{}} & Link with library (e.g.,
\texttt{-lm} for math) \\
\texttt{-static} & Force static linking \\
\texttt{-shared} & Build a shared library \\
\texttt{-rpath\ \textless{}dir\textgreater{}} & Add runtime library
search path \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o }\AttributeTok{{-}L.} \AttributeTok{{-}lmylib} \AttributeTok{{-}Wl,{-}rpath}\OperatorTok{=}\NormalTok{. }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

\texttt{-Wl,} passes options directly to the linker (\texttt{ld}).

\subsubsection{Tiny Code: Debug and Release
Builds}\label{tiny-code-debug-and-release-builds}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{DEBUG\_FLAGS} \CharTok{=}\StringTok{ {-}g {-}O0 {-}DDEBUG}
\DataTypeTok{RELEASE\_FLAGS} \CharTok{=}\StringTok{ {-}O2 {-}DNDEBUG}
\DataTypeTok{SRC} \CharTok{=}\StringTok{ main.c util.c}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{SRC}\KeywordTok{:}\SpecialStringTok{.c}\KeywordTok{=}\SpecialStringTok{.o}\CharTok{)}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{debug:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{DEBUG\_FLAGS}\CharTok{)}
\DecValTok{debug:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{release:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{RELEASE\_FLAGS}\CharTok{)}
\DecValTok{release:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ debug}
\FunctionTok{make}\NormalTok{ release}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Debug build: full symbols, no optimization.
\item
  Release build: optimized, no debugging info.
\end{itemize}

\subsubsection{Step 9. Sanitizers (Runtime Safety
Tools)}\label{step-9.-sanitizers-runtime-safety-tools}

Modern compilers include built-in \textbf{sanitizers} to detect memory
and thread errors:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Flag & Detects \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-fsanitize=address} & Memory leaks, buffer overflows \\
\texttt{-fsanitize=undefined} & Undefined behavior \\
\texttt{-fsanitize=thread} & Data races in multithreaded code \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{address main.c }\AttributeTok{{-}o}\NormalTok{ main}
\ExtensionTok{./main}
\end{Highlighting}
\end{Shaded}

If your code writes past an array boundary, you'll get an instant,
readable report, no guessing.

\subsubsection{Step 10. Combining Flags}\label{step-10.-combining-flags}

Typical \textbf{development build:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}Werror} \AttributeTok{{-}g} \AttributeTok{{-}O0} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c99 main.c }\AttributeTok{{-}o}\NormalTok{ debug\_app}
\end{Highlighting}
\end{Shaded}

Typical \textbf{release build:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}O2} \AttributeTok{{-}march}\OperatorTok{=}\NormalTok{native }\AttributeTok{{-}flto} \AttributeTok{{-}DNDEBUG}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ fast\_app}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{-flto} enables \textbf{link-time optimization} (LTO),
  optimizing across files.
\item
  \texttt{-DNDEBUG} disables \texttt{assert()} calls.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-55}

Compiler flags are how professionals control:

\begin{itemize}
\tightlist
\item
  \textbf{Safety} (warnings, sanitizers)
\item
  \textbf{Performance} (optimization levels)
\item
  \textbf{Debuggability} (symbols and checks)
\item
  \textbf{Portability} (standards and architectures)
\end{itemize}

Mastering them gives you precise control over how your code behaves,
builds, and performs, essential for reliable systems programming.

\subsubsection{Try It Yourself}\label{try-it-yourself-56}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compile the same program with \texttt{-O0}, \texttt{-O2}, and
  \texttt{-O3}, time each run.
\item
  Add \texttt{-fsanitize=address} and find hidden memory bugs.
\item
  Compare binary sizes between \texttt{-g} and \texttt{-s}.
\item
  Add \texttt{-Wall\ -Wextra\ -Werror} to your Makefile and fix every
  warning.
\item
  Explore \texttt{gcc\ -\/-help=optimizers} to see all available
  optimization passes.
\end{enumerate}

Next, you'll peek \textbf{inside the object file itself}, learning
what's stored inside \texttt{.o} binaries and how the linker stitches
them together to form a complete executable.

\subsection{59. Understanding the Object
File}\label{understanding-the-object-file}

By now, you've seen \texttt{.o} files appear in every build step, the
intermediate products between source and executable. But what exactly is
\emph{inside} them?

Object files are the compiler's way of packaging machine code, symbol
tables, and metadata, ready for the linker to assemble into a final
program. Understanding object files helps you debug linking errors,
inspect performance, and even reverse-engineer compiled code.

\subsubsection{Step 1. The Lifecycle
Recap}\label{step-1.-the-lifecycle-recap}

The compilation pipeline looks like this:

\begin{verbatim}
source.c ──> preprocessor ──> compiler ──> assembler ──> linker
     |                           |             |          |
     |                        hello.s        hello.o     a.out
\end{verbatim}

Your \texttt{.c} file becomes a \texttt{.o} file after
\textbf{assembly}, but before \textbf{linking}.

Each \texttt{.o} is self-contained, it knows what it defines, what it
needs, and where its code lives in memory.

\subsubsection{Step 2. Object File
Formats}\label{step-2.-object-file-formats}

Different operating systems use different binary formats:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1061}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5455}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3485}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
OS
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Format
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical Extension
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Linux & ELF (Executable and Linkable Format) & \texttt{.o},
\texttt{.so}, executable \\
macOS & Mach-O & \texttt{.o}, \texttt{.dylib} \\
Windows & COFF/PE & \texttt{.obj}, \texttt{.dll}, \texttt{.exe} \\
\end{longtable}

On Linux, ELF dominates, so we'll use it as our reference.

\subsubsection{Step 3. Sections Inside an Object
File}\label{step-3.-sections-inside-an-object-file}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main.o}
\ExtensionTok{readelf} \AttributeTok{{-}S}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

You'll see output like:

\begin{verbatim}
[ 1] .text     PROGBITS  code and functions
[ 2] .data     PROGBITS  initialized global variables
[ 3] .bss      NOBITS    uninitialized globals
[ 4] .rodata   PROGBITS  constants (e.g., string literals)
[ 5] .symtab   SYMTAB    symbol table
[ 6] .strtab   STRTAB    string table
[ 7] .rel.text RELA      relocation info
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Section & Contents \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{.text} & Compiled machine code (functions) \\
\texttt{.data} & Global variables with initial values \\
\texttt{.bss} & Global variables without initial values \\
\texttt{.rodata} & Constants, \texttt{const} variables, string
literals \\
\texttt{.symtab} & Symbol table: function and variable metadata \\
\texttt{.rel*} & Relocation info, how to connect this file to others \\
\end{longtable}

\subsubsection{Step 4. Inspecting
Symbols}\label{step-4.-inspecting-symbols}

Every \texttt{.o} file contains \textbf{symbols} that describe its
functions and variables. List them:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nm}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
0000000000000000 T main
                 U printf
\end{verbatim}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Symbol & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{T} & Defined in the text (code) section \\
\texttt{U} & Undefined, must be provided by another file or library \\
\texttt{D} & Defined in data section \\
\texttt{B} & Defined in bss section \\
\texttt{R} & Defined in read-only data \\
\texttt{W} & Weak symbol (can be overridden) \\
\end{longtable}

Here, \texttt{main} is defined, \texttt{printf} is undefined, meaning
the linker must find it in the C standard library.

\subsubsection{Tiny Code: Inspecting a Multi-File
Example}\label{tiny-code-inspecting-a-multi-file-example}

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{)} \OperatorTok{*}\NormalTok{ mul}\OperatorTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile but don't link:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ math.c}
\end{Highlighting}
\end{Shaded}

Inspect:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nm}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
U add
U mul
U printf
T main
\end{verbatim}

\texttt{U} means \emph{undefined}, the linker must resolve these.

Now inspect \texttt{math.o}:

\begin{verbatim}
T add
T mul
\end{verbatim}

These are \emph{definitions} that will satisfy the linker.

Link and inspect the result:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.o math.o }\AttributeTok{{-}o}\NormalTok{ app}
\FunctionTok{nm}\NormalTok{ app }\KeywordTok{|} \FunctionTok{grep}\NormalTok{ add}
\end{Highlighting}
\end{Shaded}

Now you'll see:

\begin{verbatim}
0000000000401136 T add
\end{verbatim}

The linker relocated \texttt{add()} into its final address.

\subsubsection{Step 5. Symbol
Visibility}\label{step-5.-symbol-visibility}

By default, every function and global variable has \textbf{external
linkage}, visible to the linker.

Use \texttt{static} to limit visibility to the current file:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ hidden\_func}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return} \DecValTok{42}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{nm} will not list it as an exported symbol. This keeps your
binary clean and prevents name collisions across files.

\subsubsection{Step 6. Inspecting
Relocations}\label{step-6.-inspecting-relocations}

Object files can't know final addresses yet, so they store
\textbf{relocation entries}: placeholders for addresses that the linker
must fill later.

Check them:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{readelf} \AttributeTok{{-}r}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Relocation section '.rela.text':
0000000000000010 R_X86_64_PC32 printf-0x4
\end{verbatim}

This tells the linker:

\begin{quote}
``When linking, replace this placeholder with the address of
\texttt{printf()}.''
\end{quote}

\subsubsection{Step 7. Disassemble the
Code}\label{step-7.-disassemble-the-code}

You can see the actual machine instructions:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{objdump} \AttributeTok{{-}d}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

Output snippet:

\begin{verbatim}
0000000000000000 <main>:
   0: 55                    push   %rbp
   1: 48 89 e5              mov    %rsp,%rbp
   4: b8 00 00 00 00        mov    $0x0,%eax
\end{verbatim}

Each instruction corresponds to compiled C code. This is how you verify
optimizations, inspect inlining, or study generated assembly.

\subsubsection{Step 8. Mixing Object
Files}\label{step-8.-mixing-object-files}

Because \texttt{.o} files contain clear symbol metadata, you can mix
object files from different languages, for example, C and assembly.

\textbf{sum.s}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.globl sum}
\FunctionTok{sum:}
\NormalTok{    addq }\OperatorTok{\%}\KeywordTok{rsi}\OperatorTok{,} \OperatorTok{\%}\KeywordTok{rdi}
    \BuiltInTok{movq} \OperatorTok{\%}\KeywordTok{rdi}\OperatorTok{,} \OperatorTok{\%}\KeywordTok{rax}
    \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

Compile and link:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{as}\NormalTok{ sum.s }\AttributeTok{{-}o}\NormalTok{ sum.o}
\FunctionTok{gcc}\NormalTok{ main.c sum.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

This is how C integrates cleanly with low-level code.

\subsubsection{Step 9. Object File Size and
Contents}\label{step-9.-object-file-size-and-contents}

Check file size:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{size}\NormalTok{ main.o}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
text    data     bss     dec     hex filename
45      4        0       49      31  main.o
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{text} → code size
\item
  \texttt{data} → initialized global variables
\item
  \texttt{bss} → uninitialized variables
\end{itemize}

\subsubsection{Step 10. Tiny Code: Investigate
Everything}\label{step-10.-tiny-code-investigate-everything}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello.o}
\ExtensionTok{readelf} \AttributeTok{{-}h}\NormalTok{ hello.o          }\CommentTok{\# ELF header}
\ExtensionTok{readelf} \AttributeTok{{-}S}\NormalTok{ hello.o          }\CommentTok{\# Sections}
\ExtensionTok{readelf} \AttributeTok{{-}s}\NormalTok{ hello.o }\KeywordTok{|} \FunctionTok{head}   \CommentTok{\# Symbol table}
\ExtensionTok{readelf} \AttributeTok{{-}r}\NormalTok{ hello.o          }\CommentTok{\# Relocations}
\ExtensionTok{objdump} \AttributeTok{{-}d}\NormalTok{ hello.o }\KeywordTok{|} \FunctionTok{head}   \CommentTok{\# Disassembly}
\end{Highlighting}
\end{Shaded}

You'll get a complete low-level view of how your C code looks to the
compiler.

\subsubsection{Why It Matters}\label{why-it-matters-56}

Understanding object files helps you:

\begin{itemize}
\tightlist
\item
  Debug linking errors and symbol conflicts
\item
  Inspect compiler optimizations
\item
  Integrate C with assembly
\item
  Build static and shared libraries manually
\item
  See what's actually inside the binary
\end{itemize}

In systems programming, this insight separates code \emph{users} from
code \emph{engineers}.

\subsubsection{Try It Yourself}\label{try-it-yourself-57}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create two \texttt{.o} files that depend on each other and inspect
  their undefined symbols.
\item
  Use \texttt{readelf\ -S} to compare \texttt{.text}, \texttt{.data},
  and \texttt{.bss} for different programs.
\item
  Add a global variable and see how it appears in \texttt{.data} or
  \texttt{.bss}.
\item
  Mark a function as \texttt{static} and confirm it disappears from
  \texttt{nm} output.
\item
  Compile with \texttt{-O2} and observe changes in disassembly with
  \texttt{objdump\ -d}.
\end{enumerate}

Next, you'll complete Chapter 6 by building your own
\textbf{Makefile-based compilation pipeline} from scratch, writing every
stage explicitly to transform \texttt{.c} files into \texttt{.o},
\texttt{.a}, and \texttt{.so} artifacts just like a real compiler
toolchain.

\subsection{60. Practice: Write Your Own
Makefile}\label{practice-write-your-own-makefile}

Now that you understand how the C build process works, preprocessing,
compiling, linking, and libraries, it's time to \textbf{tie everything
together} with your own \textbf{Makefile}.

\texttt{make} is one of the oldest and most powerful automation tools in
C development. It watches file timestamps, builds only what has changed,
and lets you define build rules in a concise way.

By writing your own Makefile, you'll automate your entire compilation
workflow like a professional.

\subsubsection{Step 1. Create the
Project}\label{step-1.-create-the-project}

Let's build a small multi-file project:

\begin{verbatim}
project/
├── Makefile
├── main.c
├── math.c
├── math.h
└── string_utils.c
\end{verbatim}

\textbf{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"2 + 3 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"2 * 3 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ mul}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_H}
\PreprocessorTok{\#define MATH\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ mul}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 2. Write the Simplest
Makefile}\label{step-2.-write-the-simplest-makefile}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{main:}\DataTypeTok{ main.c math.c}
\ErrorTok{    }\NormalTok{gcc main.c math.c {-}o main}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./main}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
2 + 3 = 5
2 * 3 = 6
\end{verbatim}

This works, but \texttt{make} will rebuild everything every time, even
if only one file changed.

Let's make it smarter.

\subsubsection{Step 3. Split the Compilation
Steps}\label{step-3.-split-the-compilation-steps}

Separate compilation into object files:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}

\DecValTok{main:}\DataTypeTok{ main.o math.o}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ main.o math.o {-}o main}

\DecValTok{main.o:}\DataTypeTok{ main.c math.h}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c main.c}

\DecValTok{math.o:}\DataTypeTok{ math.c math.h}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c math.c}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f *.o main}
\end{Highlighting}
\end{Shaded}

Now when you run \texttt{make}, it builds \texttt{.o} files only once,
and recompiles only what changed.

Test it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\FunctionTok{touch}\NormalTok{ math.c}
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

You'll see that only \texttt{math.o} is rebuilt.

\subsubsection{Step 4. Add Automatic Dependency
Handling}\label{step-4.-add-automatic-dependency-handling}

Use \textbf{pattern rules} to avoid repeating commands for every
\texttt{.c} file:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{OBJS} \CharTok{=}\StringTok{ main.o math.o string\_utils.o}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{\$\textless{}} means ``the first dependency'' (like
\texttt{main.c}). \texttt{\$@} means ``the target'' (like
\texttt{main.o}).

Now the Makefile works for any \texttt{.c} file automatically.

\subsubsection{Step 5. Add Debug and Release
Targets}\label{step-5.-add-debug-and-release-targets}

Real projects have multiple build modes:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}std=c99}
\DataTypeTok{DEBUG\_FLAGS} \CharTok{=}\StringTok{ {-}g {-}O0 {-}DDEBUG}
\DataTypeTok{RELEASE\_FLAGS} \CharTok{=}\StringTok{ {-}O2 {-}DNDEBUG}
\DataTypeTok{OBJS} \CharTok{=}\StringTok{ main.o math.o}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\OtherTok{.PHONY:}\DataTypeTok{ all clean debug release}

\DecValTok{all:}\DataTypeTok{ release}

\DecValTok{debug:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{DEBUG\_FLAGS}\CharTok{)}
\DecValTok{debug:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{release:}\DataTypeTok{ CFLAGS} \CharTok{+=}\StringTok{ }\CharTok{$(}\DataTypeTok{RELEASE\_FLAGS}\CharTok{)}
\DecValTok{release:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJS}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJS}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ debug}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

Then:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ clean}
\FunctionTok{make}\NormalTok{ release}
\end{Highlighting}
\end{Shaded}

The debug build has symbols for \texttt{gdb}; the release build is
optimized.

\subsubsection{Step 6. Add Static and Shared Library
Targets}\label{step-6.-add-static-and-shared-library-targets}

Add these to your Makefile:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{libmylib.a:}\DataTypeTok{ math.o}
\ErrorTok{    }\NormalTok{ar rcs libmylib.a math.o}

\DecValTok{libmylib.so:}\DataTypeTok{ math.o}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)}\NormalTok{ {-}shared {-}o libmylib.so math.o}
\end{Highlighting}
\end{Shaded}

Now you can build a reusable library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ libmylib.a}
\FunctionTok{make}\NormalTok{ libmylib.so}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Add Installation and
Help}\label{step-7.-add-installation-and-help}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{install:}
\ErrorTok{    }\NormalTok{cp app /usr/local/bin/}

\DecValTok{help:}
\ErrorTok{    }\CharTok{@}\FunctionTok{echo }\StringTok{"make [target]"}
    \CharTok{@}\FunctionTok{echo }\StringTok{"Targets: all, debug, release, clean, install, libmylib.a, libmylib.so"}
\end{Highlighting}
\end{Shaded}

The \texttt{@} suppresses command echoing, only prints your messages.

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ help}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Use Variables for Paths and
Options}\label{step-8.-use-variables-for-paths-and-options}

Clean up your Makefile by grouping related flags:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{SRC} \CharTok{=}\StringTok{ }\CharTok{$(}\KeywordTok{wildcard}\StringTok{ *.c}\CharTok{)}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{SRC}\KeywordTok{:}\SpecialStringTok{.c}\KeywordTok{=}\SpecialStringTok{.o}\CharTok{)}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}Wextra {-}std=c99}
\DataTypeTok{LDFLAGS} \CharTok{=}\StringTok{ {-}lm}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)} \CharTok{$(}\DataTypeTok{LDFLAGS}\CharTok{)}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{wildcard} and \texttt{patsubst} let you automatically include
new \texttt{.c} files as the project grows.

\subsubsection{Tiny Code: Final Polished
Makefile}\label{tiny-code-final-polished-makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}Wall {-}Wextra {-}std=c99 {-}O2}
\DataTypeTok{LDFLAGS} \CharTok{=}\StringTok{ {-}lm}
\DataTypeTok{SRC} \CharTok{=}\StringTok{ }\CharTok{$(}\KeywordTok{wildcard}\StringTok{ *.c}\CharTok{)}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{SRC}\KeywordTok{:}\SpecialStringTok{.c}\KeywordTok{=}\SpecialStringTok{.o}\CharTok{)}
\DataTypeTok{TARGET} \CharTok{=}\StringTok{ app}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{$(TARGET):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}\NormalTok{ {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)} \CharTok{$(}\DataTypeTok{LDFLAGS}\CharTok{)}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

This pattern is simple, robust, and scalable, the foundation of nearly
all C build systems.

\subsubsection{Step 9. Makefile
Debugging}\label{step-9.-makefile-debugging}

To see what commands \texttt{make} is running:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ VERBOSE=1}
\end{Highlighting}
\end{Shaded}

Or trace variable expansions:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make} \AttributeTok{{-}p}
\end{Highlighting}
\end{Shaded}

Add \texttt{@echo\ "Building\ \$@"} before commands for clarity.

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters}

A well-crafted Makefile:

\begin{itemize}
\tightlist
\item
  Automates your entire C build workflow
\item
  Avoids recompiling unchanged files
\item
  Scales to large multi-directory projects
\item
  Makes your builds reproducible across systems
\end{itemize}

It's your first step toward professional build systems like
\textbf{CMake}, \textbf{Meson}, or \textbf{Bazel}, all of which build on
these principles.

\subsubsection{Try It Yourself}\label{try-it-yourself-58}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a new \texttt{.c} file and watch your Makefile compile it
  automatically.
\item
  Add a \texttt{test} target that compiles and runs unit tests.
\item
  Add colorized output using \texttt{tput} or ANSI escapes.
\item
  Build both static and shared libraries in one run.
\item
  Convert your Makefile to use multiple directories (\texttt{src/},
  \texttt{include/}, \texttt{build/}).
\end{enumerate}

\textbf{Congratulations!} You've completed \textbf{Chapter 6 --
Compilation and the Build Process}. You now understand how source
becomes an executable, every stage from preprocessor to linker, and
every tool in between.

Next, we'll step deeper into \textbf{Chapter 7: Working Close to the
System}, where your programs start interacting directly with the
operating system through system calls, processes, and files.

\bookmarksetup{startatroot}

\chapter{Chapter 7. Working Close to the
System}\label{chapter-7.-working-close-to-the-system}

\subsection{61. System Calls and the Standard
Library}\label{system-calls-and-the-standard-library}

When you write C programs that touch files, processes, or devices,
you're talking to the \textbf{operating system}, not directly to
hardware. That communication happens through \textbf{system calls}.

System calls are the lowest-level interface between user-space programs
and the OS kernel. C's \textbf{standard library (libc)} is a thin layer
of wrappers built on top of those calls, making them easier to use and
more portable.

Let's explore how this works, and how to use system calls directly from
your C code.

\subsubsection{Step 1. What Is a System
Call?}\label{step-1.-what-is-a-system-call}

A \textbf{system call} (syscall) lets a program request a service from
the OS kernel, like reading a file, creating a process, or allocating
memory.

Examples:

\begin{itemize}
\tightlist
\item
  \texttt{read()}, \texttt{write()} -- access files and devices
\item
  \texttt{fork()}, \texttt{exec()} -- create and manage processes
\item
  \texttt{open()}, \texttt{close()} -- handle file descriptors
\item
  \texttt{mmap()} -- map files into memory
\item
  \texttt{socket()} -- network communication
\end{itemize}

When you call a system function, control passes from \textbf{user space}
to \textbf{kernel space}, then back again.

\subsubsection{Step 2. The Role of libc}\label{step-2.-the-role-of-libc}

The C standard library (glibc, musl, etc.) provides \emph{wrappers}
around these system calls.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"test.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"fopen failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Under the hood, \texttt{fopen()} eventually calls \texttt{open()}, a
system call defined in \texttt{\textless{}fcntl.h\textgreater{}}. You
can call it directly too.

\subsubsection{Step 3. Calling System Calls
Directly}\label{step-3.-calling-system-calls-directly}

Here's the same operation without stdio helpers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}\PreprocessorTok{     }\CommentTok{// open}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}\PreprocessorTok{    }\CommentTok{// read, write, close}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}\PreprocessorTok{     }\CommentTok{// perror}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"test.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"open failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{128}\OperatorTok{];}
    \DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        buf}\OperatorTok{[}\NormalTok{n}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{        write}\OperatorTok{(}\NormalTok{STDOUT\_FILENO}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ sysread.c }\AttributeTok{{-}o}\NormalTok{ sysread}
\ExtensionTok{./sysread}
\end{Highlighting}
\end{Shaded}

This prints the first 128 bytes of \texttt{test.txt} directly using
system calls, no \texttt{fopen()} or \texttt{printf()} involved.

\subsubsection{Tiny Code: Minimal System Call
Example}\label{tiny-code-minimal-system-call-example}

Let's drop even the C library and use a \textbf{raw syscall} interface.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello via system call}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{;}
\NormalTok{    write}\OperatorTok{(}\DecValTok{1}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{msg}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}  \CommentTok{// 1 = STDOUT}
\NormalTok{    \_exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}nostdlib} \AttributeTok{{-}static}\NormalTok{ syshello.c }\AttributeTok{{-}o}\NormalTok{ syshello}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
Hello via system call
\end{verbatim}

You just executed a system call directly, bypassing the standard library
entirely.

\subsubsection{Step 4. File Descriptors}\label{step-4.-file-descriptors}

System calls like \texttt{read()} and \texttt{write()} work with
\textbf{file descriptors}, small integer handles managed by the OS.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Descriptor & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & Standard input (\texttt{stdin}) \\
1 & Standard output (\texttt{stdout}) \\
2 & Standard error (\texttt{stderr}) \\
\end{longtable}

Every open file, socket, or pipe has a unique descriptor.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write}\OperatorTok{(}\DecValTok{1}\OperatorTok{,} \StringTok{"Output to stdout}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{17}\OperatorTok{);}
\NormalTok{write}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \StringTok{"Output to stderr}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{17}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Inspecting System
Calls}\label{step-5.-inspecting-system-calls}

You can watch your program's system calls using \texttt{strace}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{strace}\NormalTok{ ./sysread}
\end{Highlighting}
\end{Shaded}

Example output:

\begin{verbatim}
open("test.txt", O_RDONLY) = 3
read(3, "Hello World\n", 12) = 12
write(1, "Hello World\n", 12) = 12
close(3) = 0
\end{verbatim}

This shows the real kernel-level operations, a great debugging and
learning tool.

\subsubsection{Step 6. Return Values and
Errors}\label{step-6.-return-values-and-errors}

System calls usually return:

\begin{itemize}
\tightlist
\item
  \textbf{≥ 0} → success (bytes read, process ID, etc.)
\item
  \textbf{-1} → error (with \texttt{errno} set to an error code)
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"missing.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Common error codes:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Code & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ENOENT} & File not found \\
\texttt{EACCES} & Permission denied \\
\texttt{EBADF} & Invalid descriptor \\
\texttt{EINTR} & Interrupted system call \\
\end{longtable}

\subsubsection{Step 7. Mixing System Calls and
stdio}\label{step-7.-mixing-system-calls-and-stdio}

You can combine both layers safely, just don't mix them on the
\emph{same} file descriptor.

Example (safe):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
\NormalTok{write}\OperatorTok{(}\NormalTok{STDOUT\_FILENO}\OperatorTok{,} \StringTok{"Console log}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{12}\OperatorTok{);}
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \StringTok{"File log}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example (unsafe):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
\NormalTok{write}\OperatorTok{(}\NormalTok{fileno}\OperatorTok{(}\NormalTok{f}\OperatorTok{),} \StringTok{"mixed output}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{13}\OperatorTok{);}  \CommentTok{// may confuse buffering}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. System Call
Wrappers}\label{step-8.-system-call-wrappers}

The Linux kernel provides hundreds of system calls. You can call most
through \texttt{\textless{}unistd.h\textgreater{}}, but for rare ones,
you can use \texttt{syscall()}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/syscall.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    syscall}\OperatorTok{(}\NormalTok{SYS\_write}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \StringTok{"Hello syscall}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{14}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Viewing Available
Syscalls}\label{step-9.-viewing-available-syscalls}

Check all available system calls for your platform:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{man}\NormalTok{ 2 intro}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{ausyscall} \AttributeTok{{-}{-}dump} \KeywordTok{|} \FunctionTok{head}
\end{Highlighting}
\end{Shaded}

You'll see a list like:

\begin{verbatim}
read, write, open, close, stat, fork, execve, mmap, ...
\end{verbatim}

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-1}

System calls are the \emph{foundation} of everything in C and Unix-like
systems.

They give your program direct access to:

\begin{itemize}
\tightlist
\item
  Files and devices
\item
  Processes and signals
\item
  Memory and networking
\item
  Time and environment
\end{itemize}

Learning to use them directly is essential for understanding how
higher-level abstractions (like \texttt{stdio}, \texttt{pthreads}, or
sockets) are built.

\subsubsection{Try It Yourself}\label{try-it-yourself-59}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use \texttt{strace} on \texttt{ls} or \texttt{cat} to see how system
  calls drive them.
\item
  Replace a \texttt{fopen()}/\texttt{fread()} pair with direct
  \texttt{open()} and \texttt{read()} calls.
\item
  Write a tiny file copier using only \texttt{open}, \texttt{read},
  \texttt{write}, and \texttt{close}.
\item
  Experiment with invalid file descriptors and print out \texttt{errno}.
\item
  Build a version of \texttt{echo} that uses only raw system calls.
\end{enumerate}

Next, you'll take this a step further: learning how to \textbf{create
and manage processes} with \texttt{fork()} and \texttt{exec()}, the
heart of Unix multitasking.

\subsection{62. Process Creation (fork, exec,
wait)}\label{process-creation-fork-exec-wait}

Every program in a Unix-like system runs inside a \textbf{process}, a
running instance of a program with its own memory, file descriptors, and
environment. When you type \texttt{ls} or \texttt{cat}, the shell
doesn't just ``jump'' into those programs. It \textbf{creates a new
process} to run them.

In C, you can do exactly the same thing, create new processes, run other
programs, and synchronize them.

This section teaches you how \textbf{\texttt{fork()}},
\textbf{\texttt{exec()}}, and \textbf{\texttt{wait()}} work together,
the three essential building blocks of process control.

\subsubsection{Step 1. The Idea of a
Process}\label{step-1.-the-idea-of-a-process}

When your program starts, it runs as \textbf{one process}, with:

\begin{itemize}
\tightlist
\item
  a \textbf{PID} (process ID),
\item
  its own \textbf{memory space},
\item
  \textbf{file descriptors} (stdin, stdout, stderr),
\item
  and environment variables.
\end{itemize}

You can check your own PID:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"My PID is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getpid}\OperatorTok{());}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ pid.c }\AttributeTok{{-}o}\NormalTok{ pid}
\ExtensionTok{./pid}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
My PID is 5231
\end{verbatim}

\subsubsection{\texorpdfstring{Step 2. Creating a New Process with
\texttt{fork()}}{Step 2. Creating a New Process with fork()}}\label{step-2.-creating-a-new-process-with-fork}

\texttt{fork()} creates a \textbf{new process} by duplicating the
current one.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"fork failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child process! PID = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getpid}\OperatorTok{());}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent process! PID = }\SpecialCharTok{\%d}\StringTok{, child PID = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getpid}\OperatorTok{(),}\NormalTok{ pid}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ fork\_demo.c }\AttributeTok{{-}o}\NormalTok{ fork\_demo}
\ExtensionTok{./fork\_demo}
\end{Highlighting}
\end{Shaded}

Example output:

\begin{verbatim}
Parent process! PID = 5231, child PID = 5232
Child process! PID = 5232
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{fork()} returns \textbf{0} in the child process
\item
  \texttt{fork()} returns \textbf{child PID} in the parent process
\item
  Both processes continue executing from the same point
\end{itemize}

\subsubsection{\texorpdfstring{Step 3. Independent Memory After
\texttt{fork()}}{Step 3. Independent Memory After fork()}}\label{step-3.-independent-memory-after-fork}

Each process gets a \textbf{copy} of the parent's memory. Changing a
variable in the child doesn't affect the parent.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        counter }\OperatorTok{+=} \DecValTok{10}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child counter: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        counter }\OperatorTok{+=} \DecValTok{1}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent counter: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Parent counter: 1
Child counter: 10
\end{verbatim}

Each process has its own copy of \texttt{counter}.

\subsubsection{\texorpdfstring{Step 4. Replacing a Process Image with
\texttt{exec()}}{Step 4. Replacing a Process Image with exec()}}\label{step-4.-replacing-a-process-image-with-exec}

After \texttt{fork()}, the child can \textbf{replace itself} with a new
program using \texttt{exec()}.

There are multiple versions:

\begin{itemize}
\tightlist
\item
  \texttt{execl(path,\ arg0,\ arg1,\ ...,\ NULL)}
\item
  \texttt{execv(path,\ argv{[}{]})}
\item
  \texttt{execlp(file,\ arg0,\ arg1,\ ...,\ NULL)}, searches
  \texttt{\$PATH}
\item
  \texttt{execvp(file,\ argv{[}{]})}, most commonly used
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before exec}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    execlp}\OperatorTok{(}\StringTok{"ls"}\OperatorTok{,} \StringTok{"ls"}\OperatorTok{,} \StringTok{"{-}l"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"This will not run if exec succeeds}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ exec\_demo.c }\AttributeTok{{-}o}\NormalTok{ exec\_demo}
\ExtensionTok{./exec\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before exec
(total listing from `ls`)
\end{verbatim}

After \texttt{exec}, the current process image is replaced, the PID
stays the same, but the program running inside changes.

\subsubsection{\texorpdfstring{Step 5. Combining \texttt{fork()} and
\texttt{exec()}}{Step 5. Combining fork() and exec()}}\label{step-5.-combining-fork-and-exec}

This is how your shell launches commands.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        execlp}\OperatorTok{(}\StringTok{"echo"}\OperatorTok{,} \StringTok{"echo"}\OperatorTok{,} \StringTok{"Hello from child"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"exec failed"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent is waiting...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Parent is waiting...
Hello from child
\end{verbatim}

The parent forks; the child replaces itself with \texttt{echo}.

\subsubsection{\texorpdfstring{Step 6. Waiting for the Child
(\texttt{wait()} and
\texttt{waitpid()})}{Step 6. Waiting for the Child (wait() and waitpid())}}\label{step-6.-waiting-for-the-child-wait-and-waitpid}

The parent can \textbf{wait} for its child process to finish.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child running}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        execlp}\OperatorTok{(}\StringTok{"sleep"}\OperatorTok{,} \StringTok{"sleep"}\OperatorTok{,} \StringTok{"1"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent waiting for child...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child finished}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ wait\_demo.c }\AttributeTok{{-}o}\NormalTok{ wait\_demo}
\ExtensionTok{./wait\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Parent waiting for child...
Child running
Child finished
\end{verbatim}

\subsubsection{Step 7. Checking Exit
Status}\label{step-7.-checking-exit-status}

You can get the child's \textbf{exit code} using \texttt{waitpid()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        \_exit}\OperatorTok{(}\DecValTok{42}\OperatorTok{);}  \CommentTok{// child exits with status 42}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ status}\OperatorTok{;}
\NormalTok{        waitpid}\OperatorTok{(}\NormalTok{pid}\OperatorTok{,} \OperatorTok{\&}\NormalTok{status}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{WIFEXITED}\OperatorTok{(}\NormalTok{status}\OperatorTok{))}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Child exited with code }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ WEXITSTATUS}\OperatorTok{(}\NormalTok{status}\OperatorTok{));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Child exited with code 42
\end{verbatim}

\subsubsection{Step 8. Multiple
Children}\label{step-8.-multiple-children}

You can spawn multiple processes and wait for them all:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Child }\SpecialCharTok{\%d}\StringTok{ PID }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ getpid}\OperatorTok{());}
\NormalTok{            \_exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"All children done}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Child 0 PID 5321
Child 1 PID 5322
Child 2 PID 5323
All children done
\end{verbatim}

\subsubsection{Step 9. Orphan and Zombie
Processes}\label{step-9.-orphan-and-zombie-processes}

If the parent doesn't call \texttt{wait()}, the child becomes a
\textbf{zombie} (terminated, but still in process table). If the parent
terminates before the child, the child becomes an \textbf{orphan} and
gets adopted by \texttt{init} (PID 1).

Run this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{ps} \AttributeTok{{-}l} \KeywordTok{|} \FunctionTok{grep}\NormalTok{ Z}
\end{Highlighting}
\end{Shaded}

You'll see zombie processes marked with a \texttt{Z}.

\subsubsection{Tiny Code: Minimal Shell
Launcher}\label{tiny-code-minimal-shell-launcher}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\StringTok{"ls"}\OperatorTok{,} \StringTok{"{-}1"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{\};}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        execvp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ argv}\OperatorTok{);}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"exec failed"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Command finished}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ mini\_shell.c }\AttributeTok{{-}o}\NormalTok{ mini\_shell}
\ExtensionTok{./mini\_shell}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
(file listing)
Command finished
\end{verbatim}

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-2}

\texttt{fork()}, \texttt{exec()}, and \texttt{wait()} form the
\textbf{core process model} of Unix. Every command-line program, daemon,
and service uses these under the hood.

They let you:

\begin{itemize}
\tightlist
\item
  Launch other programs
\item
  Build parallel workers
\item
  Implement your own shell
\item
  Control process trees and jobs
\end{itemize}

Once you understand these, you're ready to dive into
\textbf{inter-process communication}, making your processes talk via
\textbf{pipes and redirection}.

\subsubsection{Try It Yourself}\label{try-it-yourself-60}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that forks two children, one runs \texttt{date}, one
  runs \texttt{whoami}.
\item
  Modify it to wait for both children to finish.
\item
  Create a program that forks a child, but the parent exits immediately
  (observe orphan adoption).
\item
  Write your own \texttt{run(command)} function using \texttt{fork()},
  \texttt{execvp()}, and \texttt{waitpid()}.
\item
  Combine all this into a tiny shell that accepts commands and executes
  them interactively.
\end{enumerate}

Next, you'll learn how these processes can \textbf{communicate and share
data}, using \textbf{file descriptors, pipes, and redirection} in the
next section.

\subsection{63. File Descriptors and
open/read/write}\label{file-descriptors-and-openreadwrite}

Now that you can create and manage processes, let's explore how those
processes \textbf{communicate with files, devices, and even each other},
through \textbf{file descriptors}.

File descriptors (FDs) are one of the simplest yet most powerful
abstractions in Unix and C. Everything, files, pipes, sockets,
terminals, is represented by a small integer handle. Once you understand
how to open, read, write, and close file descriptors, you can interact
with any I/O system on a Unix machine.

\subsubsection{Step 1. What Is a File
Descriptor?}\label{step-1.-what-is-a-file-descriptor}

A \textbf{file descriptor} is an integer that identifies an open
resource in your process. Every process starts with three open
descriptors by default:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
FD & Symbolic Name & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & \texttt{STDIN\_FILENO} & Standard input (keyboard) \\
1 & \texttt{STDOUT\_FILENO} & Standard output (screen) \\
2 & \texttt{STDERR\_FILENO} & Standard error (screen) \\
\end{longtable}

Each time you open a file, socket, or pipe, the kernel gives you the
\textbf{lowest unused FD}.

\subsubsection{\texorpdfstring{Step 2. Opening Files with
\texttt{open()}}{Step 2. Opening Files with open()}}\label{step-2.-opening-files-with-open}

You can open files directly using the \textbf{system call layer},
instead of \texttt{fopen()} from stdio.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}\PreprocessorTok{     }\CommentTok{// open}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}\PreprocessorTok{    }\CommentTok{// close, read, write}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}\PreprocessorTok{     }\CommentTok{// perror}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"open failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File descriptor: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ fd}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ open\_demo.c }\AttributeTok{{-}o}\NormalTok{ open\_demo}
\ExtensionTok{./open\_demo}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
File descriptor: 3
\end{verbatim}

\subsubsection{Step 3. Reading from a
File}\label{step-3.-reading-from-a-file}

\texttt{read(fd,\ buffer,\ size)} reads raw bytes into a memory buffer.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        buf}\OperatorTok{[}\NormalTok{n}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Read }\SpecialCharTok{\%zd}\StringTok{ bytes: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Read 12 bytes: Hello world
\end{verbatim}

\subsubsection{Step 4. Writing to a
File}\label{step-4.-writing-to-a-file}

\texttt{write(fd,\ buffer,\ size)} writes raw bytes from memory to a
file descriptor.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"out.txt"}\OperatorTok{,}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
    \DataTypeTok{const} \DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Writing from C using write()}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{;}
\NormalTok{    write}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{msg}\OperatorTok{));}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This overwrites \texttt{out.txt} with your message. Flags:

\begin{itemize}
\tightlist
\item
  \texttt{O\_WRONLY} → write-only
\item
  \texttt{O\_CREAT} → create if it doesn't exist
\item
  \texttt{O\_TRUNC} → truncate (clear) existing contents
\end{itemize}

The final argument \texttt{0644} sets Unix permissions:

\begin{itemize}
\tightlist
\item
  Owner can read/write,
\item
  Group/others can read.
\end{itemize}

\subsubsection{Step 5. Append and Non-blocking
Modes}\label{step-5.-append-and-non-blocking-modes}

You can combine flags using bitwise OR:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_APPEND}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{O\_APPEND} moves the file offset to the end before every write,
ideal for logs.

You can also open files as \textbf{non-blocking}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"pipe"}\OperatorTok{,}\NormalTok{ O\_RDONLY }\OperatorTok{|}\NormalTok{ O\_NONBLOCK}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Useful for I/O on sockets or named pipes.

\subsubsection{Step 6. Duplicating
Descriptors}\label{step-6.-duplicating-descriptors}

You can duplicate an FD using \texttt{dup()} or \texttt{dup2()}. This is
how \textbf{redirection} works (\texttt{\textgreater{}} in shells).

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
\NormalTok{    dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}  \CommentTok{// redirect stdout to file}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"This goes into output.txt!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

After \texttt{dup2}, everything printed to stdout goes to
\texttt{output.txt}.

Run and inspect:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./redir\_demo}
\FunctionTok{cat}\NormalTok{ output.txt}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
This goes into output.txt!
\end{verbatim}

\subsubsection{\texorpdfstring{Step 7. Offsets and
\texttt{lseek()}}{Step 7. Offsets and lseek()}}\label{step-7.-offsets-and-lseek}

You can move around inside a file using
\texttt{lseek(fd,\ offset,\ whence)}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
\NormalTok{    lseek}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,} \DecValTok{5}\OperatorTok{,}\NormalTok{ SEEK\_SET}\OperatorTok{);} \CommentTok{// move to byte 5}
    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{16}\OperatorTok{];}
\NormalTok{    read}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \DecValTok{10}\OperatorTok{);}
\NormalTok{    buf}\OperatorTok{[}\DecValTok{10}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Chunk: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{whence} can be:

\begin{itemize}
\tightlist
\item
  \texttt{SEEK\_SET} (from start)
\item
  \texttt{SEEK\_CUR} (from current)
\item
  \texttt{SEEK\_END} (from end)
\end{itemize}

\subsubsection{Step 8. Error Checking and Return
Values}\label{step-8.-error-checking-and-return-values}

All system calls return:

\begin{itemize}
\tightlist
\item
  A nonnegative value → success
\item
  \texttt{-1} → error (check \texttt{errno})
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"missing.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Error: No such file or directory
\end{verbatim}

\subsubsection{Tiny Code: Copy File Using System
Calls}\label{tiny-code-copy-file-using-system-calls}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ src }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"source.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ dst }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"copy.txt"}\OperatorTok{,}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{src }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1} \OperatorTok{||}\NormalTok{ dst }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"open failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{256}\OperatorTok{];}
    \DataTypeTok{ssize\_t}\NormalTok{ n}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{src}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)))} \OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)}
\NormalTok{        write}\OperatorTok{(}\NormalTok{dst}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}

\NormalTok{    close}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{dst}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ copy.c }\AttributeTok{{-}o}\NormalTok{ copy}
\ExtensionTok{./copy}
\end{Highlighting}
\end{Shaded}

Now \texttt{copy.txt} is identical to \texttt{source.txt}, using pure
syscalls.

\subsubsection{Step 9. Reading from STDIN and Writing to
STDOUT}\label{step-9.-reading-from-stdin-and-writing-to-stdout}

You can use \texttt{read(0,\ ...)} and \texttt{write(1,\ ...)} directly
for console I/O.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{STDIN\_FILENO}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{));}
\NormalTok{    write}\OperatorTok{(}\NormalTok{STDOUT\_FILENO}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./echo\_demo}
\ExtensionTok{hello}\NormalTok{ world}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
hello world
\end{verbatim}

That's the essence of every shell command.

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-3}

File descriptors unify I/O across everything:

\begin{itemize}
\tightlist
\item
  Regular files
\item
  Pipes and sockets
\item
  Devices and terminals
\end{itemize}

They let you control exactly how data flows in and out of your program,
a foundation for system tools, servers, and OS-level programming.

Once you understand these primitives, you can build your own versions of
tools like \texttt{cat}, \texttt{tee}, and even simple shells.

\subsubsection{Try It Yourself}\label{try-it-yourself-61}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a mini \texttt{cat} clone using \texttt{read()} and
  \texttt{write()}.
\item
  Use \texttt{dup2()} to redirect both stdout and stderr to a file.
\item
  Add error messages using \texttt{perror()} and handle \texttt{EINTR}.
\item
  Use \texttt{lseek()} to skip the first N bytes of a file before
  printing.
\item
  Implement a simple file appender with \texttt{O\_APPEND}.
\end{enumerate}

Next, you'll use these file descriptors to make \textbf{processes
communicate}, building \textbf{pipes and redirection}, the same
mechanisms shells use to connect commands like
\texttt{ls\ \textbar{}\ grep}.

\subsection{64. Pipes and Redirection}\label{pipes-and-redirection}

Now that you can read and write with file descriptors, you can connect
\textbf{two processes} so that one's output becomes the other's input,
just like \texttt{ls\ \textbar{}\ grep\ c} in a shell.

This magic happens through \textbf{pipes}, one of Unix's simplest and
most elegant inter-process communication (IPC) mechanisms.

\subsubsection{Step 1. What Is a Pipe?}\label{step-1.-what-is-a-pipe}

A \textbf{pipe} is a unidirectional data channel between two file
descriptors, one for reading, one for writing.

In the shell:

\begin{verbatim}
ls | grep main
\end{verbatim}

is equivalent to:

\begin{itemize}
\tightlist
\item
  Process A (\texttt{ls}) writes into the pipe.
\item
  Process B (\texttt{grep}) reads from the pipe.
\end{itemize}

In C, you can do the same thing using \texttt{pipe()} and
\texttt{fork()}.

\subsubsection{Step 2. Creating a Pipe}\label{step-2.-creating-a-pipe}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{)} \OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"pipe failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Read end: }\SpecialCharTok{\%d}\StringTok{, Write end: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ pipe\_demo.c }\AttributeTok{{-}o}\NormalTok{ pipe\_demo}
\ExtensionTok{./pipe\_demo}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
Read end: 3, Write end: 4
\end{verbatim}

You now have two connected file descriptors:

\begin{itemize}
\tightlist
\item
  \texttt{fds{[}0{]}}: read end
\item
  \texttt{fds{[}1{]}}: write end
\end{itemize}

Whatever you write into \texttt{fds{[}1{]}} can be read from
\texttt{fds{[}0{]}}.

\subsubsection{Step 3. Writing and Reading Through a
Pipe}\label{step-3.-writing-and-reading-through-a-pipe}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{    pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{);}

    \DataTypeTok{const} \DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[]} \OperatorTok{=} \StringTok{"hello through pipe"}\OperatorTok{;}
\NormalTok{    write}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ msg}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{msg}\OperatorTok{));}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{    buf}\OperatorTok{[}\NormalTok{n}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Received: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}

\NormalTok{    close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Received: hello through pipe
\end{verbatim}

You've just communicated through memory between two file descriptors, no
files, no network.

\subsubsection{Step 4. Pipes Between Parent and
Child}\label{step-4.-pipes-between-parent-and-child}

Here's where it gets powerful: \textbf{pipes can connect processes}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{    pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{);}

\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// Child}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);} \CommentTok{// close write end}
        \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
        \DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{        buf}\OperatorTok{[}\NormalTok{n}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child got: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
        \CommentTok{// Parent}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// close read end}
        \DataTypeTok{const} \DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hi from parent!"}\OperatorTok{;}
\NormalTok{        write}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ msg}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{msg}\OperatorTok{));}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Child got: Hi from parent!
\end{verbatim}

Parent writes, child reads, a clean data channel between two processes.

\subsubsection{Step 5. Redirecting STDIN/STDOUT to a
Pipe}\label{step-5.-redirecting-stdinstdout-to-a-pipe}

You can use \texttt{dup2()} to connect a pipe directly to standard
input/output.

Example: connect parent's write end to child's stdin.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{    pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{);}

\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        dup2}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ STDIN\_FILENO}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{        execlp}\OperatorTok{(}\StringTok{"wc"}\OperatorTok{,} \StringTok{"wc"}\OperatorTok{,} \StringTok{"{-}w"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{        write}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"Hello from parent}\SpecialCharTok{\textbackslash{}n}\StringTok{This is a pipe test}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{39}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
6
\end{verbatim}

Here's what happens:

\begin{itemize}
\tightlist
\item
  Parent writes data into the pipe.
\item
  Child's stdin is connected to that pipe.
\item
  \texttt{wc\ -w} counts the words received.
\end{itemize}

This is exactly how the shell implements pipelines like
\texttt{echo\ "hi"\ \textbar{}\ wc\ -w}.

\subsubsection{Step 6. Chaining Multiple
Commands}\label{step-6.-chaining-multiple-commands}

You can chain multiple commands by creating multiple pipes and
connecting them in series.

Example concept:

\begin{verbatim}
cat file.txt | grep "error" | wc -l
\end{verbatim}

Each process reads from the previous pipe and writes to the next, the
shell's fundamental design.

You can implement the same concept in C by:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Creating a pipe between each process pair.
\item
  Forking a new process for each command.
\item
  Redirecting its stdin/stdout via \texttt{dup2()}.
\end{enumerate}

\subsubsection{Step 7. Named Pipes
(FIFOs)}\label{step-7.-named-pipes-fifos}

Pipes normally exist only between related processes. To share data
between unrelated programs, you can use \textbf{named pipes} (FIFOs).

Create one:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{mkfifo}\NormalTok{ mypipe}
\end{Highlighting}
\end{Shaded}

Then in one terminal:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat} \OperatorTok{\textgreater{}}\NormalTok{ mypipe}
\end{Highlighting}
\end{Shaded}

And in another:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat} \OperatorTok{\textless{}}\NormalTok{ mypipe}
\end{Highlighting}
\end{Shaded}

Data flows through the named pipe like a file.

In C:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/stat.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    mkfifo}\OperatorTok{(}\StringTok{"mypipe"}\OperatorTok{,} \BaseNTok{0666}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"mypipe"}\OperatorTok{,}\NormalTok{ O\_WRONLY}\OperatorTok{);}
\NormalTok{    write}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,} \StringTok{"Hello FIFO}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{11}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Error Handling and
EOF}\label{step-8.-error-handling-and-eof}

If all write ends of a pipe are closed, \texttt{read()} returns
\texttt{0}, indicating EOF.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{);}
\NormalTok{close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);} \CommentTok{// no writers}
\DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}
\DataTypeTok{ssize\_t}\NormalTok{ n }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ buf}\OperatorTok{,} \DecValTok{10}\OperatorTok{);} \CommentTok{// n == 0 =\textgreater{} EOF}
\end{Highlighting}
\end{Shaded}

If you try to write after all readers are gone, you'll get
\texttt{SIGPIPE}.

\subsubsection{Tiny Code: Minimal Shell
Pipeline}\label{tiny-code-minimal-shell-pipeline}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fds}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{    pipe}\OperatorTok{(}\NormalTok{fds}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fork}\OperatorTok{()} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        dup2}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{        execlp}\OperatorTok{(}\StringTok{"ls"}\OperatorTok{,} \StringTok{"ls"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fork}\OperatorTok{()} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        dup2}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ STDIN\_FILENO}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{        execlp}\OperatorTok{(}\StringTok{"wc"}\OperatorTok{,} \StringTok{"wc"}\OperatorTok{,} \StringTok{"{-}l"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fds}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{    wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ pipe\_chain.c }\AttributeTok{{-}o}\NormalTok{ pipe\_chain}
\ExtensionTok{./pipe\_chain}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
(number of files in directory)
\end{verbatim}

You just recreated \texttt{ls\ \textbar{}\ wc\ -l} in C.

\subsubsection{Step 9. Combining Redirection and
Files}\label{step-9.-combining-redirection-and-files}

You can redirect stdout or stderr to files the same way:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
\NormalTok{dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}
\NormalTok{close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\NormalTok{execlp}\OperatorTok{(}\StringTok{"ls"}\OperatorTok{,} \StringTok{"ls"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now the output of \texttt{ls} goes to \texttt{output.txt}.

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-4}

Pipes and redirection are the \textbf{heart of Unix philosophy}:

\begin{itemize}
\tightlist
\item
  Programs do one thing well.
\item
  Communicate through text streams.
\item
  Compose complex workflows by chaining simple tools.
\end{itemize}

Understanding how to implement pipes makes you capable of:

\begin{itemize}
\tightlist
\item
  Building your own shell
\item
  Connecting processes dynamically
\item
  Implementing inter-process communication safely
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-62}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Recreate \texttt{ls\ \textbar{}\ grep\ c} using two \texttt{fork()}
  calls and one pipe.
\item
  Build \texttt{cat\ file\ \textbar{}\ wc\ -l}.
\item
  Implement a ``tee'' program that duplicates output to both stdout and
  a file.
\item
  Create a named pipe and write to it from one process, read from
  another.
\item
  Extend your shell to support pipelines of any length.
\end{enumerate}

Next, you'll explore how processes \textbf{signal and interrupt each
other}, using \textbf{signals} and \textbf{signal handlers}, a crucial
concept for handling interrupts, timeouts, and graceful termination.

\subsection{65. Signals and Signal
Handlers}\label{signals-and-signal-handlers}

When you press \textbf{Ctrl+C} and your program stops, that's not magic,
it's a \textbf{signal}. Signals are how the operating system tells your
process that something important has happened.

They're asynchronous, lightweight messages from the kernel or other
processes. Your C program can catch, ignore, or handle them, giving you
full control over shutdowns, interrupts, and errors.

\subsubsection{Step 1. What Is a
Signal?}\label{step-1.-what-is-a-signal}

A \textbf{signal} is an integer code sent to a process to notify it of
an event.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3611}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3611}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Signal
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Default Action
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{SIGINT} & Interrupt (Ctrl+C) & Terminate \\
\texttt{SIGTERM} & Termination request & Terminate \\
\texttt{SIGKILL} & Forced kill (cannot catch) & Terminate immediately \\
\texttt{SIGSEGV} & Invalid memory access & Core dump \\
\texttt{SIGCHLD} & Child process exited & Ignore or handle \\
\texttt{SIGALRM} & Timer expired & Terminate \\
\texttt{SIGUSR1}, \texttt{SIGUSR2} & User-defined & Terminate (unless
handled) \\
\end{longtable}

You can list all signals:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{kill} \AttributeTok{{-}l}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
1) SIGHUP  2) SIGINT  3) SIGQUIT  9) SIGKILL  15) SIGTERM  ...
\end{verbatim}

\subsubsection{Step 2. Sending Signals}\label{step-2.-sending-signals}

Any process can send a signal to another using the \texttt{kill()}
system call.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ getpid}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"My PID: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pid}\OperatorTok{);}
\NormalTok{    pause}\OperatorTok{();}  \CommentTok{// wait for signal}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run this in one terminal:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./signal\_wait}
\end{Highlighting}
\end{Shaded}

Then in another:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{kill} \AttributeTok{{-}SIGUSR1} \OperatorTok{\textless{}}\NormalTok{pid}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

The program will wake up from \texttt{pause()} and terminate (default
behavior for SIGUSR1).

\subsubsection{Step 3. Installing a Signal
Handler}\label{step-3.-installing-a-signal-handler}

You can \textbf{override} the default action by installing a
\textbf{handler function}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ handle\_sigint}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Caught signal }\SpecialCharTok{\%d}\StringTok{ (SIGINT). Exiting gracefully.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sig}\OperatorTok{);}
\NormalTok{    \_exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ handle\_sigint}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Running... Press Ctrl+C to stop.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ sigint\_demo.c }\AttributeTok{{-}o}\NormalTok{ sigint\_demo}
\ExtensionTok{./sigint\_demo}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Running... Press Ctrl+C to stop.
Running... Press Ctrl+C to stop.
^C
Caught signal 2 (SIGINT). Exiting gracefully.
\end{verbatim}

\subsubsection{\texorpdfstring{Step 4. Using \texttt{sigaction()}
(Modern
API)}{Step 4. Using sigaction() (Modern API)}}\label{step-4.-using-sigaction-modern-api}

\texttt{signal()} is simple but inconsistent across systems. The
\textbf{recommended} modern interface is \texttt{sigaction()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ handler}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    write}\OperatorTok{(}\NormalTok{STDOUT\_FILENO}\OperatorTok{,} \StringTok{"Caught signal}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{14}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ sigaction sa }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    sa}\OperatorTok{.}\NormalTok{sa\_handler }\OperatorTok{=}\NormalTok{ handler}\OperatorTok{;}
\NormalTok{    sigaction}\OperatorTok{(}\NormalTok{SIGUSR1}\OperatorTok{,} \OperatorTok{\&}\NormalTok{sa}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"PID: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getpid}\OperatorTok{());}
    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)}\NormalTok{ pause}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Send a signal:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{kill} \AttributeTok{{-}SIGUSR1} \OperatorTok{\textless{}}\NormalTok{pid}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Caught signal
\end{verbatim}

Unlike \texttt{signal()}, this version is \textbf{reliable and
reentrant-safe} (you can call only async-safe functions like
\texttt{write()} inside handlers).

\subsubsection{Step 5. Ignoring and Resetting
Signals}\label{step-5.-ignoring-and-resetting-signals}

You can \textbf{ignore} a signal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ SIG\_IGN}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Or \textbf{reset} to default behavior:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ SIG\_DFL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This can be useful if you don't want Ctrl+C to interrupt certain
sections of code.

\subsubsection{Step 6. Sending Signals to Other
Processes}\label{step-6.-sending-signals-to-other-processes}

Example: parent signaling its child.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ child\_handler}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Child got signal }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sig}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        signal}\OperatorTok{(}\NormalTok{SIGUSR1}\OperatorTok{,}\NormalTok{ child\_handler}\OperatorTok{);}
        \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)}\NormalTok{ pause}\OperatorTok{();}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent sending SIGUSR1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        kill}\OperatorTok{(}\NormalTok{pid}\OperatorTok{,}\NormalTok{ SIGUSR1}\OperatorTok{);}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{        kill}\OperatorTok{(}\NormalTok{pid}\OperatorTok{,}\NormalTok{ SIGTERM}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Parent sending SIGUSR1
Child got signal 10
\end{verbatim}

\subsubsection{Step 7. Blocking and Unblocking
Signals}\label{step-7.-blocking-and-unblocking-signals}

Sometimes you want to delay signal handling. You can use
\texttt{sigprocmask()} to block signals temporarily.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    sigset\_t set}\OperatorTok{;}
\NormalTok{    sigemptyset}\OperatorTok{(\&}\NormalTok{set}\OperatorTok{);}
\NormalTok{    sigaddset}\OperatorTok{(\&}\NormalTok{set}\OperatorTok{,}\NormalTok{ SIGINT}\OperatorTok{);}

\NormalTok{    sigprocmask}\OperatorTok{(}\NormalTok{SIG\_BLOCK}\OperatorTok{,} \OperatorTok{\&}\NormalTok{set}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"SIGINT blocked for 5 seconds...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    sleep}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Unblocking now.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    sigprocmask}\OperatorTok{(}\NormalTok{SIG\_UNBLOCK}\OperatorTok{,} \OperatorTok{\&}\NormalTok{set}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)}\NormalTok{ pause}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Press Ctrl+C during the block, nothing happens. Once unblocked, it
terminates normally.

\subsubsection{\texorpdfstring{Step 8. Timers with \texttt{alarm()} and
\texttt{SIGALRM}}{Step 8. Timers with alarm() and SIGALRM}}\label{step-8.-timers-with-alarm-and-sigalrm}

You can set a timer that sends a signal after a delay.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ handler}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Timer expired!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGALRM}\OperatorTok{,}\NormalTok{ handler}\OperatorTok{);}
\NormalTok{    alarm}\OperatorTok{(}\DecValTok{3}\OperatorTok{);}  \CommentTok{// after 3 seconds, send SIGALRM}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Waiting...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    pause}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Waiting...
Timer expired!
\end{verbatim}

\subsubsection{Step 9. Cleaning Up on
Exit}\label{step-9.-cleaning-up-on-exit}

Signals let you implement graceful cleanup (e.g., close files, delete
temp files).

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ cleanup}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Cleaning up before exit...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    unlink}\OperatorTok{(}\StringTok{"tempfile.tmp"}\OperatorTok{);}
\NormalTok{    \_exit}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ cleanup}\OperatorTok{);}
\NormalTok{    open}\OperatorTok{(}\StringTok{"tempfile.tmp"}\OperatorTok{,}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_WRONLY}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Running... (Ctrl+C to exit)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now pressing Ctrl+C removes the temporary file safely.

\subsubsection{Tiny Code: Graceful Shutdown
Server}\label{tiny-code-graceful-shutdown-server}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{volatile} \DataTypeTok{sig\_atomic\_t}\NormalTok{ running }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ stop}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    running }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ stop}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Server running. Press Ctrl+C to stop.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{running}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Handling request...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Server shutting down cleanly.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-5}

Signals are essential for:

\begin{itemize}
\tightlist
\item
  Graceful termination (Ctrl+C)
\item
  Timeouts and alarms
\item
  Child process monitoring (\texttt{SIGCHLD})
\item
  Error handling (segmentation faults)
\item
  Daemon and server control
\end{itemize}

Every real-world Unix program, from editors to web servers, depends on
correct signal handling for stability.

\subsubsection{Try It Yourself}\label{try-it-yourself-63}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that ignores SIGINT for 5 seconds, then restores
  default behavior.
\item
  Catch SIGTERM and print ``Termination requested''.
\item
  Make a parent send SIGUSR1 to its child every second.
\item
  Use \texttt{alarm()} to implement a timeout for user input.
\item
  Add a signal handler to your shell that cleans up child processes
  before exit.
\end{enumerate}

Next, you'll learn how programs \textbf{share and map memory directly},
using \textbf{\texttt{mmap()}}, a system call that powers databases,
shared memory, and file-backed data structures.

\subsection{66. Memory Mapping (mmap)}\label{memory-mapping-mmap}

In previous sections, you learned how to read and write files using
\texttt{read()} and \texttt{write()}. Those system calls move data
between \textbf{files} and \textbf{user-space buffers} in RAM.

But what if you could \textbf{map a file directly into memory}, and then
treat it as part of your process's address space?

That's exactly what \textbf{memory mapping} (via \texttt{mmap}) does,
it's faster, more flexible, and forms the backbone of databases, shared
memory systems, and even virtual memory itself.

\subsubsection{\texorpdfstring{Step 1. What Is
\texttt{mmap}?}{Step 1. What Is mmap?}}\label{step-1.-what-is-mmap}

\texttt{mmap()} maps a file or device into memory so you can access it
directly, as if it were an array in RAM.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\DataTypeTok{void} \OperatorTok{*}\NormalTok{mmap}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{addr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ length}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ prot}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ flags}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ fd}\OperatorTok{,}\NormalTok{ off\_t offset}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Parameter & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{addr} & Hint for mapping address (usually \texttt{NULL}) \\
\texttt{length} & Number of bytes to map \\
\texttt{prot} & Protection: \texttt{PROT\_READ}, \texttt{PROT\_WRITE},
etc. \\
\texttt{flags} & Type: \texttt{MAP\_PRIVATE}, \texttt{MAP\_SHARED},
etc. \\
\texttt{fd} & File descriptor to map \\
\texttt{offset} & Start offset in file (must be multiple of page
size) \\
\end{longtable}

\subsubsection{Step 2. Simple File Mapping
Example}\label{step-2.-simple-file-mapping-example}

Let's map a file into memory and print its contents.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/stat.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"open"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{struct}\NormalTok{ stat st}\OperatorTok{;}
\NormalTok{    fstat}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,} \OperatorTok{\&}\NormalTok{st}\OperatorTok{);}

    \DataTypeTok{char} \OperatorTok{*}\NormalTok{data }\OperatorTok{=}\NormalTok{ mmap}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{,}\NormalTok{ PROT\_READ}\OperatorTok{,}\NormalTok{ MAP\_PRIVATE}\OperatorTok{,}\NormalTok{ fd}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{data }\OperatorTok{==}\NormalTok{ MAP\_FAILED}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"mmap"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}

\NormalTok{    write}\OperatorTok{(}\NormalTok{STDOUT\_FILENO}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{);}
\NormalTok{    munmap}\OperatorTok{(}\NormalTok{data}\OperatorTok{,}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ mmap\_read.c }\AttributeTok{{-}o}\NormalTok{ mmap\_read}
\ExtensionTok{./mmap\_read}
\end{Highlighting}
\end{Shaded}

This directly prints the file contents, no loops, no \texttt{read()}
calls.

\subsubsection{Step 3. Reading
vs.~Writing}\label{step-3.-reading-vs.-writing}

If you want to modify a file through memory, you must open it read-write
and use \texttt{PROT\_WRITE}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/stat.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"memo.txt"}\OperatorTok{,}\NormalTok{ O\_RDWR }\OperatorTok{|}\NormalTok{ O\_CREAT}\OperatorTok{,} \BaseNTok{0666}\OperatorTok{);}
\NormalTok{    ftruncate}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,} \DecValTok{64}\OperatorTok{);} \CommentTok{// ensure file has enough size}

    \DataTypeTok{char} \OperatorTok{*}\NormalTok{map }\OperatorTok{=}\NormalTok{ mmap}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \DecValTok{64}\OperatorTok{,}\NormalTok{ PROT\_READ }\OperatorTok{|}\NormalTok{ PROT\_WRITE}\OperatorTok{,}\NormalTok{ MAP\_SHARED}\OperatorTok{,}\NormalTok{ fd}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{map }\OperatorTok{==}\NormalTok{ MAP\_FAILED}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{map}\OperatorTok{,} \StringTok{"Hello, memory{-}mapped file!"}\OperatorTok{);}
\NormalTok{    msync}\OperatorTok{(}\NormalTok{map}\OperatorTok{,} \DecValTok{64}\OperatorTok{,}\NormalTok{ MS\_SYNC}\OperatorTok{);}

\NormalTok{    munmap}\OperatorTok{(}\NormalTok{map}\OperatorTok{,} \DecValTok{64}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Open \texttt{memo.txt}, you'll see the written text instantly.

\begin{itemize}
\tightlist
\item
  \texttt{MAP\_SHARED}: changes are written back to the file.
\item
  \texttt{MAP\_PRIVATE}: copy-on-write (changes visible only to this
  process).
\end{itemize}

\subsubsection{Step 4. Anonymous
Mappings}\label{step-4.-anonymous-mappings}

You can create memory that isn't tied to any file, purely in RAM.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{size\_t}\NormalTok{ len }\OperatorTok{=} \DecValTok{4096}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ mmap}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,}\NormalTok{ len}\OperatorTok{,}\NormalTok{ PROT\_READ }\OperatorTok{|}\NormalTok{ PROT\_WRITE}\OperatorTok{,}
\NormalTok{                    MAP\_PRIVATE }\OperatorTok{|}\NormalTok{ MAP\_ANONYMOUS}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr }\OperatorTok{==}\NormalTok{ MAP\_FAILED}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

\NormalTok{    arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{1234}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"arr[0] = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

\NormalTok{    munmap}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ len}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
arr[0] = 1234
\end{verbatim}

Anonymous mappings are commonly used for dynamic memory regions or
shared memory between processes.

\subsubsection{Step 5. Shared Memory Between
Processes}\label{step-5.-shared-memory-between-processes}

You can use \texttt{MAP\_SHARED} and \texttt{fork()} to let parent and
child processes share the same mapped memory.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{shared }\OperatorTok{=}\NormalTok{ mmap}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),}
\NormalTok{                       PROT\_READ }\OperatorTok{|}\NormalTok{ PROT\_WRITE}\OperatorTok{,}
\NormalTok{                       MAP\_SHARED }\OperatorTok{|}\NormalTok{ MAP\_ANONYMOUS}\OperatorTok{,}
                       \OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}

    \OperatorTok{*}\NormalTok{shared }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \OperatorTok{(*}\NormalTok{shared}\OperatorTok{)++;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Child: shared = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{shared}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Parent: shared = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{shared}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    munmap}\OperatorTok{(}\NormalTok{shared}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Child: shared = 1
Parent: shared = 1
\end{verbatim}

Both processes see the same memory, no pipes or sockets needed.

\subsubsection{Step 6. Memory
Protections}\label{step-6.-memory-protections}

Use \texttt{PROT\_*} flags to control access:

\begin{itemize}
\tightlist
\item
  \texttt{PROT\_READ} → read allowed
\item
  \texttt{PROT\_WRITE} → write allowed
\item
  \texttt{PROT\_EXEC} → executable
\item
  \texttt{PROT\_NONE} → no access
\end{itemize}

You can change permissions later:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mprotect}\OperatorTok{(}\NormalTok{ptr}\OperatorTok{,}\NormalTok{ len}\OperatorTok{,}\NormalTok{ PROT\_READ}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This helps you simulate ``read-only'' data regions or test segmentation
faults intentionally.

\subsubsection{Step 7. Page Size and
Alignment}\label{step-7.-page-size-and-alignment}

Memory is mapped in units of \textbf{pages} (usually 4096 bytes). You
can get your system's page size:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Page size: }\SpecialCharTok{\%ld}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sysconf}\OperatorTok{(}\NormalTok{\_SC\_PAGESIZE}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Offsets in \texttt{mmap} must be \textbf{aligned} to page size.

\subsubsection{Step 8. Unmapping and
Syncing}\label{step-8.-unmapping-and-syncing}

When you're done with a mapped region, always call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{munmap}\OperatorTok{(}\NormalTok{addr}\OperatorTok{,}\NormalTok{ length}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you modified the data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msync}\OperatorTok{(}\NormalTok{addr}\OperatorTok{,}\NormalTok{ length}\OperatorTok{,}\NormalTok{ MS\_SYNC}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This ensures changes are written back to disk.

\subsubsection{\texorpdfstring{Step 9. Using \texttt{mmap} for
Performance}{Step 9. Using mmap for Performance}}\label{step-9.-using-mmap-for-performance}

Advantages over \texttt{read()} and \texttt{write()}:

\begin{itemize}
\tightlist
\item
  Avoids extra data copies between kernel and user space.
\item
  The OS loads only the pages you touch (lazy loading).
\item
  Efficient for random access to large files.
\end{itemize}

Databases, editors, and browsers (like SQLite, Vim, Chrome) rely heavily
on \texttt{mmap} for performance.

\subsubsection{Tiny Code: Count Lines in a Large
File}\label{tiny-code-count-lines-in-a-large-file}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/stat.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"bigfile.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \KeywordTok{struct}\NormalTok{ stat st}\OperatorTok{;}
\NormalTok{    fstat}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,} \OperatorTok{\&}\NormalTok{st}\OperatorTok{);}

    \DataTypeTok{char} \OperatorTok{*}\NormalTok{data }\OperatorTok{=}\NormalTok{ mmap}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{,}\NormalTok{ PROT\_READ}\OperatorTok{,}\NormalTok{ MAP\_PRIVATE}\OperatorTok{,}\NormalTok{ fd}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \DataTypeTok{size\_t}\NormalTok{ lines }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{data}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{)}\NormalTok{ lines}\OperatorTok{++;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Lines: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ lines}\OperatorTok{);}
\NormalTok{    munmap}\OperatorTok{(}\NormalTok{data}\OperatorTok{,}\NormalTok{ st}\OperatorTok{.}\NormalTok{st\_size}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it on a multi-GB file, it'll perform incredibly fast.

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-6}

\texttt{mmap} opens a new world of \textbf{memory-driven file access}:

\begin{itemize}
\tightlist
\item
  Used by OSes to load executables, shared libs, and pages.
\item
  Powers databases, compilers, and search engines.
\item
  Enables shared memory between processes.
\item
  Reduces I/O overhead for large files.
\end{itemize}

It's the bridge between \textbf{files} and \textbf{memory}, unifying two
key abstractions in C and Unix.

\subsubsection{Try It Yourself}\label{try-it-yourself-64}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a file and modify it in place using \texttt{mmap}.
\item
  Create shared memory between parent and child processes with
  \texttt{MAP\_SHARED}.
\item
  Measure performance difference between \texttt{read()} and
  \texttt{mmap}.
\item
  Map only part of a file using an offset aligned to page size.
\item
  Implement a small in-memory key-value store backed by \texttt{mmap}.
\end{enumerate}

Next, you'll explore how to work with \textbf{time and clocks in C},
retrieving system timestamps, measuring durations, and implementing
timers with precision.

\subsection{67. Time and Clock APIs}\label{time-and-clock-apis}

Time is one of the simplest things humans understand, and one of the
trickiest things for computers to handle correctly. In C, time is
represented in \textbf{seconds since the Unix epoch (Jan 1, 1970)}, and
you can work with it at various levels: wall-clock time, process time,
and high-precision timers.

Let's explore how to \textbf{get, format, and measure time} in C.

\subsubsection{\texorpdfstring{Step 1. The Basics:
\texttt{time()}}{Step 1. The Basics: time()}}\label{step-1.-the-basics-time}

The simplest way to get the current time is with the \texttt{time()}
function.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Seconds since epoch: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ now}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Seconds since epoch: 1739709201
\end{verbatim}

That's the number of seconds since \textbf{1970-01-01 00:00:00 UTC}.

\subsubsection{Step 2. Converting to Human-Readable
Format}\label{step-2.-converting-to-human-readable-format}

You can convert \texttt{time\_t} into a calendar date using
\texttt{localtime()} or \texttt{gmtime()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
    \KeywordTok{struct}\NormalTok{ tm }\OperatorTok{*}\NormalTok{t }\OperatorTok{=}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Local time: }\SpecialCharTok{\%02d}\StringTok{{-}}\SpecialCharTok{\%02d}\StringTok{{-}}\SpecialCharTok{\%04d}\StringTok{ }\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mday}\OperatorTok{,}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mon }\OperatorTok{+} \DecValTok{1}\OperatorTok{,}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_year }\OperatorTok{+} \DecValTok{1900}\OperatorTok{,}
\NormalTok{           t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_hour}\OperatorTok{,}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_min}\OperatorTok{,}\NormalTok{ t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_sec}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Local time: 16-10-2025 09:32:10
\end{verbatim}

\subsubsection{\texorpdfstring{Step 3. Formatting Dates with
\texttt{strftime()}}{Step 3. Formatting Dates with strftime()}}\label{step-3.-formatting-dates-with-strftime}

\texttt{strftime()} lets you format time into a string safely.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
    \DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
    \KeywordTok{struct}\NormalTok{ tm }\OperatorTok{*}\NormalTok{t }\OperatorTok{=}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{);}
\NormalTok{    strftime}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),} \StringTok{"\%Y{-}\%m{-}}\SpecialCharTok{\%d}\StringTok{ \%H:\%M:\%S"}\OperatorTok{,}\NormalTok{ t}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Formatted: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Formatted: 2025-10-16 09:32:10
\end{verbatim}

\subsubsection{Step 4. Measuring Elapsed
Time}\label{step-4.-measuring-elapsed-time}

To measure how long something takes, use \texttt{clock()} from
\texttt{\textless{}time.h\textgreater{}}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    clock\_t start }\OperatorTok{=}\NormalTok{ clock}\OperatorTok{();}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{volatile} \DataTypeTok{long}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);}
\NormalTok{    clock\_t end }\OperatorTok{=}\NormalTok{ clock}\OperatorTok{();}
    \DataTypeTok{double}\NormalTok{ seconds }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)(}\NormalTok{end }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{)} \OperatorTok{/}\NormalTok{ CLOCKS\_PER\_SEC}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Elapsed time: }\SpecialCharTok{\%.3f}\StringTok{ seconds}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ seconds}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Elapsed time: 0.520 seconds
\end{verbatim}

\texttt{clock()} measures \textbf{CPU time}, not real elapsed time, so
it excludes time spent waiting for I/O or sleeping.

\subsubsection{\texorpdfstring{Step 5. High-Resolution Timing with
\texttt{clock\_gettime()}}{Step 5. High-Resolution Timing with clock\_gettime()}}\label{step-5.-high-resolution-timing-with-clock_gettime}

For precise measurements, use \texttt{clock\_gettime()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ timespec start}\OperatorTok{,}\NormalTok{ end}\OperatorTok{;}
\NormalTok{    clock\_gettime}\OperatorTok{(}\NormalTok{CLOCK\_MONOTONIC}\OperatorTok{,} \OperatorTok{\&}\NormalTok{start}\OperatorTok{);}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{volatile} \DataTypeTok{long}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);}

\NormalTok{    clock\_gettime}\OperatorTok{(}\NormalTok{CLOCK\_MONOTONIC}\OperatorTok{,} \OperatorTok{\&}\NormalTok{end}\OperatorTok{);}

    \DataTypeTok{double}\NormalTok{ elapsed }\OperatorTok{=} \OperatorTok{(}\NormalTok{end}\OperatorTok{.}\NormalTok{tv\_sec }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{.}\NormalTok{tv\_sec}\OperatorTok{)}
                   \OperatorTok{+} \OperatorTok{(}\NormalTok{end}\OperatorTok{.}\NormalTok{tv\_nsec }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{.}\NormalTok{tv\_nsec}\OperatorTok{)} \OperatorTok{/} \FloatTok{1e9}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Elapsed: }\SpecialCharTok{\%.6f}\StringTok{ seconds}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ elapsed}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Elapsed: 0.515421 seconds
\end{verbatim}

This measures \textbf{real elapsed time}, immune to system clock
changes.

\subsubsection{Step 6. Sleeping for a
Duration}\label{step-6.-sleeping-for-a-duration}

You can make your program pause using \texttt{sleep()} or
\texttt{nanosleep()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sleeping for 2 seconds...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    sleep}\OperatorTok{(}\DecValTok{2}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Awake!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For sub-second precision:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ timespec ts }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{,} \DecValTok{500000000}\OperatorTok{\};} \CommentTok{// 0.5 seconds}
\NormalTok{    nanosleep}\OperatorTok{(\&}\NormalTok{ts}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Getting UTC and Local Time
Zones}\label{step-7.-getting-utc-and-local-time-zones}

\texttt{gmtime()} gives you UTC, while \texttt{localtime()} converts to
your system's timezone.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"UTC:   }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ asctime}\OperatorTok{(}\NormalTok{gmtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{)));}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Local: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ asctime}\OperatorTok{(}\NormalTok{localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{)));}
\end{Highlighting}
\end{Shaded}

You can change timezone behavior via the \texttt{TZ} environment
variable and \texttt{tzset()}.

\subsubsection{Step 8. Process Time and Resource
Usage}\label{step-8.-process-time-and-resource-usage}

You can inspect how much CPU time your program used with
\texttt{getrusage()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/resource.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ rusage usage}\OperatorTok{;}
\NormalTok{    getrusage}\OperatorTok{(}\NormalTok{RUSAGE\_SELF}\OperatorTok{,} \OperatorTok{\&}\NormalTok{usage}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"User CPU time: }\SpecialCharTok{\%ld}\StringTok{.}\SpecialCharTok{\%06ld}\StringTok{s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           usage}\OperatorTok{.}\NormalTok{ru\_utime}\OperatorTok{.}\NormalTok{tv\_sec}\OperatorTok{,}\NormalTok{ usage}\OperatorTok{.}\NormalTok{ru\_utime}\OperatorTok{.}\NormalTok{tv\_usec}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"System CPU time: }\SpecialCharTok{\%ld}\StringTok{.}\SpecialCharTok{\%06ld}\StringTok{s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           usage}\OperatorTok{.}\NormalTok{ru\_stime}\OperatorTok{.}\NormalTok{tv\_sec}\OperatorTok{,}\NormalTok{ usage}\OperatorTok{.}\NormalTok{ru\_stime}\OperatorTok{.}\NormalTok{tv\_usec}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is how profilers measure CPU consumption.

\subsubsection{Step 9. Time Differences}\label{step-9.-time-differences}

You can subtract two \texttt{time\_t} values using \texttt{difftime()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{time\_t}\NormalTok{ start }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    sleep}\OperatorTok{(}\DecValTok{2}\OperatorTok{);}
    \DataTypeTok{time\_t}\NormalTok{ end }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Elapsed: }\SpecialCharTok{\%.0f}\StringTok{ seconds}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ difftime}\OperatorTok{(}\NormalTok{end}\OperatorTok{,}\NormalTok{ start}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Elapsed: 2 seconds
\end{verbatim}

\subsubsection{Step 10. Tiny Code: Countdown
Timer}\label{step-10.-tiny-code-countdown-timer}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-})} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{        sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Time\textquotesingle{}s up!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
5...
4...
3...
2...
1...
Time's up!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-57}

Time functions are critical in:

\begin{itemize}
\tightlist
\item
  Logging and timestamps
\item
  Benchmarking and profiling
\item
  Scheduling events
\item
  Measuring performance of algorithms
\item
  Synchronizing distributed systems
\end{itemize}

Every systems program eventually needs \textbf{accurate, reliable time
measurement}, and C gives you all the low-level tools to do it
efficiently.

\subsubsection{Try It Yourself}\label{try-it-yourself-65}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print the current date in ISO 8601 format.
\item
  Measure how long it takes to read a large file.
\item
  Build a stopwatch that measures elapsed time with
  \texttt{clock\_gettime()}.
\item
  Make a countdown timer that updates in place on the terminal.
\item
  Display both UTC and local time, formatted nicely.
\end{enumerate}

Next, you'll learn how to \textbf{access and modify environment
variables}, another key part of how Unix programs communicate with their
runtime environment.

\subsection{68. Environment Variables}\label{environment-variables}

Every program in Unix inherits a \textbf{set of key--value pairs} called
\textbf{environment variables}. They store information about your shell,
system configuration, and runtime behavior, such as your username, home
directory, and compiler paths.

C gives you full control to \textbf{read, modify, and define} these
variables directly.

\subsubsection{Step 1. What Are Environment
Variables?}\label{step-1.-what-are-environment-variables}

Environment variables are strings of the form:

\begin{verbatim}
KEY=VALUE
\end{verbatim}

You can view them in your shell:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{printenv}
\end{Highlighting}
\end{Shaded}

Common examples:

\begin{verbatim}
HOME=/home/user
PATH=/usr/local/bin:/usr/bin:/bin
USER=alice
LANG=en_US.UTF-8
SHELL=/bin/bash
\end{verbatim}

These values are passed to every program when you run it.

\subsubsection{Step 2. Accessing Environment Variables in
C}\label{step-2.-accessing-environment-variables-in-c}

You can use the standard library function \texttt{getenv()} to read a
variable.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{path }\OperatorTok{=}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"PATH"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{path}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"PATH = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ path}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"PATH not found.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
PATH = /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
\end{verbatim}

If the variable doesn't exist, \texttt{getenv()} returns \texttt{NULL}.

\subsubsection{Step 3. Setting Environment
Variables}\label{step-3.-setting-environment-variables}

To define or change a variable inside your program, use
\texttt{setenv()}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    setenv}\OperatorTok{(}\StringTok{"GREETING"}\OperatorTok{,} \StringTok{"Hello from C!"}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"GREETING"}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{setenv(name,\ value,\ overwrite)}

\begin{itemize}
\tightlist
\item
  \texttt{overwrite\ =\ 0}: don't overwrite existing variable.
\item
  \texttt{overwrite\ =\ 1}: replace it if it exists.
\end{itemize}

Output:

\begin{verbatim}
Hello from C!
\end{verbatim}

\subsubsection{Step 4. Removing Environment
Variables}\label{step-4.-removing-environment-variables}

Use \texttt{unsetenv()} to delete a variable.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    setenv}\OperatorTok{(}\StringTok{"TEMPVAR"}\OperatorTok{,} \StringTok{"temporary"}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before unset: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"TEMPVAR"}\OperatorTok{));}
\NormalTok{    unsetenv}\OperatorTok{(}\StringTok{"TEMPVAR"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After unset: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"TEMPVAR"}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before unset: temporary
After unset: (null)
\end{verbatim}

\subsubsection{Step 5. Accessing All Environment
Variables}\label{step-5.-accessing-all-environment-variables}

The \texttt{environ} global variable gives you access to the entire
environment list.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{extern} \DataTypeTok{char} \OperatorTok{**}\NormalTok{environ}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{char} \OperatorTok{**}\NormalTok{env }\OperatorTok{=}\NormalTok{ environ}\OperatorTok{;} \OperatorTok{*}\NormalTok{env }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ env}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{env}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This prints all environment variables currently active in your process.

\subsubsection{Step 6. Passing Environment Variables to Child
Processes}\label{step-6.-passing-environment-variables-to-child-processes}

When you use \texttt{fork()} and \texttt{exec()}, environment variables
are \textbf{inherited} by the child process automatically.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    setenv}\OperatorTok{(}\StringTok{"HELLO"}\OperatorTok{,} \StringTok{"world"}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    execlp}\OperatorTok{(}\StringTok{"printenv"}\OperatorTok{,} \StringTok{"printenv"}\OperatorTok{,} \StringTok{"HELLO"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"execlp"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
world
\end{verbatim}

You can also provide a custom environment list using \texttt{execle()}
or \texttt{execve()}.

\subsubsection{Step 7. Custom Environment for a New
Program}\label{step-7.-custom-environment-for-a-new-program}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{newenv}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{} \StringTok{"MODE=debug"}\OperatorTok{,} \StringTok{"VERSION=1.0"}\OperatorTok{,}\NormalTok{ NULL }\OperatorTok{\};}
\NormalTok{    execle}\OperatorTok{(}\StringTok{"/usr/bin/env"}\OperatorTok{,} \StringTok{"env"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ newenv}\OperatorTok{);}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"execle"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
MODE=debug
VERSION=1.0
\end{verbatim}

Only these two variables exist for the new process, everything else is
discarded.

\subsubsection{Step 8. Why Environment Variables
Matter}\label{step-8.-why-environment-variables-matter}

They are a key part of \textbf{Unix's design philosophy}:

\begin{itemize}
\tightlist
\item
  Programs should be \textbf{configurable without recompilation}.
\item
  Environment variables provide \textbf{global, process-level
  configuration}.
\end{itemize}

For example:

\begin{itemize}
\tightlist
\item
  \texttt{PATH} controls where executables are searched.
\item
  \texttt{HOME} defines user directories.
\item
  \texttt{LANG} defines locale settings.
\item
  \texttt{LD\_LIBRARY\_PATH} controls dynamic linking.
\end{itemize}

\subsubsection{Step 9. Security
Considerations}\label{step-9.-security-considerations}

Environment variables are inherited automatically, so they can be a
security risk if not handled carefully:

\begin{itemize}
\tightlist
\item
  Avoid trusting environment variables for authentication.
\item
  Always validate \texttt{PATH}, \texttt{HOME}, and \texttt{TMPDIR}.
\item
  Use \texttt{unsetenv()} for sensitive contexts (e.g., setuid
  programs).
\end{itemize}

\subsubsection{\texorpdfstring{Tiny Code: Mini Shell with \texttt{PATH}
Lookup}{Tiny Code: Mini Shell with PATH Lookup}}\label{tiny-code-mini-shell-with-path-lookup}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{path }\OperatorTok{=}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"PATH"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{path}\OperatorTok{)}\NormalTok{ path }\OperatorTok{=} \StringTok{"(none)"}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Current PATH:}\SpecialCharTok{\textbackslash{}n\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ path}\OperatorTok{);}
\NormalTok{    setenv}\OperatorTok{(}\StringTok{"PATH"}\OperatorTok{,} \StringTok{"/usr/local/bin:/usr/bin"}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Updated PATH:}\SpecialCharTok{\textbackslash{}n\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ getenv}\OperatorTok{(}\StringTok{"PATH"}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Current PATH:
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

Updated PATH:
/usr/local/bin:/usr/bin
\end{verbatim}

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-7}

Environment variables give your programs \textbf{context}:

\begin{itemize}
\tightlist
\item
  They tell you where files, libraries, and configs live.
\item
  They let you control runtime behavior dynamically.
\item
  They're essential for system tools, shells, daemons, and tests.
\end{itemize}

Understanding how to read and modify them is key to mastering Unix
programming in C.

\subsubsection{Try It Yourself}\label{try-it-yourself-66}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print all environment variables sorted alphabetically.
\item
  Implement your own \texttt{env} command in C.
\item
  Write a program that modifies \texttt{PATH} and launches another
  program.
\item
  Create a child process that inherits modified variables.
\item
  Combine \texttt{setenv()}, \texttt{execle()}, and \texttt{getenv()} to
  simulate sandboxed runs.
\end{enumerate}

Next, you'll learn about \textbf{error handling and return codes}, the
invisible signals that every Unix process uses to tell the system
whether it succeeded or failed.

\subsection{69. Error Handling and Return
Codes}\label{error-handling-and-return-codes}

Every C program, from the tiniest script to the Linux kernel itself,
relies on \textbf{error codes} and \textbf{return values} to communicate
success or failure. Unlike higher-level languages, C gives you
\textbf{no exceptions}, only clear, explicit status codes and
\texttt{errno}.

Mastering these patterns will make your programs robust, predictable,
and professional.

\subsubsection{\texorpdfstring{Step 1. Exit Codes and
\texttt{main()}}{Step 1. Exit Codes and main()}}\label{step-1.-exit-codes-and-main}

Every process returns an integer exit code to the operating system.
Conventionally:

\begin{itemize}
\tightlist
\item
  \texttt{0} → success
\item
  nonzero → failure or specific error
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Everything OK!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \CommentTok{// exit success}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Check it in your shell:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program}
\BuiltInTok{echo} \VariableTok{$?}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Everything OK!
0
\end{verbatim}

If you return a nonzero value:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

then \texttt{\$?} will be \texttt{1}, meaning failure.

\subsubsection{\texorpdfstring{Step 2. Using \texttt{EXIT\_SUCCESS} and
\texttt{EXIT\_FAILURE}}{Step 2. Using EXIT\_SUCCESS and EXIT\_FAILURE}}\label{step-2.-using-exit_success-and-exit_failure}

Instead of hardcoded numbers, use standard macros from
\texttt{\textless{}stdlib.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Failed to open file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ EXIT\_FAILURE}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

These improve portability and readability.

\subsubsection{\texorpdfstring{Step 3. The Global
\texttt{errno}}{Step 3. The Global errno}}\label{step-3.-the-global-errno}

When a library or system call fails, it usually sets a global variable
named \textbf{\texttt{errno}}. It's declared in
\texttt{\textless{}errno.h\textgreater{}}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"nonexistent.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error opening file: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Error opening file: No such file or directory
\end{verbatim}

\texttt{errno} stores an integer code, but \texttt{strerror()} converts
it into a readable message.

\subsubsection{\texorpdfstring{Step 4. Common \texttt{errno}
Values}{Step 4. Common errno Values}}\label{step-4.-common-errno-values}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Code & Macro & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
2 & \texttt{ENOENT} & No such file or directory \\
13 & \texttt{EACCES} & Permission denied \\
12 & \texttt{ENOMEM} & Out of memory \\
22 & \texttt{EINVAL} & Invalid argument \\
9 & \texttt{EBADF} & Bad file descriptor \\
11 & \texttt{EAGAIN} & Resource temporarily unavailable \\
\end{longtable}

You can check them directly:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{errno }\OperatorTok{==}\NormalTok{ EACCES}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Step 5. The \texttt{perror()}
Function}{Step 5. The perror() Function}}\label{step-5.-the-perror-function}

A simpler way to print error messages is \texttt{perror()}, it
automatically uses the current \texttt{errno}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\StringTok{"nothing.txt"}\OperatorTok{,}\NormalTok{ O\_RDONLY}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"open"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
open: No such file or directory
\end{verbatim}

\subsubsection{Step 6. Returning Meaningful
Codes}\label{step-6.-returning-meaningful-codes}

Good C programs \textbf{translate internal errors into meaningful exit
codes}.

Example: file copy program

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ src dest}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{src }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{src}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"fopen src"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{2}\OperatorTok{;}
    \OperatorTok{\}}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{dst }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{],} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{dst}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"fopen dst"}\OperatorTok{);}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{3}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{dst}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now each exit code represents a specific type of failure.

\subsubsection{\texorpdfstring{Step 7. Resetting and Checking
\texttt{errno}}{Step 7. Resetting and Checking errno}}\label{step-7.-resetting-and-checking-errno}

Some system calls set \texttt{errno} only when they fail. So always
reset it before use if you plan to inspect it later:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\NormalTok{errno }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{some\_syscall}\OperatorTok{()} \OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"syscall failed"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Custom Error Handling
Helpers}\label{step-8.-custom-error-handling-helpers}

You can create your own function to simplify error handling.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ die}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\NormalTok{msg}\OperatorTok{);}
\NormalTok{    exit}\OperatorTok{(}\NormalTok{EXIT\_FAILURE}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"no.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)}\NormalTok{ die}\OperatorTok{(}\StringTok{"fopen"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
fopen: No such file or directory
\end{verbatim}

This pattern appears throughout Unix utilities.

\subsubsection{Step 9. Handling Partial
Failures}\label{step-9.-handling-partial-failures}

Not all errors should abort your program. Sometimes you should log,
retry, or ignore.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"optional.conf"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Warning: config file missing, using defaults.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This kind of \textbf{graceful degradation} is good design.

\subsubsection{Step 10. Tiny Code: Safe File
Reader}\label{step-10.-tiny-code-safe-file-reader}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Error: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strerror}\OperatorTok{(}\NormalTok{errno}\OperatorTok{));}
        \ControlFlowTok{return}\NormalTok{ EXIT\_FAILURE}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),}\NormalTok{ f}\OperatorTok{))}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ EXIT\_SUCCESS}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output (if missing file):

\begin{verbatim}
Error: No such file or directory
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-58}

Error handling separates \textbf{toy programs} from \textbf{real
software}:

\begin{itemize}
\tightlist
\item
  Every syscall can fail, be prepared.
\item
  Always check return values.
\item
  Always report why it failed.
\end{itemize}

By convention:

\begin{itemize}
\tightlist
\item
  Return \texttt{0} on success.
\item
  Return nonzero for recoverable or fatal errors.
\item
  Print messages to \texttt{stderr}, not \texttt{stdout}.
\end{itemize}

\subsubsection{Try It Yourself}\label{try-it-yourself-67}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open a nonexistent file and print the full \texttt{errno} value.
\item
  Build a small utility that returns specific codes for specific
  problems.
\item
  Use \texttt{perror()} vs \texttt{strerror()} and compare their
  outputs.
\item
  Add a \texttt{die()} helper to your previous exercises.
\item
  Write a safe wrapper that retries system calls when
  \texttt{errno\ ==\ EAGAIN}.
\end{enumerate}

Next, you'll put all of this together in \textbf{Practice 70: Building a
Mini Shell in C}, where you'll handle processes, pipes, and signals to
create your own working Unix shell prototype.

\subsection{70. Practice: Mini Shell in
C}\label{practice-mini-shell-in-c}

It's time to bring together everything you've learned so far,
\textbf{system calls}, \textbf{process creation}, \textbf{pipes},
\textbf{redirection}, and \textbf{signal handling}, into one cohesive
project.

In this section, you'll build a \textbf{minimal interactive shell}, just
like \texttt{bash} or \texttt{zsh}, but stripped down to the essentials.
It will run commands, handle input/output redirection, and even support
pipelines.

\subsubsection{Step 1. What You'll
Build}\label{step-1.-what-youll-build}

Your mini shell will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Display a prompt like \texttt{\$}
\item
  Read user input (e.g., \texttt{ls\ -l}, \texttt{cat\ file.txt})
\item
  Parse it into command and arguments
\item
  Create a new process using \texttt{fork()}
\item
  Replace the process image with the requested command using
  \texttt{execvp()}
\item
  Wait for the child to finish
\end{enumerate}

Optional extensions:

\begin{itemize}
\tightlist
\item
  Handle signals (Ctrl+C) gracefully
\item
  Redirect output to a file (\texttt{\textgreater{}} redirection)
\item
  Chain commands using pipes (\texttt{\textbar{}})
\end{itemize}

\subsubsection{Step 2. Core Loop
Skeleton}\label{step-2.-core-loop-skeleton}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}

\PreprocessorTok{\#define MAX }\DecValTok{1024}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ input}\OperatorTok{[}\NormalTok{MAX}\OperatorTok{];}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"$ "}\OperatorTok{);}
\NormalTok{        fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fgets}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{input}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{))}
            \ControlFlowTok{break}\OperatorTok{;}

        \CommentTok{// Remove newline}
\NormalTok{        input}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}

        \CommentTok{// Exit command}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{"exit"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{break}\OperatorTok{;}

        \CommentTok{// Tokenize input}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{args}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
        \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{token }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{" "}\OperatorTok{);}
        \ControlFlowTok{while} \OperatorTok{(}\NormalTok{token}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            args}\OperatorTok{[}\NormalTok{i}\OperatorTok{++]} \OperatorTok{=}\NormalTok{ token}\OperatorTok{;}
\NormalTok{            token }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \StringTok{" "}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        args}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

        \CommentTok{// Fork and execute}
\NormalTok{        pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            execvp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ args}\OperatorTok{);}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"execvp"}\OperatorTok{);}
\NormalTok{            exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
        \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
        \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"fork"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ mini\_shell.c }\AttributeTok{{-}o}\NormalTok{ mini\_shell}
\ExtensionTok{./mini\_shell}
\end{Highlighting}
\end{Shaded}

Try commands:

\begin{verbatim}
$ ls
$ pwd
$ echo hello world
$ exit
\end{verbatim}

\subsubsection{Step 3. Handling Errors
Gracefully}\label{step-3.-handling-errors-gracefully}

If you enter a wrong command:

\begin{verbatim}
$ xyz
\end{verbatim}

Output:

\begin{verbatim}
execvp: No such file or directory
\end{verbatim}

This happens because the program handles \texttt{execvp()} failure
properly with \texttt{perror()}, just as you learned in section 69.

\subsubsection{Step 4. Adding Signal
Handling}\label{step-4.-adding-signal-handling}

Let's make Ctrl+C stop the running command, but not kill the shell
itself.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ sigint\_handler}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Type \textquotesingle{}exit\textquotesingle{} to quit.}\SpecialCharTok{\textbackslash{}n}\StringTok{$ "}\OperatorTok{);}
\NormalTok{    fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ sigint\_handler}\OperatorTok{);}
    \OperatorTok{...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now the shell ignores Ctrl+C while waiting for input, instead of
terminating.

\subsubsection{Step 5. Supporting Output
Redirection}\label{step-5.-supporting-output-redirection}

We'll add \texttt{\textgreater{}} redirection like:

\begin{verbatim}
$ echo Hello > out.txt
\end{verbatim}

Add this before the \texttt{execvp()} call in the child:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ args}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j}\OperatorTok{],} \StringTok{"\textgreater{}"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        args}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
        \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{],}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
\NormalTok{        dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{stdout} of the command goes to the file instead of the
screen.

\subsubsection{Step 6. Supporting Input
Redirection}\label{step-6.-supporting-input-redirection}

Similarly, for \texttt{\textless{}} redirection:

\begin{verbatim}
$ cat < in.txt
\end{verbatim}

Add:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j}\OperatorTok{],} \StringTok{"\textless{}"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    args}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{],}\NormalTok{ O\_RDONLY}\OperatorTok{);}
\NormalTok{    dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDIN\_FILENO}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
    \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Adding Pipe
Support}\label{step-7.-adding-pipe-support}

To handle commands like:

\begin{verbatim}
$ ls | wc -l
\end{verbatim}

We create two processes connected by a pipe.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ pipefd}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{pipe}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{);}

\NormalTok{pid\_t p1 }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p1 }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    dup2}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{    execlp}\OperatorTok{(}\StringTok{"ls"}\OperatorTok{,} \StringTok{"ls"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{pid\_t p2 }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p2 }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    dup2}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ STDIN\_FILENO}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{    execlp}\OperatorTok{(}\StringTok{"wc"}\OperatorTok{,} \StringTok{"wc"}\OperatorTok{,} \StringTok{"{-}l"}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{close}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{close}\OperatorTok{(}\NormalTok{pipefd}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

That's the same pattern you saw in section 64,
\texttt{ls\ \textbar{}\ wc\ -l}.

\subsubsection{Step 8. Combining All
Features}\label{step-8.-combining-all-features}

Your shell now:

\begin{itemize}
\tightlist
\item
  Parses user input
\item
  Spawns child processes
\item
  Handles I/O redirection
\item
  Supports Ctrl+C interruption
\item
  Runs simple pipelines
\end{itemize}

With \textasciitilde150 lines of code, you have a \textbf{working Unix
shell prototype}.

\subsubsection{Step 9. Tiny Code: Full Mini
Shell}\label{step-9.-tiny-code-full-mini-shell}

Here's the clean, minimal version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/wait.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}fcntl.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}signal.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ sigint\_handler}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sig}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{$ "}\OperatorTok{);}
\NormalTok{    fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    signal}\OperatorTok{(}\NormalTok{SIGINT}\OperatorTok{,}\NormalTok{ sigint\_handler}\OperatorTok{);}
    \DataTypeTok{char}\NormalTok{ input}\OperatorTok{[}\DecValTok{1024}\OperatorTok{];}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"$ "}\OperatorTok{);}
\NormalTok{        fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fgets}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{input}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{))} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        input}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{"exit"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}

        \DataTypeTok{char} \OperatorTok{*}\NormalTok{args}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
        \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{token }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{input}\OperatorTok{,} \StringTok{" "}\OperatorTok{);}
        \ControlFlowTok{while} \OperatorTok{(}\NormalTok{token}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            args}\OperatorTok{[}\NormalTok{i}\OperatorTok{++]} \OperatorTok{=}\NormalTok{ token}\OperatorTok{;}
\NormalTok{            token }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \StringTok{" "}\OperatorTok{);}
        \OperatorTok{\}}
\NormalTok{        args}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

\NormalTok{        pid\_t pid }\OperatorTok{=}\NormalTok{ fork}\OperatorTok{();}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ args}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
                \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j}\OperatorTok{],} \StringTok{"\textgreater{}"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
                    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{],}\NormalTok{ O\_WRONLY }\OperatorTok{|}\NormalTok{ O\_CREAT }\OperatorTok{|}\NormalTok{ O\_TRUNC}\OperatorTok{,} \BaseNTok{0644}\OperatorTok{);}
\NormalTok{                    dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDOUT\_FILENO}\OperatorTok{);}
\NormalTok{                    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\NormalTok{                    args}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
                \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j}\OperatorTok{],} \StringTok{"\textless{}"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
                    \DataTypeTok{int}\NormalTok{ fd }\OperatorTok{=}\NormalTok{ open}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{],}\NormalTok{ O\_RDONLY}\OperatorTok{);}
\NormalTok{                    dup2}\OperatorTok{(}\NormalTok{fd}\OperatorTok{,}\NormalTok{ STDIN\_FILENO}\OperatorTok{);}
\NormalTok{                    close}\OperatorTok{(}\NormalTok{fd}\OperatorTok{);}
\NormalTok{                    args}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
                \OperatorTok{\}}
            \OperatorTok{\}}
\NormalTok{            execvp}\OperatorTok{(}\NormalTok{args}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ args}\OperatorTok{);}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"execvp"}\OperatorTok{);}
\NormalTok{            exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
        \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pid }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            wait}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Exiting shell.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try it out, it's a real, interactive shell.

\subsubsection{Step 10. Why It Matters}\label{step-10.-why-it-matters-8}

This exercise combines everything you've learned in Chapter 7:

\begin{itemize}
\tightlist
\item
  System calls (\texttt{fork}, \texttt{exec}, \texttt{wait},
  \texttt{pipe}, \texttt{dup2})
\item
  Signals (\texttt{SIGINT})
\item
  File descriptors and redirection
\item
  Error handling with \texttt{errno}
\item
  Environment inheritance
\end{itemize}

You've just built a simplified version of the core that powers
\textbf{every Unix shell}, from \texttt{bash} to \texttt{zsh} to
\texttt{fish}.

\subsubsection{Try It Yourself}\label{try-it-yourself-68}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add support for pipelines (\texttt{\textbar{}}) by chaining multiple
  commands.
\item
  Implement background processes with \texttt{\&}.
\item
  Add \texttt{cd} and \texttt{pwd} as built-in commands.
\item
  Display the exit code after each command.
\item
  Handle multiple spaces and quoted arguments.
\end{enumerate}

Next, we'll move into \textbf{Chapter 8: Debugging, Testing, and
Profiling}, starting with \textbf{gdb}, your most powerful ally in
understanding and fixing C programs.

\bookmarksetup{startatroot}

\chapter{Chapter 8. Debugging, Testing and
Profiling}\label{chapter-8.-debugging-testing-and-profiling}

\subsection{71. Debugging with gdb}\label{debugging-with-gdb}

Every C programmer eventually meets a segmentation fault, and that's
when you discover your most powerful companion: \textbf{gdb}, the GNU
Debugger. Debugging isn't about luck; it's about learning to inspect a
program as it runs, to pause time, and to see what the computer is
really doing.

Let's learn how to use gdb to \textbf{find bugs, inspect memory, trace
crashes}, and truly understand your code.

\subsubsection{Step 1. Compiling with Debug
Information}\label{step-1.-compiling-with-debug-information}

Before you can debug, you need to tell the compiler to include
\textbf{symbol information} (variable names, line numbers, etc.). Use
the \texttt{-g} flag:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

You can now open it in gdb:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./main}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 2. Starting and Running Your
Program}\label{step-2.-starting-and-running-your-program}

Inside gdb, you can run your program just like normal:

\begin{verbatim}
(gdb) run
\end{verbatim}

If it crashes, you'll get something like:

\begin{verbatim}
Program received signal SIGSEGV, Segmentation fault.
0x000000000040114a in buggy_function () at main.c:12
12        *ptr = 42;
\end{verbatim}

You now know exactly where it failed.

\subsubsection{Step 3. Setting
Breakpoints}\label{step-3.-setting-breakpoints}

A \textbf{breakpoint} tells gdb to pause before executing a specific
line or function.

\begin{verbatim}
(gdb) break main
Breakpoint 1 at 0x40113b: file main.c, line 5.
(gdb) run
\end{verbatim}

When the program stops, you can inspect state:

\begin{verbatim}
(gdb) print variable_name
(gdb) next
(gdb) step
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{next} executes the next line (skipping function calls).
\item
  \texttt{step} goes \emph{into} a function call.
\end{itemize}

\subsubsection{Step 4. Example: A Simple
Bug}\label{step-4.-example-a-simple-bug}

Here's a program with a classic segmentation fault.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ buggy}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before crash}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    buggy}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After crash}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and debug:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ bug.c }\AttributeTok{{-}o}\NormalTok{ bug}
\FunctionTok{gdb}\NormalTok{ ./bug}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{run}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Program received signal SIGSEGV, Segmentation fault.
0x0000555555555159 in buggy () at bug.c:5
5        *p = 10;
\end{verbatim}

Now inspect:

\begin{verbatim}
(gdb) backtrace
#0 buggy () at bug.c:5
#1 main () at bug.c:10
\end{verbatim}

You've just \textbf{traced the crash} from main to the exact faulty
line.

\subsubsection{Step 5. Inspecting
Variables}\label{step-5.-inspecting-variables}

You can view variable values anytime:

\begin{verbatim}
(gdb) print x
(gdb) print *ptr
\end{verbatim}

You can also modify them:

\begin{verbatim}
(gdb) set variable x = 100
\end{verbatim}

To list all local variables:

\begin{verbatim}
(gdb) info locals
\end{verbatim}

\subsubsection{Step 6. Navigating
Execution}\label{step-6.-navigating-execution}

Common gdb commands:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Command & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{run} & Start the program \\
\texttt{break\ N} & Stop at line N \\
\texttt{next} & Run next line \\
\texttt{step} & Step into function \\
\texttt{continue} & Resume until next breakpoint \\
\texttt{finish} & Run until function returns \\
\texttt{backtrace} & Show call stack \\
\texttt{info\ locals} & List local vars \\
\texttt{print\ VAR} & Show value \\
\texttt{quit} & Exit gdb \\
\end{longtable}

\subsubsection{Step 7. Watching
Variables}\label{step-7.-watching-variables}

You can set \textbf{watchpoints}, gdb stops when a variable changes.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{    counter }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In gdb:

\begin{verbatim}
(gdb) watch counter
(gdb) run
\end{verbatim}

Every time \texttt{counter} changes, the program pauses, showing where
it happened.

\subsubsection{Step 8. Conditional
Breakpoints}\label{step-8.-conditional-breakpoints}

Sometimes you only want to stop under specific conditions:

\begin{verbatim}
(gdb) break loop.c:25 if i > 100
\end{verbatim}

This breakpoint triggers only when \texttt{i} exceeds 100.

\subsubsection{Step 9. Inspecting Memory and
Registers}\label{step-9.-inspecting-memory-and-registers}

You can inspect raw memory:

\begin{verbatim}
(gdb) x/10x &array
\end{verbatim}

This prints 10 hexadecimal words starting at \texttt{\&array}.

Or view registers:

\begin{verbatim}
(gdb) info registers
\end{verbatim}

This is useful for low-level debugging (e.g., compilers, OS kernels,
embedded code).

\subsubsection{Step 10. Tiny Code: Debugging a Logic
Bug}\label{step-10.-tiny-code-debugging-a-logic-bug}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        sum }\OperatorTok{=}\NormalTok{ sum }\OperatorTok{+}\NormalTok{ i}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);} \CommentTok{// should be 15}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Introduce a bug:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);} \CommentTok{// extra semicolon!}
\end{Highlighting}
\end{Shaded}

Compile and debug:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ bug.c }\AttributeTok{{-}o}\NormalTok{ bug}
\FunctionTok{gdb}\NormalTok{ ./bug}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ControlFlowTok{break} \ExtensionTok{main}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{run}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{print}\NormalTok{ sum}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{next}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{print}\NormalTok{ sum}
\end{Highlighting}
\end{Shaded}

You'll see that \texttt{sum} never changes, because the loop body was
empty.

\subsubsection{Why It Matters}\label{why-it-matters-59}

Debugging is how you \textbf{learn to think like the machine}:

\begin{itemize}
\tightlist
\item
  You can inspect what happens between lines.
\item
  You can see every variable's value.
\item
  You can find segmentation faults in seconds.
\end{itemize}

Learning gdb teaches you how C really runs, from stack frames to
pointers.

\subsubsection{Try It Yourself}\label{try-it-yourself-69}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that crashes (e.g., use a null pointer) and trace the
  cause with gdb.
\item
  Use \texttt{next} and \texttt{step} to trace a recursive function.
\item
  Set a watchpoint on a variable in a loop.
\item
  Add a conditional breakpoint that triggers only when a value exceeds a
  limit.
\item
  Explore \texttt{backtrace} and \texttt{info\ locals} after a crash.
\end{enumerate}

Next, you'll learn how to \textbf{detect hidden memory errors}, leaks,
invalid frees, and buffer overflows, using the indispensable
\textbf{Valgrind} tool.

\subsection{72. Using Valgrind for Memory
Checking}\label{using-valgrind-for-memory-checking}

If gdb helps you \emph{see} how your program runs, \textbf{Valgrind}
helps you \emph{see where it leaks}. C gives you raw control over
memory, and that means you're responsible for every allocation,
deallocation, and pointer access.

Valgrind is your best friend when you need to find:

\begin{itemize}
\tightlist
\item
  Memory leaks (forgotten \texttt{free()})
\item
  Invalid reads/writes
\item
  Double frees
\item
  Use-after-free errors
\end{itemize}

Let's learn how to use it to make your programs solid and leak-free.

\subsubsection{Step 1. Installing
Valgrind}\label{step-1.-installing-valgrind}

On Linux:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt install valgrind}
\end{Highlighting}
\end{Shaded}

On macOS (with Homebrew):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{brew}\NormalTok{ install valgrind}
\end{Highlighting}
\end{Shaded}

Compile your program \textbf{with debug symbols}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ memory.c }\AttributeTok{{-}o}\NormalTok{ memory}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 2. Running with
Valgrind}\label{step-2.-running-with-valgrind}

Run your program under Valgrind:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind}\NormalTok{ ./memory}
\end{Highlighting}
\end{Shaded}

Valgrind runs your program inside a virtual CPU and monitors every
memory operation. At the end, it prints a detailed report of allocations
and leaks.

\subsubsection{Step 3. A Simple Example}\label{step-3.-a-simple-example}

Here's a program with two common mistakes: a leak and an invalid free.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{    p}\OperatorTok{[}\DecValTok{10}\OperatorTok{]} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}  \CommentTok{// invalid write (out of bounds)}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}    \CommentTok{// forgot to free(p)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ mem\_bug.c }\AttributeTok{{-}o}\NormalTok{ mem\_bug}
\FunctionTok{valgrind}\NormalTok{ ./mem\_bug}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
==1234== Invalid write of size 4
==1234==    at 0x1091A: main (mem_bug.c:6)
==1234==  Address 0x5201048 is 0 bytes after a block of size 40 alloc'd
==1234==    at 0x484186F: malloc (vg_replace_malloc.c:380)
==1234==
==1234== HEAP SUMMARY:
==1234==    definitely lost: 40 bytes in 1 blocks
==1234== LEAK SUMMARY:
==1234==    definitely lost: 40 bytes in 1 blocks
\end{verbatim}

Valgrind caught both the invalid access \textbf{and} the leak.

\subsubsection{Step 4. Fixing the
Errors}\label{step-4.-fixing-the-errors}

Correct version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{p}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{[}\DecValTok{9}\OperatorTok{]} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}   \CommentTok{// valid index}
\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run again:

\begin{verbatim}
valgrind ./mem_bug
\end{verbatim}

Output:

\begin{verbatim}
== All heap blocks were freed -- no leaks are possible
== ERROR SUMMARY: 0 errors from 0 contexts
\end{verbatim}

Clean and perfect.

\subsubsection{Step 5. Detecting
Use-After-Free}\label{step-5.-detecting-use-after-free}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// using freed memory}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Valgrind says:

\begin{verbatim}
==1234== Invalid read of size 4
==1234==    at 0x1091A: main (use_after_free.c:7)
==1234==  Address 0x5201040 is 0 bytes inside a block of size 4 free'd
\end{verbatim}

It even shows \emph{where} the block was freed.

\subsubsection{Step 6. Detecting Double
Free}\label{step-6.-detecting-double-free}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{4}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Valgrind output:

\begin{verbatim}
==1234== Invalid free() / delete / delete[]
==1234==    at 0x4845DEF: free (vg_replace_malloc.c:872)
==1234==  Address 0x5201040 was freed previously
\end{verbatim}

\subsubsection{Step 7. Memory Leak
Categories}\label{step-7.-memory-leak-categories}

Valgrind divides leaks into categories:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.2603}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.7397}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{definitely lost} & No pointer to the block remains, true leak \\
\textbf{indirectly lost} & Referenced by a leaked block \\
\textbf{possibly lost} & Pointer may exist but Valgrind can't confirm \\
\textbf{still reachable} & Program ended but memory wasn't freed (often
harmless) \\
\end{longtable}

\subsubsection{Step 8. Getting a Clean
Report}\label{step-8.-getting-a-clean-report}

To check for true leaks only:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind} \AttributeTok{{-}{-}leak{-}check}\OperatorTok{=}\NormalTok{full }\AttributeTok{{-}{-}show{-}leak{-}kinds}\OperatorTok{=}\NormalTok{definite ./program}
\end{Highlighting}
\end{Shaded}

For more verbose tracking:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind} \AttributeTok{{-}{-}track{-}origins}\OperatorTok{=}\NormalTok{yes ./program}
\end{Highlighting}
\end{Shaded}

That flag tells you \emph{where} an uninitialized variable first
appeared.

\subsubsection{Step 9. Checking for Stack or Uninitialized
Values}\label{step-9.-checking-for-stack-or-uninitialized-values}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// uninitialized read}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Valgrind output:

\begin{verbatim}
==1234== Use of uninitialised value of size 4
==1234==    at 0x1091A: main (uninit.c:5)
\end{verbatim}

Always initialize your variables!

\subsubsection{Step 10. Tiny Code: Leak
Detector}\label{step-10.-tiny-code-leak-detector}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ leak1}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{100}\OperatorTok{);} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ leak2}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} \DataTypeTok{char} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{50}\OperatorTok{);}\NormalTok{ free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    leak1}\OperatorTok{();}
\NormalTok{    leak2}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind} \AttributeTok{{-}{-}leak{-}check}\OperatorTok{=}\NormalTok{full ./leaks}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
==1234== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1
==1234== LEAK SUMMARY:
==1234==    definitely lost: 100 bytes in 1 blocks
\end{verbatim}

Only \texttt{leak1()} forgot to \texttt{free()}, Valgrind pinpointed it
exactly.

\subsubsection{Why It Matters}\label{why-it-matters-60}

Valgrind helps you:

\begin{itemize}
\tightlist
\item
  Find hidden memory leaks
\item
  Detect invalid pointer usage
\item
  Catch uninitialized values
\item
  Write safer, cleaner, more reliable C
\end{itemize}

It's an essential tool in your workflow, especially for long-running
programs, servers, or systems software.

\subsubsection{Try It Yourself}\label{try-it-yourself-70}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a program that allocates multiple blocks and forgets to free
  one.
\item
  Intentionally use \texttt{p{[}10{]}} on a \texttt{malloc(10)} block.
\item
  Trigger a use-after-free and find it in Valgrind.
\item
  Use \texttt{-\/-track-origins=yes} to trace uninitialized data.
\item
  Refactor your code until Valgrind reports:

\begin{verbatim}
All heap blocks were freed -- no leaks are possible
\end{verbatim}
\end{enumerate}

Next, you'll explore \textbf{Assertions and Defensive Programming},
techniques to catch logic errors \emph{before} they reach runtime
crashes.

\subsection{73. Assertions and Defensive
Programming}\label{assertions-and-defensive-programming}

Bugs are inevitable, but crashes don't have to be. C gives you direct
power over the machine, which means \textbf{you must protect your own
assumptions}. That's where \textbf{assertions} and \textbf{defensive
programming} come in: they help you catch mistakes early, fail fast, and
make your code predictable.

\subsubsection{Step 1. What Is an
Assertion?}\label{step-1.-what-is-an-assertion}

An \textbf{assertion} is a sanity check built into your code. It tests
whether something you believe to be true \emph{actually is}. If not, the
program immediately stops with an error message, before things get
worse.

Include the header:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{b }\OperatorTok{!=} \DecValTok{0}\OperatorTok{);}  \CommentTok{// ensure no division by zero}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{b} is zero, the program aborts:

\begin{verbatim}
Assertion failed: (b != 0), function divide, file main.c, line 3.
\end{verbatim}

\subsubsection{Step 2. How Assertions
Work}\label{step-2.-how-assertions-work}

\texttt{assert(expression)} expands to something like:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(!(}\NormalTok{expression}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Assertion failed: }\SpecialCharTok{\%s}\StringTok{, file }\SpecialCharTok{\%s}\StringTok{, line }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
            \StringTok{"expression"}\OperatorTok{,}\NormalTok{ \_\_FILE\_\_}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{);}
\NormalTok{    abort}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

When compiled normally, it checks the condition. When compiled with
\texttt{-DNDEBUG}, assertions are disabled.

\subsubsection{Step 3. Enabling or Disabling
Assertions}\label{step-3.-enabling-or-disabling-assertions}

Default: assertions are active. To disable them (for production builds):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}DNDEBUG}\NormalTok{ program.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

In that build, \texttt{assert()} statements are removed.

This lets you keep your debug checks without slowing down release
binaries.

\subsubsection{Step 4. Practical
Example}\label{step-4.-practical-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ find\_max}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{arr }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ max }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{];}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ max}\OperatorTok{)}\NormalTok{ max }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
    \ControlFlowTok{return}\NormalTok{ max}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ data}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{8}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Max: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ find\_max}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \DecValTok{5}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you pass a \texttt{NULL} pointer or invalid length, the program fails
immediately.

\subsubsection{Step 5. Writing Good
Assertions}\label{step-5.-writing-good-assertions}

Assertions should test \emph{internal assumptions}, not user input. Bad:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{assert}\OperatorTok{(}\NormalTok{argc }\OperatorTok{==} \DecValTok{3}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ input output}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use assertions to check invariants inside your logic, things that
\emph{should never happen} unless there's a bug.

\subsubsection{Step 6. Defensive Programming
Techniques}\label{step-6.-defensive-programming-techniques}

Defensive programming goes beyond assertions, it's about \textbf{writing
code that assumes mistakes will happen}.

\textbf{Check every function return value:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"file.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"fopen"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Validate inputs:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Avoid undefined behavior:}

\begin{itemize}
\tightlist
\item
  Initialize all variables.
\item
  Don't access freed memory.
\item
  Check array bounds.
\item
  Always match \texttt{malloc()} with \texttt{free()}.
\end{itemize}

\subsubsection{Step 7. Assertions in Complex
Systems}\label{step-7.-assertions-in-complex-systems}

In large programs, assertions act like \emph{tripwires} to detect when
state becomes inconsistent.

Example: a queue

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ enqueue}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{queue}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{*}\NormalTok{count}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ value}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ max}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    assert}\OperatorTok{(*}\NormalTok{count }\OperatorTok{\textless{}}\NormalTok{ max}\OperatorTok{);}
\NormalTok{    queue}\OperatorTok{[*}\NormalTok{count}\OperatorTok{]} \OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
    \OperatorTok{(*}\NormalTok{count}\OperatorTok{)++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If something goes wrong in your logic, the assertion will tell you
immediately, before memory corruption happens.

\subsubsection{Step 8. Logging vs
Assertions}\label{step-8.-logging-vs-assertions}

\begin{itemize}
\tightlist
\item
  \textbf{Assertions}: catch programming errors.
\item
  \textbf{Logging}: record runtime information.
\end{itemize}

Combine both:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ read\_value}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ index}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{index }\OperatorTok{\textgreater{}=} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ index }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Reading arr[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ index}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{index}\OperatorTok{]);}
    \ControlFlowTok{return}\NormalTok{ arr}\OperatorTok{[}\NormalTok{index}\OperatorTok{];}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Step 9. Using \texttt{static\_assert} for
Compile-Time Checks
(C11+)}{Step 9. Using static\_assert for Compile-Time Checks (C11+)}}\label{step-9.-using-static_assert-for-compile-time-checks-c11}

C11 introduced \texttt{\_Static\_assert}, which checks conditions
\textbf{during compilation}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\KeywordTok{\_Static\_assert}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)} \OperatorTok{==} \DecValTok{4}\OperatorTok{,} \StringTok{"int must be 4 bytes"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If the condition fails, the compiler stops with:

\begin{verbatim}
error: static assertion failed: "int must be 4 bytes"
\end{verbatim}

This is perfect for configuration or architecture assumptions.

\subsubsection{Step 10. Tiny Code: Safe Array
Access}\label{step-10.-tiny-code-safe-array-access}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MAX }\DecValTok{5}

\DataTypeTok{int}\NormalTok{ safe\_get}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ i}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{i }\OperatorTok{\textgreater{}=} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\NormalTok{MAX}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ safe\_get}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,}\NormalTok{ MAX}\OperatorTok{,} \DecValTok{2}\OperatorTok{));}  \CommentTok{// OK}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ safe\_get}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,}\NormalTok{ MAX}\OperatorTok{,} \DecValTok{10}\OperatorTok{));} \CommentTok{// triggers assertion}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Assertion failed: (i >= 0 && i < n), function safe_get, file main.c, line 7.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-61}

Assertions and defensive coding make your software:

\begin{itemize}
\tightlist
\item
  \textbf{Safer}, catch bugs early.
\item
  \textbf{Easier to debug}, fail at the source, not later.
\item
  \textbf{More maintainable}, documents assumptions clearly.
\end{itemize}

In C, a single bad pointer can crash your system. Assertions are your
safety net.

\subsubsection{Try It Yourself}\label{try-it-yourself-71}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add assertions to your stack or linked list implementation.
\item
  Write a function that validates all arguments before proceeding.
\item
  Use \texttt{\_Static\_assert} to check type sizes in a cross-platform
  program.
\item
  Combine assertions with logging for detailed error reports.
\item
  Run your program with invalid input and see how quickly assertions
  detect issues.
\end{enumerate}

Next, you'll move into \textbf{unit testing in C}, building small,
automated tests to ensure every function works exactly as intended.

\subsection{74. Unit Testing in C}\label{unit-testing-in-c}

Testing isn't just something you do at the end, it's how you
\textbf{build confidence} in every line of code. Unit testing means
checking small, isolated pieces (functions, modules) automatically, so
you can change your code without fear.

C doesn't come with a built-in testing framework, but it's easy to build
lightweight ones, and several excellent libraries exist if you want more
power.

Let's walk through how to design and run \textbf{unit tests in plain C}.

\subsubsection{Step 1. What Is Unit
Testing?}\label{step-1.-what-is-unit-testing}

A \emph{unit test} verifies a single behavior:

\begin{quote}
Given an input, does this function produce the correct output?
\end{quote}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ test\_add}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{)} \OperatorTok{!=} \DecValTok{5}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"test\_add failed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}\NormalTok{ printf}\OperatorTok{(}\StringTok{"test\_add passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run this test:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    test\_add}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
test_add passed!
\end{verbatim}

Simple, but powerful.

\subsubsection{Step 2. Organizing Tests}\label{step-2.-organizing-tests}

Keep tests separate from production code. A typical layout:

\begin{verbatim}
src/
  math.c
  math.h
tests/
  test_math.c
Makefile
\end{verbatim}

Your Makefile might build both:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all:}
\NormalTok{    gcc {-}g {-}Wall {-}I../src ../src/math.c test\_math.c {-}o test\_math}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. Writing Reusable Test
Helpers}\label{step-3.-writing-reusable-test-helpers}

Define macros to simplify your checks.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define ASSERT\_EQ\_INT}\OperatorTok{(}\PreprocessorTok{expected}\OperatorTok{,}\PreprocessorTok{ actual}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{expected}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{!=}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{actual}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"FAIL: }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{: expected }\SpecialCharTok{\%d}\StringTok{, got }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{expected}\OperatorTok{),}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{actual}\OperatorTok{));}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{else}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"PASS: }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ test\_add}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    ASSERT\_EQ\_INT}\OperatorTok{(}\DecValTok{5}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\NormalTok{    ASSERT\_EQ\_INT}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ add}\OperatorTok{({-}}\DecValTok{1}\OperatorTok{,} \DecValTok{1}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ test\_add}\OperatorTok{();} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
PASS: test_math.c:10
PASS: test_math.c:11
\end{verbatim}

\subsubsection{Step 4. Testing Multiple
Functions}\label{step-4.-testing-multiple-functions}

Add more test functions and call them in sequence:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ test\_subtract}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ ASSERT\_EQ\_INT}\OperatorTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{3} \OperatorTok{{-}} \DecValTok{2}\OperatorTok{);} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    test\_add}\OperatorTok{();}
\NormalTok{    test\_subtract}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now your program automatically verifies both functions.

\subsubsection{Step 5. Handling Floating-Point
Comparisons}\label{step-5.-handling-floating-point-comparisons}

Floating-point values rarely match exactly, use a tolerance.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}math.h\textgreater{}}
\PreprocessorTok{\#define ASSERT\_EQ\_FLOAT}\OperatorTok{(}\PreprocessorTok{expected}\OperatorTok{,}\PreprocessorTok{ actual}\OperatorTok{,}\PreprocessorTok{ eps}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{fabs}\OperatorTok{((}\PreprocessorTok{expected}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{{-}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{actual}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\textgreater{}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{eps}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"FAIL: expected }\SpecialCharTok{\%.3f}\StringTok{, got }\SpecialCharTok{\%.3f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{expected}\OperatorTok{),}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{actual}\OperatorTok{));}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{else}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"PASS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Using Return Codes to Mark
Failures}\label{step-6.-using-return-codes-to-mark-failures}

Instead of just printing results, you can make the test binary return
\texttt{EXIT\_FAILURE} if any test fails.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ fails }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\PreprocessorTok{\#define TEST}\OperatorTok{(}\PreprocessorTok{cond}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{do}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{(!(}\PreprocessorTok{cond}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"FAIL: }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#}\PreprocessorTok{cond}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        fails}\OperatorTok{++;}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{else}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        printf}\OperatorTok{(}\StringTok{"PASS: }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\OperatorTok{\}}\PreprocessorTok{ }\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{while}\PreprocessorTok{ }\OperatorTok{(}\DecValTok{0}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

At the end:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{return}\NormalTok{ fails }\OperatorTok{?}\NormalTok{ EXIT\_FAILURE }\OperatorTok{:}\NormalTok{ EXIT\_SUCCESS}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now your CI or shell can detect test results via \texttt{\$?}.

\subsubsection{Step 7. Minimal Testing Framework:
TinyTest}\label{step-7.-minimal-testing-framework-tinytest}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ tests\_run }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ tests\_failed }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\PreprocessorTok{\#define TEST}\OperatorTok{(}\PreprocessorTok{name}\OperatorTok{)}\PreprocessorTok{ }\DataTypeTok{void}\PreprocessorTok{ name}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)}
\PreprocessorTok{\#define RUN}\OperatorTok{(}\PreprocessorTok{test}\OperatorTok{)}\PreprocessorTok{ }\ControlFlowTok{do}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"Running }\SpecialCharTok{\%s}\StringTok{... "}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#}\PreprocessorTok{test}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    test}\OperatorTok{();}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    tests\_run}\OperatorTok{++;}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"OK}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{while}\OperatorTok{(}\DecValTok{0}\OperatorTok{)}
\PreprocessorTok{\#define ASSERT\_TRUE}\OperatorTok{(}\PreprocessorTok{cond}\OperatorTok{)}\PreprocessorTok{ }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{(!(}\PreprocessorTok{cond}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{  Assertion failed: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#}\PreprocessorTok{cond}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    tests\_failed}\OperatorTok{++;}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{return}\OperatorTok{;}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\OperatorTok{\}}

\NormalTok{TEST}\OperatorTok{(}\NormalTok{test\_addition}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{3}\OperatorTok{;}
\NormalTok{    ASSERT\_TRUE}\OperatorTok{(}\NormalTok{sum }\OperatorTok{==} \DecValTok{5}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    RUN}\OperatorTok{(}\NormalTok{test\_addition}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Tests run: }\SpecialCharTok{\%d}\StringTok{, failed: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ tests\_run}\OperatorTok{,}\NormalTok{ tests\_failed}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ tests\_failed }\OperatorTok{?}\NormalTok{ EXIT\_FAILURE }\OperatorTok{:}\NormalTok{ EXIT\_SUCCESS}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Running test_addition... OK

Tests run: 1, failed: 0
\end{verbatim}

\subsubsection{Step 8. Using Real Testing
Libraries}\label{step-8.-using-real-testing-libraries}

When your project grows, you can use frameworks like:

\begin{itemize}
\tightlist
\item
  \textbf{Check} (POSIX-compliant)
\item
  \textbf{Unity} (embedded-friendly)
\item
  \textbf{CMocka}
\item
  \textbf{Criterion}
\end{itemize}

Example with \emph{Check}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt install check}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}check.h\textgreater{}}

\NormalTok{START\_TEST}\OperatorTok{(}\NormalTok{test\_add}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    ck\_assert\_int\_eq}\OperatorTok{(}\DecValTok{2} \OperatorTok{+} \DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\OperatorTok{\}}
\NormalTok{END\_TEST}
\end{Highlighting}
\end{Shaded}

Then compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ test.c }\AttributeTok{{-}lcheck} \AttributeTok{{-}o}\NormalTok{ test}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Automating Tests with
Makefile}\label{step-9.-automating-tests-with-makefile}

Add a test target:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{test:}
\NormalTok{    gcc {-}Wall {-}g src/*.c tests/*.c {-}o tests/run\_tests}
\NormalTok{    ./tests/run\_tests}
\end{Highlighting}
\end{Shaded}

Now you can just run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ test}
\end{Highlighting}
\end{Shaded}

and see your full suite's results.

\subsubsection{Step 10. Tiny Code: Testing a Linked
List}\label{step-10.-tiny-code-testing-a-linked-list}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{next}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\NormalTok{Node }\OperatorTok{*}\NormalTok{push}\OperatorTok{(}\NormalTok{Node }\OperatorTok{*}\NormalTok{head}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ val}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ val}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{next }\OperatorTok{=}\NormalTok{ head}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ test\_push}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{head }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    head }\OperatorTok{=}\NormalTok{ push}\OperatorTok{(}\NormalTok{head}\OperatorTok{,} \DecValTok{10}\OperatorTok{);}
\NormalTok{    head }\OperatorTok{=}\NormalTok{ push}\OperatorTok{(}\NormalTok{head}\OperatorTok{,} \DecValTok{20}\OperatorTok{);}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{head}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{==} \DecValTok{20}\OperatorTok{);}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{head}\OperatorTok{{-}\textgreater{}}\NormalTok{next}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{==} \DecValTok{10}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"test\_push passed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    test\_push}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"All tests passed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
test_push passed
All tests passed.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-62}

Unit testing turns code into \textbf{verifiable logic}:

\begin{itemize}
\tightlist
\item
  Prevents regressions.
\item
  Encourages small, clean functions.
\item
  Makes debugging faster.
\item
  Builds confidence before refactoring.
\end{itemize}

When you trust your tests, you can rewrite your code fearlessly.

\subsubsection{Try It Yourself}\label{try-it-yourself-72}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a test suite for your dynamic array implementation.
\item
  Add \texttt{ASSERT\_EQ\_FLOAT} and \texttt{ASSERT\_EQ\_STR} macros.
\item
  Automate tests using \texttt{make\ test}.
\item
  Add a \texttt{fails} counter and colorize your results.
\item
  Use a testing library like \emph{Criterion} or \emph{Unity} and
  compare styles.
\end{enumerate}

Next, you'll learn how to \textbf{add logging systems} to your C
programs, to record what's happening under the hood in a controlled,
readable way.

\subsection{75. Logging Systems}\label{logging-systems}

As your programs grow, \textbf{printf debugging} quickly becomes messy.
You need a way to \emph{see inside your program}, what it's doing, what
went wrong, and why, without flooding your terminal with random
messages.

That's where \textbf{logging systems} come in. A good log system helps
you trace execution, record errors, and understand how your program
behaves over time.

\subsubsection{Step 1. What Is Logging?}\label{step-1.-what-is-logging}

Logging is like keeping a diary for your program. Instead of printing
everything to the screen, you log structured messages with
\textbf{levels} (INFO, WARN, ERROR) and \textbf{timestamps}.

It's essential for:

\begin{itemize}
\tightlist
\item
  Debugging complex flows.
\item
  Auditing events and errors.
\item
  Monitoring long-running services.
\item
  Diagnosing crashes and performance issues.
\end{itemize}

\subsubsection{Step 2. The Simplest Logger, printf with
Context}\label{step-2.-the-simplest-logger-printf-with-context}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"[INFO] Starting program}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"[WARN] Low memory}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"[ERROR] Failed to open file}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This works, but there's no timestamp, file name, or severity control.

\subsubsection{Step 3. Adding Log Levels and
Macros}\label{step-3.-adding-log-levels-and-macros}

We can make this structured and reusable using macros.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{level}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\ControlFlowTok{do}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\DataTypeTok{time\_t}\PreprocessorTok{ t }\OperatorTok{=}\PreprocessorTok{ time}\OperatorTok{(}\PreprocessorTok{NULL}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\KeywordTok{struct}\PreprocessorTok{ tm }\OperatorTok{*}\PreprocessorTok{tm\_info }\OperatorTok{=}\PreprocessorTok{ localtime}\OperatorTok{(\&}\PreprocessorTok{t}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\DataTypeTok{char}\PreprocessorTok{ buf}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    strftime}\OperatorTok{(}\PreprocessorTok{buf}\OperatorTok{,}\PreprocessorTok{ }\DecValTok{20}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"\%Y{-}\%m{-}}\SpecialCharTok{\%d}\StringTok{ \%H:\%M:\%S"}\OperatorTok{,}\PreprocessorTok{ tm\_info}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"[}\SpecialCharTok{\%s}\StringTok{] [}\SpecialCharTok{\%s}\StringTok{] "}\PreprocessorTok{ msg }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ buf}\OperatorTok{,}\PreprocessorTok{ level}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{while}\PreprocessorTok{ }\OperatorTok{(}\DecValTok{0}\OperatorTok{)}

\PreprocessorTok{\#define LOG\_INFO}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{  }\NormalTok{LOG}\OperatorTok{(}\StringTok{"INFO"}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{)}
\PreprocessorTok{\#define LOG\_WARN}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{  }\NormalTok{LOG}\OperatorTok{(}\StringTok{"WARN"}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{)}
\PreprocessorTok{\#define LOG\_ERROR}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\NormalTok{LOG}\OperatorTok{(}\StringTok{"ERROR"}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{)}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    LOG\_INFO}\OperatorTok{(}\StringTok{"Program started"}\OperatorTok{);}
\NormalTok{    LOG\_WARN}\OperatorTok{(}\StringTok{"Memory usage at }\SpecialCharTok{\%d\%\%}\StringTok{"}\OperatorTok{,} \DecValTok{80}\OperatorTok{);}
\NormalTok{    LOG\_ERROR}\OperatorTok{(}\StringTok{"File }\SpecialCharTok{\%s}\StringTok{ not found"}\OperatorTok{,} \StringTok{"data.txt"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
[2025-10-16 23:41:09] [INFO] Program started
[2025-10-16 23:41:09] [WARN] Memory usage at 80%
[2025-10-16 23:41:09] [ERROR] File data.txt not found
\end{verbatim}

Now your logs have consistent structure and useful context.

\subsubsection{Step 4. Controlling Log
Verbosity}\label{step-4.-controlling-log-verbosity}

Add a global log level:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum} \OperatorTok{\{}\NormalTok{ LOG\_LEVEL\_INFO}\OperatorTok{,}\NormalTok{ LOG\_LEVEL\_WARN}\OperatorTok{,}\NormalTok{ LOG\_LEVEL\_ERROR }\OperatorTok{\};}
\DataTypeTok{int}\NormalTok{ CURRENT\_LOG\_LEVEL }\OperatorTok{=}\NormalTok{ LOG\_LEVEL\_INFO}\OperatorTok{;}

\PreprocessorTok{\#define SHOULD\_LOG}\OperatorTok{(}\PreprocessorTok{level}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{level}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textgreater{}=}\PreprocessorTok{ CURRENT\_LOG\_LEVEL}\OperatorTok{)}
\PreprocessorTok{\#define LOGX}\OperatorTok{(}\PreprocessorTok{level}\OperatorTok{,}\PreprocessorTok{ tag}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\ControlFlowTok{do}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{SHOULD\_LOG}\OperatorTok{(}\PreprocessorTok{level}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        }\DataTypeTok{time\_t}\PreprocessorTok{ t }\OperatorTok{=}\PreprocessorTok{ time}\OperatorTok{(}\PreprocessorTok{NULL}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        }\KeywordTok{struct}\PreprocessorTok{ tm }\OperatorTok{*}\PreprocessorTok{tm\_info }\OperatorTok{=}\PreprocessorTok{ localtime}\OperatorTok{(\&}\PreprocessorTok{t}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        }\DataTypeTok{char}\PreprocessorTok{ buf}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        strftime}\OperatorTok{(}\PreprocessorTok{buf}\OperatorTok{,}\PreprocessorTok{ }\DecValTok{20}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"\%H:\%M:\%S"}\OperatorTok{,}\PreprocessorTok{ tm\_info}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"[}\SpecialCharTok{\%s}\StringTok{] [}\SpecialCharTok{\%s}\StringTok{] "}\PreprocessorTok{ msg }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ buf}\OperatorTok{,}\PreprocessorTok{ tag}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\OperatorTok{\}}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{while}\PreprocessorTok{ }\OperatorTok{(}\DecValTok{0}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Now:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LOGX}\OperatorTok{(}\NormalTok{LOG\_LEVEL\_INFO}\OperatorTok{,} \StringTok{"INFO"}\OperatorTok{,} \StringTok{"Running"}\OperatorTok{);}
\NormalTok{LOGX}\OperatorTok{(}\NormalTok{LOG\_LEVEL\_WARN}\OperatorTok{,} \StringTok{"WARN"}\OperatorTok{,} \StringTok{"Low disk space"}\OperatorTok{);}
\NormalTok{LOGX}\OperatorTok{(}\NormalTok{LOG\_LEVEL\_ERROR}\OperatorTok{,} \StringTok{"ERROR"}\OperatorTok{,} \StringTok{"Crash at line }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Change verbosity dynamically:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CURRENT\_LOG\_LEVEL }\OperatorTok{=}\NormalTok{ LOG\_LEVEL\_WARN}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now INFO messages are skipped.

\subsubsection{Step 5. Logging to a
File}\label{step-5.-logging-to-a-file}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ log\_to\_file}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}
    \DataTypeTok{time\_t}\NormalTok{ t }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ctime}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{),}\NormalTok{ msg}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    log\_to\_file}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"Program started"}\OperatorTok{);}
\NormalTok{    log\_to\_file}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"Action complete"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The log file will contain:

\begin{verbatim}
Thu Oct 16 23:41:09 2025: Program started
Thu Oct 16 23:41:10 2025: Action complete
\end{verbatim}

\subsubsection{Step 6. Including File and Line
Information}\label{step-6.-including-file-and-line-information}

You can include source info automatically using \texttt{\_\_FILE\_\_}
and \texttt{\_\_LINE\_\_}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define LOG\_DEBUG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"[DEBUG] }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{ "}\PreprocessorTok{ msg }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LOG\_DEBUG}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
[DEBUG] main.c:42 x = 10
\end{verbatim}

\subsubsection{Step 7. Rotating or Limiting
Logs}\label{step-7.-rotating-or-limiting-logs}

For long-running programs, you don't want logs to grow forever. You can:

\begin{itemize}
\tightlist
\item
  Truncate or rename old files.
\item
  Only keep N entries.
\item
  Write daily logs (\texttt{log\_2025-10-16.txt}).
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ filename}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
\DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\NormalTok{strftime}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{filename}\OperatorTok{),} \StringTok{"log\_\%Y{-}\%m{-}}\SpecialCharTok{\%d}\StringTok{.txt"}\OperatorTok{,}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{));}
\NormalTok{log\_to\_file}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"Daily entry"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Adding Colors
(Optional)}\label{step-8.-adding-colors-optional}

Make console logs easier to read with ANSI color codes:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define RED   }\StringTok{"}\SpecialCharTok{\textbackslash{}x1b}\StringTok{[31m"}
\PreprocessorTok{\#define YEL   }\StringTok{"}\SpecialCharTok{\textbackslash{}x1b}\StringTok{[33m"}
\PreprocessorTok{\#define GRN   }\StringTok{"}\SpecialCharTok{\textbackslash{}x1b}\StringTok{[32m"}
\PreprocessorTok{\#define RST   }\StringTok{"}\SpecialCharTok{\textbackslash{}x1b}\StringTok{[0m"}

\PreprocessorTok{\#define LOGC}\OperatorTok{(}\PreprocessorTok{level}\OperatorTok{,}\PreprocessorTok{ color}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ color }\StringTok{"[}\SpecialCharTok{\%s}\StringTok{] "}\PreprocessorTok{ msg }\NormalTok{RST}\PreprocessorTok{ }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ level}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LOGC}\OperatorTok{(}\StringTok{"INFO"}\OperatorTok{,}\NormalTok{ GRN}\OperatorTok{,} \StringTok{"Server started"}\OperatorTok{);}
\NormalTok{LOGC}\OperatorTok{(}\StringTok{"WARN"}\OperatorTok{,}\NormalTok{ YEL}\OperatorTok{,} \StringTok{"High CPU usage"}\OperatorTok{);}
\NormalTok{LOGC}\OperatorTok{(}\StringTok{"ERROR"}\OperatorTok{,}\NormalTok{ RED}\OperatorTok{,} \StringTok{"Out of memory"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Combining Logging and
Assertions}\label{step-9.-combining-logging-and-assertions}

You can combine assertions with logs for extra safety:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}

\PreprocessorTok{\#define SAFE\_LOG}\OperatorTok{(}\PreprocessorTok{cond}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\ControlFlowTok{if}\PreprocessorTok{ }\OperatorTok{(!(}\PreprocessorTok{cond}\OperatorTok{))}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        }\NormalTok{LOG\_ERROR}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{        assert}\OperatorTok{(}\PreprocessorTok{cond}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If something fails, it both logs and triggers an assertion.

\subsubsection{Step 10. Tiny Code: Minimal
Logger}\label{step-10.-tiny-code-minimal-logger}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{fmt}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{...)}\PreprocessorTok{ }\ControlFlowTok{do}\PreprocessorTok{ }\OperatorTok{\{}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\DataTypeTok{time\_t}\PreprocessorTok{ now }\OperatorTok{=}\PreprocessorTok{ time}\OperatorTok{(}\PreprocessorTok{NULL}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    }\DataTypeTok{char}\PreprocessorTok{ buf}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    strftime}\OperatorTok{(}\PreprocessorTok{buf}\OperatorTok{,}\PreprocessorTok{ }\KeywordTok{sizeof}\OperatorTok{(}\PreprocessorTok{buf}\OperatorTok{),}\PreprocessorTok{ }\StringTok{"\%H:\%M:\%S"}\OperatorTok{,}\PreprocessorTok{ localtime}\OperatorTok{(\&}\PreprocessorTok{now}\OperatorTok{));}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    fprintf}\OperatorTok{(}\PreprocessorTok{stderr}\OperatorTok{,}\PreprocessorTok{ }\StringTok{"[}\SpecialCharTok{\%s}\StringTok{] "}\PreprocessorTok{ fmt }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ buf}\OperatorTok{,}\PreprocessorTok{ }\OperatorTok{\#\#}\PreprocessorTok{\_\_VA\_ARGS\_\_}\OperatorTok{);}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\OperatorTok{\}}\PreprocessorTok{ }\ControlFlowTok{while}\PreprocessorTok{ }\OperatorTok{(}\DecValTok{0}\OperatorTok{)}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Starting program"}\OperatorTok{);}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Loading config"}\OperatorTok{);}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Finished setup"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
[23:42:00] Starting program
[23:42:01] Loading config
[23:42:02] Finished setup
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-63}

Logging makes invisible processes visible. It helps you:

\begin{itemize}
\tightlist
\item
  Trace execution flow.
\item
  Debug production code.
\item
  Audit errors and warnings.
\item
  Understand system performance over time.
\end{itemize}

In real systems, servers, compilers, databases, \textbf{logs are your
lifeline} when things go wrong.

\subsubsection{Try It Yourself}\label{try-it-yourself-73}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \texttt{LOG\_INFO}, \texttt{LOG\_WARN}, and \texttt{LOG\_ERROR}
  macros to one of your C projects.
\item
  Write logs to both \texttt{stderr} and a file.
\item
  Add timestamps and line numbers automatically.
\item
  Add colors for each level.
\item
  Implement a rotating file log system that keeps only today's file
  active.
\end{enumerate}

Next, you'll learn about \textbf{profiling with gprof}, how to measure
where your program spends its time, and how to make it faster.

\subsection{76. Profiling with gprof}\label{profiling-with-gprof}

When your program works but feels \emph{slow}, guessing isn't enough,
you need to \textbf{measure}. Profiling shows you \emph{where} your
program spends its time, which functions are hot, and where optimization
truly matters.

C gives you a lot of control, but performance tuning without profiling
is like driving blindfolded. That's why we use \textbf{gprof}, the GNU
profiler, a tool that measures how long your code spends in each
function.

\subsubsection{Step 1. What Is
Profiling?}\label{step-1.-what-is-profiling}

\textbf{Profiling} is the process of recording runtime statistics such
as:

\begin{itemize}
\tightlist
\item
  How many times each function runs.
\item
  How much CPU time each function uses.
\item
  Which functions call which others.
\end{itemize}

It helps you find bottlenecks, functions that dominate runtime, and
focus your optimization there.

\subsubsection{Step 2. Enabling Profiling with
gprof}\label{step-2.-enabling-profiling-with-gprof}

Compile your program with the \texttt{-pg} flag to enable profiling
hooks:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

Run the program normally:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program}
\end{Highlighting}
\end{Shaded}

After it finishes, a file named \texttt{gmon.out} is created. This file
contains execution data collected during runtime.

Generate a report:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{gprof}\NormalTok{ program gmon.out }\OperatorTok{\textgreater{}}\NormalTok{ analysis.txt}
\end{Highlighting}
\end{Shaded}

Now open \texttt{analysis.txt} to see where your program spent its time.

\subsubsection{Step 3. Example Program}\label{step-3.-example-program}

Here's a small example to demonstrate profiling:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ slow\_function}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{volatile} \DataTypeTok{long}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ fast\_function}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{volatile} \DataTypeTok{long}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    slow\_function}\OperatorTok{();}
\NormalTok{    fast\_function}\OperatorTok{();}
\NormalTok{    slow\_function}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ profile\_me}
\ExtensionTok{./profile\_me}
\ExtensionTok{gprof}\NormalTok{ profile\_me gmon.out }\OperatorTok{\textgreater{}}\NormalTok{ report.txt}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Reading the gprof
Report}\label{step-4.-reading-the-gprof-report}

The report has two key sections:

\textbf{1. Flat Profile}

\begin{verbatim}
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   ms/call  ms/call  name
 66.7      0.20     0.20        2   100.00   100.00  slow_function
 33.3      0.30     0.10        1   100.00   100.00  fast_function
\end{verbatim}

This tells you:

\begin{itemize}
\tightlist
\item
  \texttt{slow\_function()} took 66\% of total time.
\item
  \texttt{fast\_function()} took 33\%.
\end{itemize}

\textbf{2. Call Graph}

\begin{verbatim}
index % time    self  children    called     name
                0.20    0.00       2/2       slow_function
                0.10    0.00       1/1       fast_function
\end{verbatim}

This shows relationships, which functions called which, and how time was
distributed among them.

\subsubsection{Step 5. Profiling Multi-File
Programs}\label{step-5.-profiling-multi-file-programs}

When working on multiple \texttt{.c} files, just compile each with
\texttt{-pg}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg} \AttributeTok{{-}c}\NormalTok{ foo.c}
\FunctionTok{gcc} \AttributeTok{{-}pg} \AttributeTok{{-}c}\NormalTok{ bar.c}
\FunctionTok{gcc} \AttributeTok{{-}pg}\NormalTok{ foo.o bar.o }\AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

Then run and analyze as before.

\subsubsection{Step 6. Ignoring Initialization or Short
Runs}\label{step-6.-ignoring-initialization-or-short-runs}

Profiling works best for \emph{real workloads}. Avoid profiling tiny
runs, because initialization costs can dominate and distort results.

For example, a 10 ms startup delay might look huge if your program only
runs 20 ms in total. Use representative input and real loops to get
meaningful data.

\subsubsection{Step 7. Focusing on
Hotspots}\label{step-7.-focusing-on-hotspots}

When you know which functions dominate runtime (often the top 5\%), you
can:

\begin{itemize}
\tightlist
\item
  Inline them manually.
\item
  Use better data structures.
\item
  Reduce allocations.
\item
  Simplify inner loops.
\end{itemize}

Optimization is about precision, don't guess where your code is slow;
let the profiler prove it.

\subsubsection{Step 8. Combining gprof with Compiler
Optimizations}\label{step-8.-combining-gprof-with-compiler-optimizations}

Compare your performance before and after adding optimization flags:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg} \AttributeTok{{-}O0}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ slow}
\FunctionTok{gcc} \AttributeTok{{-}pg} \AttributeTok{{-}O3}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ fast}
\end{Highlighting}
\end{Shaded}

Then run both and inspect the reports. You'll see dramatic changes in
timing distribution, sometimes even inlined functions disappear entirely
from the profile.

\subsubsection{Step 9. Visualizing
Profiles}\label{step-9.-visualizing-profiles}

You can visualize gprof results using \textbf{gprof2dot} and
\textbf{Graphviz}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{pip}\NormalTok{ install gprof2dot}
\ExtensionTok{gprof}\NormalTok{ program gmon.out }\KeywordTok{|} \ExtensionTok{gprof2dot} \KeywordTok{|} \ExtensionTok{dot} \AttributeTok{{-}Tpng} \AttributeTok{{-}o}\NormalTok{ profile.png}
\end{Highlighting}
\end{Shaded}

This generates a \textbf{call graph image}, showing which functions
dominate. The thicker the arrow, the more time is spent there.

\subsubsection{Step 10. Tiny Code: Measuring a Sorting
Algorithm}\label{step-10.-tiny-code-measuring-a-sorting-algorithm}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\PreprocessorTok{\#define N }\DecValTok{100000}

\DataTypeTok{void}\NormalTok{ bubble\_sort}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ n }\OperatorTok{{-}}\NormalTok{ i }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{])} \OperatorTok{\{}
                \DataTypeTok{int}\NormalTok{ tmp }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{];}
\NormalTok{                arr}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{];}
\NormalTok{                arr}\OperatorTok{[}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{]} \OperatorTok{=}\NormalTok{ tmp}\OperatorTok{;}
            \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ fill\_random}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{arr}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ rand}\OperatorTok{()} \OperatorTok{\%} \DecValTok{100000}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{N }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{    fill\_random}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ N}\OperatorTok{);}
\NormalTok{    bubble\_sort}\OperatorTok{(}\NormalTok{arr}\OperatorTok{,}\NormalTok{ N}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}pg}\NormalTok{ main.c }\AttributeTok{{-}O0} \AttributeTok{{-}o}\NormalTok{ sort\_profile}
\ExtensionTok{./sort\_profile}
\ExtensionTok{gprof}\NormalTok{ sort\_profile gmon.out }\KeywordTok{|} \FunctionTok{head} \AttributeTok{{-}n}\NormalTok{ 20}
\end{Highlighting}
\end{Shaded}

Output (excerpt):

\begin{verbatim}
  %   cumulative   self              self     total
 time   seconds   seconds    calls   ms/call  ms/call  name
 95.0      0.95     0.95        1   950.00   950.00  bubble_sort
\end{verbatim}

This tells you 95\% of time is spent in \texttt{bubble\_sort()},
confirming the algorithmic bottleneck.

\subsubsection{Why It Matters}\label{why-it-matters-64}

Profiling bridges the gap between ``feels slow'' and \textbf{knowing
why}. It helps you:

\begin{itemize}
\tightlist
\item
  Focus optimization effort where it matters most.
\item
  Verify improvements quantitatively.
\item
  Eliminate guesswork.
\end{itemize}

In performance engineering, \textbf{measurement beats intuition} every
time.

\subsubsection{Try It Yourself}\label{try-it-yourself-74}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Profile your own sorting or search algorithm.
\item
  Compare results between \texttt{-O0}, \texttt{-O2}, and \texttt{-O3}.
\item
  Profile a multithreaded or I/O-bound program.
\item
  Visualize results with \texttt{gprof2dot}.
\item
  Identify one bottleneck and fix it, then re-profile to see the
  difference.
\end{enumerate}

Next, you'll explore \textbf{common undefined behaviors} in C, the
silent bugs that can make your perfectly profiled program crash
unpredictably.

\subsection{77. Common Undefined
Behaviors}\label{common-undefined-behaviors}

C gives you freedom, but also \textbf{responsibility}. Unlike
higher-level languages, C doesn't protect you from dangerous mistakes.
Some actions cause \textbf{undefined behavior (UB)}: the compiler is
allowed to do \emph{anything} in response, crash, hang, or even appear
to work fine until it doesn't.

Undefined behavior is what makes C both powerful and perilous. Let's
explore what causes it, how to recognize it, and how to write code that
never falls into its traps.

\subsubsection{Step 1. What Is Undefined
Behavior?}\label{step-1.-what-is-undefined-behavior}

In the C standard, \textbf{undefined behavior} means ``no rules apply.''
If your program does something the language doesn't define, the compiler
can assume it never happens and optimize freely.

This means your program might:

\begin{itemize}
\tightlist
\item
  Crash immediately.
\item
  Produce wrong results.
\item
  Behave differently each time.
\item
  Work fine on one compiler and fail on another.
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5} \OperatorTok{/} \DecValTok{0}\OperatorTok{;}  \CommentTok{// UB: division by zero}
\end{Highlighting}
\end{Shaded}

The compiler is \emph{not required} to warn you or handle this safely.

\subsubsection{Step 2. Common Sources of
UB}\label{step-2.-common-sources-of-ub}

Here are the most frequent offenders every C programmer must know:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4688}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5312}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Category
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Out-of-bounds access} & \texttt{arr{[}10{]}} when the array has
10 elements \\
\textbf{Use of uninitialized variable} &
\texttt{int\ x;\ printf("\%d",\ x);} \\
\textbf{Dangling pointer access} & Use memory after \texttt{free()} \\
\textbf{Invalid pointer arithmetic} & \texttt{(p\ +\ 5)} when \texttt{p}
doesn't point into an array \\
\textbf{Signed integer overflow} &
\texttt{int\ x\ =\ INT\_MAX\ +\ 1;} \\
\textbf{Modifying and reading same variable} & \texttt{i\ =\ i++;} or
\texttt{a{[}i{]}\ =\ i++;} \\
\textbf{Null pointer dereference} &
\texttt{int\ *p\ =\ NULL;\ *p\ =\ 5;} \\
\textbf{Incorrect type punning} & Accessing a float as int through wrong
pointer type \\
\textbf{Mismatched \texttt{malloc}/\texttt{free}} & \texttt{free()}
memory not allocated by \texttt{malloc()} \\
\textbf{Violating \texttt{const} or \texttt{volatile} contracts} &
Writing to a \texttt{const} variable \\
\end{longtable}

\subsubsection{Step 3. Out-of-Bounds
Access}\label{step-3.-out-of-bounds-access}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]);}  \CommentTok{// UB: index 3 is past the end}
\end{Highlighting}
\end{Shaded}

C doesn't check bounds, you're responsible for it. You might print
garbage, crash, or accidentally overwrite another variable.

Always check:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{index }\OperatorTok{\textgreater{}=} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ index }\OperatorTok{\textless{}}\NormalTok{ size}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{index}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Using Uninitialized
Variables}\label{step-4.-using-uninitialized-variables}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}  \CommentTok{// UB: x is uninitialized}
\end{Highlighting}
\end{Shaded}

Even if it prints \texttt{0}, that's luck, not correctness. Always
initialize your variables explicitly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Dangling
Pointers}\label{step-5.-dangling-pointers}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}  \CommentTok{// UB: accessing freed memory}
\end{Highlighting}
\end{Shaded}

After \texttt{free()}, the pointer still \emph{exists} but the memory
doesn't belong to you. Set it to \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Signed Integer
Overflow}\label{step-6.-signed-integer-overflow}

In C, \textbf{signed overflow is undefined}, but unsigned overflow wraps
around predictably.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2147483647}\OperatorTok{;}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}  \CommentTok{// UB}
\end{Highlighting}
\end{Shaded}

Unsigned version:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{4294967295}\OperatorTok{;}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}  \CommentTok{// wraps to 0 (defined)}
\end{Highlighting}
\end{Shaded}

To check overflow safely:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}}\NormalTok{ INT\_MAX }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"overflow}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    x }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Modifying and Reading in One
Expression}\label{step-7.-modifying-and-reading-in-one-expression}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{i }\OperatorTok{=}\NormalTok{ i}\OperatorTok{++} \OperatorTok{+} \DecValTok{1}\OperatorTok{;}  \CommentTok{// UB: reading and writing i without sequence point}
\end{Highlighting}
\end{Shaded}

Avoid combining side effects. Write clean code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i}\OperatorTok{++;}
\NormalTok{i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Null Pointer
Dereference}\label{step-8.-null-pointer-dereference}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}  \CommentTok{// UB}
\end{Highlighting}
\end{Shaded}

Always validate pointers:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Type Punning and
Aliasing}\label{step-9.-type-punning-and-aliasing}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ f }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{ip }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int} \OperatorTok{*)\&}\NormalTok{f}\OperatorTok{;}  \CommentTok{// UB: violates strict aliasing}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ip}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you must reinterpret bytes, use \texttt{memcpy}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
\NormalTok{memcpy}\OperatorTok{(\&}\NormalTok{i}\OperatorTok{,} \OperatorTok{\&}\NormalTok{f}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{i}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

This avoids aliasing violations and is safe across compilers.

\subsubsection{Step 10. Tiny Code: Detecting UB with
Tools}\label{step-10.-tiny-code-detecting-ub-with-tools}

Use \textbf{compilers and runtime checkers} to detect UB before it hits
production.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{undefined }\AttributeTok{{-}g}\NormalTok{ ub\_example.c }\AttributeTok{{-}o}\NormalTok{ ub\_example}
\ExtensionTok{./ub\_example}
\end{Highlighting}
\end{Shaded}

Sample program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2147483647}\OperatorTok{;}
\NormalTok{    x}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
\end{verbatim}

This is the \textbf{Undefined Behavior Sanitizer (UBSan)} in action,
your best friend for finding invisible bugs.

\subsubsection{Why It Matters}\label{why-it-matters-65}

Undefined behavior is silent corruption. It can:

\begin{itemize}
\tightlist
\item
  Work on your machine but fail elsewhere.
\item
  Break when you change compiler flags.
\item
  Cause subtle, unpredictable bugs.
\end{itemize}

Avoiding UB is the foundation of reliable systems programming. In C,
correctness comes from \emph{discipline}.

\subsubsection{Try It Yourself}\label{try-it-yourself-75}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program with deliberate UB (like using uninitialized
  variables).
\item
  Run it with \texttt{-fsanitize=undefined}.
\item
  Fix each issue until UBSan runs clean.
\item
  Check array access and pointer validity.
\item
  Refactor old C code to avoid UB, it's a great debugging exercise.
\end{enumerate}

Next, you'll learn how to perform \textbf{crash analysis and read core
dumps}, so even when your program fails, you can find out \emph{exactly
why}.

\subsection{78. Crash Analysis and Core
Dumps}\label{crash-analysis-and-core-dumps}

Even with careful coding and testing, programs crash. In C, a crash is
your system's way of saying \emph{``you touched something you shouldn't
have.''} The good news is you can \textbf{analyze crashes}
scientifically using \textbf{core dumps}, snapshots of your program's
memory at the moment of failure.

Learning how to read them is an essential skill for every systems
programmer.

\subsubsection{Step 1. What Is a Core
Dump?}\label{step-1.-what-is-a-core-dump}

A \textbf{core dump} is a file that captures your program's state
(stack, registers, memory) at the time it crashed. You can inspect it
later using a debugger like \textbf{gdb} to see what went wrong.

Common crash signals that generate core dumps:

\begin{itemize}
\tightlist
\item
  \textbf{SIGSEGV} -- invalid memory access (segmentation fault)
\item
  \textbf{SIGABRT} -- failed assertion
\item
  \textbf{SIGFPE} -- arithmetic error (like division by zero)
\item
  \textbf{SIGILL} -- illegal instruction
\end{itemize}

\subsubsection{Step 2. Enabling Core
Dumps}\label{step-2.-enabling-core-dumps}

By default, modern systems limit or disable them. Enable them using:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{ulimit} \AttributeTok{{-}c}\NormalTok{ unlimited}
\end{Highlighting}
\end{Shaded}

Check:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{ulimit} \AttributeTok{{-}a} \KeywordTok{|} \FunctionTok{grep}\NormalTok{ core}
\end{Highlighting}
\end{Shaded}

Now when your program crashes, a file named \texttt{core} or
\texttt{core.\textless{}pid\textgreater{}} will appear.

\subsubsection{Step 3. A Crashing
Example}\label{step-3.-a-crashing-example}

Let's make a simple crash:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}  \CommentTok{// crash: dereferencing null pointer}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ crash.c }\AttributeTok{{-}g} \AttributeTok{{-}o}\NormalTok{ crash}
\ExtensionTok{./crash}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Segmentation fault (core dumped)
\end{verbatim}

A \texttt{core} file is now created in your directory.

\subsubsection{Step 4. Opening the Core Dump in
gdb}\label{step-4.-opening-the-core-dump-in-gdb}

Use gdb to inspect what happened:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./crash core}
\end{Highlighting}
\end{Shaded}

You'll see:

\begin{verbatim}
Core was generated by `./crash'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000401136 in main () at crash.c:5
5       *p = 42;
\end{verbatim}

This tells you the \textbf{exact line} where the program crashed.

\subsubsection{Step 5. Inspecting Variables and
Stack}\label{step-5.-inspecting-variables-and-stack}

Within gdb:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(gdb) bt}
\end{Highlighting}
\end{Shaded}

Shows the \textbf{backtrace}, the call stack at the moment of crash.

\begin{verbatim}
#0  main () at crash.c:5
\end{verbatim}

You can inspect variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(gdb) info locals}
\NormalTok{(gdb) print p}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
$1 = (int *) 0x0
\end{verbatim}

\subsubsection{Step 6. A More Complex
Example}\label{step-6.-a-more-complex-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ f3}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}  \CommentTok{// likely crash here}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ f2}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    f3}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ f1}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{x }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    f2}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    f1}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it, crash it, then:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./crash core}
\end{Highlighting}
\end{Shaded}

Inside gdb:

\begin{verbatim}
(gdb) bt
#0  f3 (p=0x0) at crash.c:4
#1  f2 (p=0x0) at crash.c:8
#2  f1 () at crash.c:12
#3  main () at crash.c:16
\end{verbatim}

You can see the entire call chain that led to the null dereference.

\subsubsection{Step 7. Debugging Optimized
Builds}\label{step-7.-debugging-optimized-builds}

When you compile with \texttt{-O2} or \texttt{-O3}, the compiler may
inline or reorder code, making debugging harder. For debugging, always
use:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g} \AttributeTok{{-}O0}\NormalTok{ crash.c }\AttributeTok{{-}o}\NormalTok{ crash}
\end{Highlighting}
\end{Shaded}

The \texttt{-g} flag keeps symbol information (file names, line
numbers). Without it, gdb can't tell you much beyond addresses.

\subsubsection{Step 8. Controlling Core Dump
Location}\label{step-8.-controlling-core-dump-location}

Change where dumps are stored:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ sysctl }\AttributeTok{{-}w}\NormalTok{ kernel.core\_pattern=/tmp/core.\%e.\%p}
\end{Highlighting}
\end{Shaded}

This example saves them in \texttt{/tmp} with program name and process
ID:

\begin{verbatim}
/tmp/core.crash.1234
\end{verbatim}

\subsubsection{Step 9. Crash Analysis
Workflow}\label{step-9.-crash-analysis-workflow}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Enable dumps}: \texttt{ulimit\ -c\ unlimited}
\item
  \textbf{Run program until it crashes}
\item
  \textbf{Locate core file}
\item
  \textbf{Analyze with gdb}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{bt} for stack trace
  \item
    \texttt{info\ locals} for local vars
  \item
    \texttt{frame\ \textless{}n\textgreater{}} to inspect each stack
    frame
  \item
    \texttt{list} to see nearby code
  \end{itemize}
\end{enumerate}

This gives you a full picture of what happened just before failure.

\subsubsection{Step 10. Tiny Code: Assertion Failure
Analysis}\label{step-10.-tiny-code-assertion-failure-analysis}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    assert}\OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{10}\OperatorTok{);}  \CommentTok{// fails}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Done}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ assert\_fail.c }\AttributeTok{{-}o}\NormalTok{ assert\_fail}
\BuiltInTok{ulimit} \AttributeTok{{-}c}\NormalTok{ unlimited}
\ExtensionTok{./assert\_fail}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
assert_fail: assert_fail.c:5: main: Assertion `x == 10' failed.
Aborted (core dumped)
\end{verbatim}

Now inspect:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./assert\_fail core}
\KeywordTok{(}\FunctionTok{gdb}\KeywordTok{)} \ExtensionTok{bt}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
#0  0x00007f0a9a4b9187 in raise () from /lib64/libc.so.6
#1  0x00007f0a9a4c53e8 in abort () from /lib64/libc.so.6
#2  0x00007f0a9a4b0246 in __assert_fail_base () from /lib64/libc.so.6
#3  0x00007f0a9a4b02f2 in __assert_fail () from /lib64/libc.so.6
#4  0x0000000000401136 in main () at assert_fail.c:5
\end{verbatim}

You can trace exactly how the assertion caused the abort signal.

\subsubsection{Why It Matters}\label{why-it-matters-66}

Crash analysis turns chaos into clarity. Instead of guessing, you can:

\begin{itemize}
\tightlist
\item
  See which line caused the crash.
\item
  Inspect all variables at that point.
\item
  Reproduce and fix the bug quickly.
\end{itemize}

Every serious C programmer must master this, it's how systems engineers
debug everything from user tools to kernels.

\subsubsection{Try It Yourself}\label{try-it-yourself-76}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program that dereferences a null pointer.
\item
  Enable core dumps (\texttt{ulimit\ -c\ unlimited}).
\item
  Crash it, then analyze the dump in gdb.
\item
  Add one more function layer and check the call chain.
\item
  Experiment with \texttt{SIGFPE} (divide by zero) and see how the core
  dump differs.
\end{enumerate}

Next, you'll build a \textbf{code review checklist for C projects},
habits and principles that help prevent these crashes before they ever
happen.

\subsection{79. Code Review Checklist for C
Projects}\label{code-review-checklist-for-c-projects}

Before your C program ships to production (or even your homework
submission), it should survive one last test, \textbf{a code review}.
This is where you or your teammates look at the code not just for
correctness, but for \emph{clarity, safety, and maintainability}.

Think of this as your personal pilot checklist before takeoff. Every
great C programmer has one.

\subsubsection{Step 1. Readability and
Structure}\label{step-1.-readability-and-structure}

\begin{itemize}
\tightlist
\item
  Are files organized logically (\texttt{src/}, \texttt{include/},
  \texttt{tests/})?
\item
  Are headers clean, with include guards?
\item
  Are functions short and focused (one purpose each)?
\item
  Are names meaningful (\texttt{count\_users()} is better than
  \texttt{doit()})?
\item
  Is indentation consistent and readable?
\item
  Are comments clear and relevant, not just noise?
\end{itemize}

\textbf{Tiny Code Example:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Bad}
\DataTypeTok{void}\NormalTok{ d}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{+}\NormalTok{b}\OperatorTok{);} \OperatorTok{\}}

\CommentTok{// Good}
\DataTypeTok{void}\NormalTok{ print\_sum}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Readable code \emph{explains itself}.

\subsubsection{Step 2. Header Hygiene}\label{step-2.-header-hygiene}

\begin{itemize}
\tightlist
\item
  Each \texttt{.h} file must have an \textbf{include guard}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}
\CommentTok{// declarations}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Headers should declare, not define.
\item
  No global variables unless justified.
\item
  Use \texttt{static\ inline} carefully (for small utilities only).
\end{itemize}

\subsubsection{Step 3. Memory Safety}\label{step-3.-memory-safety}

\begin{itemize}
\tightlist
\item
  Every \texttt{malloc} must have a corresponding \texttt{free}.
\item
  Check all allocation results:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{size}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"malloc"}\OperatorTok{);}\NormalTok{ exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Avoid dangling pointers:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Use Valgrind or AddressSanitizer to ensure no leaks.
\end{itemize}

\subsubsection{Step 4. Pointer
Discipline}\label{step-4.-pointer-discipline}

\begin{itemize}
\tightlist
\item
  Check for null pointers before dereferencing.
\item
  Don't return pointers to local variables:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\OperatorTok{*}\NormalTok{ bad}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;} \CommentTok{// wrong: stack memory}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Document ownership: who allocates, who frees.
\end{itemize}

\subsubsection{Step 5. Error Handling}\label{step-5.-error-handling}

\begin{itemize}
\tightlist
\item
  Always check function return values:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fwrite}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ len}\OperatorTok{,}\NormalTok{ file}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ len}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"fwrite"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Use meaningful error messages.
\item
  Prefer returning error codes over silently ignoring failures.
\item
  For libraries, use \texttt{errno} or your own error enums.
\end{itemize}

\subsubsection{Step 6. Undefined Behavior
Prevention}\label{step-6.-undefined-behavior-prevention}

\begin{itemize}
\tightlist
\item
  No uninitialized variables.
\item
  No out-of-bounds array access.
\item
  No signed integer overflow.
\item
  No use-after-free.
\item
  Compile with:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}Wpedantic} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{undefined,address}
\end{Highlighting}
\end{Shaded}

Fix all warnings, treat them as errors.

\subsubsection{Step 7. Portability}\label{step-7.-portability}

\begin{itemize}
\tightlist
\item
  Don't assume \texttt{int} is 32 bits or \texttt{char} is signed.
\item
  Use \texttt{\textless{}stdint.h\textgreater{}} types
  (\texttt{int32\_t}, \texttt{uint64\_t}).
\item
  Use \texttt{size\_t} for sizes and indexing.
\item
  Avoid platform-specific APIs unless wrapped.
\item
  Test on multiple compilers (\texttt{gcc}, \texttt{clang},
  \texttt{tinycc}).
\end{itemize}

\subsubsection{Step 8. Testing and
Validation}\label{step-8.-testing-and-validation}

\begin{itemize}
\tightlist
\item
  Every function that can fail must have at least one test.
\item
  Edge cases: empty input, zero values, large input.
\item
  Tests should run automatically:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ test}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Compare results with known-good output.
\item
  Document how to reproduce test results.
\end{itemize}

\subsubsection{Step 9. Documentation}\label{step-9.-documentation}

\begin{itemize}
\tightlist
\item
  Add a short header to every file:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* math\_utils.c}
\CommentTok{ * Simple math helpers.}
\CommentTok{ * Author: Your Name}
\CommentTok{ * License: MIT}
\CommentTok{ */}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Comment tricky code, but not the obvious.
\item
  Maintain a \texttt{README.md} explaining build and run steps.
\item
  Version your code (Git). Write meaningful commit messages.
\end{itemize}

\subsubsection{Step 10. Tiny Code: Applying the
Checklist}\label{step-10.-tiny-code-applying-the-checklist}

Let's check a small example:

\textbf{Original:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{make\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)\{}
  \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\NormalTok{n}\OperatorTok{];} \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{i}\OperatorTok{\textless{}}\NormalTok{n}\OperatorTok{;}\NormalTok{i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]=}\NormalTok{i}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ arr}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Review notes:}

\begin{itemize}
\tightlist
\item
  Returns pointer to local array → UB
\item
  Magic loop style → unreadable
\item
  Missing input validation
\end{itemize}

\textbf{Fixed:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int} \OperatorTok{*}\NormalTok{make\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}=} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{arr}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"malloc"}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ arr}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Passes checklist ✅

\begin{itemize}
\tightlist
\item
  Safe, clear, and portable.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-67}

A checklist builds \textbf{discipline and consistency}. It ensures:

\begin{itemize}
\tightlist
\item
  Clean, maintainable code.
\item
  Fewer crashes and leaks.
\item
  Easier debugging and onboarding.
\item
  Long-term stability in complex systems.
\end{itemize}

Every high-quality C project uses one, from open-source libraries to
kernels.

\subsubsection{Try It Yourself}\label{try-it-yourself-77}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take one of your old C programs and review it using this checklist.
\item
  Fix memory leaks, add error checks, clean up naming.
\item
  Compile with all warnings on.
\item
  Run it through AddressSanitizer or Valgrind.
\item
  Document everything, then repeat for your next project.
\end{enumerate}

Next, you'll wrap up this debugging chapter with a \textbf{hands-on
practice session}: fixing real memory and logic bugs step by step.

\subsection{80. Practice: Fix Memory and Logic
Bugs}\label{practice-fix-memory-and-logic-bugs}

Now it's time to apply everything you've learned, debugging, testing,
assertions, logging, and analysis, to \emph{real code that's broken}.
This section walks you through a handful of small, common C bugs that
new programmers (and even experienced ones) run into, showing how to
find, understand, and fix them.

\subsubsection{Step 1. Bug \#1, Segmentation Fault from a Bad
Pointer}\label{step-1.-bug-1-segmentation-fault-from-a-bad-pointer}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}  \CommentTok{// writing to uninitialized pointer}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Symptom:}

\begin{verbatim}
Segmentation fault (core dumped)
\end{verbatim}

\textbf{Diagnosis:}

\begin{itemize}
\tightlist
\item
  The pointer \texttt{p} is never initialized.
\item
  It points to an undefined address.
\end{itemize}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Always initialize pointers before use. If dynamic,
allocate with \texttt{malloc()} and check for \texttt{NULL}.

\subsubsection{Step 2. Bug \#2, Memory
Leak}\label{step-2.-bug-2-memory-leak}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ leak}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
    \CommentTok{// forgot to free}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ leak}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Diagnosis:} Each call to \texttt{leak()} allocates memory and
never frees it. Use Valgrind to confirm:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind}\NormalTok{ ./a.out}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ leak}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{arr}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Every \texttt{malloc()} needs a matching
\texttt{free()}, no exceptions.

\subsubsection{Step 3. Bug \#3, Off-by-One
Error}\label{step-3.-bug-3-off-by-one-error}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\};}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}  \CommentTok{// ❌ should be \textless{} 5}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Symptom:} Sometimes prints garbage or segfaults.

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Off-by-one errors are the most common bug in loops.
Always check your boundary conditions carefully.

\subsubsection{Step 4. Bug \#4,
Use-After-Free}\label{step-4.-bug-4-use-after-free}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{x }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \OperatorTok{*}\NormalTok{x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    free}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{x}\OperatorTok{);}  \CommentTok{// ❌ accessing freed memory}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}
\NormalTok{x }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Once you free memory, it's no longer yours, never touch
it again.

\subsubsection{Step 5. Bug \#5, Stack Variable Escaping
Scope}\label{step-5.-bug-5-stack-variable-escaping-scope}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{make\_ptr}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}  \CommentTok{// ❌ pointer to local variable}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ make\_ptr}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}  \CommentTok{// UB}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{make\_ptr}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{x }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \OperatorTok{*}\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

and remember to \texttt{free(p)} later.

\textbf{Lesson:} Never return the address of a local variable, its
lifetime ends when the function returns.

\subsubsection{Step 6. Bug \#6, Missing Return
Statement}\label{step-6.-bug-6-missing-return-statement}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ c }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
    \CommentTok{// forgot to return}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{return}\NormalTok{ c}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} If the function's return type is non-\texttt{void},
always return a value. Compile with \texttt{-Wall\ -Wextra} to catch
this automatically.

\subsubsection{Step 7. Bug \#7, Uninitialized
Variable}\label{step-7.-bug-7-uninitialized-variable}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sum}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ s}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ s }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}  \CommentTok{// s not initialized}
    \ControlFlowTok{return}\NormalTok{ s}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ s }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Initialize all variables before using them, especially
accumulators.

\subsubsection{Step 8. Bug \#8, Mixing Signed and
Unsigned}\label{step-8.-bug-8-mixing-signed-and-unsigned}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ b }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textless{}}\NormalTok{ b}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"less}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{else}\NormalTok{ printf}\OperatorTok{(}\StringTok{"greater}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Output:}

\begin{verbatim}
greater
\end{verbatim}

\textbf{Explanation:} \texttt{a} is converted to unsigned, so it becomes
a large positive number.

\textbf{Fix:} Avoid mixing signed and unsigned types. Use explicit casts
or consistent types.

\subsubsection{Step 9. Bug \#9, Buffer
Overflow}\label{step-9.-bug-9-buffer-overflow}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{8}\OperatorTok{];}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \StringTok{"Superlongname"}\OperatorTok{);}  \CommentTok{// ❌ too big}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strncpy}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \StringTok{"Superlongname"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{name}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{name}\OperatorTok{[}\DecValTok{7}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Never trust input size, always use bounded functions.

\subsubsection{Step 10. Bug \#10, Floating-Point
Comparison}\label{step-10.-bug-10-floating-point-comparison}

\textbf{Buggy Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{0.1}\BuiltInTok{f} \OperatorTok{*} \DecValTok{3}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{a }\OperatorTok{==} \FloatTok{0.3}\BuiltInTok{f}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Equal}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Not equal}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Output:}

\begin{verbatim}
Not equal
\end{verbatim}

\textbf{Fix:}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fabsf}\OperatorTok{(}\NormalTok{a }\OperatorTok{{-}} \FloatTok{0.3}\BuiltInTok{f}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{1e{-}6}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Equal}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Lesson:} Floating-point math is approximate, always compare with
a tolerance.

\subsubsection{Putting It All Together}\label{putting-it-all-together}

You can combine all these techniques:

\begin{itemize}
\tightlist
\item
  Use \textbf{assertions} to catch impossible states.
\item
  Use \textbf{logging} to trace events.
\item
  Run \textbf{Valgrind} or \textbf{ASan} to detect memory bugs.
\item
  Use \textbf{unit tests} to verify correctness.
\item
  And if it still crashes, \textbf{analyze the core dump}.
\end{itemize}

Every debugging tool is a lens. Use them together to see clearly.

\subsubsection{Why It Matters}\label{why-it-matters-68}

Debugging teaches you \emph{how programs fail}. Each bug fixed makes you
a more confident systems engineer. C doesn't forgive mistakes, but it
rewards precision.

\subsubsection{Try It Yourself}\label{try-it-yourself-78}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program containing at least 3 of these bugs.
\item
  Run it under AddressSanitizer (\texttt{-fsanitize=address}).
\item
  Fix each bug one by one.
\item
  Document what caused it and what fixed it.
\item
  Make this a personal debugging kata, practice until no bug survives
  longer than 10 minutes.
\end{enumerate}

Next, we'll begin \textbf{Chapter 9: Portable and Modern C}, where
you'll learn how to write C that runs everywhere, from embedded chips to
modern servers.

\bookmarksetup{startatroot}

\chapter{Chapter 9. Portable and Modern
C}\label{chapter-9.-portable-and-modern-c}

\subsection{81. The C Standard Timeline (C89 to
C23)}\label{the-c-standard-timeline-c89-to-c23}

C has been around for more than fifty years, and it has evolved slowly
and carefully. Every version of the C standard improves the language
while keeping backward compatibility with decades of existing code.

Understanding the \textbf{timeline of C standards} helps you write
portable, modern code and know which features are safe to use in your
target environments.

\subsubsection{Step 1. The Beginning, K\&R C
(1972--1989)}\label{step-1.-the-beginning-kr-c-19721989}

C was born at Bell Labs in the early 1970s, developed by \textbf{Dennis
Ritchie} as a systems programming language for \textbf{Unix}. The first
book, \emph{The C Programming Language} by Kernighan and Ritchie (1978),
informally defined ``K\&R C.''

\textbf{Key Traits:}

\begin{itemize}
\tightlist
\item
  No standardization yet.
\item
  Implicit function declarations.
\item
  No \texttt{void} type for functions without return.
\item
  No function prototypes (parameters not type-checked).
\item
  Header files were optional.
\end{itemize}

\textbf{Example:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It was simple, direct, and dangerous, but it worked.

\subsubsection{Step 2. ANSI C (C89 / C90)}\label{step-2.-ansi-c-c89-c90}

In 1989, C became standardized by ANSI (and in 1990 by ISO). This
version, \textbf{C89/C90}, unified compiler behavior and made C portable
across systems.

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  Function prototypes (\texttt{int\ add(int,\ int);})
\item
  Standard headers (\texttt{\textless{}stdio.h\textgreater{}},
  \texttt{\textless{}stdlib.h\textgreater{}},
  \texttt{\textless{}string.h\textgreater{}})
\item
  \texttt{void} keyword
\item
  Type qualifiers: \texttt{const}, \texttt{volatile}
\item
  New library functions (\texttt{memcpy}, \texttt{qsort},
  \texttt{assert})
\item
  Formalized the standard library
\item
  Single-line comments were still not supported (use \texttt{/*\ */})
\end{itemize}

\textbf{Tiny Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. C95 (ISO
Amendment)}\label{step-3.-c95-iso-amendment}

A minor update that refined C90, rarely mentioned but still significant.

\textbf{Added:}

\begin{itemize}
\tightlist
\item
  Wide character support (\texttt{\textless{}wchar.h\textgreater{}})
\item
  Multibyte strings
\item
  More internationalization utilities
\item
  Macros like \texttt{\_\_STDC\_VERSION\_\_}
\end{itemize}

It paved the way for Unicode support in later versions.

\subsubsection{Step 4. C99, Modernization
Begins}\label{step-4.-c99-modernization-begins}

C99 (published in 1999) was the biggest update since the beginning.

\textbf{Major Improvements:}

\begin{itemize}
\tightlist
\item
  \texttt{//} single-line comments
\item
  Variable declarations anywhere
\item
  Inline functions
\item
  \texttt{long\ long} (64-bit integer)
\item
  \texttt{stdbool.h} for \texttt{bool}, \texttt{true}, \texttt{false}
\item
  \texttt{stdint.h} for fixed-width integers (\texttt{int32\_t},
  \texttt{uint64\_t})
\item
  Designated initializers and compound literals
\item
  Flexible array members
\item
  \texttt{snprintf} safer string formatting
\item
  Variable-length arrays (VLAs)
\end{itemize}

\textbf{Tiny Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{bool}\NormalTok{ done }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
    \DataTypeTok{uint64\_t}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        sum }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%llu\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\OperatorTok{)}\NormalTok{sum}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ done}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C99 made C feel modern, introducing safer and more expressive syntax.

\subsubsection{Step 5. C11, Concurrency and
Safety}\label{step-5.-c11-concurrency-and-safety}

Released in 2011, \textbf{C11} added better threading and safety
mechanisms.

\textbf{Key Additions:}

\begin{itemize}
\tightlist
\item
  \texttt{\_Thread\_local} storage specifier
\item
  \texttt{\textless{}threads.h\textgreater{}} for portable threads,
  mutexes, condition variables
\item
  \texttt{\_Atomic} for atomic operations
\item
  \texttt{\_Static\_assert} for compile-time checks
\item
  Bounds-checked functions (\texttt{strcpy\_s}, \texttt{memcpy\_s})
\item
  Optional Annex K for safer standard library functions
\item
  Improved Unicode and wide character support
\end{itemize}

\textbf{Tiny Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ run}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from thread }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\DataTypeTok{int} \OperatorTok{*)}\NormalTok{arg}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    thrd\_t t}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ run}\OperatorTok{,} \OperatorTok{\&}\NormalTok{id}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C11 made C safer and concurrency-aware, though not all compilers
implemented \texttt{\textless{}threads.h\textgreater{}} fully.

\subsubsection{Step 6. C17 (a.k.a. C18), The
Refinement}\label{step-6.-c17-a.k.a.-c18-the-refinement}

Officially ISO/IEC 9899:2018 (published in 2018), C17 fixed
inconsistencies and bugs in C11 but didn't add new features.

\textbf{Highlights:}

\begin{itemize}
\tightlist
\item
  Clarifications to atomics, macros, and UB rules.
\item
  Improved compatibility with C++ compilers.
\item
  Bug fixes in the standard library.
\item
  \texttt{\_\_STDC\_VERSION\_\_} is \texttt{201710L}.
\end{itemize}

It's the default ``stable'' standard for modern C codebases.

\subsubsection{Step 7. C23, The Latest
Standard}\label{step-7.-c23-the-latest-standard}

C23 is the most recent (published in 2024), continuing modernization
without breaking backward compatibility.

\textbf{Major Features:}

\begin{itemize}
\tightlist
\item
  \texttt{typeof} (like in GCC)
\item
  \texttt{nullptr} keyword
\item
  \texttt{static\_assert} (alias for \texttt{\_Static\_assert})
\item
  UTF-8 string literals: \texttt{u8"Hello"}
\item
  New standard attributes (\texttt{{[}{[}maybe\_unused{]}{]}},
  \texttt{{[}{[}nodiscard{]}{]}})
\item
  \texttt{constexpr}-like features (\texttt{constexpr} functions are
  planned)
\item
  Better Unicode and formatting APIs
\item
  Safer library extensions
\item
  Improved interoperability with C++
\end{itemize}

\textbf{Tiny Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \OperatorTok{[[}\AttributeTok{maybe\_unused}\OperatorTok{]]} \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
    \KeywordTok{static\_assert}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)} \OperatorTok{==} \DecValTok{4}\OperatorTok{,} \StringTok{"Expected 4{-}byte int"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C23 brings C closer to modern C++ and Rust-style safety while staying
simple and lightweight.

\subsubsection{Step 8. Checking Your Compiler's
Version}\label{step-8.-checking-your-compilers-version}

You can check your compiler's supported C standard using:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}dM} \AttributeTok{{-}E} \AttributeTok{{-}} \OperatorTok{\textless{}}\NormalTok{ /dev/null }\KeywordTok{|} \FunctionTok{grep}\NormalTok{ \_\_STDC\_VERSION\_\_}
\end{Highlighting}
\end{Shaded}

Common outputs:

\begin{verbatim}
199901L  → C99  
201112L  → C11  
201710L  → C17  
202311L  → C23
\end{verbatim}

Or compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c99 program.c}
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c11 program.c}
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 program.c}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Compatibility and Portability
Tips}\label{step-9.-compatibility-and-portability-tips}

\begin{itemize}
\tightlist
\item
  Always declare the standard explicitly: \texttt{-std=c11} or
  \texttt{-std=c17}.
\item
  Avoid compiler-specific extensions unless guarded with
  \texttt{\#ifdef\ \_\_GNUC\_\_}.
\item
  Use standard headers like \texttt{\textless{}stdint.h\textgreater{}}
  and \texttt{\textless{}stdbool.h\textgreater{}}.
\item
  When writing libraries, prefer the lowest standard that supports your
  needs.
\item
  Add \texttt{\_Static\_assert} or \texttt{\#error} for unsupported
  standards.
\end{itemize}

\subsubsection{Step 10. Tiny Code: Version
Detector}\label{step-10.-tiny-code-version-detector}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if \_\_STDC\_VERSION\_\_ \textgreater{}= 202311L}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C23 or newer}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_STDC\_VERSION\_\_ \textgreater{}= 201710L}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C17}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_STDC\_VERSION\_\_ \textgreater{}= 201112L}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C11}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_STDC\_VERSION\_\_ \textgreater{}= 199901L}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C99}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C90 or earlier}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run to see what your compiler supports.

\subsubsection{Why It Matters}\label{why-it-matters-69}

C's evolution shows its unique philosophy: \textbf{change slowly, but
never break old code.} Knowing which standard you target means you can
use modern features confidently, without losing portability.

\subsubsection{Try It Yourself}\label{try-it-yourself-79}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write the version detector program above and run it with
  \texttt{-std=c99}, \texttt{-std=c11}, and \texttt{-std=c23}.
\item
  Experiment with \texttt{\_Static\_assert} and
  \texttt{\_Thread\_local}, see which standards support them.
\item
  Try compiling a small thread example using
  \texttt{\textless{}threads.h\textgreater{}}.
\item
  Look up your compiler's documentation to see which features of C23 are
  implemented.
\item
  Pick one feature (like \texttt{{[}{[}nodiscard{]}{]}}) and use it in a
  tiny project.
\end{enumerate}

Next, you'll explore \textbf{portability and endianness}, the invisible
details that determine how your C programs behave across different
machines and architectures.

\subsection{82. Portability and
Endianness}\label{portability-and-endianness}

Portability means your C program behaves the same way everywhere, on
Linux, Windows, ARM, x86, or even a tiny microcontroller. Writing
portable code is one of the hardest and most important skills in systems
programming.

This section helps you understand the biggest low-level trap of all:
\textbf{endianness}, and how to write code that runs safely across
architectures.

\subsubsection{Step 1. What Is
Portability?}\label{step-1.-what-is-portability}

A \textbf{portable C program} is one that:

\begin{itemize}
\tightlist
\item
  Compiles cleanly with different compilers.
\item
  Runs correctly on 32-bit, 64-bit, and embedded systems.
\item
  Does not assume details of CPU, OS, or compiler behavior.
\end{itemize}

Portability depends on respecting what the C standard guarantees, and
avoiding assumptions that might be true only on \emph{your} machine.

\subsubsection{Step 2. Why Portability
Matters}\label{step-2.-why-portability-matters}

You might write a C program on macOS (little-endian x86\_64) and later
need to run it on:

\begin{itemize}
\tightlist
\item
  A Raspberry Pi (ARM, also little-endian)
\item
  A big-endian PowerPC router
\item
  An embedded MIPS controller
\end{itemize}

If your program reads or writes binary data, it must handle
\textbf{endianness}, or the same file may be misread on another
architecture.

\subsubsection{Step 3. Understanding
Endianness}\label{step-3.-understanding-endianness}

Endianness defines how bytes of multibyte values are stored in memory.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2208}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4156}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Memory (4-byte int = 0x12345678)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Little-endian} & Least significant byte first &
\texttt{78\ 56\ 34\ 12} \\
\textbf{Big-endian} & Most significant byte first &
\texttt{12\ 34\ 56\ 78} \\
\end{longtable}

Intel and ARM (in most modes) are \textbf{little-endian}. Many older
CPUs (PowerPC, SPARC) are \textbf{big-endian}.

C does not define the byte order, it depends on the platform.

\subsubsection{Step 4. Checking Endianness at
Runtime}\label{step-4.-checking-endianness-at-runtime}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \BaseNTok{0x12345678}\OperatorTok{;}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*)\&}\NormalTok{x}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{p }\OperatorTok{==} \BaseNTok{0x78}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Little{-}endian}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Big{-}endian}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:} The pointer \texttt{p} reads the lowest memory
byte. If it contains the least significant byte (\texttt{0x78}), it's
little-endian.

\subsubsection{Step 5. Converting Between
Endiannesses}\label{step-5.-converting-between-endiannesses}

Use standard POSIX functions to handle conversions safely:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}\PreprocessorTok{  }\CommentTok{// or \textless{}winsock2.h\textgreater{} on Windows}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{uint32\_t}\NormalTok{ x }\OperatorTok{=} \BaseNTok{0x12345678}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ y }\OperatorTok{=}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{x}\OperatorTok{);} \CommentTok{// Host to Network Long (big{-}endian)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"0x}\SpecialCharTok{\%x}\StringTok{ {-}\textgreater{} 0x}\SpecialCharTok{\%x\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Functions:}

\begin{itemize}
\tightlist
\item
  \texttt{htons} -- host to network short (16-bit)
\item
  \texttt{htonl} -- host to network long (32-bit)
\item
  \texttt{ntohs} -- network to host short
\item
  \texttt{ntohl} -- network to host long
\end{itemize}

Network byte order is always \textbf{big-endian}.

\subsubsection{Step 6. Handling Portability in File
Formats}\label{step-6.-handling-portability-in-file-formats}

If you serialize structs directly to disk:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{header}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{header}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ file}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

you're likely writing machine-dependent data:

\begin{itemize}
\tightlist
\item
  Endianness may differ.
\item
  Padding and alignment may differ.
\item
  Structure layout can vary by compiler.
\end{itemize}

\textbf{Better approach:} Write each field individually in a
well-defined order:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{uint32\_t}\NormalTok{ size\_net }\OperatorTok{=}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{header}\OperatorTok{.}\NormalTok{size}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{size\_net}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{size\_net}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ file}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now, any machine can read your file by reversing the conversion
(\texttt{ntohl}).

\subsubsection{Step 7. Data Type Size
Differences}\label{step-7.-data-type-size-differences}

Type sizes vary across systems:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Typical 32-bit & Typical 64-bit \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{char} & 1 byte & 1 byte \\
\texttt{short} & 2 bytes & 2 bytes \\
\texttt{int} & 4 bytes & 4 bytes \\
\texttt{long} & 4 bytes & 8 bytes \\
\texttt{long\ long} & 8 bytes & 8 bytes \\
\texttt{void*} & 4 bytes & 8 bytes \\
\end{longtable}

Use \texttt{\textless{}stdint.h\textgreater{}} types (\texttt{int32\_t},
\texttt{uint64\_t}, etc.) for predictable sizes.

\subsubsection{Step 8. Alignment and
Padding}\label{step-8.-alignment-and-padding}

The compiler may insert padding between structure fields for speed or
alignment.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Example }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ a}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

On most systems:

\begin{itemize}
\tightlist
\item
  \texttt{sizeof(struct\ Example)} = 8, not 5 (3 bytes of padding).
\end{itemize}

To make portable formats:

\begin{itemize}
\tightlist
\item
  Use \texttt{\#pragma\ pack(1)} (non-standard) or serialize
  field-by-field.
\item
  Never assume \texttt{sizeof(struct)} is the same across systems.
\end{itemize}

\subsubsection{Step 9. Compiler and OS
Differences}\label{step-9.-compiler-and-os-differences}

\textbf{Be careful with:}

\begin{itemize}
\tightlist
\item
  Path separators (\texttt{/} vs
  \texttt{\textbackslash{}\textbackslash{}})
\item
  Newline conventions (\texttt{\textbackslash{}n} vs
  \texttt{\textbackslash{}r\textbackslash{}n})
\item
  \texttt{\#include\ \textless{}unistd.h\textgreater{}} (POSIX only)
\item
  \texttt{system()} commands (OS-specific)
\item
  Thread APIs (\texttt{pthread} vs Windows threads)
\item
  Socket APIs (\texttt{\textless{}arpa/inet.h\textgreater{}} vs
  \texttt{\textless{}winsock2.h\textgreater{}})
\end{itemize}

Use conditional compilation:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef \_WIN32}
\PreprocessorTok{\#include }\ImportTok{\textless{}winsock2.h\textgreater{}}
\PreprocessorTok{\#else}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 10. Tiny Code: Writing Portable Binary
I/O}\label{step-10.-tiny-code-writing-portable-binary-io}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"num.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \DataTypeTok{uint32\_t}\NormalTok{ n }\OperatorTok{=} \BaseNTok{0x12345678}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ net }\OperatorTok{=}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{n}\OperatorTok{);}
\NormalTok{    fwrite}\OperatorTok{(\&}\NormalTok{net}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{net}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ f}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}

\NormalTok{    f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"num.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \DataTypeTok{uint32\_t}\NormalTok{ read\_net}\OperatorTok{;}
\NormalTok{    fread}\OperatorTok{(\&}\NormalTok{read\_net}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{read\_net}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ f}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Read back: 0x}\SpecialCharTok{\%x\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{read\_net}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This program writes and reads a 32-bit integer in \textbf{portable
big-endian form}, the same bytes on any machine.

\subsubsection{Why It Matters}\label{why-it-matters-70}

Portability ensures your software lives longer than your hardware. A
portable program:

\begin{itemize}
\tightlist
\item
  Runs on different CPUs and OSes.
\item
  Shares data safely across architectures.
\item
  Builds trust in your code across teams and systems.
\end{itemize}

Portability is a kind of professionalism, future-proofing your code.

\subsubsection{Try It Yourself}\label{try-it-yourself-80}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that detects and prints system endianness.
\item
  Serialize a struct to a binary file, then deserialize it on another
  system.
\item
  Use \texttt{htonl} and \texttt{ntohl} to ensure data stays consistent.
\item
  Compile your code with both GCC and Clang.
\item
  Test it on both 32-bit and 64-bit architectures.
\end{enumerate}

Next, you'll explore \textbf{inline assembly and hardware access}, the
bridge between pure C and the underlying CPU instructions.

\subsection{83. Inline Assembly and Hardware
Access}\label{inline-assembly-and-hardware-access}

C gives you precise control over memory and performance, but sometimes
you need to go one level deeper, directly to the \textbf{CPU}. That's
where \textbf{inline assembly} comes in: embedding assembly language
inside your C code to optimize performance or access hardware-level
features.

This chapter will show how to mix C and assembly safely, portably, and
meaningfully.

\subsubsection{Step 1. What Is Inline
Assembly?}\label{step-1.-what-is-inline-assembly}

\textbf{Inline assembly} lets you insert small snippets of machine
instructions into your C program. You can use it to:

\begin{itemize}
\tightlist
\item
  Access CPU instructions not exposed by C.
\item
  Optimize performance-critical paths.
\item
  Implement hardware drivers or low-level routines.
\end{itemize}

However, it's also \textbf{non-portable} and compiler-specific, so use
it sparingly and isolate it behind clean C interfaces.

\subsubsection{Step 2. Two Common
Flavors}\label{step-2.-two-common-flavors}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{GCC / Clang syntax (AT\&T or Intel style)} Uses the
  \texttt{asm} or \texttt{\_\_asm\_\_} keyword.
\item
  \textbf{MSVC syntax} Uses \texttt{\_\_asm\ \{\ ...\ \}} inside
  functions.
\end{enumerate}

We'll focus on GCC/Clang syntax, since it's used in most systems
programming contexts.

\subsubsection{Step 3. Basic Inline Assembly
Example}\label{step-3.-basic-inline-assembly-example}

\textbf{Tiny Code:} Print CPU ID register (x86 only)

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ eax}\OperatorTok{,}\NormalTok{ ebx}\OperatorTok{,}\NormalTok{ ecx}\OperatorTok{,}\NormalTok{ edx}\OperatorTok{;}
\NormalTok{    eax }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    \_\_asm\_\_ \_\_volatile\_\_}\OperatorTok{(}
        \StringTok{"cpuid"}
        \OperatorTok{:} \StringTok{"=a"}\OperatorTok{(}\NormalTok{eax}\OperatorTok{),} \StringTok{"=b"}\OperatorTok{(}\NormalTok{ebx}\OperatorTok{),} \StringTok{"=c"}\OperatorTok{(}\NormalTok{ecx}\OperatorTok{),} \StringTok{"=d"}\OperatorTok{(}\NormalTok{edx}\OperatorTok{)}
        \OperatorTok{:} \StringTok{"a"}\OperatorTok{(}\DecValTok{0}\OperatorTok{)}
    \OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"CPU Vendor: }\SpecialCharTok{\%.4s\%.4s\%.4s\textbackslash{}n}\StringTok{"}\OperatorTok{,}
           \OperatorTok{(}\DataTypeTok{char}\OperatorTok{*)\&}\NormalTok{ebx}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{char}\OperatorTok{*)\&}\NormalTok{edx}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{char}\OperatorTok{*)\&}\NormalTok{ecx}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:}

\begin{itemize}
\tightlist
\item
  \texttt{cpuid} is a CPU instruction that fills registers with
  information.
\item
  \texttt{"=a"(eax)} means ``store the output of register \texttt{eax}
  into variable \texttt{eax}.''
\item
  \texttt{:\ "a"(0)} means ``put 0 into \texttt{eax} before running the
  instruction.''
\item
  The \texttt{\_\_volatile\_\_} keyword tells the compiler not to
  optimize it away.
\end{itemize}

\subsubsection{Step 4. GCC Inline Assembly
Syntax}\label{step-4.-gcc-inline-assembly-syntax}

General form:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{asm }\DataTypeTok{volatile} \OperatorTok{(}\StringTok{"instruction list"}
              \OperatorTok{:}\NormalTok{ output\_operands}
              \OperatorTok{:}\NormalTok{ input\_operands}
              \OperatorTok{:}\NormalTok{ clobbered\_registers}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{asm }\DataTypeTok{volatile} \OperatorTok{(}\StringTok{"addl }\SpecialCharTok{\%\%}\StringTok{ebx, }\SpecialCharTok{\%\%}\StringTok{eax"}
              \OperatorTok{:} \StringTok{"=a"}\OperatorTok{(}\NormalTok{result}\OperatorTok{)}
              \OperatorTok{:} \StringTok{"a"}\OperatorTok{(}\NormalTok{x}\OperatorTok{),} \StringTok{"b"}\OperatorTok{(}\NormalTok{y}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:}

\begin{itemize}
\tightlist
\item
  \texttt{"addl\ \%\%ebx,\ \%\%eax"}, assembly instruction
\item
  \texttt{"=a"(result)}, output in \texttt{eax} goes to \texttt{result}
\item
  \texttt{"a"(x),\ "b"(y)}, inputs: put \texttt{x} in \texttt{eax},
  \texttt{y} in \texttt{ebx}
\end{itemize}

\subsubsection{Step 5. Reading CPU Cycle
Counters}\label{step-5.-reading-cpu-cycle-counters}

\textbf{Tiny Code: Measure CPU cycles between operations}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\NormalTok{ rdtsc}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ lo}\OperatorTok{,}\NormalTok{ hi}\OperatorTok{;}
\NormalTok{    \_\_asm\_\_ \_\_volatile\_\_}\OperatorTok{(}\StringTok{"rdtsc"} \OperatorTok{:} \StringTok{"=a"}\OperatorTok{(}\NormalTok{lo}\OperatorTok{),} \StringTok{"=d"}\OperatorTok{(}\NormalTok{hi}\OperatorTok{));}
    \ControlFlowTok{return} \OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\OperatorTok{)}\NormalTok{hi }\OperatorTok{\textless{}\textless{}} \DecValTok{32}\OperatorTok{)} \OperatorTok{|}\NormalTok{ lo}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\NormalTok{ start }\OperatorTok{=}\NormalTok{ rdtsc}\OperatorTok{();}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{volatile} \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{1000000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++);}
    \DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\NormalTok{ end }\OperatorTok{=}\NormalTok{ rdtsc}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Cycles: }\SpecialCharTok{\%llu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ end }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Explanation:}

\begin{itemize}
\tightlist
\item
  \texttt{rdtsc} reads the CPU's timestamp counter.
\item
  It's a precise measure of time in CPU cycles, great for
  microbenchmarking.
\end{itemize}

\subsubsection{Step 6. Writing to I/O Ports (Embedded or Kernel
Context)}\label{step-6.-writing-to-io-ports-embedded-or-kernel-context}

If you're writing embedded code or OS kernels, you often interact with
hardware registers directly.

Example (x86, privileged mode only):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ outb}\OperatorTok{(}\DataTypeTok{unsigned} \DataTypeTok{short}\NormalTok{ port}\OperatorTok{,} \DataTypeTok{unsigned} \DataTypeTok{char}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    \_\_asm\_\_ \_\_volatile\_\_}\OperatorTok{(}\StringTok{"outb \%0, \%1"} \OperatorTok{:} \OperatorTok{:} \StringTok{"a"}\OperatorTok{(}\NormalTok{value}\OperatorTok{),} \StringTok{"Nd"}\OperatorTok{(}\NormalTok{port}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This writes a byte to an I/O port, used for devices like serial ports,
timers, or PIC controllers.

In user-space, you generally can't do this (needs kernel privileges).

\subsubsection{Step 7. Memory Barriers and CPU
Fences}\label{step-7.-memory-barriers-and-cpu-fences}

When working with concurrency or hardware, you may need to control
instruction ordering.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\_\_asm\_\_ \_\_volatile\_\_}\OperatorTok{(}\StringTok{"mfence"} \OperatorTok{:::} \StringTok{"memory"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This tells the CPU and compiler not to reorder memory operations,
essential for writing thread-safe or device-control code at the hardware
level.

\subsubsection{Step 8. Register
Constraints}\label{step-8.-register-constraints}

GCC lets you specify which registers to use.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Constraint & Register & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{"a"} & \texttt{eax} & accumulator \\
\texttt{"b"} & \texttt{ebx} & base \\
\texttt{"c"} & \texttt{ecx} & counter \\
\texttt{"d"} & \texttt{edx} & data \\
\texttt{"S"} & \texttt{esi} & source index \\
\texttt{"D"} & \texttt{edi} & destination index \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{asm}\OperatorTok{(}\StringTok{"mul \%1"} \OperatorTok{:} \StringTok{"=a"}\OperatorTok{(}\NormalTok{res}\OperatorTok{)} \OperatorTok{:} \StringTok{"r"}\OperatorTok{(}\NormalTok{x}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

The \texttt{"r"} constraint lets the compiler choose any register.

\subsubsection{Step 9. Mixing Assembly and C
Functions}\label{step-9.-mixing-assembly-and-c-functions}

You can write small routines in separate \texttt{.S} files (pure
assembly) and call them from C:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\# }\DataTypeTok{file}\OperatorTok{:}\NormalTok{ add}\OperatorTok{.}\NormalTok{S}
\NormalTok{.global add\_two}
\FunctionTok{add\_two:}
\NormalTok{    addl }\OperatorTok{\%}\KeywordTok{esi}\OperatorTok{,} \OperatorTok{\%}\KeywordTok{edi}
\NormalTok{    movl }\OperatorTok{\%}\KeywordTok{edi}\OperatorTok{,} \OperatorTok{\%}\KeywordTok{eax}
    \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

Then in C:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add\_two}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add\_two}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{7}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This hybrid style is used in OS kernels, bootloaders, and math
libraries.

\subsubsection{Step 10. Tiny Code: Inline Assembly Add
Function}\label{step-10.-tiny-code-inline-assembly-add-function}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add\_fast}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ result}\OperatorTok{;}
\NormalTok{    \_\_asm\_\_ }\OperatorTok{(}\StringTok{"addl \%1, \%0"} \OperatorTok{:} \StringTok{"=r"}\OperatorTok{(}\NormalTok{result}\OperatorTok{)} \OperatorTok{:} \StringTok{"r"}\OperatorTok{(}\NormalTok{b}\OperatorTok{),} \StringTok{"0"}\OperatorTok{(}\NormalTok{a}\OperatorTok{));}
    \ControlFlowTok{return}\NormalTok{ result}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add\_fast}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{"0"(a)} constraint tells the compiler to use the same
register for input and output.

\subsubsection{Why It Matters}\label{why-it-matters-71}

Inline assembly teaches you what really happens beneath your C code.
Even if you rarely use it, understanding it helps you:

\begin{itemize}
\tightlist
\item
  Read compiler-generated assembly (\texttt{gcc\ -S})
\item
  Optimize performance-critical code
\item
  Understand how system calls, context switches, and kernel traps work
\end{itemize}

It's where software meets hardware, the true metal of computing.

\subsubsection{Try It Yourself}\label{try-it-yourself-81}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small inline assembly snippet that swaps two integers.
\item
  Print the CPU vendor string with \texttt{cpuid}.
\item
  Use \texttt{rdtsc()} to benchmark your function.
\item
  Inspect compiler-generated assembly using \texttt{gcc\ -S}.
\item
  Try to reimplement a basic math operation in assembly and compare
  performance.
\end{enumerate}

Next, you'll learn \textbf{cross-compilation}, how to build your C
programs for \emph{other architectures and systems}, from your own
machine.

\subsection{84. Cross-Compilation}\label{cross-compilation}

Cross-compilation means \textbf{building a program on one machine so it
runs on another}. If you've ever compiled a C program on your laptop and
deployed it to a Raspberry Pi, an ESP32 board, or even a custom Linux
image, you've done cross-compilation.

This is an essential skill for systems programmers, embedded developers,
and anyone who builds for multiple architectures or operating systems.

\subsubsection{Step 1. What Is a
Cross-Compiler?}\label{step-1.-what-is-a-cross-compiler}

A \textbf{cross-compiler} is a compiler that produces executables for a
\emph{target platform} different from the \emph{host platform}.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.1299}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.8701}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Host} & The system where you build the code \\
\textbf{Target} & The system where the program will run \\
\textbf{Build} & The system where the compiler itself was built (often
same as host) \\
\end{longtable}

Example: You're on macOS (x86\_64) and want to compile for a Raspberry
Pi (ARM). Your toolchain must translate x86 instructions into ARM ones.

\subsubsection{Step 2. Why
Cross-Compile?}\label{step-2.-why-cross-compile}

\begin{itemize}
\tightlist
\item
  Deploy software to embedded devices without compiling directly on
  them.
\item
  Build for multiple architectures from one workstation.
\item
  Generate portable binaries (for ARM, MIPS, RISC-V, etc.).
\item
  Prepare static binaries for minimal systems or containers.
\end{itemize}

Cross-compilation is the foundation of \textbf{embedded Linux},
\textbf{IoT}, and \textbf{firmware development}.

\subsubsection{Step 3. Installing a
Cross-Compiler}\label{step-3.-installing-a-cross-compiler}

On Linux, install a toolchain package for your target architecture.
Examples:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt install gcc{-}arm{-}linux{-}gnueabihf}
\FunctionTok{sudo}\NormalTok{ apt install gcc{-}aarch64{-}linux{-}gnu}
\FunctionTok{sudo}\NormalTok{ apt install gcc{-}riscv64{-}linux{-}gnu}
\end{Highlighting}
\end{Shaded}

Each toolchain contains:

\begin{itemize}
\tightlist
\item
  \texttt{gcc} or \texttt{clang} cross-compiler
\item
  \texttt{as} (assembler)
\item
  \texttt{ld} (linker)
\item
  target system headers and libraries
\end{itemize}

\subsubsection{Step 4. Verifying the
Target}\label{step-4.-verifying-the-target}

Check your compiler's target triple:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{arm{-}linux{-}gnueabihf{-}gcc} \AttributeTok{{-}v}
\end{Highlighting}
\end{Shaded}

Output example:

\begin{verbatim}
Target: arm-linux-gnueabihf
\end{verbatim}

The \textbf{triple} encodes:

\begin{verbatim}
<architecture>-<vendor>-<OS>-<ABI>
\end{verbatim}

For instance:

\begin{itemize}
\tightlist
\item
  \texttt{x86\_64-pc-linux-gnu}
\item
  \texttt{arm-none-eabi} (bare-metal, no OS)
\item
  \texttt{aarch64-linux-gnu}
\end{itemize}

\subsubsection{Step 5. Compiling for Another
Platform}\label{step-5.-compiling-for-another-platform}

\textbf{Tiny Code:}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from cross{-}compiled C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile for ARM:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{arm{-}linux{-}gnueabihf{-}gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello\_arm}
\end{Highlighting}
\end{Shaded}

Transfer it to your ARM device:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{scp}\NormalTok{ hello\_arm user@raspberrypi.local:/home/user/}
\end{Highlighting}
\end{Shaded}

Then run on the Pi:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./hello\_arm}
\end{Highlighting}
\end{Shaded}

If everything's configured correctly, you'll see:

\begin{verbatim}
Hello from cross-compiled C!
\end{verbatim}

\subsubsection{Step 6. Static vs Dynamic
Linking}\label{step-6.-static-vs-dynamic-linking}

When cross-compiling, your target system might not have the same
libraries. You can link everything into one binary:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{arm{-}linux{-}gnueabihf{-}gcc} \AttributeTok{{-}static}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello\_static}
\end{Highlighting}
\end{Shaded}

\textbf{Static linking} ensures the binary runs even if the target lacks
shared libraries, useful for minimal or embedded systems.

\subsubsection{Step 7. Using Clang for
Cross-Compilation}\label{step-7.-using-clang-for-cross-compilation}

Clang simplifies multi-target builds through \texttt{-\/-target} and
\texttt{-\/-sysroot} options:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{clang} \AttributeTok{{-}{-}target}\OperatorTok{=}\NormalTok{aarch64{-}linux{-}gnu }\AttributeTok{{-}{-}sysroot}\OperatorTok{=}\NormalTok{/path/to/sysroot hello.c }\AttributeTok{{-}o}\NormalTok{ hello\_arm64}
\end{Highlighting}
\end{Shaded}

\texttt{-\/-sysroot} points to a directory that mimics the target's
filesystem, containing its headers and libraries.

\subsubsection{Step 8. Building for Windows or macOS from
Linux}\label{step-8.-building-for-windows-or-macos-from-linux}

You can also cross-compile across operating systems:

\textbf{Linux → Windows:}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt install mingw{-}w64}
\ExtensionTok{x86\_64{-}w64{-}mingw32{-}gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello.exe}
\end{Highlighting}
\end{Shaded}

\textbf{Linux → macOS:} More complex, usually requires Clang with Apple
SDKs or \texttt{osxcross}.

\subsubsection{Step 9. Automating with CMake or
Makefiles}\label{step-9.-automating-with-cmake-or-makefiles}

CMake makes multi-platform builds easy.

\texttt{toolchain-arm.cmake}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{SET}\NormalTok{(}\DecValTok{CMAKE\_SYSTEM\_NAME}\NormalTok{ Linux)}
\KeywordTok{SET}\NormalTok{(}\DecValTok{CMAKE\_SYSTEM\_PROCESSOR}\NormalTok{ arm)}
\KeywordTok{SET}\NormalTok{(}\DecValTok{CMAKE\_C\_COMPILER}\NormalTok{ arm{-}linux{-}gnueabihf{-}gcc)}
\end{Highlighting}
\end{Shaded}

Then:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cmake} \AttributeTok{{-}DCMAKE\_TOOLCHAIN\_FILE}\OperatorTok{=}\NormalTok{toolchain{-}arm.cmake ..}
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Your build system now knows it's cross-compiling for ARM.

\subsubsection{Step 10. Tiny Code: Detect and Print Target
Architecture}\label{step-10.-tiny-code-detect-and-print-target-architecture}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if defined(\_\_x86\_64\_\_)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x86\_64}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif defined(\_\_aarch64\_\_)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"ARM64}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif defined(\_\_arm\_\_)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"ARM 32{-}bit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif defined(\_\_riscv)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"RISC{-}V}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Unknown architecture}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile for different targets and observe the output.

\subsubsection{Why It Matters}\label{why-it-matters-72}

Cross-compilation connects your laptop to every other device you'll ever
program. It's how kernel modules, embedded systems, and even Android
apps are built. Once you learn it, you can build \textbf{anywhere, for
anything}.

\subsubsection{Try It Yourself}\label{try-it-yourself-82}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install an ARM or RISC-V cross-compiler on your host system.
\item
  Cross-compile and run a simple ``Hello'' binary on an emulator
  (\texttt{qemu-arm}).
\item
  Use the \texttt{-static} flag to make it self-contained.
\item
  Add a Makefile with variables \texttt{CC}, \texttt{CFLAGS}, and
  \texttt{LDFLAGS} for easy reuse.
\item
  Try building both for Linux and Windows from the same source.
\end{enumerate}

Next, you'll explore \textbf{threading with pthreads}, how to run
multiple parts of your program at the same time using standard C
threads.

\subsection{85. Threading with pthreads}\label{threading-with-pthreads}

Modern computers run many things at once. Your web browser, text editor,
and compiler all share CPU time through \textbf{threads}. In C, the most
widely used threading API is \textbf{POSIX threads}, or
\textbf{pthreads}. It's low-level, portable, and gives you fine-grained
control over parallel execution.

This section will teach you how to create, manage, and synchronize
threads safely.

\subsubsection{Step 1. What Is a
Thread?}\label{step-1.-what-is-a-thread}

A \textbf{thread} is a lightweight execution unit that shares the same
memory space as other threads in a process.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Process
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Thread
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Has its own memory (stack, heap, code) & Shares memory with other
threads \\
Created by OS & Created by process \\
Expensive to start & Cheap and fast to start \\
Communicates via IPC & Communicates via shared memory \\
\end{longtable}

Threads are ideal for tasks like handling multiple network requests,
performing parallel computation, or keeping a UI responsive.

\subsubsection{Step 2. Including
pthreads}\label{step-2.-including-pthreads}

To use pthreads, include the header:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

When compiling, link with the pthread library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ program.c }\AttributeTok{{-}o}\NormalTok{ program }\AttributeTok{{-}lpthread}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. Creating Threads}\label{step-3.-creating-threads}

Each thread runs a separate function. The function must take and return
\texttt{void\ *}.

\textbf{Tiny Code: Basic Thread Creation}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ task}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from thread! Arg = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{arg}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t thread}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}

\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{thread}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ task}\OperatorTok{,} \OperatorTok{\&}\NormalTok{value}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{thread}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Main thread finished.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello from thread! Arg = 42
Main thread finished.
\end{verbatim}

\textbf{Explanation:}

\begin{itemize}
\tightlist
\item
  \texttt{pthread\_create} starts a new thread.
\item
  \texttt{pthread\_join} waits for it to finish.
\end{itemize}

\subsubsection{Step 4. Multiple Threads}\label{step-4.-multiple-threads}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ work}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Thread }\SpecialCharTok{\%d}\StringTok{ running}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ id}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t threads}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ ids}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        pthread\_create}\OperatorTok{(\&}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        pthread\_join}\OperatorTok{(}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"All threads done.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output order may vary, threads run concurrently.

\subsubsection{Step 5. Race Conditions}\label{step-5.-race-conditions}

When two threads modify the same variable at the same time, bad things
happen. This is called a \textbf{race condition}.

Example (unsafe):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ increment}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        counter}\OperatorTok{++;}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Expected: \texttt{200000} Actual: unpredictable (e.g.~\texttt{137421}),
because increments overlap.

\subsubsection{Step 6. Using Mutexes (Mutual Exclusion
Locks)}\label{step-6.-using-mutexes-mutual-exclusion-locks}

A \textbf{mutex} ensures that only one thread modifies shared data at a
time.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{pthread\_mutex\_t lock}\OperatorTok{;}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ increment}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        pthread\_mutex\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{        counter}\OperatorTok{++;}
\NormalTok{        pthread\_mutex\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    pthread\_mutex\_init}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_mutex\_destroy}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now the output will consistently be \texttt{200000}.

\subsubsection{Step 7. Condition
Variables}\label{step-7.-condition-variables}

Condition variables let threads wait for a signal. They're used to
coordinate producer--consumer models.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\NormalTok{pthread\_mutex\_t lock}\OperatorTok{;}
\NormalTok{pthread\_cond\_t cond}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ ready }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ worker}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_mutex\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(!}\NormalTok{ready}\OperatorTok{)}
\NormalTok{        pthread\_cond\_wait}\OperatorTok{(\&}\NormalTok{cond}\OperatorTok{,} \OperatorTok{\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Worker got the signal!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    pthread\_mutex\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t t}\OperatorTok{;}
\NormalTok{    pthread\_mutex\_init}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_cond\_init}\OperatorTok{(\&}\NormalTok{cond}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ worker}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    sleep}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\NormalTok{    pthread\_mutex\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{    ready }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    pthread\_cond\_signal}\OperatorTok{(\&}\NormalTok{cond}\OperatorTok{);}
\NormalTok{    pthread\_mutex\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}

\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Thread
Attributes}\label{step-8.-thread-attributes}

You can control thread behavior using \texttt{pthread\_attr\_t}:

\begin{itemize}
\tightlist
\item
  Stack size
\item
  Detach state (joinable or detached)
\item
  Scheduling policy
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread\_attr\_t attr}\OperatorTok{;}
\NormalTok{pthread\_attr\_init}\OperatorTok{(\&}\NormalTok{attr}\OperatorTok{);}
\NormalTok{pthread\_attr\_setdetachstate}\OperatorTok{(\&}\NormalTok{attr}\OperatorTok{,}\NormalTok{ PTHREAD\_CREATE\_DETACHED}\OperatorTok{);}
\NormalTok{pthread\_create}\OperatorTok{(\&}\NormalTok{thread}\OperatorTok{,} \OperatorTok{\&}\NormalTok{attr}\OperatorTok{,}\NormalTok{ task}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{pthread\_attr\_destroy}\OperatorTok{(\&}\NormalTok{attr}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Detached threads free resources automatically when done.

\subsubsection{Step 9. Thread Safety and Best
Practices}\label{step-9.-thread-safety-and-best-practices}

\begin{itemize}
\tightlist
\item
  Protect all shared data with mutexes.
\item
  Avoid global variables when possible.
\item
  Use thread-safe functions (\texttt{strtok\_r} instead of
  \texttt{strtok}).
\item
  Keep critical sections short.
\item
  Join or detach all threads before program exit.
\end{itemize}

\subsubsection{Step 10. Tiny Code: Parallel
Sum}\label{step-10.-tiny-code-parallel-sum}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define N }\DecValTok{4}

\DataTypeTok{int}\NormalTok{ partial}\OperatorTok{[}\DecValTok{4}\OperatorTok{];}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ compute}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ start }\OperatorTok{=}\NormalTok{ id }\OperatorTok{*} \DecValTok{25}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=}\NormalTok{ start}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ start }\OperatorTok{+} \DecValTok{25}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        sum }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{    partial}\OperatorTok{[}\NormalTok{id}\OperatorTok{]} \OperatorTok{=}\NormalTok{ sum}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t threads}\OperatorTok{[}\NormalTok{N}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ ids}\OperatorTok{[}\NormalTok{N}\OperatorTok{];}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ N}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
\NormalTok{        pthread\_create}\OperatorTok{(\&}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ compute}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ N}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        pthread\_join}\OperatorTok{(}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{        total }\OperatorTok{+=}\NormalTok{ partial}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This program splits a task across multiple threads and combines results.

\subsubsection{Why It Matters}\label{why-it-matters-73}

Threads make your programs faster, more responsive, and scalable. They
allow C to fully exploit modern multi-core CPUs, from servers to
embedded systems. Learning pthreads means learning how real systems
multitask efficiently and safely.

\subsubsection{Try It Yourself}\label{try-it-yourself-83}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that starts 5 threads, each printing its ID.
\item
  Add a shared counter and protect it with a mutex.
\item
  Implement a producer--consumer queue using condition variables.
\item
  Use \texttt{pthread\_attr\_t} to create detached worker threads.
\item
  Profile your program's performance as you increase the thread count.
\end{enumerate}

Next, you'll explore \textbf{atomic operations and memory models}, how
modern CPUs ensure consistency when multiple threads share data without
locks.

\subsection{86. Atomic Operations and Memory
Models}\label{atomic-operations-and-memory-models}

When multiple threads share data, you usually protect that data with
\textbf{locks} like \texttt{pthread\_mutex\_t}. But sometimes, you need
something faster, a way to perform an update that can't be interrupted,
even across threads. That's where \textbf{atomic operations} come in.

This section introduces atomic operations in C and how the
\textbf{memory model} ensures your program behaves predictably across
cores.

\subsubsection{Step 1. What Does ``Atomic''
Mean?}\label{step-1.-what-does-atomic-mean}

An \textbf{atomic operation} is one that happens all at once, it can't
be divided or interrupted.

Example idea: If two threads both run \texttt{counter++} at the same
time:

\begin{itemize}
\tightlist
\item
  Without atomicity → race condition.
\item
  With atomicity → one thread's update completes fully before the other
  starts.
\end{itemize}

Atomic operations are essential in lock-free algorithms, concurrent
queues, and reference counters.

\subsubsection{\texorpdfstring{Step 2. The Problem with
\texttt{counter++}}{Step 2. The Problem with counter++}}\label{step-2.-the-problem-with-counter}

This line looks simple:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counter}\OperatorTok{++;}
\end{Highlighting}
\end{Shaded}

But under the hood, it's three separate steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Load \texttt{counter} from memory.
\item
  Increment it.
\item
  Store it back.
\end{enumerate}

Two threads doing this at once can lose updates:

\begin{verbatim}
Thread A: load(5)
Thread B: load(5)
Thread A: store(6)
Thread B: store(6)
\end{verbatim}

Result: one increment lost, final value should be 7 but ends up 6.

\subsubsection{Step 3. Using Atomic
Types}\label{step-3.-using-atomic-types}

C11 introduced \texttt{\textless{}stdatomic.h\textgreater{}}, a portable
way to use atomic operations.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdatomic.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    atomic\_int counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    atomic\_fetch\_add}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    atomic\_fetch\_add}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);} \CommentTok{// 2}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

No locks. No race conditions. The \texttt{atomic\_*} functions guarantee
the operations are atomic at the hardware level.

\subsubsection{Step 4. Common Atomic
Functions}\label{step-4.-common-atomic-functions}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Function & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{atomic\_load} & Read atomically \\
\texttt{atomic\_store} & Write atomically \\
\texttt{atomic\_fetch\_add} & Add and return old value \\
\texttt{atomic\_fetch\_sub} & Subtract and return old value \\
\texttt{atomic\_exchange} & Replace and return old value \\
\texttt{atomic\_compare\_exchange\_strong} & Compare-and-swap \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{atomic\_compare\_exchange\_strong}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \OperatorTok{\&}\NormalTok{expected}\OperatorTok{,}\NormalTok{ desired}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If \texttt{counter\ ==\ expected}, replace it with \texttt{desired}.
Otherwise, update \texttt{expected} with the current value.

\subsubsection{Step 5. Tiny Code: Atomic Counter with
Threads}\label{step-5.-tiny-code-atomic-counter-with-threads}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdatomic.h\textgreater{}}

\NormalTok{atomic\_int counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ work}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        atomic\_fetch\_add}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    pthread\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output is always \texttt{200000}, with no mutexes and no data races.

\subsubsection{Step 6. Relaxed vs Sequential
Consistency}\label{step-6.-relaxed-vs-sequential-consistency}

Atomic operations can have \textbf{different memory orders}. By default,
they're \emph{sequentially consistent}, the strongest and safest
ordering.

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Memory Order & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{memory\_order\_seq\_cst} & Global consistent order (default) \\
\texttt{memory\_order\_relaxed} & Only atomicity guaranteed \\
\texttt{memory\_order\_acquire} & Prevent reordering before load \\
\texttt{memory\_order\_release} & Prevent reordering after store \\
\texttt{memory\_order\_acq\_rel} & Acquire + Release combo \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{atomic\_fetch\_add\_explicit}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ memory\_order\_relaxed}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is faster but weaker, use only when you understand your memory
model.

\subsubsection{Step 7. Memory Barriers and
Visibility}\label{step-7.-memory-barriers-and-visibility}

Modern CPUs reorder reads/writes for performance. Atomics, fences, and
locks control \emph{when} updates become visible to other threads.

\textbf{Example:} Thread A writes \texttt{ready\ =\ 1}. Thread B waits
until it sees \texttt{ready\ ==\ 1}. If the compiler reorders memory
operations, Thread B might not see the change.

Use:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{atomic\_thread\_fence}\OperatorTok{(}\NormalTok{memory\_order\_seq\_cst}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

to prevent reordering across the fence.

\subsubsection{Step 8. Compare-and-Swap
(CAS)}\label{step-8.-compare-and-swap-cas}

CAS is the backbone of lock-free data structures.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ expected }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ desired }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{atomic\_compare\_exchange\_strong}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \OperatorTok{\&}\NormalTok{expected}\OperatorTok{,}\NormalTok{ desired}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Swapped!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It atomically checks if \texttt{counter\ ==\ expected} and updates it,
all in one instruction. This is used to build things like spinlocks,
queues, and reference counters.

\subsubsection{Step 9. Spinlocks with
Atomics}\label{step-9.-spinlocks-with-atomics}

A \textbf{spinlock} keeps checking until it can acquire the lock.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdatomic.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}

\NormalTok{atomic\_flag lock }\OperatorTok{=}\NormalTok{ ATOMIC\_FLAG\_INIT}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ lock\_spin}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{atomic\_flag\_test\_and\_set}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{))}
        \OperatorTok{;} \CommentTok{// busy wait}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ unlock\_spin}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    atomic\_flag\_clear}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is efficient when the lock is held for a very short time. For
longer waits, use \texttt{pthread\_mutex\_t} instead.

\subsubsection{Step 10. Tiny Code: Atomic Reference
Counter}\label{step-10.-tiny-code-atomic-reference-counter}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdatomic.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    atomic\_int refcount}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Object}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ retain}\OperatorTok{(}\NormalTok{Object}\OperatorTok{*}\NormalTok{ obj}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    atomic\_fetch\_add}\OperatorTok{(\&}\NormalTok{obj}\OperatorTok{{-}\textgreater{}}\NormalTok{refcount}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ release}\OperatorTok{(}\NormalTok{Object}\OperatorTok{*}\NormalTok{ obj}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{atomic\_fetch\_sub}\OperatorTok{(\&}\NormalTok{obj}\OperatorTok{{-}\textgreater{}}\NormalTok{refcount}\OperatorTok{,} \DecValTok{1}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Object freed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Object obj }\OperatorTok{=} \OperatorTok{\{} \OperatorTok{.}\NormalTok{refcount }\OperatorTok{=} \DecValTok{1} \OperatorTok{\};}
\NormalTok{    retain}\OperatorTok{(\&}\NormalTok{obj}\OperatorTok{);}
\NormalTok{    release}\OperatorTok{(\&}\NormalTok{obj}\OperatorTok{);}
\NormalTok{    release}\OperatorTok{(\&}\NormalTok{obj}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Object freed
\end{verbatim}

This is how many real-world systems (e.g.~file handles, shared memory)
track usage.

\subsubsection{Why It Matters}\label{why-it-matters-74}

Atomic operations are the building blocks of lock-free programming. They
allow you to write high-performance concurrent code without blocking
other threads. The C memory model gives you guarantees to reason about
correctness even across multiple CPU cores.

\subsubsection{Try It Yourself}\label{try-it-yourself-84}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace a mutex counter with an atomic counter.
\item
  Implement a spinlock using \texttt{atomic\_flag}.
\item
  Use \texttt{atomic\_compare\_exchange\_strong} to build a simple CAS
  loop.
\item
  Test the difference between \texttt{memory\_order\_relaxed} and
  \texttt{seq\_cst}.
\item
  Build a reference-counted structure using atomics.
\end{enumerate}

Next, you'll explore \textbf{using C with other languages (FFI)}, how to
make C libraries callable from Python, Rust, and Go.

\subsection{87. Using C with Other Languages
(FFI)}\label{using-c-with-other-languages-ffi}

C is often called the \emph{universal assembly language}, nearly every
modern language can call into it. This is made possible through the
\textbf{Foreign Function Interface (FFI)}, which defines how different
languages talk to C code.

In this section, you'll learn how to expose your C functions to Python,
Rust, and Go, and how to call functions from those languages
\emph{inside} C.

\subsubsection{Step 1. What Is an FFI?}\label{step-1.-what-is-an-ffi}

An \textbf{FFI (Foreign Function Interface)} is a bridge that lets
programs written in one language use code written in another.

Why FFI matters:

\begin{itemize}
\tightlist
\item
  Reuse fast, low-level C libraries (e.g., OpenSSL, SQLite).
\item
  Integrate C modules into higher-level languages like Python or Go.
\item
  Extend existing programs without rewriting everything.
\item
  Combine system-level control with productivity.
\end{itemize}

\subsubsection{Step 2. The Foundation: C
ABI}\label{step-2.-the-foundation-c-abi}

The \textbf{ABI (Application Binary Interface)} defines how function
calls, parameters, and data structures are represented in memory. The
FFI works because C has a stable and simple ABI.

Rules include:

\begin{itemize}
\tightlist
\item
  How arguments are passed (registers or stack).
\item
  How return values are handled.
\item
  How data types are aligned in memory.
\end{itemize}

That's why almost every language provides a way to ``speak'' the C ABI.

\subsubsection{Step 3. Exposing C Functions to Other
Languages}\label{step-3.-exposing-c-functions-to-other-languages}

You can make your C functions callable by other languages by marking
them with \texttt{extern\ "C"} (if compiling as C++) or just regular C
functions otherwise.

\textbf{Tiny Code: Shared C Library}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: mathlib.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile it into a shared library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}shared} \AttributeTok{{-}fPIC} \AttributeTok{{-}o}\NormalTok{ libmathlib.so mathlib.c}
\end{Highlighting}
\end{Shaded}

This creates a \texttt{.so} (Linux) or \texttt{.dll} (Windows) or
\texttt{.dylib} (macOS) file you can load in other languages.

\subsubsection{Step 4. Using C in Python
(ctypes)}\label{step-4.-using-c-in-python-ctypes}

Python can call C functions directly using the \texttt{ctypes} module.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ ctypes}

\NormalTok{lib }\OperatorTok{=}\NormalTok{ ctypes.CDLL(}\StringTok{"./libmathlib.so"}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(lib.add(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(lib.multiply(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
5
20
\end{verbatim}

Python automatically converts standard types (\texttt{int},
\texttt{float}, \texttt{char\ *}) to C equivalents.

For more complex types, you can define \texttt{ctypes.Structure} classes
matching your C structs.

\subsubsection{Step 5. Using C in Rust}\label{step-5.-using-c-in-rust}

Rust has a built-in \texttt{extern\ "C"} block for FFI.

\textbf{Rust Example:}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{\#[}\NormalTok{link}\AttributeTok{(}\NormalTok{name }\OperatorTok{=} \StringTok{"mathlib"}\AttributeTok{)]}
\KeywordTok{extern} \StringTok{"C"} \OperatorTok{\{}
    \KeywordTok{fn}\NormalTok{ add(a}\OperatorTok{:} \DataTypeTok{i32}\OperatorTok{,}\NormalTok{ b}\OperatorTok{:} \DataTypeTok{i32}\NormalTok{) }\OperatorTok{{-}\textgreater{}} \DataTypeTok{i32}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{fn}\NormalTok{ main() }\OperatorTok{\{}
    \KeywordTok{unsafe} \OperatorTok{\{}
        \PreprocessorTok{println!}\NormalTok{(}\StringTok{"\{\}"}\OperatorTok{,}\NormalTok{ add(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{))}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{rustc}\NormalTok{ main.rs }\AttributeTok{{-}L}\NormalTok{ .}
\end{Highlighting}
\end{Shaded}

Rust enforces \texttt{unsafe} because it can't verify what happens
inside the C function.

\subsubsection{Step 6. Using C in Go}\label{step-6.-using-c-in-go}

Go uses the \texttt{import\ "C"} directive for seamless C integration.

\textbf{Go Example:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*}
\CommentTok{\#include "mathlib.c"}
\CommentTok{*/}
\KeywordTok{import} \StringTok{"C"}
\KeywordTok{import} \StringTok{"fmt"}

\KeywordTok{func}\NormalTok{ main}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    fmt}\OperatorTok{.}\NormalTok{Println}\OperatorTok{(}\NormalTok{C}\OperatorTok{.}\NormalTok{add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{))}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{go}\NormalTok{ run main.go}
\end{Highlighting}
\end{Shaded}

Go will compile your C code behind the scenes and link it automatically.

\subsubsection{Step 7. Calling Foreign Code from
C}\label{step-7.-calling-foreign-code-from-c}

You can also go the other way, call functions from another language
\emph{inside C}.

\textbf{Example: C calling Python}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}Python.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Py\_Initialize}\OperatorTok{();}
\NormalTok{    PyRun\_SimpleString}\OperatorTok{(}\StringTok{"print(\textquotesingle{}Hello from Python in C!\textquotesingle{})"}\OperatorTok{);}
\NormalTok{    Py\_Finalize}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main }\VariableTok{$(}\ExtensionTok{python3{-}config} \AttributeTok{{-}{-}cflags} \AttributeTok{{-}{-}ldflags}\VariableTok{)}
\end{Highlighting}
\end{Shaded}

This embeds a Python interpreter in your C program, powerful for
scripting or AI integration.

\subsubsection{Step 8. Data Structures Across
Languages}\label{step-8.-data-structures-across-languages}

FFI works best with \textbf{simple, C-compatible types}:

\begin{itemize}
\tightlist
\item
  \texttt{int}, \texttt{double}, \texttt{char\ *}, and flat structs.
  Avoid C++ classes, pointers to complex structs, or variable-length
  arrays, they often don't translate cleanly.
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ score}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Record}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can use this struct easily from Python (\texttt{ctypes.Structure})
or Rust (\texttt{\#{[}repr(C){]}\ struct}).

\subsubsection{Step 9. Memory Ownership
Rules}\label{step-9.-memory-ownership-rules}

Always define \emph{who allocates and who frees memory}.

If C allocates something:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\OperatorTok{*}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\OperatorTok{*}\NormalTok{ s }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{32}\OperatorTok{);}
\NormalTok{    sprintf}\OperatorTok{(}\NormalTok{s}\OperatorTok{,} \StringTok{"Hello from C!"}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ s}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then the caller (e.g., Python) must call \texttt{free()} via FFI to
avoid leaks. Never assume the garbage collector of another language will
clean up C memory.

\subsubsection{Step 10. Tiny Code: C Shared Library +
Python}\label{step-10.-tiny-code-c-shared-library-python}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// greet.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{char}\OperatorTok{*}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ name}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{static} \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
\NormalTok{    snprintf}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{),} \StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ buf}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}shared} \AttributeTok{{-}fPIC} \AttributeTok{{-}o}\NormalTok{ libgreet.so greet.c}
\end{Highlighting}
\end{Shaded}

\textbf{Python:}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ ctypes}
\NormalTok{lib }\OperatorTok{=}\NormalTok{ ctypes.CDLL(}\StringTok{"./libgreet.so"}\NormalTok{)}
\NormalTok{lib.greet.restype }\OperatorTok{=}\NormalTok{ ctypes.c\_char\_p}
\BuiltInTok{print}\NormalTok{(lib.greet(}\StringTok{b"World"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, World!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-75}

FFI turns C into the foundation of the software world, your C code can
power systems written in any language. This is how databases, OS
kernels, and AI frameworks expose APIs across ecosystems. Understanding
FFI means you can build \emph{language bridges}, not just programs.

\subsubsection{Try It Yourself}\label{try-it-yourself-85}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a simple C library (math, strings, or sorting).
\item
  Load it in Python using \texttt{ctypes} and call its functions.
\item
  Reuse the same library from Rust using \texttt{extern\ "C"}.
\item
  Embed Python in C for a scripting layer.
\item
  Think about which side should own and free memory.
\end{enumerate}

Next, you'll explore \textbf{safer alternatives and modern C features},
bounds checking, static assertions, and ways to make C code more
reliable.

\subsection{\texorpdfstring{88. Safer Alternatives (Bounds Checking,
\texttt{\_Static\_assert}, and Modern C Safety
Tools)}{88. Safer Alternatives (Bounds Checking, \_Static\_assert, and Modern C Safety Tools)}}\label{safer-alternatives-bounds-checking-_static_assert-and-modern-c-safety-tools}

C gives you power and control, but also responsibility. Because C does
not automatically protect you from memory errors, buffer overflows, or
type misuse, you must add safety at the language and tool level.

This section explores modern safety features in \textbf{C11 to C23},
including \textbf{bounds checking}, \textbf{static assertions}, and
practical habits for writing safer C.

\subsubsection{Step 1. Why Safety Matters in
C}\label{step-1.-why-safety-matters-in-c}

C is fast because it trusts the programmer. That means:

\begin{itemize}
\tightlist
\item
  It doesn't check array bounds.
\item
  It doesn't initialize memory automatically.
\item
  It doesn't manage memory for you.
\end{itemize}

That trust is both the reason C is used for kernels and the reason it
causes so many bugs. The goal is not to make C ``safe by default,'' but
to make your \emph{use of C safe by design}.

\subsubsection{Step 2. Safer Bounds
Handling}\label{step-2.-safer-bounds-handling}

A classic error in C:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{8}\OperatorTok{];}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \StringTok{"HelloWorld"}\OperatorTok{);} \CommentTok{// buffer overflow}
\end{Highlighting}
\end{Shaded}

This overwrites memory past \texttt{name} and causes undefined behavior.

\textbf{Fix 1:} Use bounded versions of functions

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strncpy}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \StringTok{"HelloWorld"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{name}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{name}\OperatorTok{[}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{name}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Fix 2:} Use safer alternatives introduced in C11 Annex K (if
your compiler supports them):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strcpy\_s}\OperatorTok{(}\NormalTok{name}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{name}\OperatorTok{),} \StringTok{"Hello"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

They automatically check bounds and return error codes. However, Annex K
is \emph{optional}, so not all compilers implement it.

\subsubsection{Step 3. Tiny Code: Safe String
Copy}\label{step-3.-tiny-code-safe-string-copy}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ dst}\OperatorTok{[}\DecValTok{8}\OperatorTok{];}
\NormalTok{    strncpy}\OperatorTok{(}\NormalTok{dst}\OperatorTok{,} \StringTok{"Example"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{dst}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{    dst}\OperatorTok{[}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{dst}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Safe copy: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ dst}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ safe\_copy.c }\AttributeTok{{-}o}\NormalTok{ safe\_copy }\AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}O2}
\end{Highlighting}
\end{Shaded}

The \texttt{-Wall\ -Wextra} flags warn about suspicious behavior early,
one of your best ``safety tools.''

\subsubsection{\texorpdfstring{Step 4. \texttt{\_Static\_assert}:
Compile-Time
Checking}{Step 4. \_Static\_assert: Compile-Time Checking}}\label{step-4.-_static_assert-compile-time-checking}

Introduced in \textbf{C11}, \texttt{\_Static\_assert} lets you validate
conditions \emph{before} the program even compiles.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{\_Static\_assert}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)} \OperatorTok{==} \DecValTok{4}\OperatorTok{,} \StringTok{"This code requires 32{-}bit int"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If the condition fails, compilation stops with a clear message.

You can use it for:

\begin{itemize}
\tightlist
\item
  Checking structure layout
\item
  Ensuring type sizes
\item
  Verifying array lengths
\item
  Enforcing invariants
\end{itemize}

\subsubsection{Step 5. Safer Integer
Operations}\label{step-5.-safer-integer-operations}

Integer overflow is undefined behavior in C. Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2147483647} \OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// overflow}
\end{Highlighting}
\end{Shaded}

Safer options:

\begin{itemize}
\item
  Use \texttt{unsigned} types when wrapping is intentional.
\item
  Use compiler flags:

  \begin{itemize}
  \tightlist
  \item
    \texttt{-ftrapv} (GCC/Clang): trap on overflow.
  \item
    \texttt{-fsanitize=undefined}: detect overflow at runtime.
  \end{itemize}
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{undefined }\AttributeTok{{-}O2} \AttributeTok{{-}g}\NormalTok{ check.c }\AttributeTok{{-}o}\NormalTok{ check}
\end{Highlighting}
\end{Shaded}

This will abort your program the moment an overflow occurs.

\subsubsection{Step 6. Null Pointer and Resource
Safety}\label{step-6.-null-pointer-and-resource-safety}

Always check return values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For dynamic memory:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Out of memory}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

And always \texttt{free()} when done.

\subsubsection{Step 7. Tools for Safety}\label{step-7.-tools-for-safety}

Modern compilers and tools help you detect bugs early:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5556}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4444}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Tool
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{AddressSanitizer (\texttt{-fsanitize=address})} & Detects buffer
overflows, use-after-free \\
\textbf{UndefinedBehaviorSanitizer (\texttt{-fsanitize=undefined})} &
Detects integer and type errors \\
\textbf{Valgrind} & Checks for memory leaks and invalid accesses \\
\textbf{clang-tidy} & Static analysis and style checking \\
\textbf{cppcheck} & Portable static analyzer for C/C++ \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{clang} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{address safe.c }\AttributeTok{{-}o}\NormalTok{ safe}
\ExtensionTok{./safe}
\end{Highlighting}
\end{Shaded}

If there's a bug, you'll get a detailed memory trace.

\subsubsection{Step 8. Struct and Alignment
Checks}\label{step-8.-struct-and-alignment-checks}

Unintended padding can cause issues when serializing or working with
hardware. You can assert layout at compile time:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stddef.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Packet }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ type}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{\_Static\_assert}\OperatorTok{(}\NormalTok{offsetof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Packet}\OperatorTok{,}\NormalTok{ id}\OperatorTok{)} \OperatorTok{==} \DecValTok{4}\OperatorTok{,} \StringTok{"Alignment mismatch"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This ensures your assumptions about memory layout are correct.

\subsubsection{Step 9. Defensive Macros and Compile
Flags}\label{step-9.-defensive-macros-and-compile-flags}

Protect yourself with compile-time options:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3662}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6338}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Flag
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{-Wall\ -Wextra} & Enable important warnings \\
\texttt{-Werror} & Treat warnings as errors \\
\texttt{-Wconversion} & Warn on implicit type conversions \\
\texttt{-fsanitize=address} & Detect memory safety issues \\
\texttt{-D\_FORTIFY\_SOURCE=2} & Add runtime buffer checks (glibc) \\
\texttt{-fstack-protector-strong} & Detect stack corruption \\
\texttt{-O2} & Optimize safely without risky transformations \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}Werror} \AttributeTok{{-}O2} \AttributeTok{{-}fstack{-}protector{-}strong} \AttributeTok{{-}D\_FORTIFY\_SOURCE}\OperatorTok{=}\NormalTok{2 main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 10. Tiny Code: Using Static Assertions and
Sanitizers}\label{step-10.-tiny-code-using-static-assertions-and-sanitizers}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Data }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{16}\OperatorTok{];}
\OperatorTok{\};}

\KeywordTok{\_Static\_assert}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Data}\OperatorTok{)} \OperatorTok{\textless{}=} \DecValTok{32}\OperatorTok{,} \StringTok{"Struct too large"}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Data d }\OperatorTok{=} \OperatorTok{\{}\DecValTok{42}\OperatorTok{,} \StringTok{"C Safety"}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}

    \DataTypeTok{char}\NormalTok{ buf}\OperatorTok{[}\DecValTok{8}\OperatorTok{];}
\NormalTok{    strncpy}\OperatorTok{(}\NormalTok{buf}\OperatorTok{,} \StringTok{"Safe"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\NormalTok{    buf}\OperatorTok{[}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buf}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Buffer: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{address }\AttributeTok{{-}O2}\NormalTok{ safe\_program.c }\AttributeTok{{-}o}\NormalTok{ safe\_program}
\end{Highlighting}
\end{Shaded}

This program will abort if memory safety is violated, giving you
immediate feedback during testing.

\subsubsection{Why It Matters}\label{why-it-matters-76}

Safety doesn't make your code slower, it makes your software
\emph{trustworthy}. Even though C gives you sharp tools, the combination
of static checks, compiler warnings, and runtime sanitizers can make
your programs robust enough for production systems.

\subsubsection{Try It Yourself}\label{try-it-yourself-86}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \texttt{\_Static\_assert} checks in your structs and constants.
\item
  Compile with \texttt{-Wall\ -Wextra\ -Werror} and fix all warnings.
\item
  Use AddressSanitizer to catch out-of-bounds bugs.
\item
  Test your program under Valgrind for leaks.
\item
  Try writing the same buggy code twice, once raw, once safe, and
  compare behavior.
\end{enumerate}

Next, you'll explore \textbf{modern C style}, how to write clear,
maintainable, and idiomatic code in the C23 era.

\subsection{89. Modern Style: Clean and Readable
C}\label{modern-style-clean-and-readable-c}

C has been around for over 50 years, and yet it keeps evolving. Modern C
(C11--C23) combines the power of low-level programming with safer
syntax, cleaner idioms, and new features that make code easier to reason
about.

This section will help you write \textbf{modern, readable, and
maintainable C}, the kind of C that feels timeless.

\subsubsection{Step 1. Think ``Clarity Over
Cleverness''}\label{step-1.-think-clarity-over-cleverness}

The golden rule of modern C is:

\begin{quote}
Write for humans, not compilers.
\end{quote}

Compilers can handle complexity, your teammates (and future you) can't.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\NormalTok{i }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-};} \OperatorTok{)}\NormalTok{ a}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{    a}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Readability and simplicity always win.

\subsubsection{Step 2. Prefer Explicit
Initialization}\label{step-2.-prefer-explicit-initialization}

Always initialize your variables. Uninitialized memory is one of the
biggest sources of bugs.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Also initialize arrays and structs explicitly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{10}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{} \OperatorTok{.}\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{,} \OperatorTok{.}\NormalTok{y }\OperatorTok{=} \DecValTok{20} \OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Step 3. Use \texttt{const}
Generously}{Step 3. Use const Generously}}\label{step-3.-use-const-generously}

\texttt{const} communicates intent, ``this value shouldn't change.''

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\DataTypeTok{void}\NormalTok{ print}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{ message}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This helps the compiler optimize, prevents accidental modification, and
improves clarity.

\subsubsection{Step 4. Prefer Modern Standard
Headers}\label{step-4.-prefer-modern-standard-headers}

Use standard headers like \texttt{\textless{}stdint.h\textgreater{}},
\texttt{\textless{}stdbool.h\textgreater{}}, and
\texttt{\textless{}stddef.h\textgreater{}} for clear, portable code.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{bool}\NormalTok{ is\_even}\OperatorTok{(}\DataTypeTok{uint32\_t}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{n }\OperatorTok{\%} \DecValTok{2}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Avoid using old-style typedefs like
\texttt{typedef\ unsigned\ long\ ulong;} unless it improves meaning.

\subsubsection{\texorpdfstring{Step 5. Use \texttt{bool} Instead of
\texttt{int} for
Logic}{Step 5. Use bool Instead of int for Logic}}\label{step-5.-use-bool-instead-of-int-for-logic}

In old C, people used \texttt{int} for true/false. Modern C gives you
\texttt{\_Bool} via \texttt{\textless{}stdbool.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{bool}\NormalTok{ done }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{done}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    done }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This improves clarity and makes your code self-documenting.

\subsubsection{Step 6. Write Small, Focused
Functions}\label{step-6.-write-small-focused-functions}

Keep functions short, ideally one purpose per function.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ handle\_all}\OperatorTok{()} \OperatorTok{\{} \CommentTok{/* does 10 things */} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ read\_input}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ process\_data}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ write\_output}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This makes testing and debugging far easier.

\subsubsection{Step 7. Avoid Macros for
Everything}\label{step-7.-avoid-macros-for-everything}

In early C, macros were overused for constants and functions. Today,
prefer inline functions and \texttt{const} instead.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Inline functions are type-safe and debug-friendly.

\subsubsection{Step 8. Use Scoped Variables and
Declarations}\label{step-8.-use-scoped-variables-and-declarations}

Since C99, you can declare variables close to where they're used:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Avoid keeping variables alive longer than necessary, this reduces bugs
and clarifies scope.

\subsubsection{Step 9. Embrace C23
Features}\label{step-9.-embrace-c23-features}

C23 modernizes syntax and makes C safer and more expressive.

Highlights:

\begin{itemize}
\tightlist
\item
  \texttt{typeof}, reuse variable types automatically
\item
  \texttt{nullptr}, replaces \texttt{NULL}
\item
  \texttt{{[}{[}nodiscard{]}{]}}, warn if function return is ignored
\item
  \texttt{auto}, type inference for local variables
\item
  UTF-8 character support and string literals
\item
  \texttt{alignof} / \texttt{alignas} for precise memory layout
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[[}\AttributeTok{nodiscard}\OperatorTok{]]} \DataTypeTok{int}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 10. Tiny Code: Modern C23
Example}\label{step-10.-tiny-code-modern-c23-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\OperatorTok{[[}\AttributeTok{nodiscard}\OperatorTok{]]} \DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{uint32\_t}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{uint32\_t}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{uint32\_t}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}

    \DataTypeTok{bool}\NormalTok{ valid }\OperatorTok{=} \OperatorTok{(}\NormalTok{sum }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{valid}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%u\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with a modern compiler (GCC 13+ or Clang 17+):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 modern.c }\AttributeTok{{-}o}\NormalTok{ modern}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum = 30
\end{verbatim}

This code uses \texttt{{[}{[}nodiscard{]}{]}}, \texttt{bool}, and
\texttt{const}, small touches that improve both style and safety.

\subsubsection{Why It Matters}\label{why-it-matters-77}

Readable C code lasts for decades. The best systems code, in kernels,
compilers, and libraries, looks simple because it follows clear
patterns:

\begin{itemize}
\tightlist
\item
  \textbf{Small, pure functions.}
\item
  \textbf{Explicit types.}
\item
  \textbf{No surprises in memory handling.}
\end{itemize}

Modern C doesn't mean rewriting everything. It means writing
\emph{intentional C}, clear, correct, and expressive.

\subsubsection{Try It Yourself}\label{try-it-yourself-87}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Refactor one of your old programs to use
  \texttt{\textless{}stdint.h\textgreater{}} and
  \texttt{\textless{}stdbool.h\textgreater{}}.
\item
  Replace macros with inline functions.
\item
  Add \texttt{const} wherever possible.
\item
  Try compiling with \texttt{-std=c23} and explore new warnings.
\item
  Make your functions pure and side-effect free where possible.
\end{enumerate}

Next, you'll conclude this journey with \textbf{Practice: Portable
Multithreaded Program (90)}, a hands-on project that combines everything
from memory management to threading and portability.

\subsection{90. Practice: Portable Multithreaded
Program}\label{practice-portable-multithreaded-program}

It's time to bring together everything you've learned, memory
management, threads, synchronization, and portability, into one cohesive
program.

In this final section of \textbf{Chapter 9}, you'll build a
\textbf{portable multithreaded counter} that runs correctly across
architectures, compilers, and systems, demonstrating clean, safe, and
modern C in practice.

\subsubsection{Step 1. The Goal}\label{step-1.-the-goal}

We'll write a program that:

\begin{itemize}
\tightlist
\item
  Spawns multiple threads using \texttt{pthread} (POSIX standard).
\item
  Uses atomic operations for safe concurrent updates.
\item
  Prints consistent results regardless of CPU or endianness.
\item
  Compiles cleanly across Linux, macOS, and Windows (via MinGW).
\item
  Uses modern, readable C11--C23 style.
\end{itemize}

\subsubsection{Step 2. Plan the Design}\label{step-2.-plan-the-design}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Shared Counter:} \texttt{atomic\_int} for thread-safe
  increments.
\item
  \textbf{Thread Function:} Each thread performs a loop of increments.
\item
  \textbf{Timing:} Measure elapsed time for performance insight.
\item
  \textbf{Portability:} Use \texttt{\#ifdef} for cross-platform
  compatibility.
\item
  \textbf{Final Validation:} Ensure result equals total increments.
\end{enumerate}

\subsubsection{Step 3. Full Tiny Code}\label{step-3.-full-tiny-code}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdatomic.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\PreprocessorTok{\#ifdef \_WIN32}
\PreprocessorTok{\#include }\ImportTok{\textless{}windows.h\textgreater{}}
\PreprocessorTok{\#define SLEEP}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ Sleep}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}
\PreprocessorTok{\#else}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#define SLEEP}\OperatorTok{(}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ }\NormalTok{usleep}\OperatorTok{((}\PreprocessorTok{ms}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\DecValTok{1000}\OperatorTok{)}
\PreprocessorTok{\#endif}

\PreprocessorTok{\#define THREADS }\DecValTok{4}
\PreprocessorTok{\#define ITERATIONS }\DecValTok{250000}

\NormalTok{atomic\_int counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{void}\OperatorTok{*}\NormalTok{ worker}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{*}\NormalTok{ arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int}\OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ ITERATIONS}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        atomic\_fetch\_add}\OperatorTok{(\&}\NormalTok{counter}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{\%} \DecValTok{100000} \OperatorTok{==} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ id }\OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{            SLEEP}\OperatorTok{(}\DecValTok{1}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ now}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ timespec ts}\OperatorTok{;}
\NormalTok{    clock\_gettime}\OperatorTok{(}\NormalTok{CLOCK\_MONOTONIC}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ts}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ ts}\OperatorTok{.}\NormalTok{tv\_sec }\OperatorTok{+}\NormalTok{ ts}\OperatorTok{.}\NormalTok{tv\_nsec }\OperatorTok{/} \FloatTok{1e9}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    pthread\_t threads}\OperatorTok{[}\NormalTok{THREADS}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ ids}\OperatorTok{[}\NormalTok{THREADS}\OperatorTok{];}
    \DataTypeTok{double}\NormalTok{ start }\OperatorTok{=}\NormalTok{ now}\OperatorTok{();}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ THREADS}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{pthread\_create}\OperatorTok{(\&}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ worker}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{])} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"pthread\_create failed"}\OperatorTok{);}
            \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ THREADS}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        pthread\_join}\OperatorTok{(}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{);}

    \DataTypeTok{double}\NormalTok{ end }\OperatorTok{=}\NormalTok{ now}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter = }\SpecialCharTok{\%d}\StringTok{ (expected }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{,}\NormalTok{ THREADS }\OperatorTok{*}\NormalTok{ ITERATIONS}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Elapsed time: }\SpecialCharTok{\%.3f}\StringTok{ seconds}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ end }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. How It Works}\label{step-4.-how-it-works}

\begin{itemize}
\item
  \textbf{Atomic Counter:} \texttt{atomic\_fetch\_add} ensures that
  increments are atomic and race-free without using a mutex.
\item
  \textbf{Thread Creation:} Each thread runs the \texttt{worker()}
  function independently.
\item
  \textbf{Synchronization:} \texttt{pthread\_join} ensures all threads
  finish before printing results.
\item
  \textbf{Timing:} Uses \texttt{clock\_gettime()} for precise
  cross-platform timing.
\item
  \textbf{Sleep Macro:} \texttt{SLEEP(ms)} abstracts away platform
  differences between Windows and POSIX.
\end{itemize}

\subsubsection{Step 5. Compile and Run}\label{step-5.-compile-and-run}

On Linux or macOS:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}pthread} \AttributeTok{{-}O2} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra}\NormalTok{ portable\_threads.c }\AttributeTok{{-}o}\NormalTok{ portable\_threads}
\ExtensionTok{./portable\_threads}
\end{Highlighting}
\end{Shaded}

On Windows (MinGW):

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra}\NormalTok{ portable\_threads.c }\AttributeTok{{-}o}\NormalTok{ portable\_threads.exe }\AttributeTok{{-}lws2\_32}
\ExtensionTok{portable\_threads.exe}
\end{Highlighting}
\end{Shaded}

Expected output:

\begin{verbatim}
Counter = 1000000 (expected 1000000)
Elapsed time: 0.134 seconds
\end{verbatim}

The program finishes with perfect accuracy, no race conditions, and
works across platforms.

\subsubsection{Step 6. Improving
Portability}\label{step-6.-improving-portability}

\begin{itemize}
\item
  \textbf{Replace pthreads with C11
  \texttt{\textless{}threads.h\textgreater{}}} if you want standard-only
  C:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

  Use \texttt{thrd\_create} and \texttt{thrd\_join} instead of
  \texttt{pthread\_create} and \texttt{pthread\_join}.
\item
  \textbf{Use static assertions for validation:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{\_Static\_assert}\OperatorTok{(}\NormalTok{THREADS }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{,} \StringTok{"Must have at least one thread"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Use conditional macros} for system differences
  (\texttt{\_WIN32}, \texttt{\_\_linux\_\_}, \texttt{\_\_APPLE\_\_}).
\end{itemize}

\subsubsection{Step 7. Safety and Clarity
Checklist}\label{step-7.-safety-and-clarity-checklist}

✅ No raw pointers shared unsafely ✅ Atomic operations prevent races ✅
Sleep and timing are cross-platform ✅ Clean, modern syntax with C23
support ✅ Easy to modify (e.g., change thread count or workload)

\subsubsection{Step 8. Why It's
Portable}\label{step-8.-why-its-portable}

\begin{itemize}
\tightlist
\item
  Uses only standard C and POSIX APIs.
\item
  Avoids endian-dependent or undefined behavior.
\item
  Has clear abstractions for platform-specific code.
\item
  Relies on atomic types, not CPU-specific intrinsics.
\item
  Runs on x86, ARM, RISC-V, and others without changes.
\end{itemize}

\subsubsection{Step 9. Why It Matters}\label{step-9.-why-it-matters}

This tiny program embodies what C is best at:

\begin{itemize}
\tightlist
\item
  \textbf{Speed:} Threaded performance close to hardware.
\item
  \textbf{Control:} Explicit memory and concurrency.
\item
  \textbf{Clarity:} Modern C syntax keeps it readable.
\item
  \textbf{Portability:} Runs everywhere a compiler exists.
\end{itemize}

This is the C of today, minimal, precise, and reliable.

\subsubsection{Step 10. Try It Yourself}\label{step-10.-try-it-yourself}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Change \texttt{THREADS} and observe performance scaling.
\item
  Replace the atomic counter with a mutex, compare speed.
\item
  Port it to Windows and verify output.
\item
  Add timing to measure each thread's duration.
\item
  Experiment with C11 \texttt{\textless{}threads.h\textgreater{}} API
  for pure standard C.
\end{enumerate}

You've completed \textbf{Chapter 9, Portable and Modern C}. Next comes
\textbf{Chapter 10: Building Real Projects}, where you'll apply these
foundations to construct real-world systems, libraries, servers, and
interpreters, all in clean, idiomatic C.

\bookmarksetup{startatroot}

\chapter{Chapter 10. Building Real
Projects}\label{chapter-10.-building-real-projects}

\subsection{91. Designing Small C
Libraries}\label{designing-small-c-libraries}

Writing libraries is how you make your C code reusable, modular, and
easy to maintain. In this section, you'll learn how to design and
structure a \textbf{small, portable, and well-documented C library}, the
kind used in real systems for decades.

\subsubsection{Step 1. What Is a Library in
C?}\label{step-1.-what-is-a-library-in-c}

A library in C is a \textbf{collection of functions and data types} that
can be used by multiple programs.

There are two kinds of libraries:

\begin{itemize}
\tightlist
\item
  \textbf{Static libraries} (\texttt{.a} or \texttt{.lib}) -- compiled
  into the final program at build time.
\item
  \textbf{Shared libraries} (\texttt{.so} or \texttt{.dll}) -- loaded
  dynamically at runtime.
\end{itemize}

You'll start by building a small \textbf{static library} that provides
reusable math utilities.

\subsubsection{Step 2. Plan the Library}\label{step-2.-plan-the-library}

Let's design a library called \textbf{simplemath}, which provides:

\begin{itemize}
\tightlist
\item
  \texttt{add}, \texttt{subtract}, \texttt{multiply}, \texttt{divide}
\item
  Error handling for divide-by-zero
\item
  Clean, consistent naming
\end{itemize}

Structure:

\begin{verbatim}
simplemath/
 ├── include/
 │    └── simplemath.h
 ├── src/
 │    └── simplemath.c
 └── Makefile
\end{verbatim}

\subsubsection{\texorpdfstring{Step 3. The Header File
(\texttt{simplemath.h})}{Step 3. The Header File (simplemath.h)}}\label{step-3.-the-header-file-simplemath.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef SIMPLEMATH\_H}
\PreprocessorTok{\#define SIMPLEMATH\_H}

\PreprocessorTok{\#ifdef \_\_cplusplus}
\KeywordTok{extern} \StringTok{"C"} \OperatorTok{\{}
\PreprocessorTok{\#endif}

\DataTypeTok{double}\NormalTok{ sm\_add}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ sm\_sub}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ sm\_mul}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{double}\NormalTok{ sm\_div}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{*}\NormalTok{error}\OperatorTok{);}

\PreprocessorTok{\#ifdef \_\_cplusplus}
\OperatorTok{\}}
\PreprocessorTok{\#endif}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\textbf{Notes:}

\begin{itemize}
\tightlist
\item
  Include guards prevent double inclusion.
\item
  \texttt{extern\ "C"} allows usage in C++ projects.
\item
  Prefix (\texttt{sm\_}) prevents naming conflicts.
\end{itemize}

\subsubsection{\texorpdfstring{Step 4. The Implementation File
(\texttt{simplemath.c})}{Step 4. The Implementation File (simplemath.c)}}\label{step-4.-the-implementation-file-simplemath.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"simplemath.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{double}\NormalTok{ sm\_add}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{double}\NormalTok{ sm\_sub}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{double}\NormalTok{ sm\_mul}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{double}\NormalTok{ sm\_div}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{*}\NormalTok{error}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{error}\OperatorTok{)} \OperatorTok{*}\NormalTok{error }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Division by zero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \FloatTok{0.0}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{error}\OperatorTok{)} \OperatorTok{*}\NormalTok{error }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Tiny Code: Example Program Using the
Library}\label{step-5.-tiny-code-example-program-using-the-library}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"simplemath.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ err}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ x }\OperatorTok{=}\NormalTok{ sm\_div}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"10 / 2 = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}

\NormalTok{    x }\OperatorTok{=}\NormalTok{ sm\_div}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{err}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Error detected during division.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Makefile to Build the
Library}\label{step-6.-makefile-to-build-the-library}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}std=c23 {-}O2 {-}Wall {-}Wextra {-}Iinclude}

\DecValTok{all:}\DataTypeTok{ libsimplemath.a test}

\DecValTok{libsimplemath.a:}\DataTypeTok{ src/simplemath.o}
\ErrorTok{    }\NormalTok{ar rcs libsimplemath.a src/simplemath.o}

\DecValTok{src/simplemath.o:}\DataTypeTok{ src/simplemath.c include/simplemath.h}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c src/simplemath.c {-}o src/simplemath.o}

\DecValTok{test:}\DataTypeTok{ test.c libsimplemath.a}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ test.c {-}L. {-}lsimplemath {-}o test}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f src/*.o *.a test}
\end{Highlighting}
\end{Shaded}

Build it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./test}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 / 2 = 5.00
Division by zero
Error detected during division.
\end{verbatim}

\subsubsection{Step 7. Design Guidelines for Clean C
Libraries}\label{step-7.-design-guidelines-for-clean-c-libraries}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6176}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Principle
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Prefix all symbols} & Avoid global name clashes (e.g.,
\texttt{sm\_add}) \\
\textbf{Single responsibility} & Each function should do one clear
thing \\
\textbf{Minimal dependencies} & Don't rely on non-standard headers \\
\textbf{Use header guards} & Prevent duplicate inclusion \\
\textbf{Provide error handling} & Return codes, \texttt{errno}, or out
parameters \\
\textbf{Write documentation} & Use Doxygen or simple comment blocks \\
\textbf{Version your API} & Track breaking changes cleanly \\
\end{longtable}

\subsubsection{Step 8. Adding Versioning and
Metadata}\label{step-8.-adding-versioning-and-metadata}

Add this to your header:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SIMPLEMATH\_VERSION }\StringTok{"1.0.0"}
\end{Highlighting}
\end{Shaded}

In your CMake or Makefile build scripts, you can propagate this version
into your packaging system or documentation.

\subsubsection{Step 9. Why It Matters}\label{step-9.-why-it-matters-1}

Writing a library transforms you from a script author into a systems
builder. It teaches \textbf{API design, separation of interface and
implementation, and long-term maintenance}, the same principles used in
real-world software like glibc, SQLite, and curl.

\subsubsection{Step 10. Try It
Yourself}\label{step-10.-try-it-yourself-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add new functions (\texttt{sm\_pow}, \texttt{sm\_mod},
  \texttt{sm\_avg}).
\item
  Create a shared version of the library (\texttt{libsimplemath.so}).
\item
  Document your API using Doxygen-style comments.
\item
  Write a header-only version (\texttt{static\ inline} functions).
\item
  Package your library with versioning and examples.
\end{enumerate}

Next, you'll learn how to \textbf{build a full command-line tool in C
(92)}, connecting your reusable libraries to practical, user-facing
applications.

\subsection{92. Building a Command-Line
Tool}\label{building-a-command-line-tool}

Command-line tools are where most C programmers begin building
\emph{real software}. They are fast, portable, and integrate naturally
with Unix-like environments. In this section, you'll build a
\textbf{small, self-contained CLI tool} that processes input arguments,
reads files, and outputs results, the same pattern used by tools like
\texttt{grep}, \texttt{cat}, and \texttt{wc}.

\subsubsection{Step 1. The Goal}\label{step-1.-the-goal-1}

We'll build a simple command-line tool called \textbf{linestat} that:

\begin{itemize}
\tightlist
\item
  Counts lines, words, and characters in a text file (like a mini
  \texttt{wc}).
\item
  Takes input from a file or standard input.
\item
  Accepts flags like \texttt{-l}, \texttt{-w}, \texttt{-c}.
\item
  Uses clean error handling and modular functions.
\end{itemize}

\subsubsection{Step 2. Project Layout}\label{step-2.-project-layout}

\begin{verbatim}
linestat/
 ├── linestat.c
 ├── Makefile
 └── README.md
\end{verbatim}

\subsubsection{Step 3. Core Concepts}\label{step-3.-core-concepts}

Command-line programs follow a few timeless patterns:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Read arguments} with \texttt{argc} and \texttt{argv}.
\item
  \textbf{Validate inputs} before processing.
\item
  \textbf{Open files} safely with \texttt{fopen} or use \texttt{stdin}.
\item
  \textbf{Process data line-by-line}.
\item
  \textbf{Report results} clearly and consistently.
\end{enumerate}

\subsubsection{Step 4. Tiny Code:
linestat.c}\label{step-4.-tiny-code-linestat.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ print\_usage}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{prog}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ [{-}l] [{-}w] [{-}c] [file]}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ prog}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Options:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  {-}l   count lines}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  {-}w   count words}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"  {-}c   count characters}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ count\_lines }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ count\_words }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ count\_chars }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{filename }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

    \CommentTok{// Parse arguments}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \StringTok{"{-}l"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}\NormalTok{ count\_lines }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \StringTok{"{-}w"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}\NormalTok{ count\_words }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{],} \StringTok{"{-}c"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}\NormalTok{ count\_chars }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\DecValTok{0}\OperatorTok{]} \OperatorTok{!=} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{)}\NormalTok{ filename }\OperatorTok{=}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
        \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{            print\_usage}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
            \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ filename }\OperatorTok{?}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{filename}\OperatorTok{,} \StringTok{"r"}\OperatorTok{)} \OperatorTok{:}\NormalTok{ stdin}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{fp}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{long}\NormalTok{ lines }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ words }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ chars }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ ch}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{ch }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        chars}\OperatorTok{++;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{ch }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{)}\NormalTok{ lines}\OperatorTok{++;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{ch }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}} \OperatorTok{||}\NormalTok{ ch }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}} \OperatorTok{||}\NormalTok{ ch }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}t}\CharTok{\textquotesingle{}}\OperatorTok{)}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{in\_word}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ words}\OperatorTok{++;}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{count\_lines }\OperatorTok{\&\&} \OperatorTok{!}\NormalTok{count\_words }\OperatorTok{\&\&} \OperatorTok{!}\NormalTok{count\_chars}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        count\_lines }\OperatorTok{=}\NormalTok{ count\_words }\OperatorTok{=}\NormalTok{ count\_chars }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// Default all}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{count\_lines}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Lines: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ lines}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{count\_words}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Words: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ words}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{count\_chars}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Chars: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ chars}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Build and Run}\label{step-5.-build-and-run}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}std=c23 {-}O2 {-}Wall {-}Wextra}

\DecValTok{linestat:}\DataTypeTok{ linestat.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ linestat.c {-}o linestat}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f linestat}
\end{Highlighting}
\end{Shaded}

Build it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\end{Highlighting}
\end{Shaded}

Run it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./linestat} \AttributeTok{{-}l} \AttributeTok{{-}w} \AttributeTok{{-}c}\NormalTok{ example.txt}
\end{Highlighting}
\end{Shaded}

Or from a pipeline:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{cat}\NormalTok{ example.txt }\KeywordTok{|} \ExtensionTok{./linestat} \AttributeTok{{-}w}
\end{Highlighting}
\end{Shaded}

Example output:

\begin{verbatim}
Lines: 12
Words: 85
Chars: 430
\end{verbatim}

\subsubsection{Step 6. Breaking Down the
Code}\label{step-6.-breaking-down-the-code}

\begin{itemize}
\tightlist
\item
  \textbf{Argument Parsing:} Loops through \texttt{argv} to detect
  flags.
\item
  \textbf{Input Handling:} Reads from \texttt{stdin} when no file is
  given.
\item
  \textbf{Counting Logic:} Tracks transitions between spaces and
  characters to count words.
\item
  \textbf{Graceful Exit:} Uses \texttt{fclose} and \texttt{perror} for
  error reporting.
\item
  \textbf{Default Behavior:} When no flags are passed, all counts are
  printed.
\end{itemize}

\subsubsection{Step 7. Making It More
Robust}\label{step-7.-making-it-more-robust}

You can extend this program easily:

\begin{itemize}
\item
  Add \texttt{-q} for quiet mode (only print totals).
\item
  Add \texttt{-\/-help} for extended usage info.
\item
  Use \texttt{getline()} for reading full lines (C POSIX).
\item
  Print counts side by side in a single line:

\begin{verbatim}
12  85  430  example.txt
\end{verbatim}
\end{itemize}

\subsubsection{Step 8. Cross-Platform
Considerations}\label{step-8.-cross-platform-considerations}

\begin{itemize}
\tightlist
\item
  Use \texttt{\#ifdef\ \_WIN32} to handle file paths and newline
  differences.
\item
  Always open files in text mode: \texttt{fopen(filename,\ "r")}.
\item
  Use \texttt{size\_t} instead of \texttt{long} for portability.
\end{itemize}

\subsubsection{Step 9. Why It Matters}\label{step-9.-why-it-matters-2}

Writing a CLI teaches key systems skills:

\begin{itemize}
\tightlist
\item
  Argument parsing and I/O
\item
  File handling and error checking
\item
  Performance thinking (streaming, buffering)
\item
  Modular design for future features
\end{itemize}

Every developer who writes in C eventually writes a CLI, it's how tools
like Git, Curl, and GCC were born.

\subsubsection{Step 10. Try It
Yourself}\label{step-10.-try-it-yourself-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{-v} flag that shows program version.
\item
  Support reading multiple files.
\item
  Add timing (use \texttt{clock()} to measure runtime).
\item
  Print totals across all files.
\item
  Integrate your \textbf{simplemath} library to compute average words
  per line.
\end{enumerate}

Next, you'll move to \textbf{93. Tiny HTTP Server (Sockets and
Threads)}, where your command-line skills evolve into network
programming: accepting connections, handling requests, and serving
content in pure C.

\subsection{93. Tiny HTTP Server (Sockets and
Threads)}\label{tiny-http-server-sockets-and-threads}

Now that you know how to build command-line tools, it's time to make
your program talk to the network. In this section, you'll build a
\textbf{tiny multithreaded HTTP server}, a small, minimal clone of what
powers the web.

You'll learn sockets, threading, request parsing, and response
generation, all from first principles.

\subsubsection{Step 1. The Goal}\label{step-1.-the-goal-2}

We'll create a simple HTTP server that:

\begin{itemize}
\tightlist
\item
  Listens on port \texttt{8080}
\item
  Accepts multiple connections (one per thread)
\item
  Parses a minimal HTTP request
\item
  Responds with a static HTML page
\end{itemize}

This project combines file I/O, networking, and concurrency, three of
C's most powerful capabilities.

\subsubsection{Step 2. Project Layout}\label{step-2.-project-layout-1}

\begin{verbatim}
tinyhttp/
 ├── server.c
 ├── Makefile
 └── index.html
\end{verbatim}

\subsubsection{Step 3. The Core Idea}\label{step-3.-the-core-idea}

The server will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Create a socket} and bind it to port 8080.
\item
  \textbf{Listen} for connections.
\item
  \textbf{Accept} a client.
\item
  \textbf{Handle} the request in a new thread.
\item
  \textbf{Send} an HTTP response.
\item
  \textbf{Close} the socket and repeat.
\end{enumerate}

\subsubsection{Step 4. Tiny Code:
server.c}\label{step-4.-tiny-code-server.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}pthread.h\textgreater{}}

\PreprocessorTok{\#define PORT }\DecValTok{8080}
\PreprocessorTok{\#define BUF\_SIZE }\DecValTok{4096}

\DataTypeTok{void} \OperatorTok{*}\NormalTok{handle\_client}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ client\_fd }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int} \OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arg}\OperatorTok{);}

    \DataTypeTok{char}\NormalTok{ buffer}\OperatorTok{[}\NormalTok{BUF\_SIZE}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ bytes }\OperatorTok{=}\NormalTok{ read}\OperatorTok{(}\NormalTok{client\_fd}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{)} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{bytes }\OperatorTok{\textless{}=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        close}\OperatorTok{(}\NormalTok{client\_fd}\OperatorTok{);}
        \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    buffer}\OperatorTok{[}\NormalTok{bytes}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

    \CommentTok{// Basic HTTP response}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{body }\OperatorTok{=} \StringTok{"\textless{}html\textgreater{}\textless{}body\textgreater{}\textless{}h1\textgreater{}Hello from TinyHTTP!\textless{}/h1\textgreater{}\textless{}/body\textgreater{}\textless{}/html\textgreater{}"}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ response}\OperatorTok{[}\NormalTok{BUF\_SIZE}\OperatorTok{];}
\NormalTok{    snprintf}\OperatorTok{(}\NormalTok{response}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{response}\OperatorTok{),}
        \StringTok{"HTTP/1.1 200 OK}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Content{-}Type: text/html}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Content{-}Length: }\SpecialCharTok{\%zu\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Connection: close}\SpecialCharTok{\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{body}\OperatorTok{),}\NormalTok{ body}\OperatorTok{);}

\NormalTok{    write}\OperatorTok{(}\NormalTok{client\_fd}\OperatorTok{,}\NormalTok{ response}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{response}\OperatorTok{));}
\NormalTok{    close}\OperatorTok{(}\NormalTok{client\_fd}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ server\_fd }\OperatorTok{=}\NormalTok{ socket}\OperatorTok{(}\NormalTok{AF\_INET}\OperatorTok{,}\NormalTok{ SOCK\_STREAM}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{server\_fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"socket failed"}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\NormalTok{EXIT\_FAILURE}\OperatorTok{);}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ opt }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    setsockopt}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,}\NormalTok{ SOL\_SOCKET}\OperatorTok{,}\NormalTok{ SO\_REUSEADDR}\OperatorTok{,} \OperatorTok{\&}\NormalTok{opt}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{opt}\OperatorTok{));}

    \KeywordTok{struct}\NormalTok{ sockaddr\_in addr }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    addr}\OperatorTok{.}\NormalTok{sin\_family }\OperatorTok{=}\NormalTok{ AF\_INET}\OperatorTok{;}
\NormalTok{    addr}\OperatorTok{.}\NormalTok{sin\_addr}\OperatorTok{.}\NormalTok{s\_addr }\OperatorTok{=}\NormalTok{ INADDR\_ANY}\OperatorTok{;}
\NormalTok{    addr}\OperatorTok{.}\NormalTok{sin\_port }\OperatorTok{=}\NormalTok{ htons}\OperatorTok{(}\NormalTok{PORT}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{bind}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr }\OperatorTok{*)\&}\NormalTok{addr}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{addr}\OperatorTok{))} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"bind failed"}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\NormalTok{EXIT\_FAILURE}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{listen}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \DecValTok{10}\OperatorTok{)} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"listen failed"}\OperatorTok{);}
\NormalTok{        close}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{);}
\NormalTok{        exit}\OperatorTok{(}\NormalTok{EXIT\_FAILURE}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"TinyHTTP running on http://localhost:}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ PORT}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ client\_fd}\OperatorTok{;}
        \KeywordTok{struct}\NormalTok{ sockaddr\_in client}\OperatorTok{;}
\NormalTok{        socklen\_t len }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{client}\OperatorTok{);}
\NormalTok{        client\_fd }\OperatorTok{=}\NormalTok{ accept}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr }\OperatorTok{*)\&}\NormalTok{client}\OperatorTok{,} \OperatorTok{\&}\NormalTok{len}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{client\_fd }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"accept failed"}\OperatorTok{);}
            \ControlFlowTok{continue}\OperatorTok{;}
        \OperatorTok{\}}

        \DataTypeTok{int} \OperatorTok{*}\NormalTok{pclient }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
        \OperatorTok{*}\NormalTok{pclient }\OperatorTok{=}\NormalTok{ client\_fd}\OperatorTok{;}

\NormalTok{        pthread\_t tid}\OperatorTok{;}
\NormalTok{        pthread\_create}\OperatorTok{(\&}\NormalTok{tid}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ handle\_client}\OperatorTok{,}\NormalTok{ pclient}\OperatorTok{);}
\NormalTok{        pthread\_detach}\OperatorTok{(}\NormalTok{tid}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    close}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Build and Run}\label{step-5.-build-and-run-1}

\textbf{Makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC} \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS} \CharTok{=}\StringTok{ {-}std=c23 {-}pthread {-}O2 {-}Wall {-}Wextra}

\DecValTok{all:}\DataTypeTok{ server}

\DecValTok{server:}\DataTypeTok{ server.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ server.c {-}o server}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f server}
\end{Highlighting}
\end{Shaded}

Build and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\ExtensionTok{./server}
\end{Highlighting}
\end{Shaded}

Open your browser and visit:

\begin{verbatim}
http://localhost:8080
\end{verbatim}

You should see:

\begin{verbatim}
Hello from TinyHTTP!
\end{verbatim}

\subsubsection{Step 6. How It Works}\label{step-6.-how-it-works}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Socket setup:} The server creates a TCP socket
  (\texttt{socket()}), binds it to port 8080, and listens.
\item
  \textbf{Accept loop:} The main thread waits for connections.
\item
  \textbf{Threading:} Each connection is handled by a new thread
  (\texttt{pthread\_create}), allowing multiple clients at once.
\item
  \textbf{HTTP parsing:} Minimal, just reads the request header and
  ignores the rest for now.
\item
  \textbf{Response:} A static HTML body is written to the socket.
\item
  \textbf{Cleanup:} Each thread closes its client socket after
  responding.
\end{enumerate}

\subsubsection{Step 7. Extend It}\label{step-7.-extend-it}

To make it more realistic, add:

\begin{itemize}
\item
  Serve static files:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"index.html"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}
\item
  Parse the first line of the request to get the path.
\item
  Return 404 if the file doesn't exist.
\item
  Add MIME types for \texttt{.html}, \texttt{.css}, \texttt{.js},
  \texttt{.png}.
\item
  Add logging with timestamps.
\end{itemize}

\subsubsection{Step 8. Cross-Platform
Notes}\label{step-8.-cross-platform-notes}

\begin{itemize}
\tightlist
\item
  Use \texttt{\#ifdef\ \_WIN32} to include
  \texttt{\textless{}winsock2.h\textgreater{}} and initialize with
  \texttt{WSAStartup()}.
\item
  Replace \texttt{close()} with \texttt{closesocket()} on Windows.
\item
  Use threads from \texttt{\textless{}threads.h\textgreater{}} for
  C11-only builds.
\end{itemize}

\subsubsection{Step 9. Why It Matters}\label{step-9.-why-it-matters-3}

Building an HTTP server from scratch teaches you how the web really
works:

\begin{itemize}
\tightlist
\item
  \textbf{Sockets:} the foundation of all network software.
\item
  \textbf{Concurrency:} how to handle many users at once.
\item
  \textbf{Protocols:} understanding request/response formats.
\item
  \textbf{Systems thinking:} combining multiple low-level C features
  cleanly.
\end{itemize}

You're no longer just writing programs, you're shaping communication
between machines.

\subsubsection{Step 10. Try It
Yourself}\label{step-10.-try-it-yourself-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add logging for each client connection.
\item
  Serve static files (\texttt{index.html}, \texttt{style.css}).
\item
  Implement a \texttt{/time} endpoint returning the system time.
\item
  Benchmark with \texttt{curl} or \texttt{ab}.
\item
  Extend to HTTP/1.1 persistent connections.
\end{enumerate}

Next, you'll build \textbf{94. A Simple Key-Value Store}, where you'll
learn file-based persistence, indexing, and serialization, the first
step toward writing databases in pure C.

\subsection{94. Simple Key-Value Store}\label{simple-key-value-store}

Databases look scary until you build one yourself. In this section you
will write a tiny \textbf{append only key value store} that persists
data to disk, loads an in memory index on startup, and supports
\texttt{get} and \texttt{set} from a simple CLI.

You will learn files, serialization, indexing, and crash safety basics.

\subsubsection{Step 1. Design the file
format}\label{step-1.-design-the-file-format}

Keep it simple and binary. Each record is append only:

\begin{verbatim}
[ u32 key_len ][ u32 val_len ][ key bytes ][ value bytes ]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  All integers are stored as big endian so the file is portable.
\item
  No in place updates. Setting the same key again appends a new record.
\end{itemize}

\subsubsection{Step 2. Endianness
helpers}\label{step-2.-endianness-helpers}

We will use \texttt{htonl} and \texttt{ntohl} to encode and decode 32
bit lengths.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}\PreprocessorTok{   }\CommentTok{// Windows: winsock2.h}

\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{uint32\_t}\NormalTok{ be32}\OperatorTok{(}\DataTypeTok{uint32\_t}\NormalTok{ x}\OperatorTok{)}  \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}  \OperatorTok{\}}
\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{uint32\_t}\NormalTok{ from\_be32}\OperatorTok{(}\DataTypeTok{uint32\_t}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{x}\OperatorTok{);} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. The in memory
index}\label{step-3.-the-in-memory-index}

On startup, scan the log file once and build a hash map of key
-\textgreater{} file offset of the newest record. We will implement a
simple open addressing hash table for clarity.

Index entry:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{uint64\_t}\NormalTok{ offset}\OperatorTok{;}   \CommentTok{// file position of record start}
    \DataTypeTok{uint32\_t}\NormalTok{ key\_hash}\OperatorTok{;} \CommentTok{// cached hash for quick probing}
    \DataTypeTok{uint32\_t}\NormalTok{ key\_len}\OperatorTok{;}  \CommentTok{// used to confirm match}
\OperatorTok{\}}\NormalTok{ kv\_slot}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Hashing}\label{step-4.-hashing}

Use a compact 32 bit FNV-1a hash for strings.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{uint32\_t}\NormalTok{ fnv1a}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{uint32\_t}\NormalTok{ h }\OperatorTok{=} \DecValTok{2166136261}\BuiltInTok{u}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        h }\OperatorTok{\^{}=}\NormalTok{ s}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\NormalTok{        h }\OperatorTok{*=} \DecValTok{16777619}\BuiltInTok{u}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ h}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Tiny Code: core
implementation}\label{step-5.-tiny-code-core-implementation}

A single file version to keep things approachable.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: kv.c}
\PreprocessorTok{\#define \_POSIX\_C\_SOURCE }\DecValTok{200809}\BuiltInTok{L}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}\PreprocessorTok{   }\CommentTok{// Windows: include \textless{}winsock2.h\textgreater{} and link Ws2\_32}
\PreprocessorTok{\#include }\ImportTok{\textless{}errno.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{path}\OperatorTok{;}
    \CommentTok{// simple hash table index}
    \KeywordTok{struct}\NormalTok{ slot }\OperatorTok{\{} \DataTypeTok{uint64\_t}\NormalTok{ off}\OperatorTok{;} \DataTypeTok{uint32\_t}\NormalTok{ h}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{*}\NormalTok{tab}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ cap}\OperatorTok{,}\NormalTok{ used}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ kv\_db}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{uint32\_t}\NormalTok{ fnv1a}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{uint32\_t}\NormalTok{ h }\OperatorTok{=} \DecValTok{2166136261}\BuiltInTok{u}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}\NormalTok{ h }\OperatorTok{\^{}=}\NormalTok{ s}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}\NormalTok{ h }\OperatorTok{*=} \DecValTok{16777619}\BuiltInTok{u}\OperatorTok{;} \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ h}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{size\_t}\NormalTok{ next\_pow2}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{} \DataTypeTok{size\_t}\NormalTok{ p }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{p }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{)}\NormalTok{ p }\OperatorTok{\textless{}\textless{}=} \DecValTok{1}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ p}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ kv\_index\_put}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ klen}\OperatorTok{,} \DataTypeTok{uint64\_t}\NormalTok{ off}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{used }\OperatorTok{*} \DecValTok{2} \OperatorTok{\textgreater{}=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)} \OperatorTok{\{} \CommentTok{// grow}
        \DataTypeTok{size\_t}\NormalTok{ ncap }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{?}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{*} \DecValTok{2} \OperatorTok{:} \DecValTok{1024}\OperatorTok{;}
        \KeywordTok{struct}\NormalTok{ slot }\OperatorTok{*}\NormalTok{old }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{;}
        \DataTypeTok{size\_t}\NormalTok{ oldcap }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{;}
\NormalTok{        db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab }\OperatorTok{=}\NormalTok{ calloc}\OperatorTok{(}\NormalTok{ncap}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{));}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
\NormalTok{        db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{=}\NormalTok{ ncap}\OperatorTok{;}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{used }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ oldcap}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{old}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{off}\OperatorTok{)} \OperatorTok{\{}
            \CommentTok{// reinsert based on stored key hash and key length}
            \DataTypeTok{size\_t}\NormalTok{ m }\OperatorTok{=}\NormalTok{ ncap }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{,}\NormalTok{ j }\OperatorTok{=}\NormalTok{ old}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{h }\OperatorTok{\&}\NormalTok{ m}\OperatorTok{;}
            \ControlFlowTok{while} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{j}\OperatorTok{].}\NormalTok{off}\OperatorTok{)}\NormalTok{ j }\OperatorTok{=} \OperatorTok{(}\NormalTok{j }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{\&}\NormalTok{ m}\OperatorTok{;}
\NormalTok{            db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ old}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\NormalTok{            db}\OperatorTok{{-}\textgreater{}}\NormalTok{used}\OperatorTok{++;}
        \OperatorTok{\}}
\NormalTok{        free}\OperatorTok{(}\NormalTok{old}\OperatorTok{);}
    \OperatorTok{\}}
    \DataTypeTok{uint32\_t}\NormalTok{ h }\OperatorTok{=}\NormalTok{ fnv1a}\OperatorTok{(}\NormalTok{key}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{);}
    \DataTypeTok{size\_t}\NormalTok{ m }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{,}\NormalTok{ i }\OperatorTok{=}\NormalTok{ h }\OperatorTok{\&}\NormalTok{ m}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{off}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{h }\OperatorTok{==}\NormalTok{ h }\OperatorTok{\&\&}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{klen }\OperatorTok{==}\NormalTok{ klen}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{off }\OperatorTok{=}\NormalTok{ off}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{        i }\OperatorTok{=} \OperatorTok{(}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{\&}\NormalTok{ m}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{off }\OperatorTok{=}\NormalTok{ off}\OperatorTok{;}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{h }\OperatorTok{=}\NormalTok{ h}\OperatorTok{;}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{klen }\OperatorTok{=}\NormalTok{ klen}\OperatorTok{;}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{used}\OperatorTok{++;}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{long}\NormalTok{ kv\_index\_find\_slot}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ klen}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ h }\OperatorTok{=}\NormalTok{ fnv1a}\OperatorTok{(}\NormalTok{key}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{);}
    \DataTypeTok{size\_t}\NormalTok{ m }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{,}\NormalTok{ i }\OperatorTok{=}\NormalTok{ h }\OperatorTok{\&}\NormalTok{ m}\OperatorTok{,}\NormalTok{ steps }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{off }\OperatorTok{\&\&}\NormalTok{ steps }\OperatorTok{\textless{}=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{h }\OperatorTok{==}\NormalTok{ h }\OperatorTok{\&\&}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{klen }\OperatorTok{==}\NormalTok{ klen}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{(}\DataTypeTok{long}\OperatorTok{)}\NormalTok{i}\OperatorTok{;}
\NormalTok{        i }\OperatorTok{=} \OperatorTok{(}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{\&}\NormalTok{ m}\OperatorTok{;}\NormalTok{ steps}\OperatorTok{++;}
    \OperatorTok{\}}
    \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ kv\_open}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{path}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    memset}\OperatorTok{(}\NormalTok{db}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{db}\OperatorTok{));}
\NormalTok{    db}\OperatorTok{{-}\textgreater{}}\NormalTok{path }\OperatorTok{=}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{path}\OperatorTok{);}
\NormalTok{    db}\OperatorTok{{-}\textgreater{}}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{path}\OperatorTok{,} \StringTok{"ab+"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
\NormalTok{    fflush}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{);}
    \CommentTok{// build index by scanning from start}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{r }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{path}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{r}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \CommentTok{// start with some capacity}
\NormalTok{    db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{=} \DecValTok{1024}\OperatorTok{;}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab }\OperatorTok{=}\NormalTok{ calloc}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint64\_t}\NormalTok{ off }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{for} \OperatorTok{(;;)} \OperatorTok{\{}
        \DataTypeTok{uint32\_t}\NormalTok{ klen\_be}\OperatorTok{,}\NormalTok{ vlen\_be}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{klen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ r}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{vlen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ r}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
        \DataTypeTok{uint32\_t}\NormalTok{ klen }\OperatorTok{=}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{klen\_be}\OperatorTok{),}\NormalTok{ vlen }\OperatorTok{=}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{vlen\_be}\OperatorTok{);}
        \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{k }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{klen}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{k}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(}\NormalTok{k}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{,}\NormalTok{ r}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ klen}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{k}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;} \OperatorTok{\}}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fseek}\OperatorTok{(}\NormalTok{r}\OperatorTok{,}\NormalTok{ vlen}\OperatorTok{,}\NormalTok{ SEEK\_CUR}\OperatorTok{)} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{k}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{        kv\_index\_put}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ k}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{,}\NormalTok{ off}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{k}\OperatorTok{);}
\NormalTok{        off }\OperatorTok{+=} \DecValTok{8}\BuiltInTok{u} \OperatorTok{+}\NormalTok{ klen }\OperatorTok{+}\NormalTok{ vlen}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{r}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ kv\_set}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ klen}\OperatorTok{,}
                  \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{val}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ vlen}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{uint32\_t}\NormalTok{ klen\_be }\OperatorTok{=}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{klen}\OperatorTok{),}\NormalTok{ vlen\_be }\OperatorTok{=}\NormalTok{ htonl}\OperatorTok{(}\NormalTok{vlen}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{klen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{vlen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fwrite}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ klen}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fwrite}\OperatorTok{(}\NormalTok{val}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ vlen}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ vlen}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
\NormalTok{    fflush}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{);} \CommentTok{// durability: fsync would be stronger}
    \CommentTok{// compute offset of the record we just wrote}
    \DataTypeTok{long}\NormalTok{ end }\OperatorTok{=}\NormalTok{ ftell}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{end }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint64\_t}\NormalTok{ off }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{uint64\_t}\OperatorTok{)}\NormalTok{end }\OperatorTok{{-}} \OperatorTok{(}\DecValTok{8}\BuiltInTok{u} \OperatorTok{+}\NormalTok{ klen }\OperatorTok{+}\NormalTok{ vlen}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ kv\_index\_put}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ key}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{,}\NormalTok{ off}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ kv\_get}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{key}\OperatorTok{,} \DataTypeTok{uint32\_t}\NormalTok{ klen}\OperatorTok{,}
                  \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{**}\NormalTok{out}\OperatorTok{,} \DataTypeTok{uint32\_t} \OperatorTok{*}\NormalTok{outlen}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{long}\NormalTok{ s }\OperatorTok{=}\NormalTok{ kv\_index\_find\_slot}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ key}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{s }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint64\_t}\NormalTok{ off }\OperatorTok{=}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{[}\NormalTok{s}\OperatorTok{].}\NormalTok{off}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fseek}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{long}\OperatorTok{)}\NormalTok{off}\OperatorTok{,}\NormalTok{ SEEK\_SET}\OperatorTok{)} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ klen\_be}\OperatorTok{,}\NormalTok{ vlen\_be}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{klen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{vlen\_be}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=} \DecValTok{1}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \DataTypeTok{uint32\_t}\NormalTok{ kL }\OperatorTok{=}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{klen\_be}\OperatorTok{),}\NormalTok{ vL }\OperatorTok{=}\NormalTok{ ntohl}\OperatorTok{(}\NormalTok{vlen\_be}\OperatorTok{);}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{kbuf }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{kL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{kbuf}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(}\NormalTok{kbuf}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ kL}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ kL}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{kbuf}\OperatorTok{);} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
    \CommentTok{// confirm key match to be safe}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{kL }\OperatorTok{!=}\NormalTok{ klen }\OperatorTok{||}\NormalTok{ memcmp}\OperatorTok{(}\NormalTok{kbuf}\OperatorTok{,}\NormalTok{ key}\OperatorTok{,}\NormalTok{ klen}\OperatorTok{)} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{kbuf}\OperatorTok{);} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    free}\OperatorTok{(}\NormalTok{kbuf}\OperatorTok{);}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{v }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{vL }\OperatorTok{+} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{v}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(}\NormalTok{v}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ vL}\OperatorTok{,}\NormalTok{ db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ vL}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{v}\OperatorTok{);} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    v}\OperatorTok{[}\NormalTok{vL}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// NUL terminate for convenience}
    \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \OperatorTok{*}\NormalTok{outlen }\OperatorTok{=}\NormalTok{ vL}\OperatorTok{;}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ kv\_close}\OperatorTok{(}\NormalTok{kv\_db }\OperatorTok{*}\NormalTok{db}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{db}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{)}\NormalTok{ fclose}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{f}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{tab}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{db}\OperatorTok{{-}\textgreater{}}\NormalTok{path}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ usage}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}file\textgreater{} get \textless{}key\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"       }\SpecialCharTok{\%s}\StringTok{ \textless{}file\textgreater{} set \textless{}key\textgreater{} \textless{}value\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{**}\NormalTok{argv}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ usage}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    kv\_db db}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{kv\_open}\OperatorTok{(\&}\NormalTok{db}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{])} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"open"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}

    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{cmd }\OperatorTok{=}\NormalTok{ argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{cmd}\OperatorTok{,} \StringTok{"set"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ usage}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}\NormalTok{ kv\_close}\OperatorTok{(\&}\NormalTok{db}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
        \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{k }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*)}\NormalTok{argv}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
        \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{v }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*)}\NormalTok{argv}\OperatorTok{[}\DecValTok{4}\OperatorTok{];}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{kv\_set}\OperatorTok{(\&}\NormalTok{db}\OperatorTok{,}\NormalTok{ k}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{uint32\_t}\OperatorTok{)}\NormalTok{strlen}\OperatorTok{((}\DataTypeTok{char}\OperatorTok{*)}\NormalTok{k}\OperatorTok{),}\NormalTok{ v}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{uint32\_t}\OperatorTok{)}\NormalTok{strlen}\OperatorTok{((}\DataTypeTok{char}\OperatorTok{*)}\NormalTok{v}\OperatorTok{))} \OperatorTok{!=} \DecValTok{0}\OperatorTok{)}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"set"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{cmd}\OperatorTok{,} \StringTok{"get"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{k }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*)}\NormalTok{argv}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
        \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \DataTypeTok{uint32\_t}\NormalTok{ n }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{kv\_get}\OperatorTok{(\&}\NormalTok{db}\OperatorTok{,}\NormalTok{ k}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{uint32\_t}\OperatorTok{)}\NormalTok{strlen}\OperatorTok{((}\DataTypeTok{char}\OperatorTok{*)}\NormalTok{k}\OperatorTok{),} \OperatorTok{\&}\NormalTok{out}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            fwrite}\OperatorTok{(}\NormalTok{out}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ stdout}\OperatorTok{);}
\NormalTok{            fputc}\OperatorTok{(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{,}\NormalTok{ stdout}\OperatorTok{);}
\NormalTok{            free}\OperatorTok{(}\NormalTok{out}\OperatorTok{);}
        \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{            fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"not found}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        usage}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    kv\_close}\OperatorTok{(\&}\NormalTok{db}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra}\NormalTok{ kv.c }\AttributeTok{{-}o}\NormalTok{ kv}
\end{Highlighting}
\end{Shaded}

Run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./kv}\NormalTok{ store.log set color blue}
\ExtensionTok{./kv}\NormalTok{ store.log get color}
\CommentTok{\# prints: blue}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Compaction}\label{step-6.-compaction}

Because we append forever, the log grows. Implement a simple
\textbf{compact} command that rewrites only the latest version of each
key to a new file, then swaps files.

Idea:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Iterate index
\item
  Read the newest record for each key
\item
  Append it to \texttt{store.log.new}
\item
  Replace the old file
\end{enumerate}

This keeps disk usage under control and speeds up startup scanning.

\subsubsection{Step 7. Crash safety
basics}\label{step-7.-crash-safety-basics}

\begin{itemize}
\tightlist
\item
  Always \texttt{fflush} after appending a record.
\item
  For stronger durability call
  \texttt{fsync(fileno(db-\textgreater{}f))} on POSIX after
  \texttt{fflush}.
\item
  Write whole records or none. Length headers first, then key, then
  value.
\item
  Consider a checksum per record to detect torn writes.
\end{itemize}

\subsubsection{Step 8. CLI improvements}\label{step-8.-cli-improvements}

Add subcommands:

\begin{verbatim}
kv <file> set <k> <v>
kv <file> get <k>
kv <file> compact
kv <file> stats
\end{verbatim}

\texttt{stats} can print number of keys, file size, load factor, and
index capacity.

\subsubsection{Step 9. Testing}\label{step-9.-testing}

\begin{itemize}
\item
  Insert 10k keys, then get a random 100 keys and verify values.
\item
  Overwrite the same key many times and ensure \texttt{get} returns the
  latest one.
\item
  Kill the program during writes and ensure the log is still readable.
\item
  Run with AddressSanitizer to catch memory bugs:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{clang} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O1} \AttributeTok{{-}g} \AttributeTok{{-}fsanitize}\OperatorTok{=}\NormalTok{address,undefined kv.c }\AttributeTok{{-}o}\NormalTok{ kv\_asan}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\subsubsection{Step 10. Why it matters}\label{step-10.-why-it-matters-9}

This tiny store teaches the core database loop:

\begin{itemize}
\tightlist
\item
  \textbf{Log structured storage} for durability
\item
  \textbf{In memory index} for speed
\item
  \textbf{Compaction} for space and locality
\item
  \textbf{Portable encoding} for cross platform reads
\end{itemize}

You just built the foundation that many production systems use at larger
scale.

\subsubsection{Try it yourself}\label{try-it-yourself-88}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a delete tombstone record type and have \texttt{get} respect it.
\item
  Store expiration timestamps and implement a \texttt{purge} command.
\item
  Use memory mapped I O for reads to speed up lookups.
\item
  Replace the linear probing table with a chained hash or hopscotch
  hashing.
\item
  Add a simple checksum per record and verify on read.
\end{enumerate}

Next you will implement \textbf{95. Implementing a Custom Allocator}
where you will learn how \texttt{malloc} like systems manage the heap,
and write a tiny arena allocator you can drop into small C projects.

\subsection{95. Implementing a Custom
Allocator}\label{implementing-a-custom-allocator}

Every C program eventually asks the operating system for memory, but
\texttt{malloc} and \texttt{free} are not magic---they are layers above
system calls like \texttt{brk} and \texttt{mmap}. In this section, you
will build your own \textbf{custom memory allocator}---a simple arena
allocator that grabs a large block of memory once and doles it out
efficiently.

You'll see how real allocators work inside kernels, games, and embedded
systems.

\subsubsection{Step 1. The Goal}\label{step-1.-the-goal-3}

We'll implement a minimal \textbf{arena allocator} that:

\begin{itemize}
\tightlist
\item
  Allocates from a preallocated block
\item
  Never frees individual objects
\item
  Resets all memory at once when the arena is cleared
\end{itemize}

This model is perfect for short-lived data structures, parsing, and
high-performance applications.

\subsubsection{Step 2. Design}\label{step-2.-design}

An arena allocator tracks:

\begin{itemize}
\tightlist
\item
  The \textbf{base pointer} (start of memory)
\item
  The \textbf{current pointer} (next free position)
\item
  The \textbf{capacity} (total size of the arena)
\end{itemize}

When you allocate, it simply bumps the pointer forward.

Structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{base}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ capacity}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ offset}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Arena}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 3. Tiny Code: Minimal
Arena}\label{step-3.-tiny-code-minimal-arena}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdint.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{base}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ capacity}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ offset}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Arena}\OperatorTok{;}

\NormalTok{Arena }\OperatorTok{*}\NormalTok{arena\_create}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ capacity}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Arena }\OperatorTok{*}\NormalTok{a }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{a}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{base }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{capacity}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{capacity }\OperatorTok{=}\NormalTok{ capacity}\OperatorTok{;}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ a}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \OperatorTok{*}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{+}\NormalTok{ size }\OperatorTok{\textgreater{}}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{capacity}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \DataTypeTok{void} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{base }\OperatorTok{+}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset}\OperatorTok{;}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{+=}\NormalTok{ size}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ ptr}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ arena\_reset}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ arena\_free}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    free}\OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Example Use}\label{step-4.-example-use}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Arena }\OperatorTok{*}\NormalTok{arena }\OperatorTok{=}\NormalTok{ arena\_create}\OperatorTok{(}\DecValTok{1024}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{arena}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Failed to create arena}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ arena\_alloc}\OperatorTok{(}\NormalTok{arena}\OperatorTok{,} \DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{arr}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        arena\_free}\OperatorTok{(}\NormalTok{arena}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{*}\NormalTok{ i}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Squares: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    arena\_reset}\OperatorTok{(}\NormalTok{arena}\OperatorTok{);}  \CommentTok{// all memory reused}
\NormalTok{    arena\_free}\OperatorTok{(}\NormalTok{arena}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. How It Works}\label{step-5.-how-it-works}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{arena\_create} grabs one large block from \texttt{malloc}.
\item
  \texttt{arena\_alloc} hands out memory by increasing an offset---no
  per-object metadata.
\item
  \texttt{arena\_reset} rewinds the arena to reuse the memory instantly.
\item
  \texttt{arena\_free} releases the entire block in one call.
\end{enumerate}

This is \emph{O(1)} for every allocation, with zero fragmentation.

\subsubsection{Step 6. Adding Alignment}\label{step-6.-adding-alignment}

Sometimes allocations must be aligned (for example, 16-byte alignment
for SIMD). We can round up the offset to the nearest alignment boundary.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{size\_t}\NormalTok{ align\_up}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ align}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{n }\OperatorTok{+} \OperatorTok{(}\NormalTok{align }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{))} \OperatorTok{\&} \OperatorTok{\textasciitilde{}(}\NormalTok{align }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \OperatorTok{*}\NormalTok{arena\_alloc\_aligned}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ align}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{size\_t}\NormalTok{ new\_offset }\OperatorTok{=}\NormalTok{ align\_up}\OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset}\OperatorTok{,}\NormalTok{ align}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{new\_offset }\OperatorTok{+}\NormalTok{ size }\OperatorTok{\textgreater{}}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{capacity}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \DataTypeTok{void} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{base }\OperatorTok{+}\NormalTok{ new\_offset}\OperatorTok{;}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{=}\NormalTok{ new\_offset }\OperatorTok{+}\NormalTok{ size}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ ptr}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Debugging
Helpers}\label{step-7.-debugging-helpers}

Add diagnostic printing to understand usage:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ arena\_stats}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Arena used: }\SpecialCharTok{\%zu}\StringTok{ / }\SpecialCharTok{\%zu}\StringTok{ bytes (}\SpecialCharTok{\%.1f\%\%}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset}\OperatorTok{,}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{capacity}\OperatorTok{,}
           \OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{*} \FloatTok{100.0}\OperatorTok{)} \OperatorTok{/}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{capacity}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 8. Advanced Idea: Nested
Arenas}\label{step-8.-advanced-idea-nested-arenas}

You can make \textbf{sub-arenas} for scoped memory:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Arena }\OperatorTok{*}\NormalTok{parent}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ start}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ ArenaScope}\OperatorTok{;}

\NormalTok{ArenaScope arena\_push}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{ArenaScope}\OperatorTok{)\{} \OperatorTok{.}\NormalTok{parent }\OperatorTok{=}\NormalTok{ a}\OperatorTok{,} \OperatorTok{.}\NormalTok{start }\OperatorTok{=}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{\};}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ arena\_pop}\OperatorTok{(}\NormalTok{ArenaScope s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    s}\OperatorTok{.}\NormalTok{parent}\OperatorTok{{-}\textgreater{}}\NormalTok{offset }\OperatorTok{=}\NormalTok{ s}\OperatorTok{.}\NormalTok{start}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This lets you ``temporarily allocate'' for a function or block and reset
automatically.

\subsubsection{Step 9. Why It Matters}\label{step-9.-why-it-matters-4}

Allocators define how performance feels in large systems. By writing
one, you understand:

\begin{itemize}
\tightlist
\item
  How \texttt{malloc} and \texttt{free} manage metadata
\item
  How fragmentation occurs
\item
  How specialized allocators (arenas, pools, slabs) achieve speed and
  predictability
\end{itemize}

Games, web servers, and compilers all use custom allocators to control
lifetime and avoid overhead.

\subsubsection{Step 10. Try It
Yourself}\label{step-10.-try-it-yourself-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add bounds checking that prints errors when overrun.
\item
  Implement a \textbf{pool allocator} for fixed-size objects (e.g.,
  \texttt{struct\ Node}).
\item
  Use \texttt{mmap} to request anonymous memory directly from the OS.
\item
  Add a leak detector that reports unfreed bytes at shutdown.
\item
  Combine multiple arenas into a hierarchical allocator.
\end{enumerate}

Next you'll build \textbf{96. Writing a Text Parser}, using your
allocator to manage short-lived strings and tokens as you build a mini
lexer and parser in pure C.

\subsection{96. Writing a Text Parser}\label{writing-a-text-parser}

Time to turn raw text into structure. In this section you will write a
\textbf{tiny expression parser} that converts strings like
\texttt{3\ +\ 4*2\ -\ (1\ +\ 5)} into an \textbf{AST} (abstract syntax
tree). We will build a simple tokenizer, a recursive descent parser with
precedence, and a pretty printer to check the result. In the next
section you can add an evaluator to run it.

\subsubsection{Step 1. Goal and scope}\label{step-1.-goal-and-scope}

We will parse integer arithmetic with these features:

\begin{itemize}
\tightlist
\item
  Integers: \texttt{0}, \texttt{42}, \texttt{1234}
\item
  Operators: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}
\item
  Parentheses: \texttt{(\ ...\ )}
\item
  Whitespace ignored
\end{itemize}

Output: an AST you can traverse or evaluate later.

\subsubsection{Step 2. Grammar
(informal)}\label{step-2.-grammar-informal}

We will use the classic precedence rules:

\begin{verbatim}
expr   -> term (('+' | '-') term)*
term   -> factor (('*' | '/') factor)*
factor -> INT | '(' expr ')'
\end{verbatim}

Parsing follows these functions in order: \texttt{parse\_expr},
\texttt{parse\_term}, \texttt{parse\_factor}.

\subsubsection{Step 3. Tokens}\label{step-3.-tokens}

We first scan characters into tokens:

\begin{itemize}
\tightlist
\item
  \texttt{TOK\_INT} with a numeric value
\item
  \texttt{TOK\_PLUS}, \texttt{TOK\_MINUS}, \texttt{TOK\_STAR},
  \texttt{TOK\_SLASH}
\item
  \texttt{TOK\_LPAREN}, \texttt{TOK\_RPAREN}
\item
  \texttt{TOK\_EOF} to mark the end
\end{itemize}

\subsubsection{Step 4. AST nodes}\label{step-4.-ast-nodes}

Use a compact node type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ N\_INT}\OperatorTok{,}\NormalTok{ N\_ADD}\OperatorTok{,}\NormalTok{ N\_SUB}\OperatorTok{,}\NormalTok{ N\_MUL}\OperatorTok{,}\NormalTok{ N\_DIV }\OperatorTok{\}}\NormalTok{ NodeKind}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
\NormalTok{    NodeKind kind}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{left}\OperatorTok{,} \OperatorTok{*}\NormalTok{right}\OperatorTok{;}  \CommentTok{// for binary ops}
    \DataTypeTok{long}\NormalTok{ value}\OperatorTok{;}                  \CommentTok{// for integers}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Binary nodes use \texttt{left} and \texttt{right}. Integer nodes use
\texttt{value}.

\subsubsection{Step 5. A tiny arena for
nodes}\label{step-5.-a-tiny-arena-for-nodes}

Allocating nodes frequently with \texttt{malloc} is noisy. Use a tiny
arena so each node is just a bump allocation and everything frees at
once when you are done.

\subsubsection{Step 6. Error handling
strategy}\label{step-6.-error-handling-strategy}

Keep it simple:

\begin{itemize}
\tightlist
\item
  If an unexpected token appears, print a message with the position.
\item
  Stop parsing and return \texttt{NULL}.
\item
  The pretty printer will only run if the tree is not \texttt{NULL}.
\end{itemize}

\subsubsection{Step 7. Pretty printing the
AST}\label{step-7.-pretty-printing-the-ast}

To verify parsing, print with minimal parentheses:

\begin{itemize}
\tightlist
\item
  For binary nodes, print \texttt{(left\ op\ right)}.
\item
  For integers, print the number. This is enough to confirm shape and
  precedence.
\end{itemize}

\subsubsection{Step 8. Tiny Code: self contained lexer + parser +
printer}\label{step-8.-tiny-code-self-contained-lexer-parser-printer}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: expr\_parser.c}
\PreprocessorTok{\#define \_POSIX\_C\_SOURCE }\DecValTok{200809}\BuiltInTok{L}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}ctype.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} tiny arena {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{base}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ cap}\OperatorTok{,}\NormalTok{ off}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Arena}\OperatorTok{;}

\DataTypeTok{static}\NormalTok{ Arena }\OperatorTok{*}\NormalTok{arena\_new}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ cap}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Arena }\OperatorTok{*}\NormalTok{a }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{a}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{a}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{base }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{cap}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    a}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{=}\NormalTok{ cap}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{off }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ a}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static} \DataTypeTok{void} \OperatorTok{*}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ align}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{size\_t}\NormalTok{ p }\OperatorTok{=} \OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{off }\OperatorTok{+} \OperatorTok{(}\NormalTok{align }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{))} \OperatorTok{\&} \OperatorTok{\textasciitilde{}(}\NormalTok{align }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ n }\OperatorTok{\textgreater{}}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
    \DataTypeTok{void} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{base }\OperatorTok{+}\NormalTok{ p}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{off }\OperatorTok{=}\NormalTok{ p }\OperatorTok{+}\NormalTok{ n}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ ptr}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ arena\_free}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{a}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{);}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);} \OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} tokens {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    TOK\_INT}\OperatorTok{,}\NormalTok{ TOK\_PLUS}\OperatorTok{,}\NormalTok{ TOK\_MINUS}\OperatorTok{,}\NormalTok{ TOK\_STAR}\OperatorTok{,}\NormalTok{ TOK\_SLASH}\OperatorTok{,}
\NormalTok{    TOK\_LPAREN}\OperatorTok{,}\NormalTok{ TOK\_RPAREN}\OperatorTok{,}\NormalTok{ TOK\_EOF}\OperatorTok{,}\NormalTok{ TOK\_ERR}
\OperatorTok{\}}\NormalTok{ TokKind}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    TokKind kind}\OperatorTok{;}
    \DataTypeTok{long}\NormalTok{    ival}\OperatorTok{;}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{start}\OperatorTok{;}  \CommentTok{// for error messages}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{end}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Token}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{src}\OperatorTok{;}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{cur}\OperatorTok{;}
\NormalTok{    Token       look}\OperatorTok{;}   \CommentTok{// one{-}token lookahead}
\OperatorTok{\}}\NormalTok{ Lexer}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ skip\_ws}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{isspace}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{))}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{++;}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Token make}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{,}\NormalTok{ TokKind k}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{e}\OperatorTok{,} \DataTypeTok{long}\NormalTok{ v}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Token t }\OperatorTok{=} \OperatorTok{\{}\NormalTok{k}\OperatorTok{,}\NormalTok{ v}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ e}\OperatorTok{\};}
    \ControlFlowTok{return}\NormalTok{ t}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Token next\_token\_raw}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    skip\_ws}\OperatorTok{(}\NormalTok{L}\OperatorTok{);}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s }\OperatorTok{=}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_EOF}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}

    \DataTypeTok{char}\NormalTok{ c }\OperatorTok{=} \OperatorTok{*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{++;}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{c}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_PLUS}\OperatorTok{,}\NormalTok{   s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_MINUS}\OperatorTok{,}\NormalTok{  s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_STAR}\OperatorTok{,}\NormalTok{   s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_SLASH}\OperatorTok{,}\NormalTok{  s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}(\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_LPAREN}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{case} \CharTok{\textquotesingle{})\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_RPAREN}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \ControlFlowTok{default}\OperatorTok{:}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{isdigit}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)}\NormalTok{c}\OperatorTok{))} \OperatorTok{\{}
                \DataTypeTok{long}\NormalTok{ v }\OperatorTok{=}\NormalTok{ c }\OperatorTok{{-}} \CharTok{\textquotesingle{}0\textquotesingle{}}\OperatorTok{;}
                \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{;}
                \ControlFlowTok{while} \OperatorTok{(}\NormalTok{isdigit}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)*}\NormalTok{p}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{                    v }\OperatorTok{=}\NormalTok{ v }\OperatorTok{*} \DecValTok{10} \OperatorTok{+} \OperatorTok{(*}\NormalTok{p }\OperatorTok{{-}} \CharTok{\textquotesingle{}0\textquotesingle{}}\OperatorTok{);}
\NormalTok{                    p}\OperatorTok{++;}
                \OperatorTok{\}}
\NormalTok{                Token t }\OperatorTok{=}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_INT}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ p}\OperatorTok{,}\NormalTok{ v}\OperatorTok{);}
\NormalTok{                L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
                \ControlFlowTok{return}\NormalTok{ t}\OperatorTok{;}
            \OperatorTok{\}}
            \ControlFlowTok{return}\NormalTok{ make}\OperatorTok{(}\NormalTok{L}\OperatorTok{,}\NormalTok{ TOK\_ERR}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ lexer\_init}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{src}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    L}\OperatorTok{{-}\textgreater{}}\NormalTok{src }\OperatorTok{=}\NormalTok{ src}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur }\OperatorTok{=}\NormalTok{ src}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look }\OperatorTok{=}\NormalTok{ next\_token\_raw}\OperatorTok{(}\NormalTok{L}\OperatorTok{);}
\OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Token peek}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Token take}\OperatorTok{(}\NormalTok{Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Token t }\OperatorTok{=}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look }\OperatorTok{=}\NormalTok{ next\_token\_raw}\OperatorTok{(}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ t}\OperatorTok{;} \OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} AST {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ N\_INT}\OperatorTok{,}\NormalTok{ N\_ADD}\OperatorTok{,}\NormalTok{ N\_SUB}\OperatorTok{,}\NormalTok{ N\_MUL}\OperatorTok{,}\NormalTok{ N\_DIV }\OperatorTok{\}}\NormalTok{ NodeKind}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
\NormalTok{    NodeKind kind}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{l}\OperatorTok{,} \OperatorTok{*}\NormalTok{r}\OperatorTok{;}
    \DataTypeTok{long}\NormalTok{ value}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{node\_new\_int}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{A}\OperatorTok{,} \DataTypeTok{long}\NormalTok{ v}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),} \KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{kind }\OperatorTok{=}\NormalTok{ N\_INT}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l }\OperatorTok{=}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{r }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{node\_new\_bin}\OperatorTok{(}\NormalTok{Arena }\OperatorTok{*}\NormalTok{A}\OperatorTok{,}\NormalTok{ NodeKind k}\OperatorTok{,}\NormalTok{ Node }\OperatorTok{*}\NormalTok{l}\OperatorTok{,}\NormalTok{ Node }\OperatorTok{*}\NormalTok{r}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),} \KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    n}\OperatorTok{{-}\textgreater{}}\NormalTok{kind }\OperatorTok{=}\NormalTok{ k}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l }\OperatorTok{=}\NormalTok{ l}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{r }\OperatorTok{=}\NormalTok{ r}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{value }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} parser: expr {-}\textgreater{} term {-}\textgreater{} factor {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}\NormalTok{ Lexer }\OperatorTok{*}\NormalTok{L}\OperatorTok{;}\NormalTok{ Arena }\OperatorTok{*}\NormalTok{A}\OperatorTok{;} \DataTypeTok{int}\NormalTok{ ok}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Parser}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ fail}\OperatorTok{(}\NormalTok{Parser }\OperatorTok{*}\NormalTok{P}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{,}\NormalTok{ Token t}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{ pos }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{size\_t}\OperatorTok{)(}\NormalTok{t}\OperatorTok{.}\NormalTok{start }\OperatorTok{{-}}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{src}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Parse error at pos }\SpecialCharTok{\%zu}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pos}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{parse\_expr}\OperatorTok{(}\NormalTok{Parser }\OperatorTok{*}\NormalTok{P}\OperatorTok{);} \CommentTok{// forward}

\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{parse\_factor}\OperatorTok{(}\NormalTok{Parser }\OperatorTok{*}\NormalTok{P}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Token t }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{t}\OperatorTok{.}\NormalTok{kind }\OperatorTok{==}\NormalTok{ TOK\_INT}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ node\_new\_int}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ t}\OperatorTok{.}\NormalTok{ival}\OperatorTok{);} \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{t}\OperatorTok{.}\NormalTok{kind }\OperatorTok{==}\NormalTok{ TOK\_LPAREN}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
\NormalTok{        Node }\OperatorTok{*}\NormalTok{inside }\OperatorTok{=}\NormalTok{ parse\_expr}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind }\OperatorTok{!=}\NormalTok{ TOK\_RPAREN}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ fail}\OperatorTok{(}\NormalTok{P}\OperatorTok{,} \StringTok{"expected \textquotesingle{})\textquotesingle{}"}\OperatorTok{,}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{));} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
        \ControlFlowTok{return}\NormalTok{ inside}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    fail}\OperatorTok{(}\NormalTok{P}\OperatorTok{,} \StringTok{"expected number or \textquotesingle{}(\textquotesingle{}"}\OperatorTok{,}\NormalTok{ t}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{parse\_term}\OperatorTok{(}\NormalTok{Parser }\OperatorTok{*}\NormalTok{P}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ parse\_factor}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        TokKind k }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{k }\OperatorTok{!=}\NormalTok{ TOK\_STAR }\OperatorTok{\&\&}\NormalTok{ k }\OperatorTok{!=}\NormalTok{ TOK\_SLASH}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
\NormalTok{        Node }\OperatorTok{*}\NormalTok{r }\OperatorTok{=}\NormalTok{ parse\_factor}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{r}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{        n }\OperatorTok{=}\NormalTok{ node\_new\_bin}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ k }\OperatorTok{==}\NormalTok{ TOK\_STAR }\OperatorTok{?}\NormalTok{ N\_MUL }\OperatorTok{:}\NormalTok{ N\_DIV}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ r}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Node }\OperatorTok{*}\NormalTok{parse\_expr}\OperatorTok{(}\NormalTok{Parser }\OperatorTok{*}\NormalTok{P}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ parse\_term}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        TokKind k }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{k }\OperatorTok{!=}\NormalTok{ TOK\_PLUS }\OperatorTok{\&\&}\NormalTok{ k }\OperatorTok{!=}\NormalTok{ TOK\_MINUS}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
\NormalTok{        Node }\OperatorTok{*}\NormalTok{r }\OperatorTok{=}\NormalTok{ parse\_term}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{r}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{        n }\OperatorTok{=}\NormalTok{ node\_new\_bin}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ k }\OperatorTok{==}\NormalTok{ TOK\_PLUS }\OperatorTok{?}\NormalTok{ N\_ADD }\OperatorTok{:}\NormalTok{ N\_SUB}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ r}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} printer {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{Node }\OperatorTok{*}\NormalTok{n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{kind}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case}\NormalTok{ N\_INT}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%ld}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{value}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ N\_ADD}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"("}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{" + "}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{")"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ N\_SUB}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"("}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{" {-} "}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{")"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ N\_MUL}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"("}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{" * "}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{")"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ N\_DIV}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"("}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{" / "}\OperatorTok{);}\NormalTok{ print\_ast}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{);}\NormalTok{ printf}\OperatorTok{(}\StringTok{")"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} main for quick testing {-}{-}{-}{-}{-}{-}{-}{-}{-}{-} */}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{**}\NormalTok{argv}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{src }\OperatorTok{=} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textgreater{}} \DecValTok{1}\OperatorTok{)} \OperatorTok{?}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{:} \StringTok{"3 + 4*2 {-} (1 + 5)"}\OperatorTok{;}
\NormalTok{    Lexer L}\OperatorTok{;}\NormalTok{ lexer\_init}\OperatorTok{(\&}\NormalTok{L}\OperatorTok{,}\NormalTok{ src}\OperatorTok{);}

\NormalTok{    Arena }\OperatorTok{*}\NormalTok{A }\OperatorTok{=}\NormalTok{ arena\_new}\OperatorTok{(}\DecValTok{1} \OperatorTok{\textless{}\textless{}} \DecValTok{16}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{A}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"arena alloc failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}

\NormalTok{    Parser P }\OperatorTok{=} \OperatorTok{\{} \OperatorTok{.}\NormalTok{L }\OperatorTok{=} \OperatorTok{\&}\NormalTok{L}\OperatorTok{,} \OperatorTok{.}\NormalTok{A }\OperatorTok{=}\NormalTok{ A}\OperatorTok{,} \OperatorTok{.}\NormalTok{ok }\OperatorTok{=} \DecValTok{1} \OperatorTok{\};}
\NormalTok{    Node }\OperatorTok{*}\NormalTok{root }\OperatorTok{=}\NormalTok{ parse\_expr}\OperatorTok{(\&}\NormalTok{P}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{P}\OperatorTok{.}\NormalTok{ok }\OperatorTok{\&\&}\NormalTok{ peek}\OperatorTok{(\&}\NormalTok{L}\OperatorTok{).}\NormalTok{kind }\OperatorTok{==}\NormalTok{ TOK\_EOF }\OperatorTok{\&\&}\NormalTok{ root}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        print\_ast}\OperatorTok{(}\NormalTok{root}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"Failed to parse input.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    arena\_free}\OperatorTok{(}\NormalTok{A}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ P}\OperatorTok{.}\NormalTok{ok }\OperatorTok{?} \DecValTok{0} \OperatorTok{:} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra}\NormalTok{ expr\_parser.c }\AttributeTok{{-}o}\NormalTok{ expr\_parser}
\ExtensionTok{./expr\_parser} \StringTok{"3 + 4*2 {-} (1 + 5)"}
\end{Highlighting}
\end{Shaded}

Example output:

\begin{verbatim}
((3 + (4 * 2)) - (1 + 5))
\end{verbatim}

This shows correct precedence and grouping.

\subsubsection{Step 9. How to extend it}\label{step-9.-how-to-extend-it}

\begin{itemize}
\tightlist
\item
  Add unary \texttt{+} and unary \texttt{-} in \texttt{parse\_factor}.
\item
  Support integers in hex and underscores like \texttt{1\_000}.
\item
  Add power operator \texttt{\^{}} with higher precedence.
\item
  Record source spans on each node for better error messages.
\item
  Swap the pretty printer for a JSON dump of the AST.
\end{itemize}

\subsubsection{Step 10. Why this
matters}\label{step-10.-why-this-matters}

Parsing transforms bytes into meaning. With a tokenizer, a clean
grammar, and a small AST, you can build:

\begin{itemize}
\tightlist
\item
  Expression evaluators
\item
  Config file readers
\item
  Query languages
\item
  Full interpreters
\end{itemize}

In the next section you will use this AST to build a \textbf{tiny
interpreter} that evaluates expressions at runtime.

\subsection{97. Tiny Interpreter for an Expression
Language}\label{tiny-interpreter-for-an-expression-language}

You already built a tokenizer, parser, and AST. Now you will
\textbf{evaluate} that AST so \texttt{3\ +\ 4*2\ -\ (1\ +\ 5)} produces
\texttt{5} at runtime. We will add a tiny environment for variables, a
few built in functions, and a simple REPL.

\subsubsection{Step 1. Evaluation model}\label{step-1.-evaluation-model}

We will walk the AST recursively:

\begin{itemize}
\tightlist
\item
  \texttt{N\_INT} returns its value
\item
  \texttt{N\_ADD} returns \texttt{eval(left)\ +\ eval(right)}
\item
  \texttt{N\_SUB}, \texttt{N\_MUL}, \texttt{N\_DIV} similar, with divide
  by zero checks
\end{itemize}

Keep everything in \texttt{long} for now. You can switch to
\texttt{double} later if you want decimals.

\subsubsection{Step 2. Variables and
assignments}\label{step-2.-variables-and-assignments}

Extend the grammar slightly:

\begin{verbatim}
stmt   -> IDENT '=' expr | expr
expr   -> term (('+' | '-') term)*
term   -> factor (('*' | '/') factor)*
factor -> INT | IDENT | '(' expr ')'
\end{verbatim}

\begin{itemize}
\tightlist
\item
  If input contains \texttt{x\ =\ 10}, store
  \texttt{x\ -\textgreater{}\ 10} in the environment
\item
  If input contains \texttt{x\ +\ 2}, look up \texttt{x} then evaluate
\end{itemize}

\subsubsection{Step 3. Environment}\label{step-3.-environment}

Use a tiny linear table for clarity:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;} \DataTypeTok{long}\NormalTok{ value}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Binding}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Binding }\OperatorTok{*}\NormalTok{items}\OperatorTok{;}
    \DataTypeTok{size\_t}\NormalTok{   count}\OperatorTok{,}\NormalTok{ cap}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Env}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{long} \OperatorTok{*}\NormalTok{env\_get}\OperatorTok{(}\NormalTok{Env }\OperatorTok{*}\NormalTok{E}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ name}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{value}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ env\_set}\OperatorTok{(}\NormalTok{Env }\OperatorTok{*}\NormalTok{E}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{,} \DataTypeTok{long}\NormalTok{ v}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{long} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ env\_get}\OperatorTok{(}\NormalTok{E}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{count }\OperatorTok{==}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{size\_t}\NormalTok{ ncap }\OperatorTok{=}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{?}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{*} \DecValTok{2} \OperatorTok{:} \DecValTok{16}\OperatorTok{;}
\NormalTok{        Binding }\OperatorTok{*}\NormalTok{n }\OperatorTok{=}\NormalTok{ realloc}\OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{,}\NormalTok{ ncap }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{));}
        \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\NormalTok{        E}\OperatorTok{{-}\textgreater{}}\NormalTok{items }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap }\OperatorTok{=}\NormalTok{ ncap}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{count}\OperatorTok{++]} \OperatorTok{=} \OperatorTok{(}\NormalTok{Binding}\OperatorTok{)\{}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{name}\OperatorTok{),}\NormalTok{ v }\OperatorTok{\};}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is not the fastest map, but it is simple and good for a tiny
interpreter.

\subsubsection{Step 4. Extend tokens for identifiers and
equals}\label{step-4.-extend-tokens-for-identifiers-and-equals}

Add two kinds:

\begin{itemize}
\tightlist
\item
  \texttt{TOK\_IDENT} for variable names
\item
  \texttt{TOK\_EQ} for \texttt{=}
\end{itemize}

Identifier rule: start with letter or \texttt{\_}, continue with letter,
digit, \texttt{\_}.

\subsubsection{Step 5. AST nodes for identifiers and
assignment}\label{step-5.-ast-nodes-for-identifiers-and-assignment}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ N\_INT}\OperatorTok{,}\NormalTok{ N\_ADD}\OperatorTok{,}\NormalTok{ N\_SUB}\OperatorTok{,}\NormalTok{ N\_MUL}\OperatorTok{,}\NormalTok{ N\_DIV}\OperatorTok{,}\NormalTok{ N\_IDENT}\OperatorTok{,}\NormalTok{ N\_ASSIGN }\OperatorTok{\}}\NormalTok{ NodeKind}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}
\NormalTok{    NodeKind kind}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{l}\OperatorTok{,} \OperatorTok{*}\NormalTok{r}\OperatorTok{;}  \CommentTok{// for binary ops and assignment}
    \DataTypeTok{long}\NormalTok{ value}\OperatorTok{;}          \CommentTok{// for integers}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;}    \CommentTok{// for identifiers}
\OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{N\_IDENT} uses \texttt{name}
\item
  \texttt{N\_ASSIGN} uses \texttt{l} as name node and \texttt{r} as
  expression node
\end{itemize}

\subsubsection{Step 6. Parser changes}\label{step-6.-parser-changes}

\begin{itemize}
\item
  In \texttt{factor}, if token is \texttt{IDENT}, return
  \texttt{N\_IDENT}
\item
  Add \texttt{parse\_stmt}:

  \begin{itemize}
  \tightlist
  \item
    If lookahead is \texttt{IDENT} then \texttt{=} then parse
    \texttt{expr} and build \texttt{N\_ASSIGN}
  \item
    Else parse \texttt{expr}
  \end{itemize}
\end{itemize}

\subsubsection{Step 7. Tiny Code: evaluator + minimal
REPL}\label{step-7.-tiny-code-evaluator-minimal-repl}

Below is a compact interpreter that builds on the earlier parser. For
brevity, the lexer and arena are trimmed to only the new bits you need
here.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: tiny\_interp.c}
\PreprocessorTok{\#define \_POSIX\_C\_SOURCE }\DecValTok{200809}\BuiltInTok{L}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}ctype.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* {-}{-}{-}{-}{-} tiny arena {-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{base}\OperatorTok{;} \DataTypeTok{size\_t}\NormalTok{ cap}\OperatorTok{,}\NormalTok{ off}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Arena}\OperatorTok{;}
\DataTypeTok{static}\NormalTok{ Arena }\OperatorTok{*}\NormalTok{arena\_new}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ cap}\OperatorTok{)\{}\NormalTok{ Arena}\OperatorTok{*}\NormalTok{a}\OperatorTok{=}\NormalTok{malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{a}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{a}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{=}\NormalTok{malloc}\OperatorTok{(}\NormalTok{cap}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{)\{}\NormalTok{free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;\}}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{=}\NormalTok{cap}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{off}\OperatorTok{=}\DecValTok{0}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ a}\OperatorTok{;\}}
\DataTypeTok{static} \DataTypeTok{void} \OperatorTok{*}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{a}\OperatorTok{,}\DataTypeTok{size\_t}\NormalTok{ n}\OperatorTok{,}\DataTypeTok{size\_t}\NormalTok{ al}\OperatorTok{)\{} \DataTypeTok{size\_t}\NormalTok{ p}\OperatorTok{=(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{off}\OperatorTok{+(}\NormalTok{al}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{))\&\textasciitilde{}(}\NormalTok{al}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{+}\NormalTok{n}\OperatorTok{\textgreater{}}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \DataTypeTok{void}\OperatorTok{*}\NormalTok{ptr}\OperatorTok{=}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{+}\NormalTok{p}\OperatorTok{;}\NormalTok{ a}\OperatorTok{{-}\textgreater{}}\NormalTok{off}\OperatorTok{=}\NormalTok{p}\OperatorTok{+}\NormalTok{n}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ ptr}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ arena\_free}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{a}\OperatorTok{)\{} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{a}\OperatorTok{)}\ControlFlowTok{return}\OperatorTok{;}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{{-}\textgreater{}}\NormalTok{base}\OperatorTok{);}\NormalTok{ free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);} \OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} tokens {-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ TOK\_INT}\OperatorTok{,}\NormalTok{ TOK\_PLUS}\OperatorTok{,}\NormalTok{ TOK\_MINUS}\OperatorTok{,}\NormalTok{ TOK\_STAR}\OperatorTok{,}\NormalTok{ TOK\_SLASH}\OperatorTok{,}
\NormalTok{               TOK\_LPAREN}\OperatorTok{,}\NormalTok{ TOK\_RPAREN}\OperatorTok{,}\NormalTok{ TOK\_IDENT}\OperatorTok{,}\NormalTok{ TOK\_EQ}\OperatorTok{,}\NormalTok{ TOK\_EOF}\OperatorTok{,}\NormalTok{ TOK\_ERR }\OperatorTok{\}}\NormalTok{ TokKind}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}\NormalTok{ TokKind kind}\OperatorTok{;} \DataTypeTok{long}\NormalTok{ ival}\OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s}\OperatorTok{,*}\NormalTok{e}\OperatorTok{;} \DataTypeTok{char} \OperatorTok{*}\NormalTok{lexeme}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Token}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{src}\OperatorTok{,*}\NormalTok{cur}\OperatorTok{;}\NormalTok{ Token look}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Lexer}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ skip\_ws}\OperatorTok{(}\NormalTok{Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{)\{} \ControlFlowTok{while}\OperatorTok{(}\NormalTok{isspace}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{))}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{++;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Token make\_tok}\OperatorTok{(}\NormalTok{TokKind k}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{s}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{e}\OperatorTok{,}\DataTypeTok{long}\NormalTok{ v}\OperatorTok{,}\DataTypeTok{char}\OperatorTok{*}\NormalTok{lex}\OperatorTok{)\{} \ControlFlowTok{return} \OperatorTok{(}\NormalTok{Token}\OperatorTok{)\{}\NormalTok{k}\OperatorTok{,}\NormalTok{v}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{e}\OperatorTok{,}\NormalTok{lex}\OperatorTok{\};} \OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Token next\_raw}\OperatorTok{(}\NormalTok{Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{)\{}
\NormalTok{    skip\_ws}\OperatorTok{(}\NormalTok{L}\OperatorTok{);} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{s}\OperatorTok{=}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{==}\DecValTok{0}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_EOF}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \DataTypeTok{char}\NormalTok{ c}\OperatorTok{=*}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{++;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_PLUS}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_MINUS}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_STAR}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_SLASH}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}(\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_LPAREN}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{})\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_RPAREN}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c}\OperatorTok{==}\CharTok{\textquotesingle{}=\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_EQ}\OperatorTok{,}\NormalTok{    s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{isdigit}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)}\NormalTok{c}\OperatorTok{))} \OperatorTok{\{}
        \DataTypeTok{long}\NormalTok{ v }\OperatorTok{=}\NormalTok{ c }\OperatorTok{{-}} \CharTok{\textquotesingle{}0\textquotesingle{}}\OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{p}\OperatorTok{=}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{;}
        \ControlFlowTok{while} \OperatorTok{(}\NormalTok{isdigit}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)*}\NormalTok{p}\OperatorTok{))} \OperatorTok{\{}\NormalTok{ v }\OperatorTok{=}\NormalTok{ v}\OperatorTok{*}\DecValTok{10} \OperatorTok{+} \OperatorTok{(*}\NormalTok{p }\OperatorTok{{-}} \CharTok{\textquotesingle{}0\textquotesingle{}}\OperatorTok{);}\NormalTok{ p}\OperatorTok{++;} \OperatorTok{\}}
\NormalTok{        L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_INT}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{p}\OperatorTok{,}\NormalTok{v}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{isalpha}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)}\NormalTok{c}\OperatorTok{)} \OperatorTok{||}\NormalTok{ c}\OperatorTok{==}\CharTok{\textquotesingle{}\_\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{p}\OperatorTok{=}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{;} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{isalnum}\OperatorTok{((}\DataTypeTok{unsigned} \DataTypeTok{char}\OperatorTok{)*}\NormalTok{p}\OperatorTok{)} \OperatorTok{||} \OperatorTok{*}\NormalTok{p}\OperatorTok{==}\CharTok{\textquotesingle{}\_\textquotesingle{}}\OperatorTok{)}\NormalTok{ p}\OperatorTok{++;}
        \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{size\_t}\OperatorTok{)(}\NormalTok{p }\OperatorTok{{-}} \OperatorTok{(}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{));} \CommentTok{// include first char}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{lex }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n}\OperatorTok{+}\DecValTok{1}\OperatorTok{);}
\NormalTok{        memcpy}\OperatorTok{(}\NormalTok{lex}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}\NormalTok{ lex}\OperatorTok{[}\NormalTok{n}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{        L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_IDENT}\OperatorTok{,}\NormalTok{s}\OperatorTok{,}\NormalTok{p}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{lex}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ make\_tok}\OperatorTok{(}\NormalTok{TOK\_ERR}\OperatorTok{,}\NormalTok{ s}\OperatorTok{,}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{,}\DecValTok{0}\OperatorTok{,}\NormalTok{NULL}\OperatorTok{);}
\OperatorTok{\}}
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ lex\_init}\OperatorTok{(}\NormalTok{Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{src}\OperatorTok{)\{}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{src}\OperatorTok{=}\NormalTok{src}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{cur}\OperatorTok{=}\NormalTok{src}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{=}\NormalTok{next\_raw}\OperatorTok{(}\NormalTok{L}\OperatorTok{);} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Token peek}\OperatorTok{(}\NormalTok{Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{)\{} \ControlFlowTok{return}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Token take}\OperatorTok{(}\NormalTok{Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{)\{}\NormalTok{ Token t}\OperatorTok{=}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{;}\NormalTok{ L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{=}\NormalTok{next\_raw}\OperatorTok{(}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ t}\OperatorTok{;} \OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} AST {-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ N\_INT}\OperatorTok{,}\NormalTok{ N\_ADD}\OperatorTok{,}\NormalTok{ N\_SUB}\OperatorTok{,}\NormalTok{ N\_MUL}\OperatorTok{,}\NormalTok{ N\_DIV}\OperatorTok{,}\NormalTok{ N\_IDENT}\OperatorTok{,}\NormalTok{ N\_ASSIGN }\OperatorTok{\}}\NormalTok{ NodeKind}\OperatorTok{;}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{\{}\NormalTok{ NodeKind k}\OperatorTok{;} \KeywordTok{struct}\NormalTok{ Node }\OperatorTok{*}\NormalTok{l}\OperatorTok{,*}\NormalTok{r}\OperatorTok{;} \DataTypeTok{long}\NormalTok{ v}\OperatorTok{;} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{name}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Node}\OperatorTok{;}

\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ new\_int}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{A}\OperatorTok{,}\DataTypeTok{long}\NormalTok{ v}\OperatorTok{)\{}\NormalTok{ Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),}\KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{k}\OperatorTok{=}\NormalTok{N\_INT}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{=}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{=}\NormalTok{NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{v}\OperatorTok{=}\NormalTok{v}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{=}\NormalTok{NULL}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ new\_ident}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{A}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{name}\OperatorTok{)\{}\NormalTok{ Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),}\KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{k}\OperatorTok{=}\NormalTok{N\_IDENT}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{=}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{=}\NormalTok{NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{v}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{=}\NormalTok{name}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ new\_bin}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{A}\OperatorTok{,}\NormalTok{NodeKind k}\OperatorTok{,}\NormalTok{Node}\OperatorTok{*}\NormalTok{l}\OperatorTok{,}\NormalTok{Node}\OperatorTok{*}\NormalTok{r}\OperatorTok{)\{}\NormalTok{ Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),}\KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{k}\OperatorTok{=}\NormalTok{k}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{=}\NormalTok{l}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{=}\NormalTok{r}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{v}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{=}\NormalTok{NULL}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ new\_assign}\OperatorTok{(}\NormalTok{Arena}\OperatorTok{*}\NormalTok{A}\OperatorTok{,}\NormalTok{Node}\OperatorTok{*}\NormalTok{name}\OperatorTok{,}\NormalTok{Node}\OperatorTok{*}\NormalTok{expr}\OperatorTok{)\{}\NormalTok{ Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{arena\_alloc}\OperatorTok{(}\NormalTok{A}\OperatorTok{,}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{),}\KeywordTok{\_Alignof}\OperatorTok{(}\NormalTok{Node}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)}\ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{k}\OperatorTok{=}\NormalTok{N\_ASSIGN}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{=}\NormalTok{name}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{=}\NormalTok{expr}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{v}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{=}\NormalTok{NULL}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;} \OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} parser {-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}\NormalTok{ Lexer}\OperatorTok{*}\NormalTok{L}\OperatorTok{;}\NormalTok{ Arena}\OperatorTok{*}\NormalTok{A}\OperatorTok{;} \DataTypeTok{int}\NormalTok{ ok}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Parser}\OperatorTok{;}
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ fail}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{msg}\OperatorTok{,}\NormalTok{Token t}\OperatorTok{)\{}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{=}\DecValTok{0}\OperatorTok{;} \DataTypeTok{size\_t}\NormalTok{ pos}\OperatorTok{=(}\DataTypeTok{size\_t}\OperatorTok{)(}\NormalTok{t}\OperatorTok{.}\NormalTok{s }\OperatorTok{{-}}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{src}\OperatorTok{);}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Parse error at }\SpecialCharTok{\%zu}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pos}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);} \OperatorTok{\}}

\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ parse\_expr}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{);} \CommentTok{// forward}

\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ parse\_factor}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{)\{}
\NormalTok{    Token t }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{t}\OperatorTok{.}\NormalTok{kind}\OperatorTok{==}\NormalTok{TOK\_INT}\OperatorTok{)\{}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ new\_int}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ t}\OperatorTok{.}\NormalTok{ival}\OperatorTok{);} \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{t}\OperatorTok{.}\NormalTok{kind}\OperatorTok{==}\NormalTok{TOK\_IDENT}\OperatorTok{)\{}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ new\_ident}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ t}\OperatorTok{.}\NormalTok{lexeme}\OperatorTok{);} \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{t}\OperatorTok{.}\NormalTok{kind}\OperatorTok{==}\NormalTok{TOK\_LPAREN}\OperatorTok{)\{}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}\NormalTok{ Node}\OperatorTok{*}\NormalTok{e}\OperatorTok{=}\NormalTok{parse\_expr}\OperatorTok{(}\NormalTok{P}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(}\NormalTok{peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{!=}\NormalTok{TOK\_RPAREN}\OperatorTok{)\{}\NormalTok{ fail}\OperatorTok{(}\NormalTok{P}\OperatorTok{,}\StringTok{"expected \textquotesingle{})\textquotesingle{}"}\OperatorTok{,}\NormalTok{peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{));} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;\}}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ e}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    fail}\OperatorTok{(}\NormalTok{P}\OperatorTok{,}\StringTok{"expected number, name, or \textquotesingle{}(\textquotesingle{}"}\OperatorTok{,}\NormalTok{ t}\OperatorTok{);} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ parse\_term}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{)\{}
\NormalTok{    Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{parse\_factor}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
    \ControlFlowTok{while}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{)\{}
\NormalTok{        TokKind k }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{k}\OperatorTok{!=}\NormalTok{TOK\_STAR }\OperatorTok{\&\&}\NormalTok{ k}\OperatorTok{!=}\NormalTok{TOK\_SLASH}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
\NormalTok{        Node}\OperatorTok{*}\NormalTok{r}\OperatorTok{=}\NormalTok{parse\_factor}\OperatorTok{(}\NormalTok{P}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{r}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{        n}\OperatorTok{=}\NormalTok{new\_bin}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ k}\OperatorTok{==}\NormalTok{TOK\_STAR}\OperatorTok{?}\NormalTok{N\_MUL}\OperatorTok{:}\NormalTok{N\_DIV}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ r}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ parse\_expr}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{)\{}
\NormalTok{    Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{parse\_term}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
    \ControlFlowTok{while}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{ok}\OperatorTok{)\{}
\NormalTok{        TokKind k }\OperatorTok{=}\NormalTok{ peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{;}
        \ControlFlowTok{if}\OperatorTok{(}\NormalTok{k}\OperatorTok{!=}\NormalTok{TOK\_PLUS }\OperatorTok{\&\&}\NormalTok{ k}\OperatorTok{!=}\NormalTok{TOK\_MINUS}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
\NormalTok{        Node}\OperatorTok{*}\NormalTok{r}\OperatorTok{=}\NormalTok{parse\_term}\OperatorTok{(}\NormalTok{P}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{r}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{        n}\OperatorTok{=}\NormalTok{new\_bin}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ k}\OperatorTok{==}\NormalTok{TOK\_PLUS}\OperatorTok{?}\NormalTok{N\_ADD}\OperatorTok{:}\NormalTok{N\_SUB}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ r}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\DataTypeTok{static}\NormalTok{ Node}\OperatorTok{*}\NormalTok{ parse\_stmt}\OperatorTok{(}\NormalTok{Parser}\OperatorTok{*}\NormalTok{P}\OperatorTok{)\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{==}\NormalTok{TOK\_IDENT}\OperatorTok{)\{}
        \CommentTok{// look ahead for \textquotesingle{}=\textquotesingle{}}
\NormalTok{        Token save }\OperatorTok{=}\NormalTok{ P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{look}\OperatorTok{;}
\NormalTok{        Token ident }\OperatorTok{=}\NormalTok{ take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{peek}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{).}\NormalTok{kind}\OperatorTok{==}\NormalTok{TOK\_EQ}\OperatorTok{)\{}
\NormalTok{            take}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{);} \CommentTok{// consume \textquotesingle{}=\textquotesingle{}}
\NormalTok{            Node}\OperatorTok{*}\NormalTok{rhs }\OperatorTok{=}\NormalTok{ parse\_expr}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
            \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{rhs}\OperatorTok{)} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;}
            \ControlFlowTok{return}\NormalTok{ new\_assign}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ new\_ident}\OperatorTok{(}\NormalTok{P}\OperatorTok{{-}\textgreater{}}\NormalTok{A}\OperatorTok{,}\NormalTok{ ident}\OperatorTok{.}\NormalTok{lexeme}\OperatorTok{),}\NormalTok{ rhs}\OperatorTok{);}
        \OperatorTok{\}}
        \CommentTok{// no \textquotesingle{}=\textquotesingle{}, rewind}
\NormalTok{        P}\OperatorTok{{-}\textgreater{}}\NormalTok{L}\OperatorTok{{-}\textgreater{}}\NormalTok{look }\OperatorTok{=}\NormalTok{ save}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ parse\_expr}\OperatorTok{(}\NormalTok{P}\OperatorTok{);}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} environment {-}{-}{-}{-}{-} */}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{name}\OperatorTok{;} \DataTypeTok{long}\NormalTok{ value}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Binding}\OperatorTok{;}
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}\NormalTok{ Binding }\OperatorTok{*}\NormalTok{items}\OperatorTok{;} \DataTypeTok{size\_t}\NormalTok{ count}\OperatorTok{,}\NormalTok{ cap}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ Env}\OperatorTok{;}
\DataTypeTok{static} \DataTypeTok{long}\OperatorTok{*}\NormalTok{ env\_get}\OperatorTok{(}\NormalTok{Env}\OperatorTok{*}\NormalTok{E}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{name}\OperatorTok{)\{} \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{i}\OperatorTok{\textless{}}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{count}\OperatorTok{;}\NormalTok{i}\OperatorTok{++)} \ControlFlowTok{if}\OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{name}\OperatorTok{)==}\DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{value}\OperatorTok{;} \ControlFlowTok{return}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ env\_set}\OperatorTok{(}\NormalTok{Env}\OperatorTok{*}\NormalTok{E}\OperatorTok{,}\DataTypeTok{const} \DataTypeTok{char}\OperatorTok{*}\NormalTok{name}\OperatorTok{,}\DataTypeTok{long}\NormalTok{ v}\OperatorTok{)\{}
    \DataTypeTok{long}\OperatorTok{*}\NormalTok{p}\OperatorTok{=}\NormalTok{env\_get}\OperatorTok{(}\NormalTok{E}\OperatorTok{,}\NormalTok{name}\OperatorTok{);} \ControlFlowTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{)\{*}\NormalTok{p}\OperatorTok{=}\NormalTok{v}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;\}}
    \ControlFlowTok{if}\OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{count}\OperatorTok{==}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{)\{} \DataTypeTok{size\_t}\NormalTok{ ncap}\OperatorTok{=}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{?}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{*}\DecValTok{2}\OperatorTok{:}\DecValTok{16}\OperatorTok{;}\NormalTok{ Binding}\OperatorTok{*}\NormalTok{n}\OperatorTok{=}\NormalTok{realloc}\OperatorTok{(}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{,}\NormalTok{ncap}\OperatorTok{*}\KeywordTok{sizeof}\OperatorTok{(*}\NormalTok{n}\OperatorTok{));} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)}\ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{=}\NormalTok{n}\OperatorTok{;}\NormalTok{ E}\OperatorTok{{-}\textgreater{}}\NormalTok{cap}\OperatorTok{=}\NormalTok{ncap}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    E}\OperatorTok{{-}\textgreater{}}\NormalTok{items}\OperatorTok{[}\NormalTok{E}\OperatorTok{{-}\textgreater{}}\NormalTok{count}\OperatorTok{++]} \OperatorTok{=} \OperatorTok{(}\NormalTok{Binding}\OperatorTok{)\{}\NormalTok{ strdup}\OperatorTok{(}\NormalTok{name}\OperatorTok{),}\NormalTok{ v }\OperatorTok{\};}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} evaluator {-}{-}{-}{-}{-} */}
\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ eval}\OperatorTok{(}\NormalTok{Node}\OperatorTok{*}\NormalTok{n}\OperatorTok{,}\NormalTok{ Env}\OperatorTok{*}\NormalTok{E}\OperatorTok{,} \DataTypeTok{long} \OperatorTok{*}\NormalTok{out}\OperatorTok{)\{}
    \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \ControlFlowTok{switch}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{k}\OperatorTok{)\{}
        \ControlFlowTok{case}\NormalTok{ N\_INT}\OperatorTok{:} \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{v}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ N\_IDENT}\OperatorTok{:} \OperatorTok{\{}
            \DataTypeTok{long} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ env\_get}\OperatorTok{(}\NormalTok{E}\OperatorTok{,}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{);}
            \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{p}\OperatorTok{)\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Name not found: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
            \OperatorTok{*}\NormalTok{out }\OperatorTok{=} \OperatorTok{*}\NormalTok{p}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
        \ControlFlowTok{case}\NormalTok{ N\_ADD}\OperatorTok{:} \OperatorTok{\{} \DataTypeTok{long}\NormalTok{ a}\OperatorTok{,}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{a}\OperatorTok{)||!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{b}\OperatorTok{))} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{*}\NormalTok{out}\OperatorTok{=}\NormalTok{a}\OperatorTok{+}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
        \ControlFlowTok{case}\NormalTok{ N\_SUB}\OperatorTok{:} \OperatorTok{\{} \DataTypeTok{long}\NormalTok{ a}\OperatorTok{,}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{a}\OperatorTok{)||!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{b}\OperatorTok{))} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{*}\NormalTok{out}\OperatorTok{=}\NormalTok{a}\OperatorTok{{-}}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
        \ControlFlowTok{case}\NormalTok{ N\_MUL}\OperatorTok{:} \OperatorTok{\{} \DataTypeTok{long}\NormalTok{ a}\OperatorTok{,}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{a}\OperatorTok{)||!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{b}\OperatorTok{))} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{*}\NormalTok{out}\OperatorTok{=}\NormalTok{a}\OperatorTok{*}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}
        \ControlFlowTok{case}\NormalTok{ N\_DIV}\OperatorTok{:} \OperatorTok{\{}
            \DataTypeTok{long}\NormalTok{ a}\OperatorTok{,}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{a}\OperatorTok{)||!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{b}\OperatorTok{))} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
            \ControlFlowTok{if}\OperatorTok{(}\NormalTok{b}\OperatorTok{==}\DecValTok{0}\OperatorTok{)\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Divide by zero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
            \OperatorTok{*}\NormalTok{out}\OperatorTok{=}\NormalTok{a}\OperatorTok{/}\NormalTok{b}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
        \ControlFlowTok{case}\NormalTok{ N\_ASSIGN}\OperatorTok{:} \OperatorTok{\{}
            \DataTypeTok{long}\NormalTok{ v}\OperatorTok{;} \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{eval}\OperatorTok{(}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{r}\OperatorTok{,}\NormalTok{E}\OperatorTok{,\&}\NormalTok{v}\OperatorTok{))} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
            \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{n}\OperatorTok{{-}\textgreater{}}\NormalTok{l }\OperatorTok{||}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{{-}\textgreater{}}\NormalTok{k }\OperatorTok{!=}\NormalTok{ N\_IDENT}\OperatorTok{)\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Left side of \textquotesingle{}=\textquotesingle{} must be a name}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
            \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{env\_set}\OperatorTok{(}\NormalTok{E}\OperatorTok{,}\NormalTok{ n}\OperatorTok{{-}\textgreater{}}\NormalTok{l}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ v}\OperatorTok{))\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Env set failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
            \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ v}\OperatorTok{;} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{/* {-}{-}{-}{-}{-} simple REPL {-}{-}{-}{-}{-} */}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{line }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \DataTypeTok{size\_t}\NormalTok{ n }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    Env env }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    puts}\OperatorTok{(}\StringTok{"tiny repl. enter expressions or assignments. Ctrl D to exit."}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"\textgreater{} "}\OperatorTok{);}\NormalTok{ fflush}\OperatorTok{(}\NormalTok{stdout}\OperatorTok{);}
        \DataTypeTok{ssize\_t}\NormalTok{ m }\OperatorTok{=}\NormalTok{ getline}\OperatorTok{(\&}\NormalTok{line}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{,}\NormalTok{ stdin}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{m }\OperatorTok{\textless{}=} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}

        \CommentTok{// strip newline}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{m}\OperatorTok{\textgreater{}}\DecValTok{0} \OperatorTok{\&\&}\NormalTok{ line}\OperatorTok{[}\NormalTok{m}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{]==}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{)}\NormalTok{ line}\OperatorTok{[}\NormalTok{m}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{]=}\DecValTok{0}\OperatorTok{;}

\NormalTok{        Arena }\OperatorTok{*}\NormalTok{A }\OperatorTok{=}\NormalTok{ arena\_new}\OperatorTok{(}\DecValTok{1}\OperatorTok{\textless{}\textless{}}\DecValTok{16}\OperatorTok{);}
        \ControlFlowTok{if}\OperatorTok{(!}\NormalTok{A}\OperatorTok{)\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"arena failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;} \OperatorTok{\}}

\NormalTok{        Lexer L}\OperatorTok{;}\NormalTok{ lex\_init}\OperatorTok{(\&}\NormalTok{L}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}
\NormalTok{        Parser P }\OperatorTok{=} \OperatorTok{\{} \OperatorTok{.}\NormalTok{L}\OperatorTok{=\&}\NormalTok{L}\OperatorTok{,} \OperatorTok{.}\NormalTok{A}\OperatorTok{=}\NormalTok{A}\OperatorTok{,} \OperatorTok{.}\NormalTok{ok}\OperatorTok{=}\DecValTok{1} \OperatorTok{\};}
\NormalTok{        Node}\OperatorTok{*}\NormalTok{ root }\OperatorTok{=}\NormalTok{ parse\_stmt}\OperatorTok{(\&}\NormalTok{P}\OperatorTok{);}

        \DataTypeTok{long}\NormalTok{ result }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{P}\OperatorTok{.}\NormalTok{ok }\OperatorTok{\&\&}\NormalTok{ root }\OperatorTok{\&\&}\NormalTok{ eval}\OperatorTok{(}\NormalTok{root}\OperatorTok{,} \OperatorTok{\&}\NormalTok{env}\OperatorTok{,} \OperatorTok{\&}\NormalTok{result}\OperatorTok{))}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
        \ControlFlowTok{else}
\NormalTok{            fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,}\StringTok{"Error}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{        arena\_free}\OperatorTok{(}\NormalTok{A}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    free}\OperatorTok{(}\NormalTok{line}\OperatorTok{);}
    \CommentTok{// free env bindings}
    \ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ i}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{i}\OperatorTok{\textless{}}\NormalTok{env}\OperatorTok{.}\NormalTok{count}\OperatorTok{;}\NormalTok{i}\OperatorTok{++)}\NormalTok{ free}\OperatorTok{((}\DataTypeTok{void}\OperatorTok{*)}\NormalTok{env}\OperatorTok{.}\NormalTok{items}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{env}\OperatorTok{.}\NormalTok{items}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build and try:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra}\NormalTok{ tiny\_interp.c }\AttributeTok{{-}o}\NormalTok{ tiny\_interp}
\ExtensionTok{./tiny\_interp}
\end{Highlighting}
\end{Shaded}

Example session:

\begin{verbatim}
> 3 + 4*2 - (1 + 5)
5
> x = 10
10
> x + 7
17
> y = x * 3
30
> y / 5
6
\end{verbatim}

\subsubsection{Step 8. Add built in functions
(optional)}\label{step-8.-add-built-in-functions-optional}

You can recognize identifiers like \texttt{max} or \texttt{min} and
parse a function call form
\texttt{name\ \textquotesingle{}(\textquotesingle{}\ args\ \textquotesingle{})\textquotesingle{}}.
Then implement small handlers in the evaluator that pop evaluated
arguments and return a result.

\subsubsection{Step 9. Better numbers}\label{step-9.-better-numbers}

Switch to \texttt{double} if you want division with fractions:

\begin{itemize}
\tightlist
\item
  Change value type to \texttt{double}
\item
  Print with \texttt{\%.6g}
\item
  Update divide by zero checks accordingly
\end{itemize}

\subsubsection{Step 10. Why this
matters}\label{step-10.-why-this-matters-1}

You now have a complete loop:

\begin{itemize}
\tightlist
\item
  Text
\item
  Tokens
\item
  AST
\item
  Evaluation
\end{itemize}

This is the heart of configuration languages, query languages,
calculators, and many scripting systems. In the next section you will
connect this skill to external data by \textbf{interfacing with SQLite
or LevelDB} from C and building a tiny query tool.

\subsection{98. Interfacing with SQLite or
LevelDB}\label{interfacing-with-sqlite-or-leveldb}

Time to connect your C programs to real data. In this section you will
talk to two popular embeddable databases:

\begin{itemize}
\tightlist
\item
  \textbf{SQLite}: relational, SQL queries, ACID transactions in a
  single file
\item
  \textbf{LevelDB}: key value store, ordered by key, fast reads and
  writes
\end{itemize}

You will write tiny programs that insert and query data with both
engines.

\subsubsection{Step 1. When to choose
which}\label{step-1.-when-to-choose-which}

\begin{itemize}
\tightlist
\item
  Choose \textbf{SQLite} when you want tables, indexes, SQL, and
  transactions
\item
  Choose \textbf{LevelDB} when you want a simple sorted key value store,
  no SQL, and you control schema in your app
\end{itemize}

Both are embeddable and require no separate server process.

\subsubsection{Step 2. Install headers and
libs}\label{step-2.-install-headers-and-libs}

On Linux or macOS with Homebrew or apt:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# SQLite}
\FunctionTok{sudo}\NormalTok{ apt install libsqlite3{-}dev        }\CommentTok{\# Debian based}
\CommentTok{\# or}
\ExtensionTok{brew}\NormalTok{ install sqlite                    }\CommentTok{\# macOS}

\CommentTok{\# LevelDB}
\FunctionTok{sudo}\NormalTok{ apt install libleveldb{-}dev        }\CommentTok{\# Debian based}
\CommentTok{\# or}
\ExtensionTok{brew}\NormalTok{ install leveldb                   }\CommentTok{\# macOS}
\end{Highlighting}
\end{Shaded}

Windows users can grab prebuilt binaries or build from source and link
the .lib files.

\subsubsection{Step 3. Tiny Code for SQLite: create, insert,
query}\label{step-3.-tiny-code-for-sqlite-create-insert-query}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: sqlite\_demo.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}sqlite3.h\textgreater{}}

\DataTypeTok{static} \DataTypeTok{int}\NormalTok{ print\_row}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{unused}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{**}\NormalTok{argv}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{**}\NormalTok{col}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ col}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{?}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{:} \StringTok{"NULL"}\OperatorTok{);}
\NormalTok{    puts}\OperatorTok{(}\StringTok{"{-}{-}{-}"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    sqlite3 }\OperatorTok{*}\NormalTok{db }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sqlite3\_open}\OperatorTok{(}\StringTok{"people.db"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{db}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ SQLITE\_OK}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"open: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sqlite3\_errmsg}\OperatorTok{(}\NormalTok{db}\OperatorTok{));}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{ddl }\OperatorTok{=}
        \StringTok{"CREATE TABLE IF NOT EXISTS people ("}
        \StringTok{" id INTEGER PRIMARY KEY AUTOINCREMENT,"}
        \StringTok{" name TEXT NOT NULL,"}
        \StringTok{" age INTEGER NOT NULL"}
        \StringTok{");"}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sqlite3\_exec}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ ddl}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ SQLITE\_OK}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"ddl: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sqlite3\_errmsg}\OperatorTok{(}\NormalTok{db}\OperatorTok{));}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \CommentTok{// Use prepared statements for safety and speed}
    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{ins }\OperatorTok{=} \StringTok{"INSERT INTO people(name, age) VALUES(?, ?);"}\OperatorTok{;}
\NormalTok{    sqlite3\_stmt }\OperatorTok{*}\NormalTok{stmt }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sqlite3\_prepare\_v2}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ ins}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \OperatorTok{\&}\NormalTok{stmt}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ SQLITE\_OK}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"prepare: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sqlite3\_errmsg}\OperatorTok{(}\NormalTok{db}\OperatorTok{));}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{struct} \OperatorTok{\{} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name}\OperatorTok{;} \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;} \OperatorTok{\}}\NormalTok{ rows}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{\{}\StringTok{"Ada"}\OperatorTok{,} \DecValTok{36}\OperatorTok{\},} \OperatorTok{\{}\StringTok{"Linus"}\OperatorTok{,} \DecValTok{55}\OperatorTok{\},} \OperatorTok{\{}\StringTok{"Grace"}\OperatorTok{,} \DecValTok{61}\OperatorTok{\}}
    \OperatorTok{\};}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        sqlite3\_reset}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{);}
\NormalTok{        sqlite3\_clear\_bindings}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{);}
\NormalTok{        sqlite3\_bind\_text}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,} \DecValTok{1}\OperatorTok{,}\NormalTok{ rows}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{,}\NormalTok{ SQLITE\_TRANSIENT}\OperatorTok{);}
\NormalTok{        sqlite3\_bind\_int}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,}  \DecValTok{2}\OperatorTok{,}\NormalTok{ rows}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{age}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sqlite3\_step}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ SQLITE\_DONE}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"insert: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sqlite3\_errmsg}\OperatorTok{(}\NormalTok{db}\OperatorTok{));}
            \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\NormalTok{    sqlite3\_finalize}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{);}

    \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{q }\OperatorTok{=} \StringTok{"SELECT id, name, age FROM people WHERE age \textgreater{}= ? ORDER BY age DESC;"}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{sqlite3\_prepare\_v2}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ q}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \OperatorTok{\&}\NormalTok{stmt}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ SQLITE\_OK}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"prepare q: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sqlite3\_errmsg}\OperatorTok{(}\NormalTok{db}\OperatorTok{));}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    sqlite3\_bind\_int}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{40}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{sqlite3\_step}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{)} \OperatorTok{==}\NormalTok{ SQLITE\_ROW}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=}\NormalTok{ sqlite3\_column\_int}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
        \DataTypeTok{const} \DataTypeTok{unsigned} \DataTypeTok{char} \OperatorTok{*}\NormalTok{name }\OperatorTok{=}\NormalTok{ sqlite3\_column\_text}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
        \DataTypeTok{int}\NormalTok{ age }\OperatorTok{=}\NormalTok{ sqlite3\_column\_int}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{,} \DecValTok{2}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"id=}\SpecialCharTok{\%d}\StringTok{ name=}\SpecialCharTok{\%s}\StringTok{ age=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ id}\OperatorTok{,}\NormalTok{ name}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    sqlite3\_finalize}\OperatorTok{(}\NormalTok{stmt}\OperatorTok{);}

\NormalTok{    sqlite3\_close}\OperatorTok{(}\NormalTok{db}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2}\NormalTok{ sqlite\_demo.c }\AttributeTok{{-}lsqlite3} \AttributeTok{{-}o}\NormalTok{ sqlite\_demo}
\ExtensionTok{./sqlite\_demo}
\end{Highlighting}
\end{Shaded}

You should see rows printed for people with age 40 or higher.

\subsubsection{Step 4. SQLite best practices in
C}\label{step-4.-sqlite-best-practices-in-c}

\begin{itemize}
\tightlist
\item
  Always use \textbf{prepared statements} with \texttt{?} placeholders
\item
  Always call \texttt{sqlite3\_finalize} on statements
\item
  Wrap batches in \texttt{BEGIN} and \texttt{COMMIT} for speed
\item
  Check every return code and print \texttt{sqlite3\_errmsg(db)} on
  error
\item
  Use \texttt{sqlite3\_last\_insert\_rowid} to fetch new primary keys
\end{itemize}

\subsubsection{Step 5. Tiny Code for LevelDB: open, put, get,
iterate}\label{step-5.-tiny-code-for-leveldb-open-put-get-iterate}

LevelDB has a C API that mirrors the C++ API.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: leveldb\_demo.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}leveldb/c.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{err }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

\NormalTok{    leveldb\_options\_t }\OperatorTok{*}\NormalTok{opts }\OperatorTok{=}\NormalTok{ leveldb\_options\_create}\OperatorTok{();}
\NormalTok{    leveldb\_options\_set\_create\_if\_missing}\OperatorTok{(}\NormalTok{opts}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}

\NormalTok{    leveldb\_t }\OperatorTok{*}\NormalTok{db }\OperatorTok{=}\NormalTok{ leveldb\_open}\OperatorTok{(}\NormalTok{opts}\OperatorTok{,} \StringTok{"kvdb"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{err}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"open: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ err}\OperatorTok{);}\NormalTok{ leveldb\_free}\OperatorTok{(}\NormalTok{err}\OperatorTok{);} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;} \OperatorTok{\}}

\NormalTok{    leveldb\_writeoptions\_t }\OperatorTok{*}\NormalTok{wopt }\OperatorTok{=}\NormalTok{ leveldb\_writeoptions\_create}\OperatorTok{();}
\NormalTok{    leveldb\_readoptions\_t  }\OperatorTok{*}\NormalTok{ropt }\OperatorTok{=}\NormalTok{ leveldb\_readoptions\_create}\OperatorTok{();}

    \CommentTok{// Put some keys}
\NormalTok{    leveldb\_put}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ wopt}\OperatorTok{,} \StringTok{"name"}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \StringTok{"Ada"}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{err}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"put: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ err}\OperatorTok{);}\NormalTok{ leveldb\_free}\OperatorTok{(}\NormalTok{err}\OperatorTok{);}\NormalTok{ err }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
\NormalTok{    leveldb\_put}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ wopt}\OperatorTok{,} \StringTok{"lang"}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \StringTok{"C"}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
\NormalTok{    leveldb\_put}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ wopt}\OperatorTok{,} \StringTok{"year"}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \StringTok{"1972"}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}

    \CommentTok{// Get a value}
    \DataTypeTok{size\_t}\NormalTok{ vlen }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{char} \OperatorTok{*}\NormalTok{val }\OperatorTok{=}\NormalTok{ leveldb\_get}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ ropt}\OperatorTok{,} \StringTok{"name"}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \OperatorTok{\&}\NormalTok{vlen}\OperatorTok{,} \OperatorTok{\&}\NormalTok{err}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{err}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"get: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ err}\OperatorTok{);}\NormalTok{ leveldb\_free}\OperatorTok{(}\NormalTok{err}\OperatorTok{);}\NormalTok{ err }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{val}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"name=}\SpecialCharTok{\%.*s\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{vlen}\OperatorTok{,}\NormalTok{ val}\OperatorTok{);}\NormalTok{ leveldb\_free}\OperatorTok{(}\NormalTok{val}\OperatorTok{);} \OperatorTok{\}}

    \CommentTok{// Iterate in key order}
\NormalTok{    leveldb\_iterator\_t }\OperatorTok{*}\NormalTok{it }\OperatorTok{=}\NormalTok{ leveldb\_create\_iterator}\OperatorTok{(}\NormalTok{db}\OperatorTok{,}\NormalTok{ ropt}\OperatorTok{);}
\NormalTok{    leveldb\_iter\_seek\_to\_first}\OperatorTok{(}\NormalTok{it}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{leveldb\_iter\_valid}\OperatorTok{(}\NormalTok{it}\OperatorTok{))} \OperatorTok{\{}
        \DataTypeTok{size\_t}\NormalTok{ klen}\OperatorTok{,}\NormalTok{ vlen2}\OperatorTok{;}
        \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{k }\OperatorTok{=}\NormalTok{ leveldb\_iter\_key}\OperatorTok{(}\NormalTok{it}\OperatorTok{,} \OperatorTok{\&}\NormalTok{klen}\OperatorTok{);}
        \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{v }\OperatorTok{=}\NormalTok{ leveldb\_iter\_value}\OperatorTok{(}\NormalTok{it}\OperatorTok{,} \OperatorTok{\&}\NormalTok{vlen2}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.*s}\StringTok{=}\SpecialCharTok{\%.*s\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{klen}\OperatorTok{,}\NormalTok{ k}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{vlen2}\OperatorTok{,}\NormalTok{ v}\OperatorTok{);}
\NormalTok{        leveldb\_iter\_next}\OperatorTok{(}\NormalTok{it}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{if} \OperatorTok{((}\NormalTok{err }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{char}\OperatorTok{*)}\NormalTok{leveldb\_iter\_get\_error}\OperatorTok{(}\NormalTok{it}\OperatorTok{))} \OperatorTok{\&\&} \OperatorTok{*}\NormalTok{err}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{stderr}\OperatorTok{,} \StringTok{"iter: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ err}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    leveldb\_iter\_destroy}\OperatorTok{(}\NormalTok{it}\OperatorTok{);}

    \CommentTok{// Clean up}
\NormalTok{    leveldb\_readoptions\_destroy}\OperatorTok{(}\NormalTok{ropt}\OperatorTok{);}
\NormalTok{    leveldb\_writeoptions\_destroy}\OperatorTok{(}\NormalTok{wopt}\OperatorTok{);}
\NormalTok{    leveldb\_close}\OperatorTok{(}\NormalTok{db}\OperatorTok{);}
\NormalTok{    leveldb\_options\_destroy}\OperatorTok{(}\NormalTok{opts}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2}\NormalTok{ leveldb\_demo.c }\AttributeTok{{-}lleveldb} \AttributeTok{{-}o}\NormalTok{ leveldb\_demo}
\ExtensionTok{./leveldb\_demo}
\end{Highlighting}
\end{Shaded}

You should see key value pairs in sorted key order.

\subsubsection{Step 6. Transactions and
durability}\label{step-6.-transactions-and-durability}

\begin{itemize}
\item
  \textbf{SQLite} has full transactions

  \begin{itemize}
  \tightlist
  \item
    Use \texttt{BEGIN\ IMMEDIATE;} then your inserts then
    \texttt{COMMIT;}
  \item
    For crash safety use the default rollback journal or WAL mode
  \end{itemize}
\item
  \textbf{LevelDB} has atomic writes per key and write batches

  \begin{itemize}
  \tightlist
  \item
    Use \texttt{leveldb\_writebatch\_t} to group puts and deletes
    atomically
  \item
    Sync to disk with
    \texttt{leveldb\_writeoptions\_set\_sync(wopt,\ 1)}
  \end{itemize}
\end{itemize}

\subsubsection{Step 7. Parameter binding and type safety with
SQLite}\label{step-7.-parameter-binding-and-type-safety-with-sqlite}

Use the correct bind and column functions:

\begin{itemize}
\tightlist
\item
  \texttt{sqlite3\_bind\_int}, \texttt{sqlite3\_bind\_int64},
  \texttt{sqlite3\_bind\_double}, \texttt{sqlite3\_bind\_text}
\item
  \texttt{sqlite3\_column\_int}, \texttt{sqlite3\_column\_int64},
  \texttt{sqlite3\_column\_double}, \texttt{sqlite3\_column\_text}
\end{itemize}

Never build SQL by string concatenation with user input. Bindings
prevent SQL injection and handle escaping for you.

\subsubsection{Step 8. Working with binary
data}\label{step-8.-working-with-binary-data}

\begin{itemize}
\tightlist
\item
  \textbf{SQLite}: use \texttt{sqlite3\_bind\_blob} and
  \texttt{sqlite3\_column\_blob} with a separate length
\item
  \textbf{LevelDB}: keys and values are raw byte spans
  \texttt{(ptr,\ length)}, so binary is natural
\end{itemize}

You can store serialized structs, protobufs, or JSON. Remember to define
your own versioning for compatibility.

\subsubsection{Step 9. Schema and indexing
ideas}\label{step-9.-schema-and-indexing-ideas}

\begin{itemize}
\item
  \textbf{SQLite}

  \begin{itemize}
  \tightlist
  \item
    Normalize into tables with primary keys and foreign keys
  \item
    Create indexes for frequent lookups
  \item
    Use \texttt{PRAGMA\ foreign\_keys\ =\ ON;} to enforce constraints
  \end{itemize}
\item
  \textbf{LevelDB}

  \begin{itemize}
  \tightlist
  \item
    Design composite keys to encode access patterns
  \item
    Example: \texttt{user:\textless{}id\textgreater{}} for user row,
    \texttt{user\_email:\textless{}email\textgreater{}} points to
    \texttt{\textless{}id\textgreater{}}
  \item
    Range scans are easy: store keys like
    \texttt{post:\textless{}yyyy-mm\textgreater{}:\textless{}id\textgreater{}}
    and iterate by prefix
  \end{itemize}
\end{itemize}

\subsubsection{Step 10. Why this
matters}\label{step-10.-why-this-matters-2}

Embedding a database takes your C program from toy to tool. You now know
how to:

\begin{itemize}
\tightlist
\item
  Execute SQL queries and prepared statements with SQLite
\item
  Use a sorted key value engine with LevelDB
\item
  Choose the right storage model for each problem
\item
  Handle durability, binary data, and iteration from C
\end{itemize}

\subsubsection{Try it yourself}\label{try-it-yourself-89}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Extend the SQLite demo with a \texttt{BEGIN} and \texttt{COMMIT}
  around a loop of 10000 inserts and measure time.
\item
  Add an index on \texttt{age} and compare query performance.
\item
  In the LevelDB demo add a write batch that inserts 1000 sequential
  keys.
\item
  Store binary blobs in both systems and read them back.
\item
  Build a tiny CLI that routes \texttt{sql\ ...} lines to SQLite and
  \texttt{kv\ ...} lines to LevelDB.
\end{enumerate}

Next up is \textbf{99. Packaging, Versioning, and Documentation} where
you will learn how to ship your code like a pro with Makefiles, pkg
config, semantic versioning, and clean README docs.

\subsection{99. Packaging, Versioning, and
Documentation}\label{packaging-versioning-and-documentation}

You've written real C programs---now it's time to \textbf{package,
version, and document} them like a professional. This is what makes your
code usable by others and maintainable by your future self.

\subsubsection{Step 1. The goal of
packaging}\label{step-1.-the-goal-of-packaging}

Packaging is about making your project easy to:

\begin{itemize}
\tightlist
\item
  build (\texttt{make}, \texttt{cmake}, or \texttt{meson})
\item
  install (\texttt{make\ install})
\item
  link (\texttt{pkg-config})
\item
  use (\texttt{\#include\ "yourlib.h"})
\end{itemize}

You'll create a structure that helps others build and use your code
without guessing.

\subsubsection{Step 2. Standard project
layout}\label{step-2.-standard-project-layout}

A simple, conventional layout for a C project:

\begin{verbatim}
myproject/
├── include/
│   └── myproject.h
├── src/
│   ├── main.c
│   └── util.c
├── tests/
│   └── test_basic.c
├── Makefile
├── README.md
└── LICENSE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{include/} holds headers that others can include
\item
  \texttt{src/} holds your implementation files
\item
  \texttt{tests/} holds unit tests
\item
  \texttt{Makefile} defines how to build and install
\end{itemize}

\subsubsection{Step 3. Tiny Code: a simple reusable
library}\label{step-3.-tiny-code-a-simple-reusable-library}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// include/myproject.h}
\PreprocessorTok{\#ifndef MYPROJECT\_H}
\PreprocessorTok{\#define MYPROJECT\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ sub}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// src/myproject.c}
\PreprocessorTok{\#include }\ImportTok{"myproject.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ sub}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 4. Minimal Makefile}\label{step-4.-minimal-makefile}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC}      \CharTok{=}\StringTok{ gcc}
\DataTypeTok{CFLAGS}  \CharTok{=}\StringTok{ {-}std=c23 {-}O2 {-}Wall {-}Iinclude}
\DataTypeTok{LDFLAGS} \CharTok{=}

\DataTypeTok{SRC} \CharTok{=}\StringTok{ }\CharTok{$(}\KeywordTok{wildcard}\StringTok{ src/*.c}\CharTok{)}
\DataTypeTok{OBJ} \CharTok{=}\StringTok{ }\CharTok{$(}\DataTypeTok{SRC}\KeywordTok{:}\SpecialStringTok{.c}\KeywordTok{=}\SpecialStringTok{.o}\CharTok{)}
\DataTypeTok{LIB} \CharTok{=}\StringTok{ libmyproject.a}

\OtherTok{.PHONY:}\DataTypeTok{ all clean install uninstall}

\DecValTok{all:}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}

\DecValTok{$(LIB):}\DataTypeTok{ }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)}
\ErrorTok{    }\NormalTok{ar rcs }\CharTok{$@} \CharTok{$\^{}}

\DecValTok{\%.o:}\DataTypeTok{ \%.c}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ {-}c }\CharTok{$\textless{}}\NormalTok{ {-}o }\CharTok{$@}

\DecValTok{install:}
\ErrorTok{    }\NormalTok{mkdir {-}p /usr/local/include/myproject}
\NormalTok{    cp include/*.h /usr/local/include/myproject/}
\NormalTok{    cp }\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}\NormalTok{ /usr/local/lib/}

\DecValTok{uninstall:}
\ErrorTok{    }\NormalTok{rm {-}f /usr/local/lib/}\CharTok{$(}\DataTypeTok{LIB}\CharTok{)}
\NormalTok{    rm {-}rf /usr/local/include/myproject}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{OBJ}\CharTok{)} \CharTok{$(}\DataTypeTok{LIB}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Build the library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}
\FunctionTok{sudo}\NormalTok{ make install}
\end{Highlighting}
\end{Shaded}

Then another project can link against it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}lmyproject} \AttributeTok{{-}L}\NormalTok{/usr/local/lib }\AttributeTok{{-}I}\NormalTok{/usr/local/include/myproject}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 5. Versioning your
releases}\label{step-5.-versioning-your-releases}

Follow \textbf{semantic versioning}:

\begin{verbatim}
vMAJOR.MINOR.PATCH
\end{verbatim}

Examples:

\begin{itemize}
\tightlist
\item
  \texttt{v1.0.0} -- stable release
\item
  \texttt{v1.1.0} -- new feature, backward compatible
\item
  \texttt{v1.1.1} -- bug fix, no API change
\item
  \texttt{v2.0.0} -- breaking API change
\end{itemize}

Tag your releases in git:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ tag }\AttributeTok{{-}a}\NormalTok{ v1.0.0 }\AttributeTok{{-}m} \StringTok{"First stable release"}
\FunctionTok{git}\NormalTok{ push origin v1.0.0}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 6. Create a pkg-config
file}\label{step-6.-create-a-pkg-config-file}

\texttt{pkg-config} lets others compile your library easily.

Create \texttt{myproject.pc}:

\begin{verbatim}
prefix=/usr/local
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include/myproject

Name: myproject
Description: Tiny math helper library
Version: 1.0.0
Libs: -L${libdir} -lmyproject
Cflags: -I${includedir}
\end{verbatim}

Install it in \texttt{/usr/local/lib/pkgconfig/} and test:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{pkg{-}config} \AttributeTok{{-}{-}cflags} \AttributeTok{{-}{-}libs}\NormalTok{ myproject}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Documentation with Markdown and
Doxygen}\label{step-7.-documentation-with-markdown-and-doxygen}

Keep a clear \textbf{README.md} at the root:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\# myproject}

\NormalTok{A tiny example C library for arithmetic functions.}

\FunctionTok{\#\# Build}
\end{Highlighting}
\end{Shaded}

make sudo make install

\begin{verbatim}

## Usage
```c
#include <myproject.h>

int main() {
    printf("%d\n", add(3, 4));
}
\end{verbatim}

\begin{verbatim}

For API documentation, use **Doxygen**:

```bash
sudo apt install doxygen
doxygen -g
\end{verbatim}

Edit \texttt{Doxyfile} to include your source paths, then run:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{doxygen}\NormalTok{ Doxyfile}
\end{Highlighting}
\end{Shaded}

Docs will appear in \texttt{html/} or \texttt{latex/}.

\subsubsection{Step 8. Licensing}\label{step-8.-licensing}

Add a \texttt{LICENSE} file so others know how they can use your code.
Common ones:

\begin{itemize}
\tightlist
\item
  \textbf{MIT License}: simple, permissive
\item
  \textbf{Apache 2.0}: adds patent protection
\item
  \textbf{GPLv3}: ensures derivatives remain open
\end{itemize}

Example MIT License header for your source files:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* }
\CommentTok{ * Copyright (c) 2025 Your Name}
\CommentTok{ * Licensed under the MIT License.}
\CommentTok{ */}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 9. Continuous Integration
(optional)}\label{step-9.-continuous-integration-optional}

Add GitHub Actions or another CI service:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# .github/workflows/build.yml}
\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Build and Test}
\FunctionTok{on}\KeywordTok{:}\AttributeTok{ }\KeywordTok{[}\AttributeTok{push}\KeywordTok{,}\AttributeTok{ pull\_request}\KeywordTok{]}
\FunctionTok{jobs}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{build}\KeywordTok{:}
\AttributeTok{    }\FunctionTok{runs{-}on}\KeywordTok{:}\AttributeTok{ ubuntu{-}latest}
\AttributeTok{    }\FunctionTok{steps}\KeywordTok{:}
\AttributeTok{    }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/checkout@v3}
\AttributeTok{    }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ make}
\AttributeTok{    }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ make test || echo "No tests yet"}
\end{Highlighting}
\end{Shaded}

Now every push builds automatically.

\subsubsection{Step 10. Why this
matters}\label{step-10.-why-this-matters-3}

Professional packaging is part of being a systems engineer:

\begin{itemize}
\tightlist
\item
  Your projects build reproducibly.
\item
  Others can install, link, and use them easily.
\item
  Documentation and version tags create confidence.
\item
  Licensing clarifies ownership.
\end{itemize}

You have now moved from \emph{C programmer} to \emph{C maintainer}, the
person others trust to deliver solid, reusable, and well-documented
software.

Next is \textbf{100. Practice: Build Your Own Mini Project}, where you
will bring everything together, writing, building, debugging, and
packaging a complete small system in pure C.

\subsection{100. Practice: Build Your Own Mini
Project}\label{practice-build-your-own-mini-project}

You've walked through all the essential layers of C, syntax, memory,
data structures, file I/O, compilation, debugging, and even packaging.
Now you'll bring it all together by building a complete mini project
from scratch.

This final section is a synthesis: plan, design, implement, test, and
document a small, useful system in pure C.

\subsubsection{Step 1. Choose your project
scope}\label{step-1.-choose-your-project-scope}

Pick something small enough to finish but rich enough to touch multiple
topics. Here are three good options:

\textbf{Option A: A Tiny Note Manager}

\begin{itemize}
\tightlist
\item
  Command line tool to add, list, and delete notes
\item
  Stores data in a simple binary file
\item
  Indexes notes by ID
\end{itemize}

\textbf{Option B: A Simple HTTP Server}

\begin{itemize}
\tightlist
\item
  Serves static files from a directory
\item
  Uses sockets (\texttt{socket}, \texttt{bind}, \texttt{listen},
  \texttt{accept})
\item
  Logs each request to a file
\end{itemize}

\textbf{Option C: A Tiny Key-Value Store}

\begin{itemize}
\tightlist
\item
  Command line tool with commands \texttt{put}, \texttt{get},
  \texttt{list}, \texttt{delete}
\item
  Uses \texttt{fopen}, \texttt{fread}, and \texttt{fwrite}
\item
  Optional: add LevelDB or SQLite backend
\end{itemize}

\subsubsection{Step 2. Plan your
structure}\label{step-2.-plan-your-structure}

Example: for the \textbf{Tiny Note Manager}

\begin{verbatim}
tinynotes/
├── include/
│   └── tinynotes.h
├── src/
│   ├── main.c
│   ├── notes.c
│   └── util.c
├── data/
│   └── notes.bin
├── Makefile
├── README.md
└── LICENSE
\end{verbatim}

\subsubsection{Step 3. Tiny Code: minimal working
version}\label{step-3.-tiny-code-minimal-working-version}

Below is a working \textbf{Tiny Note Manager} in under 150 lines.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// file: tinynotes.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_NOTE\_LEN }\DecValTok{256}
\PreprocessorTok{\#define DATA\_FILE }\StringTok{"notes.bin"}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ text}\OperatorTok{[}\NormalTok{MAX\_NOTE\_LEN}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Note}\OperatorTok{;}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ add\_note}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{DATA\_FILE}\OperatorTok{,} \StringTok{"ab"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ perror}\OperatorTok{(}\StringTok{"open"}\OperatorTok{);}\NormalTok{ exit}\OperatorTok{(}\DecValTok{1}\OperatorTok{);} \OperatorTok{\}}

\NormalTok{    Note n }\OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    fseek}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ SEEK\_END}\OperatorTok{);}
    \DataTypeTok{long}\NormalTok{ size }\OperatorTok{=}\NormalTok{ ftell}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\NormalTok{    n}\OperatorTok{.}\NormalTok{id }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)(}\NormalTok{size }\OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Note}\OperatorTok{))} \OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\NormalTok{    strncpy}\OperatorTok{(}\NormalTok{n}\OperatorTok{.}\NormalTok{text}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{,}\NormalTok{ MAX\_NOTE\_LEN }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}

\NormalTok{    fwrite}\OperatorTok{(\&}\NormalTok{n}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{n}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ f}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Added note }\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ n}\OperatorTok{.}\NormalTok{text}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ list\_notes}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{DATA\_FILE}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{f}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ puts}\OperatorTok{(}\StringTok{"No notes yet."}\OperatorTok{);} \ControlFlowTok{return}\OperatorTok{;} \OperatorTok{\}}

\NormalTok{    Note n}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fread}\OperatorTok{(\&}\NormalTok{n}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{n}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ f}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ n}\OperatorTok{.}\NormalTok{text}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ delete\_all}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{remove}\OperatorTok{(}\NormalTok{DATA\_FILE}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{        puts}\OperatorTok{(}\StringTok{"All notes deleted."}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        puts}\OperatorTok{(}\StringTok{"No notes to delete."}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{**}\NormalTok{argv}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        puts}\OperatorTok{(}\StringTok{"Usage: tinynotes \textless{}add|list|clear\textgreater{} [message]"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"add"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ argc }\OperatorTok{\textgreater{}=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        add\_note}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"list"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        list\_notes}\OperatorTok{();}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"clear"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        delete\_all}\OperatorTok{();}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        puts}\OperatorTok{(}\StringTok{"Invalid command."}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}std}\OperatorTok{=}\NormalTok{c23 }\AttributeTok{{-}O2}\NormalTok{ tinynotes.c }\AttributeTok{{-}o}\NormalTok{ tinynotes}
\end{Highlighting}
\end{Shaded}

Try it:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./tinynotes}\NormalTok{ add }\StringTok{"Learn C deeply"}
\ExtensionTok{./tinynotes}\NormalTok{ add }\StringTok{"Write clear code"}
\ExtensionTok{./tinynotes}\NormalTok{ list}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Added note 1: Learn C deeply
Added note 2: Write clear code
1: Learn C deeply
2: Write clear code
\end{verbatim}

\subsubsection{Step 4. Extend it}\label{step-4.-extend-it}

Add these small improvements:

\begin{itemize}
\tightlist
\item
  \texttt{tinynotes\ delete\ \textless{}id\textgreater{}} to remove a
  note by index
\item
  Store creation time (\texttt{time\_t})
\item
  Save to a user-specific directory
  (\texttt{\textasciitilde{}/.tinynotes/})
\item
  Encrypt notes with XOR or AES before writing (optional)
\item
  Add JSON export using \texttt{fprintf}
\end{itemize}

\subsubsection{Step 5. Package it}\label{step-5.-package-it}

Add a Makefile:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{CC}\CharTok{=}\StringTok{gcc}
\DataTypeTok{CFLAGS}\CharTok{=}\StringTok{{-}std=c23 {-}O2 {-}Wall}
\DataTypeTok{TARGET}\CharTok{=}\StringTok{tinynotes}

\DecValTok{all:}
\ErrorTok{    }\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CFLAGS}\CharTok{)}\NormalTok{ tinynotes.c {-}o }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}

\DecValTok{install:}
\ErrorTok{    }\NormalTok{cp }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}\NormalTok{ /usr/local/bin/}

\DecValTok{clean:}
\ErrorTok{    }\NormalTok{rm {-}f }\CharTok{$(}\DataTypeTok{TARGET}\CharTok{)}
\end{Highlighting}
\end{Shaded}

Install:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ make install}
\end{Highlighting}
\end{Shaded}

Now you can type \texttt{tinynotes\ list} from anywhere.

\subsubsection{Step 6. Document it}\label{step-6.-document-it}

\textbf{README.md}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\# tinynotes}

\NormalTok{A simple command{-}line note manager written in C.}

\FunctionTok{\#\# Build}
\NormalTok{make}
\NormalTok{sudo make install}

\FunctionTok{\#\# Usage}
\NormalTok{tinynotes add "hello world"}
\NormalTok{tinynotes list}
\NormalTok{tinynotes clear}
\end{Highlighting}
\end{Shaded}

\subsubsection{Step 7. Version and
license}\label{step-7.-version-and-license}

Tag your release:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ tag }\AttributeTok{{-}a}\NormalTok{ v0.1.0 }\AttributeTok{{-}m} \StringTok{"first public release"}
\end{Highlighting}
\end{Shaded}

Add \texttt{LICENSE} (MIT, Apache, or GPL). Publish it on GitHub if you
want others to use or contribute.

\subsubsection{Step 8. Why this matters}\label{step-8.-why-this-matters}

This is how small programs grow into tools:

\begin{itemize}
\tightlist
\item
  Real file I/O
\item
  Error handling
\item
  Build automation
\item
  Documentation and versioning
\end{itemize}

C gives you the power to build precise, fast, and minimal software. You
now know every layer---from compiler to system call.

\subsubsection{Step 9. Try it yourself}\label{step-9.-try-it-yourself}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace file storage with SQLite or LevelDB
\item
  Add \texttt{search} and \texttt{sort}
\item
  Build a networked version that syncs notes over sockets
\item
  Add a unit test suite with assertions
\item
  Package your project as a \texttt{.deb} or \texttt{.tar.gz}
\end{enumerate}

\subsubsection{Step 10. Congratulations}\label{step-10.-congratulations}

You've reached the end of \textbf{The Little Book of C}.

You started from \texttt{printf("Hello,\ World");} and finished with
building, packaging, and documenting full working systems.

You now have the foundation to explore:

\begin{itemize}
\tightlist
\item
  \textbf{Operating Systems}
\item
  \textbf{Compilers and Interpreters}
\item
  \textbf{Embedded Systems}
\item
  \textbf{Databases and Networking}
\end{itemize}

C is not just a language. It is the foundation of computing. You now
speak it fluently, like a systems engineer.

You've reached the final page, the quiet epilogue of \emph{The Little
Book of C.}

Let's close this journey the same way C programs begin: with clarity,
purpose, and curiosity.

\section{Epilogue. The Spirit of C}\label{epilogue.-the-spirit-of-c}

C is not just about syntax, pointers, or the compiler. It is a mindset,
one that teaches you to think about \textbf{how machines actually work}.

When you write in C, you're speaking the native tongue of computers. You
tell the processor what to do, byte by byte, without any illusion
between you and the hardware.

You've learned that:

\begin{itemize}
\tightlist
\item
  Every variable has a precise place in memory
\item
  Every function call has a cost on the stack
\item
  Every pointer is a promise to be careful
\item
  Every line you write translates into instructions and data
\end{itemize}

C rewards those who think deeply and punishes those who guess. But when
you master it, you gain a kind of freedom that few languages can match.

\section{The Path Beyond}\label{the-path-beyond}

Now that you can code confidently in C, here are natural next steps:

\textbf{1. Systems Programming} Explore Linux internals, system calls,
and kernel modules. Books like \emph{The Linux Programming Interface} or
your future ``Little Book of System Programming with C'' are perfect
companions.

\textbf{2. Compilers and Language Tools} Write your own parser or
bytecode interpreter. C gives you the precision to build new languages
from scratch.

\textbf{3. Operating Systems and Embedded} Try building a tiny OS (like
\emph{xv6}), or program microcontrollers with bare-metal C. You'll see
how C shapes the firmware world.

\textbf{4. Libraries and Open Source} Contribute to open-source projects
written in C, from SQLite to Redis to Git. You'll read world-class C and
learn design by example.

\textbf{5. Build Your Own X in C} You can build your own database, HTTP
server, shell, or compiler. Each one is a new chance to reapply what
you've learned here.

\section{A Note from the Author}\label{a-note-from-the-author}

When Dennis Ritchie designed C in the 1970s, he wasn't just inventing a
language. He was inventing a way to think, about \textbf{data, control,
and abstraction} at the same time.

Fifty years later, the same clarity still matters. C is timeless because
it stays close to truth.

Every byte you allocate, every loop you write, every segmentation fault
you fix, it all teaches you how computers \emph{really} work.

So keep experimenting. Break things. Fix them. Rebuild.

That's how every systems engineer begins.

\section{Final Exercise}\label{final-exercise}

Before you leave this book, write one last C program. It doesn't need to
do anything fancy, just something that reminds you why you love building
things from first principles.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"I learned to think in C.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile it. Run it. Smile. You now speak the language of the machine.

\textbf{The Little Book of C} \emph{End of Volume}




\end{document}
