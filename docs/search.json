[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Little Book of C",
    "section": "",
    "text": "Part I. First Steps",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-1.-getting-started",
    "href": "index.html#chapter-1.-getting-started",
    "title": "The Little Book of C",
    "section": "Chapter 1. Getting started",
    "text": "Chapter 1. Getting started\n\n1.1 What is C?\nC is a programming language. But before we go deeper, let’s step back: what is a programming language?\nA programming language is a way for humans to give precise, step-by-step instructions to a computer. Just as we use English, Vietnamese, or Japanese to talk to each other, we use languages like C, Python, or Java to “talk” to a computer.\nC was created in the early 1970s at Bell Labs by Dennis Ritchie. It was designed to write the UNIX operating system - and it became so successful that many modern languages (C++, Java, Rust, Go, even parts of Python) are deeply influenced by it.\nEven today, more than fifty years later, C remains everywhere:\n\nThe operating system inside your phone and laptop has thousands of lines of C code.\nDevice drivers - the programs that let your computer talk to printers, cameras, or Wi-Fi cards - are usually written in C.\nEmbedded systems, like the computer inside your microwave or car, are often powered by C.\n\nC is sometimes called a “low-level high-level language”:\n\nIt’s -low-level- because it lets you control memory and hardware directly, almost like assembly.\nIt’s -high-level- because it still uses readable words and structures that humans can understand, unlike raw 1s and 0s.\n\nThink of C as the middle ground: close enough to the machine to be powerful, but high-level enough to be practical for humans.\n\nA First Glimpse\nHere’s a very small piece of C code. Don’t worry if it looks mysterious - we’ll explain it step by step in the next sections:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nThis tiny program does one thing: it prints the words Hello, world! on the screen.\nEven though this is just a few lines, it already shows you the essence of programming: you write instructions, the computer follows them, and you get a result.\n\n\nWhy Learn C First?\n\nC has a small set of features. You can learn the whole language core in this little book.\nOnce you learn C, you’ll find Java, C++, Go, and others easier to understand.\nC gives you direct access to memory, which is rare in modern languages. This helps you understand how computers really work.\nC has been around for over 50 years, and it isn’t going away anytime soon. Learning it is like learning the grammar of computing.\n\n\n\nWhy It Matters\nLearning C is like learning to drive a manual car before moving to an automatic: it teaches you what’s happening under the hood. Even if you later use higher-level languages, your knowledge of C will give you confidence and deeper insight into performance, efficiency, and problem-solving.\n\n\nExercises\n\nLook up (online or in books) one example of a system you use every day that was written in C.\nExplain in your own words the difference between a programming language and a human language.\nIf C is over 50 years old, why do you think it’s still widely used today?\n\n\n\n\n1.2 Hello, World!\nEvery journey in C programming begins with a simple tradition: writing a program that prints “Hello, world!” to the screen.\nThis may look small, but it teaches you the essentials of how a C program is structured.\n\nThe Full Program\nHere is the complete code:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nWhen you run this program, it shows:\nHello, world!\n\n\nBreaking It Down\nLet’s go through this step by step:\n\n#include &lt;stdio.h&gt;\n\nThis tells the compiler: “Before you build my program, please include the Standard Input/Output library.”\nThe file stdio.h contains the definition of printf, which we’ll use to display text.\nWithout this line, the compiler wouldn’t know what printf means.\n\nint main(void)\n\nEvery C program starts execution at a special function called main.\nint means that main will return an integer number to the operating system when it finishes.\n(void) means “main takes no arguments.” Later we’ll see other forms that can take inputs.\n\n{ ... }\n\nThe curly braces mark the start { and end } of a block of code.\nEverything inside belongs to the main function.\n\nprintf(\"Hello, world!\\n\");\n\nprintf is a function that prints text.\nThe text we want to print is inside quotation marks \"...\".\nThe \\n is a newline character: it moves the cursor to the next line after printing. Without it, the next output would continue on the same line.\nThe semicolon ; ends the instruction - in C, every statement must end with ;.\n\nreturn 0;\n\nThis line tells the operating system: -“The program finished successfully.”-\nA return value of 0 usually means success. Other numbers can indicate errors, which you’ll learn about later.\n\n\n\n\nHow It Fits Together\n\nThe program starts at main.\nIt runs each line inside the braces.\nIt prints Hello, world! with a newline.\nIt exits and returns 0 to the system.\n\nThat’s the life cycle of your very first program.\n\n\nWhy It Matters\nThis tiny program shows you many key ideas that repeat throughout C:\n\nLibraries (#include) give you tools you didn’t write yourself.\nFunctions (main, printf) are the building blocks of programs.\nStatements (ending with ;) are instructions the computer follows.\nReturn values (return 0) communicate success or failure.\n\nOnce you understand “Hello, world!”, you can build more complex programs with confidence.\n\n\nExercises\n\nChange the message in the program to print your name instead of “Hello, world!”.\nRemove the \\n and see what happens when you run the program.\nTry printing two lines by calling printf twice:\nprintf(\"First line\\n\");\nprintf(\"Second line\\n\");\n\n\n\n\n1.3 Compiling and Running a Program\nWriting a program is only the first step. To make the computer understand it, we need to translate our C code into something the machine can run. This translation process is called compilation.\n\nFrom Source Code to Program\nWhen you write C code in a text file (for example, hello.c), you are writing source code - human-readable instructions. But your computer only understands machine code - long sequences of 0s and 1s.\nThe compiler’s job is to take your source code and produce a program that your computer can execute.\nThe process usually looks like this:\n\nWrite code → You save your C code in a file like hello.c.\nCompile → The compiler checks your code and translates it into an executable program.\nRun → You execute the compiled program, and the computer follows your instructions.\n\n\n\nUsing a Compiler\nThe most common compiler today is GCC (GNU Compiler Collection). Another popular one is Clang. Both support the modern C23 standard.\nLet’s say your program is saved in a file called hello.c.\nTo compile it with GCC:\ngcc hello.c -o hello\n\ngcc is the compiler command.\nhello.c is your source code.\n-o hello tells the compiler to create an output program named hello.\n\nAfter this command, you will see a new file named hello.\n\n\nRunning the Program\nOn Linux or macOS, you can run it like this:\n./hello\nOn Windows, you might just type:\nhello.exe\nAnd you should see:\nHello, world!\n\n\nCommon Mistakes\nWhen compiling, beginners often see errors. Here are some typical ones:\n\nMissing semicolon:\nerror: expected ‘;’ before ‘return’\n→ In C, every statement must end with ;.\nMisspelled function name:\nerror: implicit declaration of function ‘print’\n→ You probably wrote print instead of printf.\nMissing quotes:\nerror: missing terminating \" character\n→ Strings must always be inside \" \".\n\n\n\nWhy It Matters\nUnderstanding compilation is crucial because:\n\nIt shows you that C is different from interpreted languages (like Python).\nIt teaches you to think in two steps: write → compile → run.\nIt prepares you for reading error messages - an essential skill for every programmer.\n\n\n\nExercises\n\nSave the “Hello, world!” program in a file called hello.c, compile it with GCC or Clang, and run it.\nIntroduce a mistake (like removing a semicolon) and see what error message the compiler gives you.\nTry compiling with a different output name, e.g.:\ngcc hello.c -o myprogram\nThen run ./myprogram.\n\n\n\n\n1.4 Editing, Saving, and Errors\nNow that you know how to compile and run a C program, let’s talk about something every programmer does all the time: editing and fixing errors. Writing code isn’t just about typing it once perfectly. In fact, most of programming is a cycle of edit → compile → fix errors → run → repeat.\n\nEditing and Saving Code\nC programs are just text files. You can edit them with any text editor. Some common choices:\n\nLinux/macOS: VS Code, Sublime Text, nano, vim\nWindows: VS Code, Notepad++, or even the built-in Notepad (though more advanced editors are recommended)\n\nWhen you save your file, make sure it has the .c extension. For example:\nhello.c\nThe compiler looks at that file extension to know it’s C source code.\n\n\nThe Reality of Errors\nIt’s normal for your first compilation to show errors. Don’t be discouraged - errors are part of programming. Even professionals see them daily.\nFor example, if you forget a semicolon:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\")\n    return 0;\n}\nWhen compiled, GCC might say:\nhello.c: In function ‘main’:\nhello.c:4:5: error: expected ‘;’ before ‘return’\nThis looks intimidating, but let’s break it down:\n\nhello.c:4:5 → File hello.c, line 4, character 5\nerror: expected ‘;’ before ‘return’ → The compiler wanted a ; but found return instead\n\nOnce you add the missing semicolon, the program compiles.\n\n\nWarnings vs Errors\nCompilers give two kinds of feedback:\n\nErrors → Your program cannot run until you fix them.\nWarnings → Your program will run, but the compiler is alerting you to something suspicious.\n\nExample warning:\nint main(void) {\n    int x;\n    printf(\"%d\\n\", x);\n    return 0;\n}\nThe compiler may warn:\nwarning: ‘x’ is used uninitialized in this function\nThis means you’re trying to print x before giving it a value - dangerous behavior. The program may run, but the result will be unpredictable.\n\n\nDebugging Mindset\nWhen you see an error:\n\nRead it carefully - The compiler usually tells you the line number.\nDon’t panic - Errors are normal.\nFix one at a time - Often, one small mistake (like a missing semicolon) can cause multiple errors.\nRecompile after each fix - Don’t try to fix everything at once without testing.\n\n\n\nWhy It Matters\nLearning how to read and respond to error messages is a key skill. Beginners who treat errors as enemies get frustrated. Experts see errors as helpful feedback. The compiler is your friend: it points out problems before your program misbehaves.\n\n\nExercises\n\nWrite a simple program with a deliberate mistake (for example, misspell printf as prntf). Compile it, and read the error message.\nRemove a closing brace } and see what kind of error appears.\nCreate a program with both a warning and an error. Can you fix both?\n\n\n\n\n1.5 Why C Still Matters\nAt this point, you might be wondering: C is over fifty years old. Why should I learn it today? After all, there are newer languages like Python, JavaScript, Rust, and Go. The answer is simple: C is still at the heart of computing.\n\nC Is Everywhere\n\nThe Linux kernel, Windows core, and macOS internals are mostly written in C.\nThe tiny chips inside your car, microwave, TV, or washing machine often run code written in C.\nMySQL, SQLite, Git, and even parts of Python itself are implemented in C.\nMany performance-critical parts of game engines rely on C for speed.\n\nLearning C means understanding the language that underpins much of modern software.\n\n\nFoundation for Other Languages\nMany modern languages borrow C’s syntax and concepts:\n\nC++ extends C with classes and object-oriented features.\nJava, C#, Go, Rust all use C-like curly braces, operators, and control flow.\nPython itself is implemented in C, and its extension modules often use C for performance.\n\nWhen you learn C, you build a foundation that transfers to other languages.\n\n\nPerformance and Control\nC gives you direct access to memory. Unlike Python or Java, where memory is managed for you, in C you decide:\n\nWhere data lives\nHow much memory is used\nWhen memory is freed\n\nThis makes C extremely fast - and also teaches you how computers actually work under the hood.\n\n\nLongevity and Stability\nLanguages come and go, but C endures. The C23 standard is the latest in a long line of updates that keep C modern while preserving compatibility. Code written decades ago in C can often still compile today.\nThat’s rare in the world of technology.\n\n\nA Mindset Shift\nLearning C isn’t just about syntax. It changes how you think:\n\nYou learn to be precise.\nYou become comfortable with errors and debugging.\nYou start thinking about efficiency, not just correctness.\n\nC teaches you programming at its most essential.\n\n\nWhy It Matters\nEven if you later move on to Python, JavaScript, or Rust, learning C gives you a mental model that makes you a stronger programmer. It’s like learning arithmetic before using a calculator: once you understand the basics, you can appreciate and use advanced tools better.\n\n\nExercises\n\nLook up three widely used software projects that are written in C.\nAsk yourself: if you had to write a program for a device with very little memory (like a smartwatch or a sensor), why might C be a good choice?\nCompare the age of C (1972) with another technology you use every day. Why do you think C has lasted so long?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-2.-variables-and-types",
    "href": "index.html#chapter-2.-variables-and-types",
    "title": "The Little Book of C",
    "section": "Chapter 2. Variables and Types",
    "text": "Chapter 2. Variables and Types\n\n2.1 Numbers and Text\nSo far, our programs only printed fixed text like \"Hello, world!\". That’s nice, but real programs need to work with data - numbers, words, and symbols that can change each time the program runs. In C, we represent data using variables.\n\nVariables: Boxes for Data\nThink of a variable as a box with a label on it:\n\nThe box holds some value (like a number or letter).\nThe label (the variable’s name) tells us how to refer to it later.\n\nIn C, you must tell the computer what kind of data the box holds. This is called the type of the variable.\n\n\nNumbers\nC supports several kinds of numbers:\n\nIntegers: whole numbers like -5, 0, 42\nFloating-point numbers: numbers with decimal points like 3.14, -0.5, 2.71828\n\nHere’s a simple program that uses both:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int age = 20;            // an integer\n    float height = 1.75;     // a floating-point number\n\n    printf(\"Age: %d\\n\", age);\n    printf(\"Height: %.2f meters\\n\", height);\n\n    return 0;\n}\nOutput:\nAge: 20\nHeight: 1.75 meters\nNotice:\n\n%d tells printf to print an integer.\n%f tells printf to print a floating-point number.\n%.2f means “print with 2 digits after the decimal point.”\n\n\n\nText (Characters)\nC represents text as characters, written in single quotes: 'A', 'z', '?'. Characters are stored as small integer codes (ASCII codes).\nExample:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char grade = 'A';   // a single character\n\n    printf(\"Your grade is %c\\n\", grade);\n\n    return 0;\n}\nOutput:\nYour grade is A\nThe %c format specifier prints a single character.\n\n\nText (Strings)\nA string is a sequence of characters, like \"Hello\" or \"C programming\". In C, strings are written inside double quotes \"...\" and stored as arrays of characters (we’ll learn more in Chapter 6).\nFor now, you can print them directly:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char name[] = \"Alice\";\n\n    printf(\"Hello, %s!\\n\", name);\n\n    return 0;\n}\nOutput:\nHello, Alice!\nThe %s format specifier prints a string.\n\n\nWhy It Matters\n\nVariables let your program handle different inputs instead of fixed text.\nTypes ensure the computer knows how to store and work with the data.\nBy learning numbers and text, you’re starting to write programs that can interact with the world, not just display the same message every time.\n\n\n\nExercises\n\nWrite a program that declares an integer year and prints:\nThe year is 2025\nusing printf.\nModify the program to include your favorite decimal number (like your height or a constant such as π). Print it with 3 decimal places.\nCreate a program that stores your first initial as a char and prints:\nMy initial is X\nreplacing X with your character.\n\n\n\n\n2.2 Declaring Variables\nIn the previous section, we used variables like int age = 20; and float height = 1.75;. But what does it mean to declare a variable in C?\n\nThe Anatomy of a Declaration\nA variable declaration in C has two parts:\ntype name;\n\ntype → what kind of data the variable will hold (e.g., int, float, char)\nname → the label you give the variable, so you can use it later\n\nExample:\nint score;\nThis means: “Make a box named score that can hold an integer.” Right now, the contents of the box are undefined (whatever random value happened to be in memory).\n\n\nInitialization\nYou can also give a variable an initial value when declaring it:\nint score = 100;\nThis both creates the variable and sets its value. This is called initialization.\nIf you don’t initialize, C does not set it to zero automatically. Using an uninitialized variable is a common beginner mistake.\n\n\nMultiple Declarations\nYou can declare several variables of the same type on one line:\nint x = 1, y = 2, z = 3;\nThis creates three integers: x, y, and z. For readability, beginners are encouraged to declare each variable on its own line.\n\n\nNaming Rules\nVariable names in C:\n\nMust start with a letter or underscore (_)\nCan contain letters, digits, and underscores\nAre case-sensitive (Age and age are different)\nCannot be a keyword (e.g., int, return, for)\n\nGood names make your code clearer. Compare:\nint x;   // unclear\nint age; // clear\n\n\nA Full Example\nHere’s a small program that shows variable declaration, initialization, and usage:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int year = 2025;          // integer\n    float pi = 3.14159;       // floating-point number\n    char initial = 'N';       // character\n    int a = 5, b = 10;        // multiple integers\n\n    printf(\"Year: %d\\n\", year);\n    printf(\"Value of pi: %.2f\\n\", pi);\n    printf(\"My initial: %c\\n\", initial);\n    printf(\"a = %d, b = %d\\n\", a, b);\n\n    return 0;\n}\nOutput:\nYear: 2025\nValue of pi: 3.14\nMy initial: N\na = 5, b = 10\n\n\nWhy It Matters\n\nDeclaring variables tells the computer what kind of information to expect.\nInitializing ensures your variables start with predictable values.\nGood naming makes your code readable and easier to maintain.\n\nWithout proper declarations, your program won’t compile, or worse - it will run with unpredictable results.\n\n\nExercises\n\nWrite a program that declares an integer day, a float temperature, and a char grade. Initialize them and print their values.\nCreate two integer variables, x and y, and print their sum.\nTry declaring a variable without initializing it. Print it - what happens? Why is this dangerous?\n\n\n\n\n2.3 Basic Types in C23\nEvery variable in C must have a type. The type tells the computer:\n\nHow much memory to reserve\nHow to interpret the bits stored inside\nWhat operations are allowed\n\nC23 keeps the same familiar types from older standards but also adds refinements for safety and clarity.\n\nIntegers\n\nint → most common integer type (size depends on the system, often 32 bits)\nshort, long, long long → smaller or larger ranges\nunsigned versions → only non-negative values\n\nExamples:\nint age = 20;\nunsigned int population = 8000000;\nlong long stars = 10000000000LL;\n\n\nFloating-Point Numbers\nFor decimals and scientific values:\n\nfloat → typically 32-bit\ndouble → 64-bit, more precise\nlong double → even more precision (implementation-dependent)\n\nExamples:\nfloat pi = 3.14f;\ndouble e = 2.718281828;\n\n\nCharacters\n\nchar → stores a single character, like 'A' or 'z'\nStored as an integer code (usually ASCII or UTF-8 in modern systems)\n\nExample:\nchar letter = 'C';\n\n\nBooleans (C23 and C99+)\nC did not originally have a true boolean type. Now you can use:\n#include &lt;stdbool.h&gt;\n\nbool is_happy = true;\nbool is_sad = false;\n\n\nSpecial Types in C23\nC23 introduces safer and clearer usage:\n\nnullptr: a special constant to represent “no pointer” (instead of older NULL).\nchar8_t: for explicit UTF-8 characters, making Unicode handling clearer.\n\nExample:\n#include &lt;stddef.h&gt;   // for nullptr\n#include &lt;uchar.h&gt;    // for char8_t\n\nint -p = nullptr;     // safe null pointer\nchar8_t smiley = u8'☺';  // UTF-8 character literal\n\n\nA Full Example\nThis program demonstrates several basic types side by side:\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;uchar.h&gt;\n\nint main(void) {\n    int year = 2025;\n    unsigned int population = 1000000;\n    float pi = 3.14159f;\n    double e = 2.718281828;\n    char grade = 'A';\n    bool is_student = true;\n    int -ptr = nullptr;\n    char8_t smiley = u8'☺';\n\n    printf(\"Year: %d\\n\", year);\n    printf(\"Population: %u\\n\", population);\n    printf(\"Pi: %.2f\\n\", pi);\n    printf(\"Euler's number: %.5f\\n\", e);\n    printf(\"Grade: %c\\n\", grade);\n    printf(\"Is student: %s\\n\", is_student ? \"true\" : \"false\");\n    printf(\"Pointer: %p\\n\", (void-)ptr);\n    printf(\"Smiley (UTF-8 code): U+%04X\\n\", smiley);\n\n    return 0;\n}\nSample Output:\nYear: 2025\nPopulation: 1000000\nPi: 3.14\nEuler's number: 2.71828\nGrade: A\nIs student: true\nPointer: (nil)\nSmiley (UTF-8 code): U+263A\n\n\nWhy It Matters\nUnderstanding types is crucial because:\n\nThey define the shape of your data.\nChoosing the right type avoids wasted memory or incorrect results.\nModern C23 types (bool, nullptr, char8_t) make code safer and clearer.\n\n\n\nExercises\n\nDeclare one variable of each type (int, float, double, char, bool). Print them using printf.\nTry printing an unsigned int with %d. What happens? Why is it wrong?\nWrite a program that stores the value of π in both float and double, then prints both with 10 decimal places. Compare the results.\n\n\n\n\n2.4 Constants (const and constexpr)\nSo far, we’ve seen variables like:\nint age = 20;\nfloat pi = 3.14159f;\nBut sometimes, we want values that should never change once set. These are called constants.\nConstants make your programs safer, clearer, and easier to maintain.\n\nconst\nThe const keyword tells the compiler: -“This variable’s value cannot be changed.”-\nExample:\nconst int days_in_week = 7;\nIf you try to assign a new value later:\ndays_in_week = 8;   // ❌ Error: assignment of read-only variable\n\n\nconstexpr (C23 and C11+)\nThe constexpr keyword ensures that a value is calculated at compile time, not at runtime. It’s like telling the compiler: -“Work this out in advance.”-\nExample:\nconstexpr int minutes_in_day = 24 - 60;\nThis guarantees that minutes_in_day is a constant known before the program even runs.\n\n\nDifference Between const and constexpr\n\nconst → value cannot be changed after the program starts\nconstexpr → value must be known before the program starts (at compile time)\n\nEvery constexpr is also const, but not every const is constexpr.\n\n\nA Full Example\nHere’s a program that shows both const and constexpr in action:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    const float pi = 3.14159f;              // constant value\n    constexpr int seconds_in_hour = 60 - 60; // compile-time constant\n    int radius = 5;\n\n    float circumference = 2 - pi - radius;  // uses const\n    int hours = 2;\n    int seconds = hours - seconds_in_hour;  // uses constexpr\n\n    printf(\"Radius: %d\\n\", radius);\n    printf(\"Circumference: %.2f\\n\", circumference);\n    printf(\"%d hours = %d seconds\\n\", hours, seconds);\n\n    return 0;\n}\nOutput:\nRadius: 5\nCircumference: 31.42\n2 hours = 7200 seconds\n\n\nWhy It Matters\n\nSafety → prevents accidental changes to values that should stay fixed.\nClarity → communicates intent (“this never changes”).\nPerformance → constexpr lets the compiler compute values ahead of time.\n\nGood C programs rely heavily on constants for configuration and clarity.\n\n\nExercises\n\nDeclare a const int for the number of days in a year and print it.\nWrite a program using constexpr to calculate the number of minutes in a week.\nTry declaring const int x = 10; and then reassigning x = 20;. What happens?\n\n\n\n\n2.5 Input and Output with scanf and printf\nSo far, our programs only showed fixed values using printf. But real programs need to interact with the user:\n\nInput → let the user type values\nOutput → display results\n\nIn C, the two main functions for this are:\n\nprintf → prints output to the screen\nscanf → reads input from the user\n\nBoth are defined in the stdio.h library.\n\nUsing printf\nYou’ve already seen examples like:\nprintf(\"Hello, world!\\n\");\nThe key idea is format specifiers:\n\n%d → integer\n%f → floating-point number\n%c → single character\n%s → string\n\nExample:\nint age = 20;\nprintf(\"I am %d years old.\\n\", age);\n\n\nUsing scanf\nThe scanf function reads user input.\nSyntax:\nscanf(\"format\", &variable);\n\n\"format\" tells scanf what kind of data to expect\n&variable gives the address of the variable (so scanf can write into it)\n\nExample:\nint age;\nscanf(\"%d\", &age);\nThis reads an integer from the keyboard and stores it in age.\n\n\nA Full Example\nHere’s a complete program that combines input and output:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int age;\n    float height;\n    char initial;\n    char name[20];   // enough space for up to 19 characters + '\\0'\n\n    printf(\"Enter your age: \");\n    scanf(\"%d\", &age);\n\n    printf(\"Enter your height in meters: \");\n    scanf(\"%f\", &height);\n\n    printf(\"Enter your first initial: \");\n    scanf(\" %c\", &initial);   // notice the space before %c to skip whitespace\n\n    printf(\"Enter your name: \");\n    scanf(\"%19s\", name);      // read string (up to 19 chars)\n\n    printf(\"\\n--- Profile ---\\n\");\n    printf(\"Name: %s\\n\", name);\n    printf(\"Initial: %c\\n\", initial);\n    printf(\"Age: %d years\\n\", age);\n    printf(\"Height: %.2f m\\n\", height);\n\n    return 0;\n}\nSample Run:\nEnter your age: 21\nEnter your height in meters: 1.72\nEnter your first initial: A\nEnter your name: Alice\n\n--- Profile ---\nName: Alice\nInitial: A\nAge: 21 years\nHeight: 1.72 m\n\n\nWhy It Matters\n\nprintf makes your program communicate results.\nscanf makes your program interactive, letting users supply data.\nTogether, they turn static programs into useful tools.\n\nAlmost every C program you’ll write uses these functions in some way.\n\n\nExercises\n\nWrite a program that asks the user for two integers and prints their sum.\nAsk the user for their name and favorite number, then print:\nHello NAME, your favorite number is N.\nModify the full example to include weight in kilograms and print the BMI (Body Mass Index = weight / (height - height)).\n\n\n\n\nProblems\n\n1. My First Profile\nWrite a program that asks the user for their name, age, and favorite character, then prints them in a short introduction. Example run:\nEnter your name: Alice\nEnter your age: 21\nEnter your favorite character: Z\n\nHello Alice! You are 21 years old and your favorite character is Z.\n\n\n2. Temperature Converter\nAsk the user for a temperature in Celsius and print it in Fahrenheit using the formula:\nF = C × 9/5 + 32\n\n\n3. Rectangle Calculator\nRead two integers from the user: length and width. Print both the area and the perimeter of the rectangle.\n\n\n4. Circle Calculator (with const)\nUse a const float pi = 3.14159f; to calculate the area and circumference of a circle given its radius. Input the radius from the user.\n\n\n5. Minutes in a Week (with constexpr)\nDefine a constexpr int to represent the number of minutes in a week. Print the result.\n\n\n6. Swap Two Numbers\nAsk the user for two integers and print them before and after swapping their values using a temporary variable.\n\n\n7. Character Codes\nAsk the user to type a character. Print both the character and its ASCII code (integer value). Example:\nEnter a character: A\nYou entered: A\nASCII code: 65\n\n\n8. String Greeting\nAsk the user for their first name and print:\nHello, NAME! Nice to meet you.\n\n\n9. Simple BMI Calculator\nAsk the user for height (meters) and weight (kilograms). Calculate and print their Body Mass Index (BMI = weight / (height - height)) with 2 decimal places.\n\n\n10. Sum of Three Numbers\nAsk the user for three integers and print their sum and average.\n\n\n11. Days to Hours and Minutes\nAsk the user for a number of days. Calculate and print how many hours and minutes that equals.\n\n\n12. Initials Program\nAsk the user for their first, middle, and last initials (as char). Print them together as one string:\nEnter your initials: A B C\nYour initials are: ABC\n\n\n13. Circle Comparison\nAsk the user for two radii, r1 and r2. Use constants for π. Print which circle is larger by area.\n\n\n14. Student Pass/Fail\nAsk the user for an integer grade (0–100). Print Pass if it is 50 or above, otherwise Fail.\n\n\n15. Profile with Multiple Types\nDeclare and initialize:\n\nAn int for your current year (e.g. 2025)\nA float for your height\nA char for your grade\nA char[] string for your name\n\nPrint them all in a formatted way, like:\nName: Alice\nYear: 2025\nHeight: 1.72 m\nGrade: A\n\n\n16. Age in Seconds\nAsk the user for their age in years. Approximate and print how many seconds they have lived, assuming 365 days per year.\n\n\n17. Favorite Number Game\nAsk the user for their favorite integer. Print the number, its square, and its cube.\n\n\n18. Welcome Banner\nAsk the user for their name and print it inside a “banner” made of - symbols:\nEnter your name: Bob\n\n- Bob  -\n\n\n\n19. Type Limits Exploration (Bonus)\nUse &lt;limits.h&gt; and &lt;float.h&gt; to print the minimum and maximum values of int, unsigned int, float, and double. (Not beginner-essential, but a good exploration.)\n\n\n20. Combine Everything\nWrite a program that:\n\nUses const for π.\nReads an integer age, a float height, a char initial, and a string name.\nPrints them all back with labels. This “mini-profile” program should combine all concepts from Chapter 2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-expressions-and-operators",
    "href": "index.html#chapter-3.-expressions-and-operators",
    "title": "The Little Book of C",
    "section": "Chapter 3. Expressions and Operators",
    "text": "Chapter 3. Expressions and Operators\n\n3.1 Arithmetic Operators\nArithmetic operators let your program calculate with numbers. In C, the basic operators are:\n\n+ (addition)\n- (subtraction / unary negation)\n- (multiplication)\n/ (division)\n% (remainder, modulo - integers only)\n\nYou’ll use them with both integers (int, long, …) and floating-point numbers (float, double).\n\nQuick Examples\nint a = 7 + 3;       // 10\nint b = 7 - 3;       // 4\nint c = 7 - 3;       // 21\nint d = 7 / 3;       // 2  (integer division truncates the fraction)\nint r = 7 % 3;       // 1  (remainder)\n\nfloat x = 7.0f / 3;  // 2.333333 (floating division)\ndouble y = 7 / 3.0;  // 2.333333 (promoted to double)\n\n\nUnary Minus\nYou can flip the sign of a number with unary -:\nint k = 5;\nint neg = -k;   // -5\n\n\nModulo (%)\nThe % operator gives the remainder after integer division:\nint r1 = 11 % 4;   // 3  (11 = 2-4 + 3)\nint r2 = 7 % 2;    // 1\nModulo is useful for tasks like checking even/odd (n % 2).\n\n\nA Full Example\nThis program shows all arithmetic operators with two integers and also demonstrates floating division:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a, b;\n    printf(\"Enter two integers (a b): \");\n    scanf(\"%d %d\", &a, &b);\n\n    int sum  = a + b;\n    int diff = a - b;\n    int prod = a - b;\n    int quot = a / b;      // integer division\n    int rem  = a % b;      // remainder\n    double fquot = (double)a / b; // floating division\n\n    printf(\"\\n--- Results ---\\n\");\n    printf(\"%d + %d = %d\\n\", a, b, sum);\n    printf(\"%d - %d = %d\\n\", a, b, diff);\n    printf(\"%d - %d = %d\\n\", a, b, prod);\n    printf(\"%d / %d = %d (integer division)\\n\", a, b, quot);\n    printf(\"%d %% %d = %d (remainder)\\n\", a, b, rem);\n    printf(\"%d / %d = %.6f (floating division)\\n\", a, b, fquot);\n    printf(\"Unary minus of %d is %d\\n\", a, *a);\n\n    return 0;\n}\nExample run:\nEnter two integers (a b): 11 4\n\n--- Results ---\n11 + 4 = 15\n11 - 4 = 7\n11 - 4 = 44\n11 / 4 = 2 (integer division)\n11 % 4 = 3 (remainder)\n11 / 4 = 2.750000 (floating division)\nUnary minus of 11 is -11\n\n\nWhy It Matters\nArithmetic operators are the foundation of programming. They let you move beyond printing fixed text and start writing programs that calculate answers. Understanding the difference between integer and floating division is one of the first “aha!” moments for every C beginner.\n\n\nExercises\n\nWrite a program that reads two integers and prints their sum, difference, product, integer division, remainder, and floating division.\nRead one integer and print its square and cube.\nRead one integer and print whether it is even or odd using %. (Just print the remainder, we’ll learn if later.)\nRead three integers and print their total and average (as floating).\nRead two integers and print the result of applying unary minus to each.\n\n\n\n\n3.2 Assignment and Precedence\nSo far we’ve calculated values and stored them in variables like this:\nint sum = a + b;\nThis uses the assignment operator =. It means: -take the value on the right-hand side and store it into the variable on the left-hand side.-\n\nBasic Assignment\nint x;     // declare a variable\nx = 5;     // assign the value 5 to x\nAfter this, x holds the number 5.\nYou can change it later:\nx = 10;    // now x holds 10\n\n\nCombined Assignments\nC has shorthand operators that combine calculation and assignment:\n\nx += y; → same as x = x + y;\nx -= y; → same as x = x - y;\nx -= y; → same as x = x - y;\nx /= y; → same as x = x / y;\nx %= y; → same as x = x % y;\n\nThese make code shorter and often clearer.\n\n\nOperator Precedence\nWhen an expression has multiple operators, C needs to decide which to do first. This is called precedence.\nGeneral order (from higher to lower, the ones we’ve seen so far):\n\nParentheses ( )\nUnary minus -x\nMultiplication, division, modulo - / %\nAddition, subtraction + -\nAssignment =\n\nSo:\nint r = 2 + 3 - 4;    // 3-4 happens first → 2 + 12 = 14\nint s = (2 + 3) - 4;  // parentheses force addition first → 5-4 = 20\nAlways use parentheses when in doubt. They make code easier to read and prevent mistakes.\n\n\nA Full Example\nThis program shows assignment, combined assignments, and precedence:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 10;\n    int y = 3;\n\n    printf(\"Initial: x = %d, y = %d\\n\", x, y);\n\n    // Basic assignment\n    x = x + y;\n    printf(\"x = x + y → %d\\n\", x);\n\n    // Reset x\n    x = 10;\n\n    // Combined assignment\n    x += y;\n    printf(\"x += y → %d\\n\", x);\n\n    x -= y;\n    printf(\"x -= y → %d\\n\", x);\n\n    x -= y;\n    printf(\"x -= y → %d\\n\", x);\n\n    x /= y;\n    printf(\"x /= y → %d\\n\", x);\n\n    x = 10;\n    x %= y;\n    printf(\"x %%= y → %d\\n\", x);\n\n    // Precedence\n    int a = 2 + 3 - 4;\n    int b = (2 + 3) - 4;\n    printf(\"2 + 3 - 4 = %d\\n\", a);\n    printf(\"(2 + 3) - 4 = %d\\n\", b);\n\n    return 0;\n}\nExample run:\nInitial: x = 10, y = 3\nx = x + y → 13\nx += y → 13\nx -= y → 10\nx -= y → 30\nx /= y → 10\nx %= y → 1\n2 + 3 - 4 = 14\n(2 + 3) - 4 = 20\n\n\nWhy It Matters\n\nAssignment is how you store results into variables.\nCombined assignments make updates simpler (important in loops later).\nPrecedence ensures the computer reads your math the same way you do - or lets you override with parentheses.\n\n\n\nExercises\n\nStart with int n = 10;. Use +=, -=, -=, /=, %= with another integer and print the result after each step.\nCalculate 5 + 2 - 3 and (5 + 2) - 3 and print both results.\nWrite a program that computes 10 - 4 + 2 - 3. Then add parentheses in different places and print the different results.\nDeclare int a = 7, b = 2;. Compute and print (a + b) - (a - b).\nShow that x = x + 1; and x += 1; give the same result.\n\n\n\n\n3.3 Relational and Logical Operators\nPrograms often need to compare values or combine conditions. C provides operators for this. They don’t give you numbers like 5 or 7 - instead they produce results that are either:\n\n1 → means true\n0 → means false\n\nThis is how C represents truth values internally.\n\nRelational Operators\nThese compare two values:\n\n== → equal\n!= → not equal\n&lt; → less than\n&gt; → greater than\n&lt;= → less than or equal\n&gt;= → greater than or equal\n\nExamples:\nint a = 5, b = 3;\n\nint r1 = (a == b);  // 0 (false)\nint r2 = (a &gt; b);   // 1 (true)\nint r3 = (a &lt;= 5);  // 1 (true)\n\n\nLogical Operators\nThese combine true/false values:\n\n&& → logical AND (true only if both are true)\n|| → logical OR (true if at least one is true)\n! → logical NOT (flips true/false)\n\nExamples:\nint x = 1, y = 0;\n\nint r1 = (x && y); // 0 (1 AND 0 is false)\nint r2 = (x || y); // 1 (1 OR 0 is true)\nint r3 = (!x);     // 0 (NOT 1 is false)\n\n\nA Full Example\nHere’s a program that shows relational and logical operators in action:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a, b;\n    printf(\"Enter two integers (a b): \");\n    scanf(\"%d %d\", &a, &b);\n\n    printf(\"\\n--- Relational ---\\n\");\n    printf(\"%d == %d → %d\\n\", a, b, a == b);\n    printf(\"%d != %d → %d\\n\", a, b, a != b);\n    printf(\"%d &lt;  %d → %d\\n\", a, b, a &lt; b);\n    printf(\"%d &gt;  %d → %d\\n\", a, b, a &gt; b);\n    printf(\"%d &lt;= %d → %d\\n\", a, b, a &lt;= b);\n    printf(\"%d &gt;= %d → %d\\n\", a, b, a &gt;= b);\n\n    printf(\"\\n--- Logical ---\\n\");\n    int x = (a &gt; 0);  // true if a is positive\n    int y = (b &gt; 0);  // true if b is positive\n\n    printf(\"(a &gt; 0) → %d\\n\", x);\n    printf(\"(b &gt; 0) → %d\\n\", y);\n    printf(\"(a &gt; 0) && (b &gt; 0) → %d\\n\", x && y);\n    printf(\"(a &gt; 0) || (b &gt; 0) → %d\\n\", x || y);\n    printf(\"!(a &gt; 0) → %d\\n\", !x);\n\n    return 0;\n}\nExample run:\nEnter two integers (a b): 5 3\n\n--- Relational ---\n5 == 3 → 0\n5 != 3 → 1\n5 &lt;  3 → 0\n5 &gt;  3 → 1\n5 &lt;= 3 → 0\n5 &gt;= 3 → 1\n\n--- Logical ---\n(a &gt; 0) → 1\n(b &gt; 0) → 1\n(a &gt; 0) && (b &gt; 0) → 1\n(a &gt; 0) || (b &gt; 0) → 1\n!(a &gt; 0) → 0\n\n\nWhy It Matter\nRelational and logical operators are how C evaluates conditions. They let you compare numbers and combine truth values, producing results as 1 (true) or 0 (false). This gives you a way to test equality, check ranges, and express logical ideas directly in your code.\nEven in simple printouts, these operators show how the computer understands relationships and logic in numeric form.\n\n\nExercises\n\nRead two integers and print the results of all six relational operators.\nRead one integer and print n % 2 == 0 to check if it’s even (you’ll see 1 or 0).\nRead two integers a and b, and print (a &gt; 0) && (b &gt; 0). Try positive and negative inputs.\nPrint the result of !(a == b) and compare it with a != b.\nExperiment with (a &gt; 5) || (b &lt; 10) and record the outputs for different inputs.\n\n\n\n\n3.4 Working with Characters\nIn C, characters are stored in variables of type char. Even though they look like letters, underneath they are just small integers representing codes (usually ASCII). This means you can compare them, add or subtract from them, and print both the character and its numeric code.\n\nDeclaring and Printing Characters\nA character literal is written in single quotes:\nchar letter = 'A';\nprintf(\"Letter: %c\\n\", letter);\nHere %c prints the character itself. If you use %d, you’ll see its integer code:\nprintf(\"Code of %c is %d\\n\", letter, letter);\nOutput:\nCode of A is 65\n\n\nCharacter Arithmetic\nBecause characters are stored as numbers, you can do math with them.\nchar letter = 'A';\nchar next = letter + 1;   // 'B'\nSimilarly:\nchar digit = '3';\nchar nextdigit = digit + 1;  // '4'\n\n\nCharacter Comparisons\nYou can compare characters with relational operators:\nchar c = 'm';\n\nint is_lower = (c &gt;= 'a' && c &lt;= 'z');  // 1 if lowercase\nint is_upper = (c &gt;= 'A' && c &lt;= 'Z');  // 1 if uppercase\nThis works because ASCII letters are stored in order.\n\n\nA Full Example\nThis program reads one character and shows its properties:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n    printf(\"Enter a character: \");\n    scanf(\" %c\", &c);   // space before %c skips whitespace\n\n    printf(\"\\n--- Character Info ---\\n\");\n    printf(\"Character: %c\\n\", c);\n    printf(\"ASCII code: %d\\n\", c);\n\n    printf(\"Next character: %c\\n\", c + 1);\n    printf(\"Previous character: %c\\n\", c - 1);\n\n    printf(\"Is uppercase? %d\\n\", (c &gt;= 'A' && c &lt;= 'Z'));\n    printf(\"Is lowercase? %d\\n\", (c &gt;= 'a' && c &lt;= 'z'));\n    printf(\"Is digit?     %d\\n\", (c &gt;= '0' && c &lt;= '9'));\n\n    return 0;\n}\nExample run:\nEnter a character: m\n\n--- Character Info ---\nCharacter: m\nASCII code: 109\nNext character: n\nPrevious character: l\nIs uppercase? 0\nIs lowercase? 1\nIs digit?     0\n\n\nWhy It Matters\nCharacters are the building blocks of text. Knowing that they are really numbers helps you:\n\nunderstand comparisons ('a' &lt; 'z')\nmove through letters and digits by simple arithmetic\nstart working with strings later, since strings are arrays of characters\n\n\n\nExercises\n\nRead one character and print its ASCII code.\nRead a digit character (e.g. '5') and print the next digit.\nRead a letter and print both its lowercase and uppercase version by adding or subtracting 32 ('A' + 32 = 'a').\nRead one character and print whether it is between 'a' and 'z'.\nRead one character and print the three following characters in sequence.\n\n\n\n\n3.5 A First Calculator Program\nSo far, you’ve learned how to use arithmetic operators, assignment, precedence, and comparisons. Now let’s combine them into a mini calculator program that reads two numbers from the user and prints the results of all the basic operations.\n\nThe Idea\n\nInput: two integers from the user (a and b)\nOutput: sum, difference, product, integer division, remainder, and floating-point division\n\nThis lets you practice:\n\n+ - - / %\nassignment to store results\nformatted output with printf\n\n\n\nA Full Example\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a, b;\n\n    printf(\"Enter two integers (a b): \");\n    scanf(\"%d %d\", &a, &b);\n\n    int sum = a + b;\n    int diff = a - b;\n    int prod = a - b;\n    int quot = a / b;         // integer division\n    int rem  = a % b;         // remainder\n    double fquot = (double)a / b;  // floating-point division\n\n    printf(\"\\n--- Calculator ---\\n\");\n    printf(\"%d + %d = %d\\n\", a, b, sum);\n    printf(\"%d - %d = %d\\n\", a, b, diff);\n    printf(\"%d - %d = %d\\n\", a, b, prod);\n    printf(\"%d / %d = %d (integer division)\\n\", a, b, quot);\n    printf(\"%d %% %d = %d (remainder)\\n\", a, b, rem);\n    printf(\"%d / %d = %.6f (floating division)\\n\", a, b, fquot);\n\n    return 0;\n}\nExample run:\nEnter two integers (a b): 11 4\n\n--- Calculator ---\n11 + 4 = 15\n11 - 4 = 7\n11 - 4 = 44\n11 / 4 = 2 (integer division)\n11 % 4 = 3 (remainder)\n11 / 4 = 2.750000 (floating division)\n\n\nWhy It Matters\nThis small calculator shows how different operators behave side by side. You see the difference between integer and floating division, how remainders work, and how assignment stores intermediate results. It also demonstrates how to format outputs clearly.\n\n\nExercises\n\nModify the program to also calculate the square and cube of each input.\nChange the program to read two floating-point numbers and show their sum, difference, product, and division.\nAdd output that shows a + b - 2 and (a + b) - 2 to illustrate operator precedence.\nExtend the program to ask for three integers and print their total and average (as floating).\nWrite a version that only prints the floating-point division result, but with 2, 4, and 8 decimal places.\n\n\n\n\nProblems\n\n1. Arithmetic Basics\nWrite a program that reads two integers and prints their sum, difference, product, integer division, remainder, and floating-point division.\n\n\n2. Square and Cube\nRead one integer and print its square and cube.\n\n\n3. Average of Two\nRead two integers and print both their integer average and their floating average.\n\n\n4. Even or Odd (with %)\nRead one integer and print the result of n % 2. Use this to check even/odd (0 means even, 1 means odd).\n\n\n5. Precedence Practice\nCompute and print the results of:\n\n5 + 2 - 3\n(5 + 2) - 3\n10 - 4 + 2 - 3\n(10 - 4 + 2) - 3\n\n\n\n6. Combined Assignment\nStart with int x = 10;. Then use +=, -=, -=, /=, %= with another integer and print the result after each step.\n\n\n7. Equality Test\nRead two integers and print the result of a == b and a != b.\n\n\n8. Greater Than Check\nRead two integers and print the result of a &gt; b and a &lt; b.\n\n\n9. Range Test\nRead one integer and print whether it is between 1 and 100 using (n &gt;= 1 && n &lt;= 100).\n\n\n10. Logical OR\nRead two integers and print (a &gt; 10 || b &gt; 10).\n\n\n11. Logical NOT\nRead one integer and print both n &gt; 0 and !(n &gt; 0).\n\n\n12. Character Info\nRead one character and print:\n\nthe character\nits ASCII code\nthe next character (c+1)\nthe previous character (c-1)\n\n\n\n13. Uppercase or Lowercase\nRead one character and print whether it is uppercase ('A'..'Z') or lowercase ('a'..'z') using relational operators.\n\n\n14. Digit Check\nRead one character and print whether it is a digit ('0'..'9').\n\n\n15. Character Math\nRead a letter and print the letter 3 positions ahead (e.g., input A → output D).\n\n\n16. Expression Explorer\nRead three integers a, b, c and print the result of:\n\na + b - c\n(a + b) - c\na - b + c\n\n\n\n17. Increment with +=\nRead one integer n. Print n, then n += 1, then n += 5.\n\n\n18. Logical Combination\nRead two integers a, b. Print the results of:\n\n(a &gt; 0 && b &gt; 0)\n(a &gt; 0 || b &gt; 0)\n!(a &gt; 0 && b &gt; 0)\n\n\n\n19. Mini Character Table\nPrint the characters 'A' through 'Z' with their ASCII codes using a loop-free approach (declare them directly and print with %c and %d).\n\n\n20. Mini Calculator\nWrite a program that reads two integers and prints their sum, difference, product, integer division, remainder, and floating division - formatted like a calculator.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-4.-control-flow",
    "href": "index.html#chapter-4.-control-flow",
    "title": "The Little Book of C",
    "section": "Chapter 4. Control Flow",
    "text": "Chapter 4. Control Flow\n\n4.1 if and else\nUntil now, all our programs did the same thing every time, no matter the input. But useful programs often need to make choices:\n\nIf the user is old enough → print “Welcome.”\nIf a number is negative → print “Error.”\nOtherwise → do something else.\n\nIn C, decisions are made with the if statement.\n\nThe if Statement\nif (condition) {\n    // statements run only if condition is true\n}\n\ncondition is an expression that evaluates to true (1) or false (0).\nIf it’s true, the block inside {} runs.\nIf it’s false, the block is skipped.\n\nExample:\nint age = 20;\nif (age &gt;= 18) {\n    printf(\"You are an adult.\\n\");\n}\n\n\nAdding else\nYou can provide an alternative with else:\nif (age &gt;= 18) {\n    printf(\"You are an adult.\\n\");\n} else {\n    printf(\"You are a minor.\\n\");\n}\n\n\nif … else if … else\nFor multiple choices:\nif (score &gt;= 90) {\n    printf(\"Grade A\\n\");\n} else if (score &gt;= 75) {\n    printf(\"Grade B\\n\");\n} else if (score &gt;= 50) {\n    printf(\"Grade C\\n\");\n} else {\n    printf(\"Fail\\n\");\n}\nThe computer checks conditions in order. The first one that’s true is executed, and the rest are skipped.\n\n\nA Full Example\nThis program reads an integer and classifies it:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &n);\n\n    if (n &gt; 0) {\n        printf(\"%d is positive.\\n\", n);\n    } else if (n &lt; 0) {\n        printf(\"%d is negative.\\n\", n);\n    } else {\n        printf(\"The number is zero.\\n\");\n    }\n\n    return 0;\n}\nExample run:\nEnter a number: -7\n-7 is negative.\n\n\nWhy It Matters\nif and else give programs the power to branch - to take different paths depending on conditions. This is the foundation for decision-making, error checking, and interactive behavior in all real-world programs.\n\n\nExercises\n\nWrite a program that reads an integer and prints whether it is even or odd.\nWrite a program that reads two integers and prints which one is larger (or if they are equal).\nWrite a program that reads an exam score (0–100) and prints a letter grade (A, B, C, or F).\nWrite a program that reads a temperature in Celsius and prints:\n\n\"Cold\" if less than 10\n\"Warm\" if between 10 and 25\n\"Hot\" if above 25\n\nWrite a program that reads a character and prints whether it is uppercase, lowercase, or not a letter.\n\n\n\n\n4.2 switch Statements\nSometimes you need to compare the same variable against several constant values. Writing many if … else if … else lines can become messy. The switch statement gives you a clearer way.\n\nThe Structure\nswitch (expression) {\n    case value1:\n        // code if expression == value1\n        break;\n    case value2:\n        // code if expression == value2\n        break;\n    ...\n    default:\n        // code if no case matches\n}\n\nThe expression is usually an integer or character.\nEach case is compared against the expression.\nbreak; ends that case so execution does not “fall through” to the next one.\ndefault runs if none of the cases match (like an “else”).\n\n\n\nExample: Day of the Week\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int day;\n    printf(\"Enter a number (1–7): \");\n    scanf(\"%d\", &day);\n\n    switch (day) {\n        case 1: printf(\"Monday\\n\"); break;\n        case 2: printf(\"Tuesday\\n\"); break;\n        case 3: printf(\"Wednesday\\n\"); break;\n        case 4: printf(\"Thursday\\n\"); break;\n        case 5: printf(\"Friday\\n\"); break;\n        case 6: printf(\"Saturday\\n\"); break;\n        case 7: printf(\"Sunday\\n\"); break;\n        default: printf(\"Invalid day number.\\n\");\n    }\n\n    return 0;\n}\nExample run:\nEnter a number (1–7): 3\nWednesday\n\n\nExample: Character Menu\nBecause characters are really small integers, you can use them in switch:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char choice;\n    printf(\"Choose (a/b/c): \");\n    scanf(\" %c\", &choice);\n\n    switch (choice) {\n        case 'a': printf(\"You chose A.\\n\"); break;\n        case 'b': printf(\"You chose B.\\n\"); break;\n        case 'c': printf(\"You chose C.\\n\"); break;\n        default:  printf(\"Unknown choice.\\n\");\n    }\n\n    return 0;\n}\n\n\nWhy It Matters\n\nswitch is easier to read when one variable has many fixed options.\nIt avoids repetitive if (x == 1) … else if (x == 2) ….\nUseful for menus, command selection, and state handling in larger programs.\n\n\n\nExercises\n\nWrite a program that reads a digit (0–9) and prints its English word (\"zero\", \"one\", …).\nWrite a program that reads a grade character ('A', 'B', 'C', 'D', 'F') and prints a message (e.g., \"Excellent\", \"Good\", \"Pass\", \"Fail\").\nExtend the day-of-week program to also print \"Weekend\" if the day is 6 or 7.\nWrite a simple calculator that reads an operator character (+, -, -, /) and two integers, then prints the result. Use switch to handle the operator.\nWrite a program that reads a character and prints whether it is a vowel (a, e, i, o, u) or consonant.\n\n\n\n\n4.3 while Loops\nSometimes you want to do something over and over while a condition is true. For example:\n\nKeep asking for input until the user types 0.\nCount from 1 to 10.\nProcess characters in a string one by one.\n\nThis is what the while loop is for.\n\nThe Structure\nwhile (condition) {\n    // statements run repeatedly\n}\n\nThe condition is checked before each iteration.\nIf it’s true, the loop body runs.\nIf it’s false, the loop stops.\n\n\n\nExample: Counting to 5\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 1;\n    while (i &lt;= 5) {\n        printf(\"%d\\n\", i);\n        i = i + 1;  // update\n    }\n    return 0;\n}\nOutput:\n1\n2\n3\n4\n5\n\n\nExample: Summing Numbers\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n, sum = 0;\n    printf(\"Enter positive numbers (0 to stop):\\n\");\n    scanf(\"%d\", &n);\n\n    while (n != 0) {\n        sum += n;\n        scanf(\"%d\", &n);\n    }\n\n    printf(\"Sum = %d\\n\", sum);\n    return 0;\n}\nRun:\nEnter positive numbers (0 to stop):\n3\n5\n7\n0\nSum = 15\n\n\nInfinite Loops\nIf the condition never becomes false, the loop runs forever. Example:\nwhile (1) {\n    printf(\"Looping forever!\\n\");\n}\nYou should almost always include an update step (like i = i + 1;) so the loop eventually stops.\n\n\nWhy It Matters\nThe while loop introduces repetition - programs can keep working until a condition changes. This is essential for tasks like input validation, iterative calculations, and data processing.\n\n\nExercises\n\nWrite a program that prints the numbers from 1 to 10 using a while loop.\nWrite a program that reads integers until the user enters 0, then prints their total.\nWrite a program that prints the first 10 even numbers.\nWrite a program that asks for a password (string) and keeps asking until the correct one is entered.\nWrite a program that reads a number n and uses a while loop to print its multiplication table (from n - 1 to n - 10).\n\n\n\n\n4.4 for Loops\nThe while loop is flexible, but sometimes you want to count through a range in a very compact form. For this, C provides the for loop.\n\nThe Structure\nfor (initialization; condition; update) {\n    // loop body\n}\n\ninitialization → set the starting value\ncondition → loop continues while true\nupdate → run after each iteration (e.g., increment)\n\nIt’s just a compact way of writing the pattern:\ninitialization;\nwhile (condition) {\n    // body\n    update;\n}\n\n\nExample: Counting to 5\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int i = 1; i &lt;= 5; i++) {\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}\nOutput:\n1\n2\n3\n4\n5\n\n\nExample: Sum of 1 to N\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n, sum = 0;\n    printf(\"Enter n: \");\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i &lt;= n; i++) {\n        sum += i;\n    }\n\n    printf(\"Sum = %d\\n\", sum);\n    return 0;\n}\nRun:\nEnter n: 5\nSum = 15\n\n\nExample: Multiplication Table\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i &lt;= 10; i++) {\n        printf(\"%d x %d = %d\\n\", n, i, n - i);\n    }\n    return 0;\n}\n\n\nNested Loops\nA loop inside another loop is called nested. Example: printing a rectangle of - characters:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int row = 1; row &lt;= 3; row++) {\n        for (int col = 1; col &lt;= 5; col++) {\n            printf(\"-\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\nOutput:\n-\n-\n-\n\n\nWhy It Matters\n\nfor loops are the standard tool for counting tasks.\nThey combine initialization, condition, and update neatly in one line.\nNested loops let you handle two dimensions (rows and columns).\n\n\n\nExercises\n\nWrite a program that prints the numbers from 1 to 20 using a for loop.\nWrite a program that prints all odd numbers from 1 to 19.\nWrite a program that computes the factorial of n (product of 1 × 2 × … × n) using a for loop.\nWrite a program that prints a multiplication table from 1 to 10 (all rows and columns).\nWrite a program that prints a right triangle of - with n rows, where n is read from input. Example for n=4:\n\n\n\n\n4.5 Breaking and Continuing\nSometimes you don’t want to finish a loop normally:\n\nYou may want to stop early when a condition is met.\nOr you may want to skip one iteration and continue with the next.\n\nC gives two keywords for this: break and continue.\n\nbreak\nbreak immediately exits the nearest loop.\nExample: stop when i reaches 5:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int i = 1; i &lt;= 10; i++) {\n        if (i == 5) {\n            break;\n        }\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}\nOutput:\n1\n2\n3\n4\nThe loop ends as soon as i == 5.\n\n\ncontinue\ncontinue skips the rest of the current iteration and jumps to the next one.\nExample: skip even numbers:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int i = 1; i &lt;= 10; i++) {\n        if (i % 2 == 0) {\n            continue;  // skip printing even numbers\n        }\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}\nOutput:\n1\n3\n5\n7\n9\n\n\nCombining with while\nbreak and continue also work with while loops.\nExample: reading until user enters 0:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n;\n    while (1) {         // infinite loop\n        scanf(\"%d\", &n);\n        if (n == 0) {\n            break;      // exit when n is 0\n        }\n        if (n &lt; 0) {\n            continue;   // skip negatives\n        }\n        printf(\"You entered: %d\\n\", n);\n    }\n    return 0;\n}\n\n\nWhy It Matters\n\nbreak lets you exit loops early, useful for searches or stopping when a goal is reached.\ncontinue lets you skip specific cases without leaving the loop.\nThey give you finer control inside loops, making programs more efficient and easier to read.\n\n\n\nExercises\n\nWrite a program that prints numbers from 1 to 20 but stops at 13 using break.\nWrite a program that prints numbers from 1 to 20 but skips multiples of 3 using continue.\nWrite a program that reads integers until 0 is entered; skip negative numbers, and print only positives.\nWrite a program that searches for the first number divisible by 17 between 1 and 100, then stops.\nWrite a program that prints all letters A to Z but skips vowels (A, E, I, O, U) using continue.\n\n\n\n\nProblems\n\n1. Positive, Negative, or Zero\nRead an integer and print whether it is positive, negative, or zero.\n\n\n2. Maximum of Two\nRead two integers and print the larger one (or print “Equal” if they are the same).\n\n\n3. Grading System\nRead a score (0–100) and print the grade:\n\nA for 90–100\nB for 75–89\nC for 50–74\nF for below 50\n\n\n\n4. Temperature Classifier\nRead a Celsius temperature and print:\n\n“Cold” if &lt; 10\n“Warm” if 10–25\n“Hot” if &gt; 25\n\n\n\n5. Calculator with Switch\nRead two integers and an operator (+, -, -, /) and use a switch to perform the calculation.\n\n\n6. Digit to Word\nRead a single digit (0–9) and print its English word (“zero”, “one”, …). Use a switch.\n\n\n7. Vowel or Consonant\nRead a character and print whether it is a vowel (a, e, i, o, u) or consonant.\n\n\n8. Count from 1 to 10\nUse a while loop to print the numbers 1 through 10.\n\n\n9. Sum Until Zero\nKeep reading integers until the user enters 0. Print their sum.\n\n\n10. Multiplication Table\nRead a number n and use a for loop to print its multiplication table (from n × 1 to n × 10).\n\n\n11. Factorial\nRead a number n and compute its factorial using a for loop.\n\n\n12. Print Odd Numbers\nUse a for loop with continue to print only the odd numbers between 1 and 20.\n\n\n13. Stop at Thirteen\nUse a for loop with break to print numbers from 1 to 20 but stop at 13.\n\n\n14. Skip Negatives\nKeep reading integers until 0 is entered. Skip negative numbers with continue and print only positives.\n\n\n15. First Divisible by 17\nUse a loop to find the first number between 1 and 100 that is divisible by 17, then stop with break.\n\n\n16. Print a Right Triangle\nRead n and use nested for loops to print a right triangle of - with n rows. Example for n=4:\n\n\n17. Rectangle of Stars\nRead rows and cols and print a rectangle of -.\n\n\n18. Guessing Game\nPick a secret number (hardcode it, e.g., 42). Use a while loop to keep asking the user until they guess it correctly. Print “Too low” or “Too high” for wrong guesses.\n\n\n19. Countdown\nRead an integer n and use a while loop to count down from n to 1, then print “Blast off!”.\n\n\n20. Prime Check\nRead an integer n and check if it is prime by testing divisibility in a loop. Print “Prime” or “Not prime.”",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-5.-functions",
    "href": "index.html#chapter-5.-functions",
    "title": "The Little Book of C",
    "section": "Chapter 5. Functions",
    "text": "Chapter 5. Functions\n\n5.1 Why Functions Matter\nAs programs grow, putting everything into main becomes messy. You end up with one giant block of code: hard to read, hard to change, easy to break.\nFunctions are how we divide programs into small, clear pieces. Each function has a name and does one job.\n\nEveryday Analogy\nThink of a program like a kitchen. Instead of one person doing everything, you split tasks:\n\none function washes vegetables,\nanother cuts them,\nanother boils water,\nanother prepares sauce.\n\nThe recipe is easier to follow, and each part can be reused whenever needed.\n\n\nWhat Functions Give You\n\nClarity → code is broken into named steps\nReuse → write once, use many times\nTesting → check each part independently\nFlexibility → update one function, all callers benefit\n\n\n\nA First Example\nHere’s a tiny function that squares an integer:\n#include &lt;stdio.h&gt;\n\nint square(int n) {\n    return n - n;\n}\n\nint main(void) {\n    int x = 7;\n    printf(\"square(%d) = %d\\n\", x, square(x));\n    return 0;\n}\nNotice how square gives a clear name to the operation. If you see square(7), you immediately know what it means.\n\n\nMore Than One Function\nYou can define several functions in the same program. Each does one job, and together they make the program easier to follow:\n#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nvoid print_line(void) { printf(\"----------\\n\"); }\n\nint main(void) {\n    int a = 12, b = 5;\n    print_line();\n    printf(\"add = %d\\n\", add(a, b));\n    printf(\"sub = %d\\n\", sub(a, b));\n    print_line();\n    return 0;\n}\nThis reads like a story: draw a line, add numbers, subtract numbers, draw a line.\n\n\nWhy It Matters\nFunctions are the building blocks of bigger programs. They let you:\n\ntell the computer -what to do- in small, named steps,\navoid repeating code,\nand make your programs easier for humans to read and understand.\n\nThe rest of this chapter will show how to define, call, and organize functions in C.\n\n\nExercises\n\nWrite a function hello(void) that prints “Hello, world!” and call it from main.\nWrite int double_it(int n) that returns twice the value of n.\nWrite two functions line(void) and stars(void) where line prints dashes and stars prints stars. Call them from main to decorate output.\nWrite a function square(int n) and use it to print the squares of numbers 1 through 5.\nWrite two functions add(int a,int b) and mul(int a,int b). Call them with different inputs and print the results.\n\n\n\n\n5.2 Defining and Calling Functions\nNow that you know why functions matter, let’s look at how to write and use them in C.\n\nFunction Definition\nA function has three parts:\n\nReturn type - the kind of value it gives back (int, double, void, …)\nName - what you call it\nParameters - inputs inside parentheses\n\nreturn_type name(parameters) {\n    // body\n    return value;   // if not void\n}\nExample:\nint add(int a, int b) {\n    return a + b;\n}\n\n\nCalling a Function\nYou call a function by writing its name followed by arguments:\nint result = add(3, 4);\nprintf(\"%d\\n\", result);\nThe values 3 and 4 are arguments; inside the function they are received as parameters (a, b).\n\n\nFunctions Defined Before main\nIf a function is defined before main, the compiler already knows it, so no extra declaration is needed:\n#include &lt;stdio.h&gt;\n\nint square(int n) {\n    return n - n;\n}\n\nint main(void) {\n    printf(\"%d\\n\", square(7));\n    return 0;\n}\n\n\nPrototypes and Defining After main\nIf you prefer to put main first and functions later, you must give the compiler a prototype before main.\nA prototype tells the compiler the function’s name, return type, and parameter types.\n#include &lt;stdio.h&gt;\n\nint square(int n);  // prototype\n\nint main(void) {\n    printf(\"%d\\n\", square(7));\n    return 0;\n}\n\nint square(int n) {\n    return n - n;\n}\nWithout this, modern C (C99 and later) will not compile: every function must be declared or defined before it is used.\n\n\nMatching Prototypes\nThe prototype must match the definition:\nint add(int a, int b);          // OK\nint add(int a, int b) { return a + b; }\nIf the return type or parameters don’t match, the compiler warns or errors.\n\n\nMultiple Functions in One Program\nYou can organize many functions. Either define them all before main, or put prototypes above main and definitions after.\n#include &lt;stdio.h&gt;\n\n/- Prototypes -/\nint add(int a, int b);\nint sub(int a, int b);\nint mul(int a, int b);\n\nint main(void) {\n    int x = 10, y = 4;\n    printf(\"add: %d\\n\", add(x, y));\n    printf(\"sub: %d\\n\", sub(x, y));\n    printf(\"mul: %d\\n\", mul(x, y));\n    return 0;\n}\n\n/- Definitions -/\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a - b; }\n\n\nWhy It Matters\n\nThe compiler must know a function before you call it.\nYou can achieve this by defining the function first, or by writing a prototype.\nThis rule becomes more important when we split code into multiple files - prototypes live in headers (.h), definitions in source files (.c).\n\n\n\nExercises\n\nWrite int triple(int n) that returns 3 × n. Define it before main and call it with different numbers.\nWrite int max2(int a, int b) but put its definition after main. Add a prototype before main.\nWrite double area_rectangle(double w, double h) and double perimeter_rectangle(double w, double h). Call them from main.\nCreate a program with functions add, sub, mul, and div_int (assume divisor not zero). Place prototypes at the top, main next, definitions at the bottom.\nModify the previous program: move the prototypes into a separate file called mathlib.h, include it with #include \"mathlib.h\", and keep definitions in your .c file.\n\n\n\n\n5.3 Arguments and Return Values\nA function is like a machine:\n\nYou feed it inputs (arguments).\nIt processes them.\nIt may give you an output (return value).\n\n\nParameters and Arguments\n\nParameters are the variable names inside the function definition.\nArguments are the actual values you pass in when calling the function.\n\nExample:\nint add(int a, int b) {   // a, b are parameters\n    return a + b;\n}\n\nint main(void) {\n    int x = 5, y = 7;\n    int result = add(x, y);  // x, y are arguments\n    printf(\"%d\\n\", result);\n    return 0;\n}\n\n\nFunctions with No Parameters\nIf a function doesn’t need input, you declare it with void:\nvoid greet(void) {\n    printf(\"Hello!\\n\");\n}\n\nint main(void) {\n    greet();\n    return 0;\n}\n\n\nFunctions with Multiple Parameters\nYou can pass as many inputs as you like, separated by commas:\nint max3(int a, int b, int c) {\n    int m = a;\n    if (b &gt; m) m = b;\n    if (c &gt; m) m = c;\n    return m;\n}\n\n\nReturn Values\nThe return statement sends a value back to the caller:\nint square(int n) {\n    return n - n;\n}\n\nThe type of the return value must match the function’s declared return type.\nIf a function is declared void, it should not return a value.\n\n\n\nExample: Average Function\n#include &lt;stdio.h&gt;\n\ndouble average3(int a, int b, int c) {\n    return (a + b + c) / 3.0;\n}\n\nint main(void) {\n    printf(\"Average = %.2f\\n\", average3(4, 7, 10));\n    return 0;\n}\nOutput:\nAverage = 7.00\n\n\nIgnoring Return Values\nYou don’t have to store the return value - you can call a function and ignore it:\nprintf(\"Result: %d\\n\", square(6));  // no variable needed\n\n\nWhy It Matters\n\nArguments let functions take in data.\nReturn values let functions produce results.\nTogether, they make functions reusable, flexible, and powerful - the building blocks of modular programs.\n\n\n\nExercises\n\nWrite int is_even(int n) that returns 1 if n is even, 0 otherwise. Test it with numbers 1–10.\nWrite double area_circle(double r) that returns π·r². Call it with several radii.\nWrite int min2(int a, int b) that returns the smaller of two integers.\nWrite double convert_c_to_f(double c) that converts Celsius to Fahrenheit: F = C - 9/5 + 32.\nWrite void line(int n) that prints n dashes in a row. Call it multiple times with different values of n.\n\n\n\n\n5.4 Scope of Variables\nWhen you write a program, you can declare variables in different places. Where a variable is declared determines where it can be used - this is called its scope.\n\nLocal Variables\nA variable declared inside a function exists only in that function.\n#include &lt;stdio.h&gt;\n\nvoid demo(void) {\n    int x = 10;   // local to demo\n    printf(\"x in demo = %d\\n\", x);\n}\n\nint main(void) {\n    demo();\n    // printf(\"%d\", x);  // ❌ error: x not visible here\n    return 0;\n}\nLocal variables are created when the function is called, and destroyed when it ends.\n\n\nFunction Parameters Are Local Too\nParameters behave like local variables.\nint square(int n) {   // n is local\n    return n - n;\n}\nHere n exists only while square runs.\n\n\nGlobal Variables\nA variable declared outside all functions is called a global variable. It can be used by all functions in the file.\n#include &lt;stdio.h&gt;\n\nint counter = 0;   // global\n\nvoid increment(void) {\n    counter++;\n}\n\nint main(void) {\n    increment();\n    increment();\n    printf(\"counter = %d\\n\", counter);  // prints 2\n    return 0;\n}\nGlobals are created when the program starts and live until it ends.\n\n\nShadowing\nA local variable can have the same name as a global. In that case, the local one hides the global in its scope.\n#include &lt;stdio.h&gt;\n\nint value = 100;   // global\n\nvoid test(void) {\n    int value = 50;   // shadows global\n    printf(\"local value = %d\\n\", value);\n}\n\nint main(void) {\n    test();\n    printf(\"global value = %d\\n\", value);\n    return 0;\n}\nOutput:\nlocal value = 50\nglobal value = 100\n\n\nBlock Scope\nVariables declared inside a block { ... } are visible only inside that block.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 10;\n    {\n        int y = 20;   // visible only here\n        printf(\"%d %d\\n\", x, y);\n    }\n    // printf(\"%d\", y);  // ❌ error: y not visible here\n    return 0;\n}\n\n\nWhy It Matters\n\nLocal variables keep functions independent and safe.\nGlobals are shared, but overusing them makes code hard to manage.\nScope rules prevent name clashes and keep data where it belongs.\nUnderstanding scope helps avoid bugs where variables “mysteriously” change.\n\n\n\nExercises\n\nWrite a program with a global counter and a function tick() that increments it. Call tick() five times and print the result.\nWrite a program where a local variable shadows a global variable with the same name. Print both values.\nWrite a function int cube(int n) that uses only local variables. Show that the parameter is local.\nDeclare a variable inside a block { ... } in main and print it. Then try printing it outside the block to see the error.\nWrite a program with two functions, each with a local variable of the same name. Show that they do not interfere with each other.\n\n\n\n\n5.5 Writing a Reusable Math Library\nBy now you know how to define functions, pass arguments, return values, and handle scope. The next step is to organize functions into a library that you can reuse across multiple programs.\n\nSplitting Code into Files\nA common C pattern is:\n\nHeader file (.h) → contains function prototypes (the “interface”)\nSource file (.c) → contains function definitions (the “implementation”)\nMain program → uses the library by including the header\n\n\n\nExample: mathlib.h\nThis file contains only prototypes:\n#ifndef MATHLIB_H\n#define MATHLIB_H\n\nint add(int a, int b);\nint sub(int a, int b);\nint mul(int a, int b);\nint div_int(int a, int b);\nint square(int n);\n\n#endif\nThe #ifndef ... #define ... #endif block is called an -include guard-. It prevents multiple inclusion errors.\n\n\nExample: mathlib.c\nThis file contains the function definitions:\n#include \"mathlib.h\"\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a - b; }\nint div_int(int a, int b) { return a / b; }   // assumes b != 0\nint square(int n) { return n - n; }\n\n\nExample: main.c\nThe main program includes the header and uses the library:\n#include &lt;stdio.h&gt;\n#include \"mathlib.h\"\n\nint main(void) {\n    int a = 12, b = 5;\n\n    printf(\"a = %d, b = %d\\n\", a, b);\n    printf(\"add = %d\\n\", add(a, b));\n    printf(\"sub = %d\\n\", sub(a, b));\n    printf(\"mul = %d\\n\", mul(a, b));\n    printf(\"div = %d\\n\", div_int(a, b));\n    printf(\"square(a) = %d\\n\", square(a));\n\n    return 0;\n}\n\n\nCompiling Together\nYou compile both files and link them:\ngcc main.c mathlib.c -o program\n\n\nExtending the Library\nYou can add more functions later, just by:\n\nAdding the prototype to mathlib.h.\nAdding the definition to mathlib.c.\n\nAny program that includes mathlib.h can then use the new function.\n\n\nWhy It Matters\n\nOrganizing functions into headers and source files is the first step toward modular programming.\nIt separates -what functions do- (interface) from -how they are implemented- (details).\nThis pattern scales from small projects to huge systems.\n\n\n\nExercises\n\nWrite a small library shapes.h and shapes.c with functions:\n\narea_rectangle(w,h)\nperimeter_rectangle(w,h)\narea_circle(r) (use 3.14159) Use it in main.c.\n\nAdd a function int max2(int a, int b) to mathlib. Update both the header and the source. Test it in main.c.\nAdd a function int factorial(int n) to mathlib. Demonstrate it in a program that prints factorials of numbers 1–10.\nMove the printf line separator function print_line(void) into its own library util.h / util.c. Include it in main.c alongside mathlib.h.\nCombine mathlib.c and util.c into one program with main.c. Compile with:\ngcc main.c mathlib.c util.c -o program\n\n\n\n\nProblems\n\n1. Hello Function\nWrite a function void hello(void) that prints \"Hello, world!\". Call it from main.\n\n\n2. Double Function\nWrite int double_it(int n) that returns twice the input. Test it with several values.\n\n\n3. Maximum of Two\nWrite int max2(int a, int b) that returns the larger of two integers. Demonstrate it in main.\n\n\n4. Minimum of Three\nWrite int min3(int a, int b, int c) that returns the smallest of three integers.\n\n\n5. Even Check\nWrite int is_even(int n) that returns 1 if the number is even, 0 otherwise. Print results for numbers 1–10.\n\n\n6. Average of Three\nWrite double average3(int a, int b, int c) that returns the average. Call it with several sets of numbers.\n\n\n7. Square Function\nWrite int square(int n) and use it to print squares of numbers from 1 to 10 in a loop.\n\n\n8. Circle Area\nWrite double area_circle(double r) that returns π·r² (use 3.14159). Test it with different radii.\n\n\n9. Celsius to Fahrenheit\nWrite double c_to_f(double c) that converts Celsius to Fahrenheit. Demonstrate with 0, 25, 100.\n\n\n10. Print Line\nWrite void line(int n) that prints a row of n dashes. Call it multiple times with different lengths.\n\n\n11. Scope Demonstration\nWrite a program with a global variable counter and a function tick() that increments it. Call tick() five times from main and print the result.\n\n\n12. Shadowing\nWrite a program with a global variable value = 100 and a function that declares a local variable value = 50. Print both the local and global values.\n\n\n13. Block Scope\nWrite a program that declares a variable y inside a block { ... }. Print it inside the block, then try printing it outside (observe the compile error).\n\n\n14. Separate Functions\nWrite three functions: add, sub, mul. Place their definitions before main. Call each with two integers.\n\n\n15. Prototypes and Later Definitions\nRewrite the previous program so that main comes first. Add prototypes above main and put definitions after.\n\n\n16. Rectangle Functions\nWrite functions double area_rectangle(double w, double h) and double perimeter_rectangle(double w, double h). Test them in main.\n\n\n17. Factorial Function\nWrite int factorial(int n) that returns n!. Use it to print factorials of numbers 1–10.\n\n\n18. Function Reuse\nWrite int sum_range(int a, int b) that returns the sum of all integers between a and b inclusive. Use it in main to compute the sum of 1–100.\n\n\n19. Tiny Math Library\nCreate two files:\n\nmathlib.h → prototypes for add, sub, mul, div_int, square\nmathlib.c → definitions Write main.c that includes mathlib.h and uses the functions.\n\n\n\n20. Shapes Library\nCreate a header shapes.h and source shapes.c with:\n\narea_rectangle(w,h)\nperimeter_rectangle(w,h)\narea_circle(r) Write main.c that uses these functions to print areas and perimeters for different shapes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-6.-arrays-and-strings",
    "href": "index.html#chapter-6.-arrays-and-strings",
    "title": "The Little Book of C",
    "section": "Chapter 6. Arrays and Strings",
    "text": "Chapter 6. Arrays and Strings\n\n6.1 Introduction to Arrays\nSo far, we’ve stored one value per variable: one int, one double, one char. But many tasks need a collection of values.\n\nA list of exam scores\nThe names of players on a team\nThe pixels in an image\n\nIn C, the simplest way to store such a collection is with an array.\n\nWhat Is an Array?\nAn array is a block of memory that holds multiple values of the same type, arranged one after another.\n\nEach value is called an element.\nYou access elements using an index (position number).\nIndexes start at 0 in C.\n\n\n\nDeclaring an Array\nint scores[5];\nThis creates space for 5 integers:\n\nscores[0]\nscores[1]\nscores[2]\nscores[3]\nscores[4]\n\n\n\nInitializing an Array\nYou can set initial values at once:\nint numbers[4] = {10, 20, 30, 40};\nOr partially:\nint numbers[4] = {10, 20};  // others become 0\nYou can also let the compiler count:\nint primes[] = {2, 3, 5, 7, 11};\n\n\nAccessing Elements\nYou use the index in square brackets:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int nums[3] = {4, 7, 9};\n    printf(\"First = %d\\n\", nums[0]);\n    printf(\"Second = %d\\n\", nums[1]);\n    printf(\"Third = %d\\n\", nums[2]);\n    return 0;\n}\nOutput:\nFirst = 4\nSecond = 7\nThird = 9\n\n\nChanging Elements\nnums[1] = 42;  // changes the second element\nNow nums is {4, 42, 9}.\n\n\nA Full Example\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int scores[5];\n\n    // read 5 scores\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"Enter score %d: \", i + 1);\n        scanf(\"%d\", &scores[i]);\n    }\n\n    // print them back\n    printf(\"You entered:\\n\");\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", scores[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\nWhy It Matters\nArrays let you store and process many values efficiently without creating dozens of separate variables. They are the foundation for working with strings, data tables, and more complex structures.\n\n\nExercises\n\nDeclare an array of 10 integers and set each element to its index (0, 1, 2, …, 9). Print them.\nRead 5 integers into an array, then print their sum.\nRead 5 integers and print the largest.\nInitialize an array of the first 6 even numbers and print them.\nRead 10 integers and print them in reverse order.\n\n\n\n\n6.2 Iterating Over Arrays\nAn array is most powerful when combined with loops. Instead of writing code for each element, you let a loop handle all of them.\n\nAccessing Elements with a Loop\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int nums[5] = {10, 20, 30, 40, 50};\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"nums[%d] = %d\\n\", i, nums[i]);\n    }\n\n    return 0;\n}\nOutput:\nnums[0] = 10\nnums[1] = 20\nnums[2] = 30\nnums[3] = 40\nnums[4] = 50\n\n\nReading Into an Array\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int arr[5];\n\n    for (int i = 0; i &lt; 5; i++) {\n        scanf(\"%d\", &arr[i]);  // note the &\n    }\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n\nCalculating a Sum\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int scores[5] = {80, 90, 70, 60, 85};\n    int sum = 0;\n\n    for (int i = 0; i &lt; 5; i++) {\n        sum += scores[i];\n    }\n\n    printf(\"Total = %d\\n\", sum);\n    return 0;\n}\n\n\nFinding a Maximum\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int scores[5] = {12, 45, 67, 23, 89};\n    int max = scores[0];\n\n    for (int i = 1; i &lt; 5; i++) {\n        if (scores[i] &gt; max) {\n            max = scores[i];\n        }\n    }\n\n    printf(\"Max = %d\\n\", max);\n    return 0;\n}\n\n\nUsing sizeof to Get Array Length\nHardcoding the array size (5 above) works, but we can calculate it:\nint arr[] = {2, 4, 6, 8, 10};\nint len = sizeof(arr) / sizeof(arr[0]);\nThis way, if the array changes size, the loop still works correctly.\n\n\nWhy It Matters\n\nLoops and arrays go hand in hand.\nYou can process data of any length with the same logic.\nThis is the foundation for algorithms like searching, sorting, and aggregation.\n\n\n\nExercises\n\nRead 10 integers into an array and print their average.\nFind the minimum value in an array of 8 integers.\nCount how many numbers in an array of 10 are even.\nRead 5 integers and print them in reverse order using a loop.\nGiven int arr[] = {1,2,3,4,5}, write a program to compute the sum of squares of all elements.\n\n\n\n\n6.3 Strings as Character Arrays\nIn C, a string is not a special type. It’s just an array of characters ending with a special character:\n\n'\\0' (null terminator)\n\nThis null character marks the end of the string, so functions know where to stop.\n\nDeclaring Strings\nchar word[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\nEasier with double quotes:\nchar word[] = \"Hello\";\nThe compiler adds the '\\0' automatically.\n\n\nPrinting Strings\nUse %s in printf:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char msg[] = \"C is fun!\";\n    printf(\"%s\\n\", msg);\n    return 0;\n}\nOutput:\nC is fun!\n\n\nReading Strings\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char name[20];\n    printf(\"Enter your name: \");\n    scanf(\"%19s\", name);   // limit to 19 chars + '\\0'\n    printf(\"Hello, %s!\\n\", name);\n    return 0;\n}\n⚠️ scanf(\"%s\", ...) stops at the first space. For reading full lines, safer functions like fgets are better (later section).\n\n\nCharacter by Character\nStrings are just arrays:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char word[] = \"Hi\";\n    printf(\"%c %c %c\\n\", word[0], word[1], word[2]);\n    return 0;\n}\nOutput:\nH i \\0\nNotice the third element is '\\0'.\n\n\nChanging Characters\nYou can change individual letters:\nchar greet[] = \"Cat\";\ngreet[0] = 'H';  // now \"Hat\"\n\n\nA Full Example\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char city[20];\n    printf(\"Enter a city: \");\n    scanf(\"%19s\", city);\n\n    printf(\"First letter: %c\\n\", city[0]);\n\n    int i = 0;\n    while (city[i] != '\\0') {\n        i++;\n    }\n    printf(\"Length = %d\\n\", i);\n\n    return 0;\n}\n\n\nWhy It Matters\n\nStrings are essential for text processing.\nUnderstanding that they are arrays helps explain how input, output, and libraries like &lt;string.h&gt; work.\nRemember: always leave room for the null terminator!\n\n\n\nExercises\n\nDeclare a string \"Hello\" and print its characters one by one in a loop.\nRead a name into a char array and print a greeting.\nWrite a program that counts the number of characters in a string (without using strlen).\nModify a string \"dog\" into \"fog\" by changing its first character.\nRead two strings and print them in reverse order (first the second, then the first).\n\n\n\n\n6.4 Standard String Functions\nC provides many useful functions for handling strings in the header &lt;string.h&gt;. These functions work with arrays of characters that end with '\\0'.\n\nstrlen - String Length\nCounts the number of characters before the null terminator.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char word[] = \"Hello\";\n    printf(\"Length = %zu\\n\", strlen(word));\n    return 0;\n}\nOutput:\nLength = 5\n\n\nstrcpy - Copy a String\nCopies characters from one string into another.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char src[] = \"world\";\n    char dst[20];\n    strcpy(dst, src);\n    printf(\"%s\\n\", dst);\n    return 0;\n}\n⚠️ Make sure the destination is large enough.\n\n\nstrcat - Concatenate Strings\nAppends one string to another.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char a[20] = \"Good\";\n    char b[] = \" morning\";\n    strcat(a, b);\n    printf(\"%s\\n\", a);\n    return 0;\n}\nOutput:\nGood morning\n\n\nstrcmp - Compare Strings\nCompares two strings lexicographically (like dictionary order).\n\nReturns 0 if equal\nNegative if first &lt; second\nPositive if first &gt; second\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char s1[] = \"apple\";\n    char s2[] = \"banana\";\n\n    if (strcmp(s1, s2) &lt; 0) {\n        printf(\"%s comes before %s\\n\", s1, s2);\n    }\n    return 0;\n}\n\n\nSafer Variants\nMany libraries provide safer versions:\n\nstrncpy (copy with size limit)\nstrncat (concatenate with size limit)\nstrncmp (compare up to n chars)\n\nExample:\nchar src[] = \"hello\";\nchar dst[10];\nstrncpy(dst, src, sizeof(dst)-1);\ndst[sizeof(dst)-1] = '\\0';   // ensure termination\n\n\nA Full Example\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char a[30] = \"Hello\";\n    char b[] = \"World\";\n\n    printf(\"a length = %zu\\n\", strlen(a));\n    strcpy(a, \"Hi\");\n    strcat(a, \" there\");\n    printf(\"a now = %s\\n\", a);\n\n    if (strcmp(a, b) == 0)\n        printf(\"a equals b\\n\");\n    else\n        printf(\"a != b\\n\");\n\n    return 0;\n}\n\n\nWhy It Matters\n\nWithout these helpers, you’d write long loops to process strings.\n&lt;string.h&gt; functions are efficient and standard across all C compilers.\nLearning them prepares you for real-world text processing.\n\n\n\nExercises\n\nRead a string and print its length using strlen.\nCopy one string into another and print both.\nConcatenate \"Hello\" and \"World\" into a buffer and print the result.\nRead two strings and print which comes first in dictionary order.\nUse strncpy to safely copy \"C programming\" into a buffer of size 8, and print the result.\n\n\n\n\n6.5 Building a Word Counter\nNow that we know how to use arrays and string functions, let’s build a simple word counter. This program will:\n\nRead a line of text.\nSplit it into words.\nCount how many words there are.\n\n\nStep 1: Reading a Line\nUse fgets to safely read a line of input (it includes spaces).\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char line[200];\n    printf(\"Enter a sentence:\\n\");\n    fgets(line, sizeof(line), stdin);\n    printf(\"You entered: %s\", line);\n    return 0;\n}\n\n\nStep 2: Splitting Into Words\nThe &lt;string.h&gt; function strtok splits a string into tokens (pieces) separated by delimiters.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char line[200];\n    printf(\"Enter a sentence:\\n\");\n    fgets(line, sizeof(line), stdin);\n\n    int count = 0;\n    char -word = strtok(line, \" \\t\\n\");  // split by space, tab, newline\n    while (word != NULL) {\n        printf(\"Word: %s\\n\", word);\n        count++;\n        word = strtok(NULL, \" \\t\\n\");\n    }\n\n    printf(\"Total words = %d\\n\", count);\n    return 0;\n}\nExample run:\nEnter a sentence:\nC makes low-level programming fun\nWord: C\nWord: makes\nWord: low-level\nWord: programming\nWord: fun\nTotal words = 5\n\n\nStep 3: Counting Word Frequencies (Optional)\nWe can go further: keep an array of words and their counts.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_WORDS 50\n#define MAX_LEN   20\n\nint main(void) {\n    char line[200];\n    char words[MAX_WORDS][MAX_LEN];\n    int counts[MAX_WORDS] = {0};\n    int total = 0;\n\n    printf(\"Enter a sentence:\\n\");\n    fgets(line, sizeof(line), stdin);\n\n    char -w = strtok(line, \" \\t\\n\");\n    while (w != NULL && total &lt; MAX_WORDS) {\n        int found = 0;\n        for (int i = 0; i &lt; total; i++) {\n            if (strcmp(words[i], w) == 0) {\n                counts[i]++;\n                found = 1;\n                break;\n            }\n        }\n        if (!found && strlen(w) &lt; MAX_LEN) {\n            strcpy(words[total], w);\n            counts[total] = 1;\n            total++;\n        }\n        w = strtok(NULL, \" \\t\\n\");\n    }\n\n    printf(\"\\nWord frequencies:\\n\");\n    for (int i = 0; i &lt; total; i++) {\n        printf(\"%s : %d\\n\", words[i], counts[i]);\n    }\n\n    return 0;\n}\n\n\nWhy It Matters\n\nCombines arrays, strings, and library functions into one real project.\nShows how to process input text, split it, and analyze it.\nThis is a small taste of how text editors, search engines, and compilers start their work.\n\n\n\nExercises\n\nModify the word counter so it ignores case (treat \"C\" and \"c\" as the same).\nExtend the program to print the longest word in the input.\nExtend the program to print the average word length.\nModify it so it counts only unique words, and prints the total number of distinct words.\nWrite a version that reads from a file instead of user input, and counts words in the whole file.\n\n\n\n\nProblems\n\n1. Index Fill\nDeclare an array of 10 integers. Use a loop to fill it so that arr[i] = i. Print all elements.\n\n\n2. Array Sum\nRead 5 integers into an array and print their sum.\n\n\n3. Array Maximum\nRead 8 integers into an array and print the largest.\n\n\n4. Reverse Print\nRead 10 integers and print them in reverse order using a loop.\n\n\n5. Even Counter\nRead 10 integers into an array and count how many are even.\n\n\n6. Average of Numbers\nRead 10 integers into an array and print their average as a double.\n\n\n7. Sum of Squares\nGiven int arr[] = {1,2,3,4,5}, compute and print the sum of their squares.\n\n\n8. Print Characters of a String\nDeclare a string \"Hello\" and print each character on a separate line.\n\n\n9. Greeting with String\nRead a string (name) into a char array and print \"Hello, &lt;name&gt;!\".\n\n\n10. Count Characters (Manual)\nRead a string and count its length manually (without strlen).\n\n\n11. Modify a String\nDeclare char word[] = \"dog\" and change it to \"fog\" by modifying one character. Print the result.\n\n\n12. Two Strings Reverse Order\nRead two strings and print them in reverse order (second, then first).\n\n\n13. Length with strlen\nRead a string and print its length using strlen.\n\n\n14. String Copy\nRead a string into one buffer, copy it into another with strcpy, and print both.\n\n\n15. String Concatenation\nConcatenate \"Hello\" and \"World\" into \"HelloWorld\" using strcat. Print the result.\n\n\n16. String Comparison\nRead two strings and print which one comes first in dictionary order (use strcmp).\n\n\n17. Safe Copy with strncpy\nCopy \"C programming\" into a buffer of size 8 using strncpy. Ensure the result is null-terminated, then print it.\n\n\n18. Word Counter (Basic)\nRead a sentence with fgets and count how many words it has (split by spaces). Print the count.\n\n\n19. Longest Word\nExtend the word counter: print the longest word in the sentence.\n\n\n20. Word Frequency\nRead a line of text and count the frequency of each unique word. Print the results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-7.-pointers",
    "href": "index.html#chapter-7.-pointers",
    "title": "The Little Book of C",
    "section": "Chapter 7. Pointers",
    "text": "Chapter 7. Pointers\n\n7.1 What is a Pointer?\nIn C, a pointer is a variable that stores the *address- of another variable.\nThink of it like:\n\nA normal variable stores a value.\nA pointer stores where that value lives in memory.\n\n\nAddresses in Memory\nEvery variable in a program is stored in memory at some location. You can get that location using the address-of operator &.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 42;\n    printf(\"x = %d\\n\", x);\n    printf(\"address of x = %p\\n\", (void-)&x);\n    return 0;\n}\nExample output:\nx = 42\naddress of x = 0x7ffee8c48a7c\n(The exact address will differ.)\n\n\nDeclaring a Pointer\nA pointer variable is declared with -:\nint -p;   // p can hold the address of an int\nTo assign it:\nint x = 42;\nint -p = &x;   // p points to x\n\n\nDereferencing a Pointer\nTo get the value stored at the address, use - again (dereference):\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 42;\n    int -p = &x;\n\n    printf(\"x = %d\\n\", x);\n    printf(\"p points to %p\\n\", (void-)p);\n    printf(\"-p = %d\\n\", -p);   // value at that address\n    return 0;\n}\nOutput:\nx = 42\np points to 0x7ffee8c48a7c\n-p = 42\n\n\nChanging Through a Pointer\nIf you change -p, it changes the original variable:\nint x = 42;\nint -p = &x;\n-p = 99;        // modifies x\nprintf(\"%d\\n\", x);   // prints 99\n\n\nPointers and Types\nThe type of pointer must match the type it points to:\n\nint - → points to int\ndouble - → points to double\nchar - → points to char\n\nThis tells the compiler how to interpret the memory at that address.\n\n\nWhy It Matters\n\nPointers let you work directly with memory.\nThey are essential for arrays, strings, dynamic memory, and data structures.\nUnderstanding pointers is the key to mastering C.\n\n\n\nExercises\n\nDeclare an int x = 5 and a pointer p that points to it. Print both x and -p.\nChange x by assigning to -p instead of x. Print the result.\nDeclare two integers a=10, b=20 and pointers pa, pb. Print their addresses.\nWrite a program that reads an integer into x and prints its address.\nExperiment: declare double y = 3.14 and double -py = &y. Print y, its address, and -py.\n\n\n\n\n7.2 Pointers and Addresses\nIn the last section, we saw that a pointer stores the address of another variable. Now let’s explore that connection more carefully.\n\nVariables and Their Addresses\nEvery variable in C has:\n\nA value - what you store in it.\nAn address - where it lives in memory.\n\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a = 123;\n    printf(\"value = %d\\n\", a);\n    printf(\"address = %p\\n\", (void-)&a);\n    return 0;\n}\n\n\nStoring the Address in a Pointer\nYou can save that address inside a pointer:\nint a = 123;\nint *pa = &a;   // pa points to a\nNow:\n\npa holds the address of a.\n*pa is another way to refer to the value of a.\n\n\n\nVisualizing It\nMemory (simplified):\n a:  123\npa:  &a\nWhen you write *pa, you are saying “follow pa to where it points” → 123.\n\n\nExample: Changing Through a Pointer\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 5;\n    int *p = &x;\n\n    printf(\"x = %d\\n\", x);\n    *p = 42;        // modifies x\n    printf(\"x = %d\\n\", x);\n    return 0;\n}\nOutput:\nx = 5\nx = 42\n\n\nMultiple Pointers to the Same Variable\nMore than one pointer can point to the same place:\nint n = 7;\nint *p1 = &n;\nint *p2 = &n;\n\n*p1 = 99;   // changes n\nprintf(\"%d\\n\", *p2);  // prints 99\n\n\nPointer Assignment\nPointers can be reassigned to point to different variables:\nint a = 10, b = 20;\nint *p = &a;\nprintf(\"*p = %d\\n\", *p);  // 10\n\np = &b;\nprintf(\"*p = %d\\n\", *p);  // 20\n\n\nWhy It Matters\n\nPointers are *names for addresses-.\nThey let functions and data structures share and modify the same memory.\nUnderstanding addresses is essential for arrays, strings, and dynamic memory.\n\n\n\nExercises\n\nDeclare an integer n = 100, and a pointer pn. Print n, &n, pn, and -pn.\nWrite a program where two pointers point to the same integer. Modify the value through one pointer and print it through the other.\nDeclare two integers a and b. Make one pointer point first to a, then to b, printing values each time.\nWrite a program with three integers and an array of pointers (int -ptrs[3]). Make each pointer point to one integer and print their values.\nExperiment: print the size of an int -, double -, and char - using sizeof. Compare the results.\n\n\n\n\n7.3 Arrays and Pointers\nIn C, an array name often behaves like a pointer. Understanding this connection is key to working with strings, loops, and dynamic memory.\n\nArray Name as an Address\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int arr[3] = {10, 20, 30};\n    printf(\"arr = %p\\n\", (void*)arr);\n    printf(\"&arr[0] = %p\\n\", (void*)&arr[0]);\n    return 0;\n}\nOutput (addresses match):\narr = 0x7ffee2c38930\n&arr[0] = 0x7ffee2c38930\nThe name arr is treated as the address of its first element.\n\n\nAccessing with Pointers\nYou can access array elements with either array indexing (arr[i]) or pointer arithmetic (-(arr + i)).\nint arr[3] = {10, 20, 30};\nprintf(\"%d\\n\", arr[1]);       // array indexing\nprintf(\"%d\\n\", -(arr + 1));   // pointer arithmetic\nBoth print 20.\n\n\nUsing a Pointer Variable\nint arr[3] = {10, 20, 30};\nint -p = arr;     // same as &arr[0]\n\nprintf(\"%d\\n\", -p);     // 10\nprintf(\"%d\\n\", -(p+1)); // 20\nprintf(\"%d\\n\", -(p+2)); // 30\n\n\nIterating with a Pointer\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int arr[5] = {2, 4, 6, 8, 10};\n    int -p = arr;\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", -(p+i));\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n\nArrays Are Not Pointers\nAlthough array names -decay- to pointers in most expressions, they are not the same thing:\n\nYou cannot reassign an array name.\nsizeof(arr) gives the full array size, while sizeof(p) (a pointer) gives only the size of the pointer type.\n\nint arr[10];\nint -p = arr;\n\nprintf(\"%zu\\n\", sizeof(arr)); // e.g., 40 (10 ints on 64-bit system)\nprintf(\"%zu\\n\", sizeof(p));   // e.g., 8 (pointer size)\n\n\nStrings and Pointers\nStrings are arrays of char. You can use pointer arithmetic to walk through characters until the null terminator:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char word[] = \"Hello\";\n    char -p = word;\n\n    while (-p != '\\0') {\n        printf(\"%c \", -p);\n        p++;\n    }\n    printf(\"\\n\");\n    return 0;\n}\nOutput:\nH e l l o\n\n\nWhy It Matters\n\nArrays and pointers are two sides of the same coin in C.\nPointers give you flexibility in traversing and manipulating arrays.\nThis connection is the basis for string handling, dynamic memory, and data structures.\n\n\n\nExercises\n\nDeclare int arr[5] = {1,2,3,4,5}. Print all elements using pointer arithmetic (-(arr+i)).\nWrite a function print_array(int -p, int n) that prints all elements of an integer array.\nRead 5 integers into an array, then use a pointer to calculate their sum.\nCreate a string \"C language\" and use a pointer to print each character until '\\0'.\nCompare sizeof(arr) and sizeof(p) where p is a pointer to the array. Print both results.\n\n\n\n\n7.4 Pointers to Functions\nJust as you can have a pointer to a variable, you can also have a pointer to a function. This lets you:\n\nCall functions dynamically,\nPass functions as arguments,\nBuild flexible libraries (like sort with a custom comparison).\n\n\nFunction Names as Addresses\nThe name of a function is its address in memory. So you can assign it to a pointer:\n#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\n\nint main(void) {\n    int (-fp)(int, int) = add;   // fp points to add\n    printf(\"%d\\n\", fp(3, 4));    // call through pointer\n    return 0;\n}\nOutput:\n7\n\n\nDeclaring a Function Pointer\nSyntax:\nreturn_type (-pointer_name)(parameter_types);\nExample:\nint (-f)(int, int);   // f is a pointer to a function taking (int,int) and returning int\n\n\nExample: Multiple Functions\n#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\n\nint main(void) {\n    int (-op)(int, int);\n\n    op = add;\n    printf(\"add: %d\\n\", op(10, 5));\n\n    op = sub;\n    printf(\"sub: %d\\n\", op(10, 5));\n\n    return 0;\n}\n\n\nPassing Function Pointers to Other Functions\n#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint mul(int a, int b) { return a - b; }\n\nvoid compute(int (-f)(int,int), int x, int y) {\n    printf(\"Result = %d\\n\", f(x,y));\n}\n\nint main(void) {\n    compute(add, 3, 4);   // pass add\n    compute(mul, 3, 4);   // pass mul\n    return 0;\n}\nOutput:\nResult = 7\nResult = 12\n\n\nReal-World Example: qsort\nThe C standard library function qsort uses a function pointer for custom comparison:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint cmp_int(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main(void) {\n    int arr[5] = {4, 2, 5, 1, 3};\n    qsort(arr, 5, sizeof(int), cmp_int);\n\n    for (int i = 0; i &lt; 5; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n    return 0;\n}\nOutput:\n1 2 3 4 5\n\n\nWhy It Matters\n\nFunction pointers enable flexibility - functions become data.\nThey are widely used in callbacks, event handlers, sorting, GUIs, and system programming.\nUnderstanding them opens the door to advanced C patterns.\n\n\n\nExercises\n\nWrite two functions: square(int) and cube(int). Use a function pointer to call each.\nWrite a function apply(int (-f)(int), int x) that applies f to x and prints the result.\nWrite an array of function pointers to basic operations (add, sub, mul, div_int) and call each in a loop.\nImplement a program that takes two numbers and an operator (+, -, -, /), then uses function pointers to choose the correct operation.\nUse qsort to sort an array of strings alphabetically. Write a comparison function for strings.\n\n\n\n\n7.5 Safe Pointers in Modern C\nPointers are powerful, but also dangerous. Misusing them can lead to bugs, crashes, or security issues. Modern C (C11–C23) encourages safe pointer practices to reduce risks.\n\nNull Pointers\nA pointer that doesn’t point anywhere should be set to a null pointer.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int -p = NULL;   // points nowhere\n    if (p == NULL) {\n        printf(\"Pointer is null\\n\");\n    }\n    return 0;\n}\n\nNULL vs nullptr in C23\n\nIn older C, NULL is used (defined in &lt;stddef.h&gt;).\nC23 introduces nullptr (similar to C++), making null checks safer and clearer:\n\nint -p = nullptr;\nif (p == nullptr) { /- safe -/ }\n\n\n\nDangling Pointers\nA pointer becomes dangling if the variable it points to goes out of scope.\nint -bad_pointer(void) {\n    int x = 10;\n    return &x;   // ❌ ERROR: x no longer exists after function ends\n}\nRule: never return a pointer to a local variable.\n\n\nWild Pointers\nA pointer that is uninitialized may point to random memory:\nint -p;  // ❌ uninitialized\n-p = 42; // undefined behavior\nAlways initialize pointers: either to a valid address or NULL/nullptr.\n\n\nDouble Free\nIf you free the same memory twice, the program may crash.\nint -p = malloc(sizeof(int));\nfree(p);\nfree(p);   // ❌ undefined behavior\nSolution: after freeing, set p = NULL (or nullptr).\n\n\nPointer Bounds\nPointers don’t carry length information. Accessing outside an array is undefined:\nint arr[3] = {1,2,3};\nint -p = arr;\nprintf(\"%d\\n\", -(p+3)); // ❌ out of bounds\nAlways check bounds when iterating.\n\n\nSafer Practices\n\nInitialize pointers - set to nullptr or valid address.\nCheck before use - don’t dereference a null pointer.\nDon’t return locals - never return a pointer to a local variable.\nSet freed pointers to null - avoid double free.\nUse const pointers if data should not change:\nconst char *msg = \"Hello\"; // prevents accidental modification\n\n\n\nA Full Example\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int *p = nullptr;       // safe initialization\n    p = malloc(sizeof(int));\n    if (p == nullptr) {     // check allocation\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    *p = 42;\n    printf(\"Value = %d\\n\", *p);\n\n    free(p);\n    p = nullptr;            // avoid dangling pointer\n\n    return 0;\n}\n\n\nWhy It Matters\n\nPointers are the sharpest tool in C: essential but risky.\nSafe usage prevents segmentation faults, memory leaks, and security vulnerabilities.\nC23’s nullptr makes code clearer and harder to misuse.\n\n\n\nExercises\n\nDeclare an uninitialized pointer, then fix it by setting it to nullptr. Print a check to confirm.\nWrite a function that safely allocates an integer, sets it to 10, prints it, and frees it.\nDemonstrate a dangling pointer bug by returning the address of a local variable. Then fix it.\nAllocate an array of 5 integers with malloc, set them to 1–5, print them, then free.\nExperiment: free a pointer twice without resetting it (observe crash/UB). Then fix it by setting to nullptr.\n\n\n\n\nProblems\n\n1. Basic Pointer Access\nDeclare int x = 10 and a pointer p to it. Print x, the address of x, the value of p, and -p.\n\n\n2. Modify Through a Pointer\nStart with int x = 5. Use a pointer to change its value to 42. Print both x and -p.\n\n\n3. Two Pointers, One Variable\nMake two pointers point to the same integer. Change the integer through the first pointer, and print it through the second.\n\n\n4. Pointer Reassignment\nDeclare two integers a=10, b=20 and one pointer p. First point p to a, then to b, printing values each time.\n\n\n5. Array with Pointer Arithmetic\nDeclare int arr[5] = {1,2,3,4,5}. Use pointer arithmetic (-(arr+i)) to print all elements.\n\n\n6. Sum with Pointer Traversal\nRead 5 integers into an array. Use a pointer to calculate their sum.\n\n\n7. Print String via Pointer\nDeclare char word[] = \"Pointers\". Use a pointer to walk through the string character by character until '\\0'.\n\n\n8. Compare Array vs Pointer Sizes\nDeclare int arr[10] and int -p = arr. Print sizeof(arr) and sizeof(p) to see the difference.\n\n\n9. Function Pointer Basics\nWrite two functions: int square(int) and int cube(int). Declare a function pointer and use it to call each function.\n\n\n10. Function Pointer as Argument\nWrite a function apply(int (-f)(int), int x) that applies f to x and prints the result. Test with both square and cube.\n\n\n11. Array of Function Pointers\nCreate an array of function pointers to four functions: add, sub, mul, div_int. Call each in a loop with two numbers.\n\n\n12. Operator with Function Pointer\nWrite a calculator program: read two integers and an operator (+ - - /), then use function pointers to call the correct operation.\n\n\n13. Safe Null Pointer\nDeclare an int -p = nullptr (or NULL). Print a message if the pointer is null.\n\n\n14. Dangling Pointer Demo\nWrite a function that returns the address of a local variable (dangling pointer). Call it and print the result to observe the bug. Then fix it by using malloc.\n\n\n15. Wild Pointer Example\nDeclare an uninitialized pointer and try dereferencing it (expect crash/UB). Then fix it by proper initialization.\n\n\n16. Double Free Experiment\nAllocate an integer with malloc, free it twice (expect UB). Then fix it by setting the pointer to nullptr after free.\n\n\n17. Safe Dynamic Array\nAllocate an array of 5 integers with malloc, fill with values 1–5, print them, then free safely.\n\n\n18. Struct with Pointer\nDefine a struct Point { int x,y; }. Create one instance and a pointer to it. Use the pointer with -&gt; to print and modify values.\n\n\n19. Passing Pointers to Functions\nWrite a function void swap(int *a, int -b) that swaps two integers using pointers. Demonstrate it in main.\n\n\n20. Function Pointer with qsort\nUse qsort to sort an array of integers. Write a comparison function and pass it as a function pointer.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-8.-structs-and-enums",
    "href": "index.html#chapter-8.-structs-and-enums",
    "title": "The Little Book of C",
    "section": "Chapter 8. Structs and Enums",
    "text": "Chapter 8. Structs and Enums\nHere’s Chapter 8.1: Grouping Data with struct, the first step into C’s way of building custom data types.\n\n8.1 Grouping Data with struct\nSo far, we’ve worked with simple types: int, double, char, arrays, and pointers. But real-world programs often deal with things that have multiple properties.\nExample:\n\nA point has both an -x- and -y- coordinate.\nA student has a name-, age-, and *grade-.\nA book has a -title-, *author-, and -year-.\n\nIn C, we can bundle related values into one structure using the keyword struct.\n\nDeclaring a struct\nstruct Point {\n    int x;\n    int y;\n};\nThis defines a new type struct Point with two fields: x and y.\n\n\nCreating Variables\nstruct Point p1;\np1.x = 3;\np1.y = 4;\nYou can also initialize at once:\nstruct Point p2 = {10, 20};\n\n\nAccessing Fields\nUse the dot operator (.):\n#include &lt;stdio.h&gt;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main(void) {\n    struct Point p = {5, 7};\n    printf(\"x=%d y=%d\\n\", p.x, p.y);\n    return 0;\n}\nOutput:\nx=5 y=7\n\n\nExample: Student Record\n#include &lt;stdio.h&gt;\n\nstruct Student {\n    char name[50];\n    int age;\n    double grade;\n};\n\nint main(void) {\n    struct Student s = {\"Alice\", 20, 3.8};\n    printf(\"Name: %s\\n\", s.name);\n    printf(\"Age: %d\\n\", s.age);\n    printf(\"Grade: %.2f\\n\", s.grade);\n    return 0;\n}\nOutput:\nName: Alice\nAge: 20\nGrade: 3.80\n\n\nArrays of Structs\nYou can create an array of structs, just like an array of ints:\nstruct Point points[3] = {\n    {1, 2},\n    {3, 4},\n    {5, 6}\n};\nLoop through them:\nfor (int i = 0; i &lt; 3; i++) {\n    printf(\"(%d,%d)\\n\", points[i].x, points[i].y);\n}\n\n\nWhy It Matters\n\nStructures let you represent real-world entities in code.\nThey keep related values together, making programs more organized and readable.\nAlmost every serious C program uses struct for data modeling.\n\n\n\nExercises\n\nDefine a struct Point with fields x and y. Create one, set values, and print them.\nDefine a struct Student with name, age, and gpa. Initialize and print it.\nCreate an array of 3 struct Points and print their coordinates.\nWrite a program that reads a student’s name, age, and grade into a struct and prints them back.\nDefine a struct Rectangle with width and height. Write a function area that takes a rectangle and returns its area.\n\n\n\n\n8.2 Using typedef\nWhen you declare a struct, you normally have to write the keyword struct every time:\nstruct Point {\n    int x;\n    int y;\n};\n\nstruct Point p1 = {3, 4};\nThis can get repetitive, especially in large programs. C provides typedef to create a shorter alias for a type.\n\nBasic typedef\ntypedef struct Point {\n    int x;\n    int y;\n} Point;\nNow you can write:\nPoint p1 = {3, 4};\ninstead of struct Point p1.\n\n\nExample: Cleaner Code\n#include &lt;stdio.h&gt;\n\ntypedef struct {\n    char name[50];\n    int age;\n    double gpa;\n} Student;\n\nint main(void) {\n    Student s = {\"Alice\", 20, 3.8};\n    printf(\"%s, %d years, GPA=%.2f\\n\", s.name, s.age, s.gpa);\n    return 0;\n}\nNotice: no need to say struct Student, just Student.\n\n\nTypedef with Pointers\ntypedef is also useful for pointer types:\ntypedef struct Point {\n    int x, y;\n} Point;\n\ntypedef Point- PointPtr;\n\nint main(void) {\n    Point a = {1, 2};\n    PointPtr p = &a;\n    printf(\"(%d,%d)\\n\", p-&gt;x, p-&gt;y);\n    return 0;\n}\n\n\nTypedef vs. struct\n\nWithout typedef:\nstruct Point a;\nWith typedef:\nPoint a;\n\nBoth create the same kind of variable. Typedef just saves typing.\n\n\nWhy It Matters\n\nMakes code shorter and cleaner.\nCommon in APIs and libraries to simplify complex type names.\nImproves readability by giving meaningful names (e.g., Point, Student, Matrix).\n\n\n\nExercises\n\nRewrite the struct Point example from 8.1 using typedef.\nDefine a typedef for struct Rectangle { int w,h; } as Rectangle. Write a function that takes a Rectangle and returns its area.\nDefine a typedef for a pointer to Student. Create a Student and print values using the pointer.\nCreate a typedef for unsigned long long called BigInt. Use it to compute factorial of 10.\nExperiment: write a typedef for a function pointer int (-Op)(int,int) and use it for add/subtract functions.\n\n\n\n\n8.3 Enumerations\nSometimes you need a variable that can take one of a small set of related values:\n\nDays of the week\nTraffic light colors\nError codes\n\nIn C, you can define these with enumerations, using the keyword enum.\n\nDeclaring an enum\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n};\nThis defines RED = 0, GREEN = 1, BLUE = 2.\n\n\nUsing an enum\n#include &lt;stdio.h&gt;\n\nenum Color { RED, GREEN, BLUE };\n\nint main(void) {\n    enum Color c = GREEN;\n    if (c == GREEN) {\n        printf(\"Go!\\n\");\n    }\n    return 0;\n}\nOutput:\nGo!\n\n\nCustom Values\nYou can assign specific integer values:\nenum Status {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n};\nNow OK = 200, NOT_FOUND = 404, etc.\n\n\nSequential Values\nUnspecified values continue from the last one:\nenum Weekday {\n    MON = 1,  // start from 1\n    TUE,      // 2\n    WED,      // 3\n    THU, FRI, SAT, SUN\n};\n\n\ntypedef with enum\nYou can combine typedef with enum to simplify usage:\ntypedef enum {\n    RED, GREEN, BLUE\n} Color;\n\nint main(void) {\n    Color c = BLUE;\n    printf(\"Color = %d\\n\", c);\n    return 0;\n}\n\n\nExample: Traffic Light\n#include &lt;stdio.h&gt;\n\ntypedef enum {\n    RED, YELLOW, GREEN\n} TrafficLight;\n\nint main(void) {\n    TrafficLight light = RED;\n\n    if (light == RED) {\n        printf(\"Stop\\n\");\n    } else if (light == GREEN) {\n        printf(\"Go\\n\");\n    } else {\n        printf(\"Wait\\n\");\n    }\n    return 0;\n}\n\n\nWhy It Matters\n\nEnums make code clearer and safer than using raw integers.\nUseful for fixed sets of options.\nOften combined with switch statements for clean logic.\n\n\n\nExercises\n\nDefine an enum Weekday with values for Monday–Sunday. Write a program that prints the number for Wednesday.\nDefine an enum TrafficLight { RED=1, YELLOW=2, GREEN=3 }. Write a program that prints \"Stop\" for RED, \"Wait\" for YELLOW, \"Go\" for GREEN.\nUse typedef enum to define Color with values {RED, GREEN, BLUE}. Declare a variable and print its integer value.\nCreate an enum ErrorCode { OK=0, FAIL=1, TIMEOUT=2 } and use a switch to print an error message for each code.\nExtend the Weekday enum so that MON=1, and write a loop to print all days with their numbers.\n\n\n\n\n8.4 union (and when to use it)\nA union is like a struct, but instead of giving each member its own storage, all members share the same memory location.\n\nAt any moment, only one member holds a valid value.\nThe size of a union is the size of its largest member.\n\n\nDeclaring a Union\nunion Number {\n    int i;\n    float f;\n};\nThis defines a type union Number with two possible views of the same memory.\n\n\nExample: One at a Time\n#include &lt;stdio.h&gt;\n\nunion Number {\n    int i;\n    float f;\n};\n\nint main(void) {\n    union Number n;\n    n.i = 42;\n    printf(\"i = %d\\n\", n.i);\n\n    n.f = 3.14f;          // overwrites same memory\n    printf(\"f = %.2f\\n\", n.f);\n    printf(\"i (garbled) = %d\\n\", n.i); // old value no longer valid\n    return 0;\n}\nOutput:\ni = 42\nf = 3.14\ni (garbled) = some unpredictable value\n\n\nMemory Layout\nunion Number:\n+----------------+\n| same memory    |  &lt;-- interpreted as int or float\n+----------------+\n\n\nPractical Use: Variant Data\nUnions are useful when a value could be one of several types.\nExample: storing a number that might be int, float, or double.\n#include &lt;stdio.h&gt;\n\ntypedef union {\n    int i;\n    float f;\n    double d;\n} Value;\n\nint main(void) {\n    Value v;\n    v.d = 12.34;\n    printf(\"double = %.2f\\n\", v.d);\n    return 0;\n}\n\n\nWith enum + struct\nTo track which type is active, combine union with an enum:\n#include &lt;stdio.h&gt;\n\ntypedef enum { INT, FLOAT } Tag;\n\ntypedef struct {\n    Tag type;\n    union {\n        int i;\n        float f;\n    } data;\n} Variant;\n\nint main(void) {\n    Variant v;\n    v.type = INT;\n    v.data.i = 42;\n\n    if (v.type == INT) {\n        printf(\"int=%d\\n\", v.data.i);\n    } else {\n        printf(\"float=%.2f\\n\", v.data.f);\n    }\n    return 0;\n}\n\n\nWhy It Matters\n\nunion saves memory by reusing space.\nIt’s the foundation of variant types and low-level data handling.\nUseful when interfacing with hardware, binary files, or protocols where the same data may mean different things.\n\n\n\nExercises\n\nDefine a union Data with int i and float f. Assign and print each in turn.\nWrite a program that stores a value in a union as int, then as float, and prints both. Observe how the second overwrites the first.\nCombine enum and union to represent a number that may be either int or float. Print it safely depending on the tag.\nCreate a union with char c[4] and int n. Assign to n and then print each c[i] (observe byte-level representation).\nDefine a union Value { int i; double d; }. Write a program that sets the double value and prints the size of the union using sizeof.\n\n\n\n\n8.5 A Simple Contact Book\nWe’ve learned how to group data with struct, simplify with typedef, and handle arrays. Now let’s put it all together in a small project: a contact book program.\n\nDefining the Contact Structure\n#include &lt;stdio.h&gt;\n\ntypedef struct {\n    char name[50];\n    char phone[20];\n    int age;\n} Contact;\nEach Contact stores a name, phone number, and age.\n\n\nCreating an Array of Contacts\nWe’ll store multiple contacts in an array:\n#define MAX_CONTACTS 5\nContact contacts[MAX_CONTACTS];\nint count = 0;  // how many we’ve added\n\n\nAdding a Contact\nvoid add_contact(Contact list[], int *count, const char *name, const char -phone, int age) {\n    if (*count &lt; MAX_CONTACTS) {\n        snprintf(list[*count].name, sizeof(list[*count].name), \"%s\", name);\n        snprintf(list[*count].phone, sizeof(list[*count].phone), \"%s\", phone);\n        list[*count].age = age;\n        (*count)++;\n    }\n}\n\n\nPrinting Contacts\nvoid print_contacts(const Contact list[], int count) {\n    for (int i = 0; i &lt; count; i++) {\n        printf(\"%s, %s, %d years\\n\", list[i].name, list[i].phone, list[i].age);\n    }\n}\n\n\nFull Example\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    char name[50];\n    char phone[20];\n    int age;\n} Contact;\n\n#define MAX_CONTACTS 5\n\nvoid add_contact(Contact list[], int *count, const char *name, const char -phone, int age) {\n    if (*count &lt; MAX_CONTACTS) {\n        snprintf(list[*count].name, sizeof(list[*count].name), \"%s\", name);\n        snprintf(list[*count].phone, sizeof(list[*count].phone), \"%s\", phone);\n        list[*count].age = age;\n        (*count)++;\n    }\n}\n\nvoid print_contacts(const Contact list[], int count) {\n    for (int i = 0; i &lt; count; i++) {\n        printf(\"%s, %s, %d years\\n\", list[i].name, list[i].phone, list[i].age);\n    }\n}\n\nint main(void) {\n    Contact contacts[MAX_CONTACTS];\n    int count = 0;\n\n    add_contact(contacts, &count, \"Alice\", \"123-4567\", 20);\n    add_contact(contacts, &count, \"Bob\", \"555-9876\", 25);\n\n    print_contacts(contacts, count);\n\n    return 0;\n}\nOutput:\nAlice, 123-4567, 20 years\nBob, 555-9876, 25 years\n\n\nWhy It Matters\n\nShows how structs can model real-world objects.\nDemonstrates typedef, arrays, and function reuse.\nThis pattern (define a type → store in array → process with functions) is the basis of larger applications like databases and address books.\n\n\n\nExercises\n\nAdd a function find_contact(Contact list[], int count, const char *name) that searches for a contact by name.\nAdd a function delete_contact(Contact list[], int *count, const char *name) that removes a contact.\nExtend Contact with an email field. Update add_contact and print_contacts.\nIncrease MAX_CONTACTS to 100 and let the program read contacts from user input instead of hardcoding.\nSave the contacts to a text file using fprintf and reload them with fscanf.\n\n\n\n\nProblems\n\n1. Basic Point Struct\nDefine a struct Point with x and y fields. Create one, set values, and print them.\n\n\n2. Student Record\nDefine a struct Student with name, age, and gpa. Initialize one student and print their details.\n\n\n3. Array of Structs\nCreate an array of 3 struct Points and print their coordinates.\n\n\n4. Input into Struct\nWrite a program that reads a student’s name, age, and gpa from the user into a struct and prints them back.\n\n\n5. Rectangle Area\nDefine a struct Rectangle with width and height. Write a function that takes a Rectangle and returns its area.\n\n\n6. Using typedef for Point\nRewrite the struct Point example using typedef so you can declare variables as Point p instead of struct Point p.\n\n\n7. Typedef with Pointers\nDefine a typedef for struct Student as Student, and another typedef StudentPtr for a pointer to Student. Create a student and print values through the pointer.\n\n\n8. Typedef Alias for Primitive\nCreate a typedef called BigInt for unsigned long long. Use it to compute factorial of 10.\n\n\n9. Enum for Weekdays\nDefine an enum Weekday with values for Monday–Sunday (starting at 1). Print the integer value for Wednesday.\n\n\n10. Enum for Traffic Light\nDefine an enum TrafficLight { RED=1, YELLOW=2, GREEN=3 }. Write a program that prints \"Stop\", \"Wait\", or \"Go\" depending on the enum value.\n\n\n11. Enum with Switch\nDefine an enum ErrorCode { OK=0, FAIL=1, TIMEOUT=2 } and use a switch to print a message for each code.\n\n\n12. Enum Loop\nUse the Weekday enum from problem 9. Write a loop to print all days with their numeric values.\n\n\n13. Basic Union\nDefine a union Data with int i and float f. Assign and print each in turn. Observe how one overwrites the other.\n\n\n14. Union with Char Array\nCreate a union with char c[4] and int n. Assign to n and then print each c[i] (observe byte-level representation).\n\n\n15. Tagged Union\nCombine enum and union into a Variant type that may hold either an int or a float. Write a program that sets and prints both kinds safely depending on the tag.\n\n\n16. Contact Struct Array\nDefine a struct Contact { char name[50]; char phone[20]; int age; }. Create an array of 3 contacts, initialize them, and print all.\n\n\n17. Contact Functions\nWrite a function add_contact that inserts a new contact into an array, and print_contacts that prints them. Test with 2–3 contacts.\n\n\n18. Find Contact by Name\nExtend problem 17 with a function find_contact that searches for a contact by name and prints their details.\n\n\n19. Delete Contact\nExtend problem 18 with a function delete_contact that removes a contact by shifting later ones down. Print the updated list.\n\n\n20. Save and Load Contacts\nWrite a program that saves contacts from an array to a text file with fprintf and reloads them with fscanf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-9.-memory-management",
    "href": "index.html#chapter-9.-memory-management",
    "title": "The Little Book of C",
    "section": "Chapter 9. Memory Management",
    "text": "Chapter 9. Memory Management\n\n9.1 Automatic vs. Dynamic Memory\nEvery program needs memory to store variables, arrays, and data. In C, there are two main categories of memory you’ll work with:\n\nAutomatic memory (stack)\nDynamic memory (heap)\n\nUnderstanding the difference is essential for writing reliable and efficient C programs.\n\nAutomatic Memory (Stack)\n\nVariables declared inside a function (without malloc) are automatic.\nTheir lifetime is tied to the function call.\nThey are created when the function begins, and destroyed when it ends.\n\nExample:\n#include &lt;stdio.h&gt;\n\nvoid hello(void) {\n    int x = 42;  // automatic variable\n    printf(\"x = %d\\n\", x);\n} // x no longer exists here\n\nint main(void) {\n    hello();\n    // printf(\"%d\", x);  // ❌ error: x is out of scope\n    return 0;\n}\nAutomatic variables are usually stored on the stack, a region of memory managed by the compiler.\n\n\nDynamic Memory (Heap)\n\nAllocated at runtime with functions like malloc and free.\nLifetime is controlled by the programmer (until explicitly freed).\nUseful when you don’t know the needed size at compile time.\n\nExample:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int -p = malloc(sizeof(int));  // dynamic allocation\n    if (p == NULL) return 1;       // always check\n    -p = 42;\n    printf(\"-p = %d\\n\", -p);\n    free(p);                       // must free after use\n    return 0;\n}\n\n\nComparing the Two\n\n\n\nAspect\nAutomatic (stack)\nDynamic (heap)\n\n\n\n\nLifetime\nEnds when function ends\nUntil free is called\n\n\nAllocation\nCompiler-managed\nProgrammer-managed (malloc)\n\n\nSpeed\nVery fast\nSlower\n\n\nSize\nUsually small, fixed\nPotentially large, flexible\n\n\n\n\n\nExample: Fixed vs. Flexible Arrays\nAutomatic array:\nint arr[100];  // size fixed at compile time\nDynamic array:\nint n;\nscanf(\"%d\", &n);\nint *arr = malloc(n - sizeof(int));  // size chosen at runtime\n\n\nWhy It Matters\n\nAutomatic memory is simple, but limited to function lifetimes and fixed sizes.\nDynamic memory gives flexibility, but requires discipline: every malloc should have a matching free.\nChoosing the right kind of memory is a fundamental design decision in C programs.\n\n\n\nExercises\n\nWrite a function that declares an automatic variable, assigns it a value, and prints it. Call the function twice - what do you observe?\nAllocate an int dynamically, assign it 99, print it, then free it.\nWrite a program that asks the user for n, allocates an array of n integers dynamically, fills it with 1..n, and prints them.\nExperiment: try to use a pointer to an automatic variable after the function returns. Why is this unsafe?\nCompare the sizes of a stack array (int a[1000];) and a dynamically allocated array (malloc(1000-sizeof(int))). Use sizeof and print results.\n\n\n\n\n9.2 malloc, calloc, free\nC gives you explicit control over memory allocation. The three most important functions are:\n\nmalloc - allocate memory\ncalloc - allocate and clear memory\nfree - release memory\n\nAll are declared in &lt;stdlib.h&gt;.\n\nmalloc - Allocate Memory\n#include &lt;stdlib.h&gt;\nvoid -malloc(size_t size);\n\nAllocates a block of memory of given size (in bytes).\nReturns a pointer to the beginning of the block, or NULL if it fails.\nContents of the memory are uninitialized (garbage).\n\nExample:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int -p = malloc(5 - sizeof(int));\n    if (!p) return 1;  // check allocation\n    for (int i = 0; i &lt; 5; i++) p[i] = i+1;\n    for (int i = 0; i &lt; 5; i++) printf(\"%d \", p[i]);\n    printf(\"\\n\");\n    free(p);\n    return 0;\n}\n\n\ncalloc - Allocate and Clear\n#include &lt;stdlib.h&gt;\nvoid -calloc(size_t n, size_t size);\n\nAllocates memory for an array of n elements, each of size bytes.\nInitializes all bits to zero.\n\nExample:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int -p = calloc(5, sizeof(int));\n    if (!p) return 1;\n    for (int i = 0; i &lt; 5; i++) printf(\"%d \", p[i]); // all zero\n    printf(\"\\n\");\n    free(p);\n    return 0;\n}\nOutput:\n0 0 0 0 0\n\n\nfree - Release Memory\n#include &lt;stdlib.h&gt;\nvoid free(void -ptr);\n\nReleases a block of memory previously allocated by malloc or calloc.\nDoes nothing if ptr == NULL.\nAccessing memory after free is undefined behavior.\n\nExample:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int -p = malloc(3 - sizeof(int));\n    if (!p) return 1;\n    p[0]=1; p[1]=2; p[2]=3;\n    free(p);\n    // p is now dangling - should set to NULL\n    p = NULL;\n    return 0;\n}\n\n\nCommon Mistakes\n❌ Forgetting to call free → memory leak ❌ Using memory after free → dangling pointer ❌ Freeing twice → double free error\nAlways follow the pattern:\np = malloc(...);\nif (!p) { /- handle error -/ }\n...\nfree(p);\np = NULL;\n\n\nWhy It Matters\n\nmalloc and calloc let programs create data structures that grow and shrink at runtime.\nfree ensures memory is returned to the system.\nCorrect memory management is crucial in C - there is no garbage collector.\n\n\n\nExercises\n\nUse malloc to allocate space for an array of 10 integers, fill with squares of 1..10, and print them.\nRepeat using calloc and observe the difference in initialization.\nAllocate an array of double of size entered by the user, set all to 3.14, and print.\nWrite a program that allocates memory, frees it, then tries to use it again (observe error). Fix it by setting pointer to NULL.\nCreate a dynamic 2D array (array of int-) with 3 rows and 4 columns using malloc. Fill it with numbers and print as a matrix.\n\n\n\n\n9.3 Pointer Pitfalls (and how to avoid them)\nPointers give you power over memory - but with great power comes great responsibility. Misusing pointers often leads to undefined behavior, crashes, or security bugs. Here are the most common pitfalls and how to avoid them.\n\n1. Dangling Pointers\nA dangling pointer points to memory that is no longer valid.\nExample: returning a pointer to a local variable:\nint- bad(void) {\n    int x = 42;\n    return &x;   // ❌ invalid after function ends\n}\nFix: Allocate dynamically or pass results back by value.\nint- good(void) {\n    int -p = malloc(sizeof(int));\n    if (p) -p = 42;\n    return p;   // caller must free\n}\n\n\n2. Memory Leaks\nA memory leak happens when you lose all references to allocated memory without freeing it.\nint -p = malloc(100 - sizeof(int));\np = NULL;  // ❌ leak: cannot free the memory anymore\nFix: Always free before overwriting pointers.\nfree(p);\np = NULL;\n\n\n3. Double Free\nFreeing the same memory twice can corrupt the heap.\nint -p = malloc(sizeof(int));\nfree(p);\nfree(p);   // ❌ undefined behavior\nFix: After free, set pointer to NULL. Freeing a null pointer is safe.\n\n\n4. Using After Free\nAccessing memory after it’s been freed:\nint -p = malloc(sizeof(int));\n-p = 7;\nfree(p);\nprintf(\"%d\\n\", -p); // ❌ use*after-free\nFix: Never dereference freed pointers. Set them to NULL to prevent accidental use.\n\n\n5. Out-of-Bounds Access\nArrays don’t track their size. Accessing outside is undefined.\nint a[5] = {1,2,3,4,5};\nprintf(\"%d\\n\", a[5]);  // ❌ out of bounds\nFix: Always check indices against array bounds.\n\n\n6. Uninitialized Pointers\nA pointer not assigned an address may point anywhere.\nint -p;   // uninitialized\n-p = 5;   // ❌ random crash\nFix: Initialize pointers to NULL or valid memory.\n\n\nChecklist for Safe Pointers\n\nInitialize all pointers.\nCheck return value of malloc/calloc.\nfree every allocation, exactly once.\nSet pointers to NULL after free.\nAlways check bounds when indexing arrays.\n\n\n\nExample: Safe Allocation Pattern\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    int n = 5;\n    int *a = malloc(n - sizeof(int));\n    if (!a) return 1;   // check for failure\n\n    for (int i = 0; i &lt; n; i++) a[i] = i - i;\n    for (int i = 0; i &lt; n; i++) printf(\"%d \", a[i]);\n    printf(\"\\n\");\n\n    free(a);\n    a = NULL;           // prevent dangling\n    return 0;\n}\n\n\nWhy It Matters\n\nPointer mistakes are a leading cause of bugs in C programs.\nUndefined behavior may look harmless in small tests, but break programs later.\nSafe habits (null checks, freeing, bounds checking) make C code much more robust.\n\n\n\nExercises\n\nWrite a function that returns a pointer to a local variable. Run it and observe. Then fix it with malloc.\nCreate a program that allocates memory but forgets to free. Use a loop to make the leak visible. Then fix it.\nDemonstrate a double free and then fix it with p = NULL.\nWrite a program that reads n, allocates an array of size n, and prints it. Add a check for out-of-bounds access.\nExperiment: declare an uninitialized pointer and dereference it. Then fix by initializing with NULL and checking before use.\n\n\n\n\n9.4 Safer Allocations in C23 (aligned_alloc, nullptr)\nC23 introduced improvements that make memory management less error-prone. Two key features are:\n\naligned_alloc - request memory with a specific alignment\nnullptr - a new null pointer constant\n\n\naligned_alloc\nNormal malloc returns memory suitable for any type, but sometimes you need aligned memory (e.g., for SIMD instructions, hardware buffers).\nPrototype (in &lt;stdlib.h&gt;):\nvoid *aligned_alloc(size_t alignment, size_t size);\n\nalignment must be a power of two (e.g., 16, 32).\nsize must be a multiple of alignment.\nReturns NULL on failure.\n\n\n\nExample: Allocate 32-byte aligned array\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    size_t n = 8;\n    int *a = aligned_alloc(32, n - sizeof(int));\n    if (!a) return 1;\n    for (size_t i = 0; i &lt; n; i++) a[i] = i;\n    for (size_t i = 0; i &lt; n; i++) printf(\"%d \", a[i]);\n    printf(\"\\n\");\n    free(a);\n    return 0;\n}\n\n\nnullptr\nTraditionally, C used NULL (defined as ((void-)0) or 0) to represent a null pointer. This could be confusing because 0 is also an integer.\nC23 introduces nullptr as a dedicated null pointer constant.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int -p = nullptr;  // safe null initialization\n    if (p == nullptr) {\n        printf(\"Pointer is null\\n\");\n    }\n    return 0;\n}\n\n\nWhy nullptr is safer:\n\nNo confusion with integers.\nMakes code more readable.\nAligns C with modern C++ style.\n\n\n\nSafer Practices in C23\n\nPrefer nullptr instead of NULL.\nUse aligned_alloc when alignment matters (e.g., vectorized math, GPU buffers).\nAlways check for allocation failure:\nif (p == nullptr) { /- handle error -/ }\n\n\n\nWhy It Matters\n\naligned_alloc enables performance optimizations with aligned memory.\nnullptr avoids common bugs with NULL being treated as integer 0.\nTogether, they represent a step toward safer, clearer C code.\n\n\n\nExercises\n\nAllocate a dynamic array of 16 ints using aligned_alloc(16, …). Fill and print it.\nWrite a program that initializes a pointer with nullptr and checks it before use.\nCompare p = NULL; and p = nullptr; in a simple program. Print the result of (p == 0).\nAllocate a block of 64 bytes with alignment 32. Print its address to confirm divisibility by 32.\nWrite a program that combines both: initialize a pointer with nullptr, then allocate aligned memory and use it.\n\n\n\n\n9.5 A Mini Dynamic Array Implementation\nDynamic arrays are one of the most common data structures. In C, there is no built-in “vector” type like in C++ - but we can build one using pointers, malloc, realloc, and free.\n\nStep 1: Define a Struct for the Array\nWe need to track:\n\nA pointer to the data\nThe number of elements (size)\nThe capacity (allocated space)\n\n#include &lt;stddef.h&gt;  // for size_t\n\ntypedef struct {\n    int -data;\n    size_t size;\n    size_t capacity;\n} DynArray;\n\n\nStep 2: Initialize\n#include &lt;stdlib.h&gt;\n\nvoid init_array(DynArray *a, size_t initial_capacity) {\n    a-&gt;data = malloc(initial_capacity - sizeof(int));\n    a-&gt;size = 0;\n    a-&gt;capacity = (a-&gt;data ? initial_capacity : 0);\n}\n\n\nStep 3: Add Elements (Resize if Full)\n#include &lt;string.h&gt;\n\nint push_back(DynArray *a, int value) {\n    if (a-&gt;size == a-&gt;capacity) {\n        size_t new_capacity = (a-&gt;capacity == 0) ? 1 : a-&gt;capacity - 2;\n        int -new_data = realloc(a-&gt;data, new_capacity - sizeof(int));\n        if (!new_data) return 0;  // fail\n        a-&gt;data = new_data;\n        a-&gt;capacity = new_capacity;\n    }\n    a-&gt;data[a-&gt;size++] = value;\n    return 1; // success\n}\n\n\nStep 4: Free the Array\nvoid free_array(DynArray *a) {\n    free(a-&gt;data);\n    a-&gt;data = NULL;\n    a-&gt;size = 0;\n    a-&gt;capacity = 0;\n}\n\n\nStep 5: Example Program\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int -data;\n    size_t size;\n    size_t capacity;\n} DynArray;\n\nvoid init_array(DynArray *a, size_t initial_capacity) {\n    a-&gt;data = malloc(initial_capacity - sizeof(int));\n    a-&gt;size = 0;\n    a-&gt;capacity = (a-&gt;data ? initial_capacity : 0);\n}\n\nint push_back(DynArray *a, int value) {\n    if (a-&gt;size == a-&gt;capacity) {\n        size_t new_capacity = (a-&gt;capacity == 0) ? 1 : a-&gt;capacity - 2;\n        int -new_data = realloc(a-&gt;data, new_capacity - sizeof(int));\n        if (!new_data) return 0;\n        a-&gt;data = new_data;\n        a-&gt;capacity = new_capacity;\n    }\n    a-&gt;data[a-&gt;size++] = value;\n    return 1;\n}\n\nvoid free_array(DynArray *a) {\n    free(a-&gt;data);\n    a-&gt;data = NULL;\n    a-&gt;size = 0;\n    a-&gt;capacity = 0;\n}\n\nint main(void) {\n    DynArray arr;\n    init_array(&arr, 2);\n\n    for (int i = 1; i &lt;= 10; i++) {\n        push_back(&arr, i - i);\n    }\n\n    for (size_t i = 0; i &lt; arr.size; i++) {\n        printf(\"%d \", arr.data[i]);\n    }\n    printf(\"\\n\");\n\n    free_array(&arr);\n    return 0;\n}\nOutput:\n1 4 9 16 25 36 49 64 81 100\n\n\nWhy It Matters\n\nShows how to build a resizable container in C.\nDemonstrates safe use of malloc, realloc, and free.\nThis pattern underlies real libraries like glib dynamic arrays or C++ vectors.\n\n\n\nExercises\n\nExtend the DynArray with a function get(DynArray *a, size_t index) that safely returns an element (or error).\nWrite a function pop_back that removes the last element.\nModify push_back so that it shrinks the array when too empty (optional).\nStore double instead of int. What changes?\nWrite a small program that reads numbers from the user until EOF and stores them in a DynArray. Print them back.\n\n\n\n\nProblems\n\n1. Automatic Variable Lifetime\nWrite a function that declares an automatic variable, assigns it a value, and prints it. Call the function twice. What do you observe?\n\n\n2. Pointer to Automatic Variable\nWrite a function that returns a pointer to a local variable. Use it in main. What happens? Fix it with malloc.\n\n\n3. Simple malloc Allocation\nUse malloc to allocate space for an integer, assign it 42, print it, and then free the memory.\n\n\n4. Array with malloc\nAsk the user for n, allocate an array of n integers with malloc, fill with 1..n, and print them. Free the memory afterward.\n\n\n5. Array with calloc\nRepeat problem 4, but use calloc. Print the values right after allocation to show they are initialized to zero.\n\n\n6. Compare malloc vs. calloc\nAllocate the same array with malloc and calloc. Print the contents before writing anything. What’s the difference?\n\n\n7. Freeing and Reusing Memory\nAllocate memory for an integer, free it, then try to use it again. What happens? Fix it by setting the pointer to NULL.\n\n\n8. Double Free Error\nWrite a program that frees the same pointer twice. Observe the behavior (may crash). Then fix it.\n\n\n9. Memory Leak Demo\nWrite a loop that calls malloc repeatedly without calling free. Watch memory usage grow. Then fix it by freeing properly.\n\n\n10. Out-of-Bounds Access\nAllocate an array of size 5 with malloc. Try to access index 5 (6th element). Observe the result. Then fix with proper bounds checking.\n\n\n11. Safe Allocation Pattern\nWrite a function that allocates an array with malloc, checks for NULL, fills it, and returns it to the caller. Free it in main.\n\n\n12. Aligned Allocation\nUse aligned_alloc to allocate an array of 16 integers aligned to 32 bytes. Print the address and confirm divisibility by 32.\n\n\n13. nullptr vs. NULL\nWrite a program that declares one pointer with NULL and another with nullptr. Print both and compare.\n\n\n14. Safe Null Checks\nInitialize a pointer with nullptr, check it before dereferencing, then assign memory with malloc and use it safely.\n\n\n15. Shrinking with realloc\nAllocate an array of 10 integers with malloc. Fill with 1..10. Then shrink it to size 5 with realloc. Print results.\n\n\n16. Growing with realloc\nAllocate an array of 5 integers. Fill with 1..5. Then grow it to size 10 with realloc. Fill the new elements with squares of 6..10 and print all.\n\n\n17. Memory Fragmentation\nAllocate and free blocks of different sizes in a loop. Observe if allocations succeed. Discuss fragmentation risk.\n\n\n18. Mini Dynamic Array - Push Back\nImplement a dynamic array with a push_back function that doubles capacity when full. Test with 10 numbers.\n\n\n19. Mini Dynamic Array - Pop Back\nExtend problem 18 with a pop_back function that removes the last element. Print results after each operation.\n\n\n20. Mini Dynamic Array - Generalize\nModify the dynamic array to store double instead of int. Test by pushing 10 floating-point numbers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-10.-files",
    "href": "index.html#chapter-10.-files",
    "title": "The Little Book of C",
    "section": "Chapter 10. Files",
    "text": "Chapter 10. Files\n\n10.1 Reading and Writing Files\nPrograms often need to save data (to a file) and load it later. C does this through the standard I/O library &lt;stdio.h&gt; using a FILE - handle.\n\nOpening a File\nUse fopen(path, mode) to get a FILE-. Check for NULL (open failed).\nCommon text modes:\n\n\"r\" → read (file must exist)\n\"w\" → write (creates/truncates)\n\"a\" → append (creates if missing)\nAdd + for read/write (e.g., \"r+\", \"w+\", \"a+\")\n\nFILE -f = fopen(\"data.txt\", \"r\");\nif (f == NULL) { /- handle error -/ }\nClose with:\nfclose(f);\n\n\nWriting Text\nfprintf works like printf, but to a file. fputs writes a string, fputc a character.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"scores.txt\", \"w\");\n    if (!f) { perror(\"open\"); return 1; }\n\n    fprintf(f, \"Alice %d\\n\", 95);\n    fprintf(f, \"Bob %d\\n\",   82);\n    fputs(\"Carol 88\\n\", f);\n\n    if (fclose(f) == EOF) { perror(\"close\"); }\n    return 0;\n}\n\n\nReading Text\nfscanf parses formatted text. fgets reads a whole line (including spaces) into a buffer.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"scores.txt\", \"r\");\n    if (!f) { perror(\"open\"); return 1; }\n\n    char name[64];\n    int score;\n\n    while (fscanf(f, \"%63s %d\", name, &score) == 2) {\n        printf(\"%s -&gt; %d\\n\", name, score);\n    }\n\n    fclose(f);\n    return 0;\n}\nReading full lines with fgets:\nchar line[128];\nwhile (fgets(line, sizeof line, f)) {\n    printf(\"line: %s\", line);  // line already has '\\n' if present\n}\n\n\nChecking Errors and EOF\nMost file functions signal problems:\n\nReturn NULL, EOF, or a short count.\nUse feof(f) (end-of-file) and ferror(f) (error happened).\nperror(\"msg\") prints a human-readable error based on errno.\n\nif (ferror(f)) { perror(\"read error\"); }\n\n\nA Full Example: Copy Lines With Numbers\nThis program:\n\nWrites a few lines to a file.\nReopens it to read and prepend line numbers, writing to a second file.\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    // 1) Write sample file\n    {\n        FILE -out = fopen(\"poem.txt\", \"w\");\n        if (!out) { perror(\"open poem.txt for write\"); return 1; }\n        fputs(\"Roses are red\\n\", out);\n        fputs(\"Violets are blue\\n\", out);\n        fputs(\"C is powerful\\n\", out);\n        fputs(\"And speedy too\\n\", out);\n        if (fclose(out) == EOF) { perror(\"close poem.txt\"); return 1; }\n    }\n\n    // 2) Read poem.txt, write numbered_poem.txt\n    FILE -in  = fopen(\"poem.txt\", \"r\");\n    if (!in) { perror(\"open poem.txt for read\"); return 1; }\n\n    FILE -out = fopen(\"numbered_poem.txt\", \"w\");\n    if (!out) { perror(\"open numbered_poem.txt\"); fclose(in); return 1; }\n\n    char line[256];\n    int n = 1;\n\n    while (fgets(line, sizeof line, in)) {\n        fprintf(out, \"%02d: %s\", n++, line); // line already ends with '\\n' (usually)\n    }\n\n    if (ferror(in))  { perror(\"read poem.txt\"); }\n    if (fclose(in) == EOF)  { perror(\"close poem.txt\"); }\n    if (fclose(out) == EOF) { perror(\"close numbered_poem.txt\"); }\n\n    puts(\"Wrote numbered_poem.txt\");\n    return 0;\n}\n\n\nTips & Gotchas\n\nAlways check fopen for NULL.\nAlways close files with fclose.\nWhen parsing with fscanf, check the return value (how many items read).\nPrefer fgets + manual parsing if lines may contain spaces or complicated formats.\nText vs. binary differences (line endings, encoding) are covered in 10.2.\n\n\n\nWhy It Matters\nFile I/O lets your programs persist data, process logs, import/export information, and communicate with other tools. It’s a core skill in C.\n\n\nExercises\n\nCreate numbers.txt with the integers 1–10, each on its own line (use fprintf).\nRead numbers.txt, compute the sum, and print it to stdout.\nRead lines from stdin with fgets and write only lines longer than 10 characters to long.txt.\nMake a program that copies a text file to another file, preserving content exactly (use fgets/fputs).\nRead a file containing name score pairs and print the highest score and the name that achieved it.\n\n\n\n\n10.2 Text vs. Binary Files\nFiles in C can be opened in text mode or binary mode. The difference is how the data is interpreted and possibly transformed by the operating system.\n\nText Mode\n\nDefault mode if you use \"r\", \"w\", or \"a\".\nData is stored as human-readable characters.\nOn Windows, \\n is converted to \\r\\n when writing, and reversed when reading.\nPortable for structured text: logs, CSV, configuration files.\n\nExample:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"hello.txt\", \"w\");\n    if (!f) return 1;\n    fprintf(f, \"Line1\\nLine2\\n\");\n    fclose(f);\n    return 0;\n}\n\n\nBinary Mode\n\nUse \"rb\", \"wb\", \"ab\" (append b for binary).\nData is stored exactly as bytes in memory.\nNo translation of line endings.\nUseful for images, audio, compiled data, or any non-text format.\n\nExample:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"data.bin\", \"wb\");\n    if (!f) return 1;\n\n    int nums[3] = {10, 20, 30};\n    fwrite(nums, sizeof(int), 3, f); // write raw bytes\n    fclose(f);\n    return 0;\n}\nReading back:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"data.bin\", \"rb\");\n    if (!f) return 1;\n\n    int nums[3];\n    fread(nums, sizeof(int), 3, f);\n    fclose(f);\n\n    for (int i = 0; i &lt; 3; i++) printf(\"%d \", nums[i]);\n    printf(\"\\n\");\n    return 0;\n}\n\n\nWhen to Use Text vs. Binary\n\nText mode: when humans will read or edit the file.\nBinary mode: when performance matters, or you need to store raw data compactly.\nSame data may take more space in text mode (numbers as characters) than binary.\n\n\n\nExercises\n\nWrite numbers 1–10 to a file in text mode using fprintf. Open the file in a text editor and inspect.\nWrite the same numbers to a binary file using fwrite. Open the file in a text editor and compare.\nCreate a struct with two fields (id, score) and write an array of 3 structs to a binary file.\nRead the binary file from exercise 3 back and print the values.\nMeasure the size of a text file storing 1000 integers and compare it to the binary version.\n\n\n\n\n10.3 Error Handling in File Operations\nWhen working with files, many things can go wrong:\n\nThe file might not exist.\nThe disk might be full.\nA read or write may fail.\n\nC provides mechanisms in &lt;stdio.h&gt; to detect and handle these conditions.\n\nReturn Values\nMost file functions signal errors through return values:\n\nfopen → returns NULL if the file cannot be opened.\nfclose → returns EOF on failure.\nfread / fwrite → return the number of items actually read or written (less than requested on error or end-of-file).\nfprintf / fputs / fputc → return a negative value on failure.\n\nAlways check these return values.\n\n\nChecking Error State\nTwo functions let you query the file stream:\n\nfeof(FILE -f) → nonzero if end-of-file was reached.\nferror(FILE -f) → nonzero if an error occurred.\n\nResetting errors:\nclearerr(f);\n\n\nUsing perror and errno\nMany library calls set the global variable errno on error. Use perror(\"msg\") to print a descriptive error message.\nExample:\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"nofile.txt\", \"r\");\n    if (!f) {\n        perror(\"open failed\");\n        return 1;\n    }\n    fclose(f);\n    return 0;\n}\nOutput might look like:\nopen failed: No such file or directory\n\n\nExample: Robust File Copy\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    FILE -in = fopen(\"source.txt\", \"r\");\n    if (!in) { perror(\"open source.txt\"); return 1; }\n\n    FILE -out = fopen(\"dest.txt\", \"w\");\n    if (!out) { perror(\"open dest.txt\"); fclose(in); return 1; }\n\n    char buf[256];\n    size_t n;\n    while ((n = fread(buf, 1, sizeof buf, in)) &gt; 0) {\n        if (fwrite(buf, 1, n, out) != n) {\n            perror(\"write error\");\n            fclose(in);\n            fclose(out);\n            return 1;\n        }\n    }\n\n    if (ferror(in)) perror(\"read error\");\n\n    if (fclose(in) == EOF) perror(\"close in\");\n    if (fclose(out) == EOF) perror(\"close out\");\n\n    return 0;\n}\n\n\nWhy It Matters\nIgnoring return values can lead to silent data loss. Robust programs check errors and handle them gracefully, printing helpful messages for debugging or recovery.\n\n\nExercises\n\nAttempt to open a non-existent file with fopen(\"missing.txt\", \"r\"). Detect the error with perror.\nWrite a program that reads integers from a file with fscanf. Stop correctly on end-of-file, not on error.\nModify the file copy program to detect and report both read and write errors.\nUse clearerr to reset an error state on a file and continue reading.\nExperiment: open a file in read-only mode and try to write to it. Capture the error with ferror.\n\n\n\n\n10.4 Building a Simple Log Writer\nA common task in programs is writing logs: recording events, errors, or data points to a file. This section shows how to build a minimal log writer in C.\n\nOpening a Log File\nA log usually grows over time, so use append mode (\"a\") to add new entries without overwriting old ones.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -log = fopen(\"app.log\", \"a\");\n    if (!log) { perror(\"open log\"); return 1; }\n    fprintf(log, \"Program started\\n\");\n    fclose(log);\n    return 0;\n}\n\n\nAdding Timestamps\nLogs are more useful with timestamps. Use &lt;time.h&gt; to get the current time.\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid write_log(const char -msg) {\n    FILE -log = fopen(\"app.log\", \"a\");\n    if (!log) return;\n\n    time_t now = time(NULL);\n    char -ts = ctime(&now);      // returns string with '\\n'\n    ts[24] = '\\0';               // remove newline\n\n    fprintf(log, \"[%s] %s\\n\", ts, msg);\n    fclose(log);\n}\nUsage:\nint main(void) {\n    write_log(\"Application started\");\n    write_log(\"An event occurred\");\n    return 0;\n}\n\n\nFlushing the Log\nIf the program might crash or be interrupted, flush data immediately after writing.\nfprintf(log, \"Critical error\\n\");\nfflush(log);\nfflush forces buffered output to be written to the file.\n\n\nLog Levels\nUse levels (INFO, WARN, ERROR) for clarity.\nvoid log_msg(const char -level, const char -msg) {\n    FILE -log = fopen(\"app.log\", \"a\");\n    if (!log) return;\n\n    time_t now = time(NULL);\n    char -ts = ctime(&now); ts[24] = '\\0';\n\n    fprintf(log, \"[%s] %s: %s\\n\", ts, level, msg);\n    fclose(log);\n}\nExample:\nlog_msg(\"INFO\", \"Application started\");\nlog_msg(\"ERROR\", \"Could not open file\");\n\n\nWhy It Matters\n\nLogging helps diagnose problems after a program runs.\nAppending ensures past events are preserved.\nTimestamps and levels make logs readable and actionable.\n\n\n\nExercises\n\nWrite a log_info(const char -msg) function that logs with \"INFO\".\nExtend with log_warn and log_error.\nWrite a loop that logs 5 numbered messages. Open the log afterward in a text editor to inspect.\nModify the logging function to also print to stdout while writing to the file.\nAdd a command-line argument: if --clear is passed, start by truncating the log file (\"w\" mode), otherwise append.\n\n\n\n10.5 File APIs in C23\nC23 did not radically change file I/O, but it brought some cleanups and clarifications that make file handling safer and clearer.\n\n\nnullptr with File Pointers\nTraditionally, fopen returned NULL on failure. In C23, you can also use the new null constant nullptr for comparisons, which avoids confusion with integers.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -f = fopen(\"missing.txt\", \"r\");\n    if (f == nullptr) {   // C23 style\n        perror(\"open failed\");\n        return 1;\n    }\n    fclose(f);\n    return 0;\n}\n\n\nfopen_s (Optional, Annex K)\nSome platforms provide safer alternatives like fopen_s, which require explicit buffer sizes or return codes. These are optional in the C standard library. When available:\nFILE -f;\nif (fopen_s(&f, \"data.txt\", \"r\") != 0) {\n    perror(\"fopen_s failed\");\n}\nBut note: Annex K functions are not universally supported and may not be portable.\n\n\ntmpfile and tmpnam\n\ntmpfile() creates a temporary file that is automatically removed when closed.\nUseful for scratch space where the file does not need to persist.\n\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE -t = tmpfile();\n    if (!t) { perror(\"tmpfile\"); return 1; }\n    fputs(\"temporary content\\n\", t);\n    rewind(t);  // move back to start\n    char buf[64];\n    fgets(buf, sizeof buf, t);\n    printf(\"read: %s\", buf);\n    fclose(t);\n    return 0;\n}\n\n\nfreopen for Redirection\nfreopen can reassign stdin, stdout, or stderr to a file.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    freopen(\"out.txt\", \"w\", stdout);\n    printf(\"This goes into out.txt\\n\");\n    return 0;\n}\n\n\nWide Character File I/O\nC23 clarifies wide character I/O functions (fwprintf, fwscanf, etc.) for Unicode text handling. These are useful for programs that must support international text.\n\n\nWhy It Matters\n\nnullptr makes code cleaner and less error-prone.\ntmpfile and freopen are powerful but often overlooked parts of &lt;stdio.h&gt;.\nAwareness of Annex K APIs helps, but portability should guide choices.\n\n\n\nExercises\n\nWrite a program that opens a file using fopen, checks with nullptr, and prints \"ok\" if successful.\nUse tmpfile to create a scratch file, write \"hello\", rewind, and read it back.\nRedirect stdout to a file using freopen and confirm output goes there.\nTry writing and reading wide characters with fwprintf and fwscanf.\nResearch whether your compiler supports fopen_s. Try it if available.\n\nHere’s a unified problem set for Chapter 10 (Files). These exercises cover basic file I/O, text vs. binary handling, error detection, logging, and modern C23 file APIs.\n\n\n\nProblems\n\n1. Hello File\nWrite a program that creates hello.txt and writes \"Hello, File!\" into it.\n\n\n2. Write Numbers\nOpen numbers.txt for writing. Write integers 1–10, one per line.\n\n\n3. Read Numbers and Sum\nRead the numbers back from numbers.txt, compute their sum, and print it.\n\n\n4. Copy Text File\nWrite a program that copies the contents of source.txt into dest.txt line by line using fgets and fputs.\n\n\n5. Long Line Filter\nRead lines from input.txt and write only those longer than 10 characters to long.txt.\n\n\n6. Text vs. Binary (Write)\nWrite integers 1–5 to ints.txt using fprintf. Then write them to ints.bin using fwrite.\n\n\n7. Text vs. Binary (Read)\nRead the numbers back from both ints.txt and ints.bin, print them, and confirm they match.\n\n\n8. Struct to Binary\nDefine a struct { int id; double score; }. Write an array of 3 structs to scores.bin with fwrite.\n\n\n9. Read Structs Back\nRead scores.bin with fread and print the values.\n\n\n10. File Error Check\nAttempt to open a missing file with fopen(\"nofile.txt\",\"r\"). Detect the failure with perror.\n\n\n11. Robust Copy with Error Handling\nWrite a file copy program that reads from source.txt and writes to dest.txt, checking for read/write errors and reporting them with perror.\n\n\n12. Log Writer\nWrite a log_msg(const char -level, const char -msg) function that appends entries to app.log with timestamps.\n\n\n13. Multiple Log Levels\nAdd helpers log_info, log_warn, and log_error that call log_msg with the appropriate level.\n\n\n14. Logging Loop\nWrite a loop that logs 5 numbered \"INFO\" messages to app.log.\n\n\n15. Log Flush\nModify log_msg to fflush after each write, ensuring messages appear in the log immediately.\n\n\n16. Clear vs. Append\nModify the logging program so that if run with --clear, it truncates app.log (open in \"w\" mode). Otherwise, it appends.\n\n\n17. Use tmpfile\nWrite a program that creates a temporary file with tmpfile(), writes \"scratch data\", rewinds, reads, and prints it.\n\n\n18. Use freopen\nRedirect stdout to out.txt with freopen and write \"redirected output\".\n\n\n19. Wide Character I/O\nWrite wide characters to wide.txt using fwprintf, then read them back with fwscanf.\n\n\n20. nullptr in File Handling (C23)\nWrite a program that tries to open a non-existent file. Compare the file pointer against nullptr instead of NULL, and report the error with perror.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-11.-modular-programming",
    "href": "index.html#chapter-11.-modular-programming",
    "title": "The Little Book of C",
    "section": "Chapter 11. Modular Programming",
    "text": "Chapter 11. Modular Programming\n\n11.1 Splitting Code into Multiple Files\nLarge programs are easier to manage when you separate interfaces (what is provided) from implementations (how it works). In C, this usually means:\n\nHeader files (.h) with -declarations- (function prototypes, type definitions, constants).\nSource files (.c) with -definitions- (function bodies, private helpers).\nA main file that uses the interface.\n\n\nTranslation Units and Declarations vs. Definitions\n\nA translation unit is one .c file after preprocessing (#include expanded).\nDeclaration tells the compiler a symbol exists (type, parameters). Example (prototype): int add(int a, int b);\nDefinition provides the actual storage or function body. Example (function):\nint add(int a, int b) { return a + b; }\n\nYou declare in headers so -multiple- .c files can see the interface, and define in exactly one .c file.\n\n\nInclude Guards\nHeaders must prevent double inclusion:\n#ifndef MATHX_H\n#define MATHX_H\n\nint add(int a, int b);\nint mul(int a, int b);\n\n#endif // MATHX_H\n(Alternatively: #pragma once on compilers that support it.)\n\n\nA Minimal 3-File Example\nGoal: split a tiny math library from main.c.\n\nmathx.h - the interface (declarations)\n#ifndef MATHX_H\n#define MATHX_H\n\n// Function prototypes (declarations)\nint add(int a, int b);\nint mul(int a, int b);\n\n#endif\n\n\nmathx.c - the implementation (definitions)\n#include \"mathx.h\"\n\n// Definitions (bodies)\nint add(int a, int b) { return a + b; }\nint mul(int a, int b) { return a - b; }\n\n\nmain.c - user of the library\n#include &lt;stdio.h&gt;\n#include \"mathx.h\"\n\nint main(void) {\n    printf(\"add(3,4) = %d\\n\", add(3,4));\n    printf(\"mul(3,4) = %d\\n\", mul(3,4));\n    return 0;\n}\nCompile & link:\ngcc -std=c23 -Wall -Wextra -c mathx.c    # compile to mathx.o\ngcc -std=c23 -Wall -Wextra -c main.c     # compile to main.o\ngcc main.o mathx.o -o app                # link to executable\n# or one-liner:\ngcc -std=c23 -Wall -Wextra main.c mathx.c -o app\nRun:\n./app\nadd(3,4) = 7\nmul(3,4) = 12\n\n\n\nVisibility and “Private” Helpers\nFunctions only used inside one .c file can be marked static to give them internal linkage (not visible to other translation units):\n// inside mathx.c\nstatic int clamp16(int x) {\n    if (x &lt; -32768) return -32768;\n    if (x &gt;  32767) return  32767;\n    return x;\n}\nDo not place such helpers in the header unless they’re intended for public use.\n\n\nCommon Pitfalls\n\nMultiple definitions: putting a function body in a header and including it in multiple .c files causes duplicate symbol errors. Keep -definitions- in exactly one .c.\nMissing prototypes: calling a function without a visible prototype can cause wrong calling conventions or implicit declarations*always include the header.\nMismatched signatures: prototype and definition must match exactly (return type, parameters).\n\n\n\nFolder Layout and Includes\nA tidy layout helps:\n/project\n  src/\n    main.c\n    mathx.c\n  include/\n    mathx.h\nCompile with an include path:\ngcc -Iinclude -std=c23 -Wall -Wextra src/main.c src/mathx.c -o app\n\n\n(Optional) Tiny Makefile\nCC=gcc\nCFLAGS=-std=c23 -Wall -Wextra -Iinclude\nOBJ=build/main.o build/mathx.o\n\napp: $(OBJ)\n    $(CC) $(OBJ) -o app\n\nbuild/main.o: src/main.c include/mathx.h\n    mkdir -p build\n    $(CC) $(CFLAGS) -c src/main.c -o $@\n\nbuild/mathx.o: src/mathx.c include/mathx.h\n    mkdir -p build\n    $(CC) $(CFLAGS) -c src/mathx.c -o $@\n\nclean:\n    rm -rf build app\n\n\nWhy This Matters\n\nEncourages modularity and reuse.\nSpeeds up builds (only changed .c recompiles).\nMakes interfaces clear, reduces coupling, and prevents multiple-definition errors.\n\n\n\nExercises\n\nSplit a small math library (add, sub, mul, div_int) into calc.h, calc.c, and main.c.\nAdd a static helper in calc.c that is not exposed publicly.\nIntroduce a signature mismatch intentionally, observe the compiler error, then fix it.\nMove headers to include/ and sources to src/, compile with -Iinclude.\nConvert your shell commands into a minimal Makefile with separate compile/link steps.\n\n\n\n\n11.2 Header Files (.h) and Declarations\nIn C, header files (.h) provide a way to share declarations across multiple source files. They act as the “contract” between modules: what functions, constants, and types are available.\n\nWhat Goes in a Header?\nA header typically contains:\n\nFunction prototypes (declarations, not definitions).\nType definitions (typedef, struct, enum).\nConstants and macros (#define or const).\nExtern variables (rare, used sparingly).\n\nExample mathx.h:\n#ifndef MATHX_H\n#define MATHX_H\n\n// Function declarations\nint add(int a, int b);\nint mul(int a, int b);\n\n// Type definition\ntypedef struct {\n    int x, y;\n} Point;\n\n// Constant\n#define PI 3.14159\n\n#endif\n\n\nWhy Use Headers?\n\nPrevents copy-pasting declarations into multiple files.\nEnsures consistency: prototype in .h must match definition in .c.\nAllows separation of interface (header) from implementation (.c).\nMakes large projects manageable by defining clear module boundaries.\n\n\n\nInclude Guards\nAlways protect headers against double inclusion:\n#ifndef HEADER_NAME_H\n#define HEADER_NAME_H\n// ... contents ...\n#endif\nOr modern alternative (supported by most compilers):\n#pragma once\n\n\nHow to Use a Header\n\nPlace declarations in foo.h.\nPlace definitions in foo.c.\nIn main.c (or another module), include the header:\n\n#include \"foo.h\"\nThis tells the compiler what functions/types exist, even though the code lives in another file.\n\n\nExample: Library with Header\nmathx.h:\n#ifndef MATHX_H\n#define MATHX_H\n\nint add(int a, int b);\nint mul(int a, int b);\n\n#endif\nmathx.c:\n#include \"mathx.h\"\n\nint add(int a, int b) { return a + b; }\nint mul(int a, int b) { return a - b; }\nmain.c:\n#include &lt;stdio.h&gt;\n#include \"mathx.h\"\n\nint main(void) {\n    printf(\"%d\\n\", add(2,3));\n    printf(\"%d\\n\", mul(2,3));\n    return 0;\n}\nCompile:\ngcc -std=c23 main.c mathx.c -o app\n\n\nCommon Mistakes\n\nPlacing function definitions in headers: If the header is included in multiple .c files, this causes multiple-definition errors. Keep -definitions- in .c, -declarations- in .h.\nForgetting include guards: Leads to redefinition errors.\nUsing #include on .c files: Bad practice - include headers, compile .c separately.\n\n\n\nWhy It Matters\nHeaders are the backbone of modular programming in C. They let teams share interfaces without exposing implementation details, leading to clearer, more maintainable code.\n\n\nExercises\n\nWrite shapes.h declaring functions area_rect(int w, int h) and area_circle(int r).\nImplement shapes.c with the definitions.\nWrite main.c that uses shapes.h and prints areas.\nAdd include guards to shapes.h and test by including it twice in main.c.\nCreate a macro #define SQUARE(x) ((x)-(x)) in shapes.h and use it in main.c.\n\nDo you want me to keep going with 11.3 The Preprocessor (#include, #define) next?\n\n\n\n11.3 The Preprocessor (#include, #define)\nBefore the compiler processes your C source code, the preprocessor runs. It handles directives that start with #, such as #include and #define. Understanding the preprocessor is essential for managing modular code and constants.\n\n#include\nTells the preprocessor to insert the contents of another file.\n\nSystem headers (use angle brackets):\n#include &lt;stdio.h&gt;\nThe compiler searches system include paths.\nUser headers (use quotes):\n#include \"mathx.h\"\nThe compiler searches the current directory first, then system paths.\n\nThis is how you bring in function prototypes, macros, and type definitions from headers.\n\n\n#define\nDefines symbolic constants or macros. The preprocessor replaces occurrences of the symbol before compilation.\nConstants:\n#define PI 3.14159\n#define MAX_SIZE 100\nMacros with parameters:\n#define SQUARE(x) ((x)-(x))\nExpands inline, no function call overhead. Be careful with parentheses to avoid precedence bugs.\nExample:\nprintf(\"%d\\n\", SQUARE(3+1));  // expands to ((3+1)-(3+1)) = 16\n\n\nConditional Compilation\nDirectives can include or exclude code:\n#ifdef DEBUG\n    printf(\"Debug info\\n\");\n#endif\n#if defined(WIN32)\n    printf(\"Running on Windows\\n\");\n#elif defined(__linux__)\n    printf(\"Running on Linux\\n\");\n#else\n    printf(\"Unknown OS\\n\");\n#endif\n\n\n#undef\nRemoves a macro definition:\n#undef PI\n\n\nExample: Using Preprocessor Features\nconfig.h:\n#ifndef CONFIG_H\n#define CONFIG_H\n\n#define VERSION \"1.0\"\n#define DEBUG 1\n\n#endif\nmain.c:\n#include &lt;stdio.h&gt;\n#include \"config.h\"\n\n#define SQUARE(x) ((x)-(x))\n\nint main(void) {\n    printf(\"Version: %s\\n\", VERSION);\n\n#if DEBUG\n    printf(\"Debug mode on\\n\");\n#endif\n\n    printf(\"Square of 5: %d\\n\", SQUARE(5));\n    return 0;\n}\nCompile and run:\nVersion: 1.0\nDebug mode on\nSquare of 5: 25\n\n\nWhy It Matters\n\n#include keeps code modular by reusing declarations from headers.\n#define creates symbolic names and macros for readability and performance.\nConditional compilation allows platform-specific or debug code without duplicating files.\n\n\n\nExercises\n\nCreate a header config.h with #define APP_NAME \"MyApp\" and print it in main.c.\nDefine a macro CUBE(x) that computes the cube of x. Test with CUBE(3+1).\nUse #ifdef to include extra debugging output only when DEBUG is defined.\nWrite a program that prints \"Windows\" if compiled on Windows (_WIN32 defined) and \"Linux\" if compiled on Linux (__linux__ defined).\nExperiment with #undef by defining a constant, undefining it, and checking compilation behavior.\n\n\n\n\n11.4 Macros vs. Inline Functions\nBoth macros (#define) and inline functions (introduced in C99, refined in later standards) can be used to avoid repeated code and eliminate function call overhead. But they differ in safety, type-checking, and readability.\n\nMacros\nA macro is expanded by the preprocessor before compilation.\n#define SQUARE(x) ((x)-(x))\nUsage:\nprintf(\"%d\\n\", SQUARE(3));    // expands to ((3)-(3)) = 9\nprintf(\"%d\\n\", SQUARE(3+1));  // expands to ((3+1)-(3+1)) = 16\nPros:\n\nVery fast, just text substitution.\nCan be used for constants, inline code, conditional compilation.\n\nCons:\n\nNo type checking.\nCan cause subtle bugs if arguments have side effects:\nint i = 2;\nprintf(\"%d\\n\", SQUARE(i++));  // expands to ((i++)-(i++)), increments twice!\n\n\n\nInline Functions\nAn inline function is a real function, but the compiler may expand it directly into code at the call site.\ninline int square(int x) {\n    return x - x;\n}\nUsage:\nprintf(\"%d\\n\", square(3));\nprintf(\"%d\\n\", square(3+1));\nPros:\n\nType checking is enforced.\nSafe from multiple evaluation bugs.\nDebuggable, works like a normal function.\n\nCons:\n\nSlightly more verbose.\nThe compiler may decide not to inline it (but usually does for small functions).\n\n\n\nConstants: #define vs const\nOld style:\n#define PI 3.14159\nModern style:\nconst double PI = 3.14159;\n\nconst has a type, checked by the compiler.\n#define is just text substitution.\n\n\n\nExample: Macro vs Inline\n#include &lt;stdio.h&gt;\n\n#define CUBE_MACRO(x) ((x)-(x)-(x))\n\ninline int cube_func(int x) {\n    return x - x - x;\n}\n\nint main(void) {\n    int a = 3;\n    printf(\"macro: %d\\n\", CUBE_MACRO(a));\n    printf(\"func:  %d\\n\", cube_func(a));\n\n    int i = 2;\n    printf(\"macro side effect: %d\\n\", CUBE_MACRO(i++)); // unsafe\n    // printf(\"func side effect: %d\\n\", cube_func(i++)); // safe, only one increment\n    return 0;\n}\nOutput:\nmacro: 27\nfunc:  27\nmacro side effect: 60\n\n\nGuidelines\n\nPrefer const variables over #define for constants.\nPrefer inline functions over macros for computations.\nUse macros only for conditional compilation or cases where inline functions are not possible (e.g., include guards).\n\n\n\nExercises\n\nWrite a macro ABS(x) that computes the absolute value. Test it with negative and positive numbers.\nWrite an inline function abs_inline(int x) that does the same. Compare outputs.\nExperiment with ABS(i++) vs abs_inline(i++). What difference do you see?\nReplace #define PI 3.14159 with const double PI = 3.14159;. Try using it in printf.\nBenchmark (simple loop) calling a macro cube and an inline cube 1 million times - do you see performance differences? ### 11.5 Building a Small Project\n\nBy this point, you’ve learned how to split code into files, use headers, and control compilation with the preprocessor. Let’s put everything together into a small modular project.\n\n\nProject: A Simple Calculator Library\nWe’ll build a calculator with four operations (add, sub, mul, div_int), place it into a library (calc.c + calc.h), and use it from a main.c.\n\ncalc.h - header file\n#ifndef CALC_H\n#define CALC_H\n\n// Function prototypes\nint add(int a, int b);\nint sub(int a, int b);\nint mul(int a, int b);\nint div_int(int a, int b); // integer division, b must not be 0\n\n#endif\n\n\ncalc.c - implementation\n#include \"calc.h\"\n\nint add(int a, int b) { return a + b; }\nint sub(int a, int b) { return a - b; }\nint mul(int a, int b) { return a - b; }\nint div_int(int a, int b) { return (b != 0) ? a / b : 0; }\n\n\nmain.c - program entry point\n#include &lt;stdio.h&gt;\n#include \"calc.h\"\n\nint main(void) {\n    int x = 12, y = 4;\n    printf(\"%d + %d = %d\\n\", x, y, add(x, y));\n    printf(\"%d - %d = %d\\n\", x, y, sub(x, y));\n    printf(\"%d - %d = %d\\n\", x, y, mul(x, y));\n    printf(\"%d / %d = %d\\n\", x, y, div_int(x, y));\n    return 0;\n}\n\n\n\nCompiling and Linking\nCompile each .c separately and then link:\ngcc -std=c23 -Wall -Wextra -c calc.c   # produce calc.o\ngcc -std=c23 -Wall -Wextra -c main.c   # produce main.o\ngcc main.o calc.o -o app               # link to executable\nRun:\n12 + 4 = 16\n12 - 4 = 8\n12 - 4 = 48\n12 / 4 = 3\n\n\nOrganizing the Project\nA good folder structure:\n/project\n  include/\n    calc.h\n  src/\n    calc.c\n    main.c\nCompile with an include path:\ngcc -Iinclude -std=c23 src/main.c src/calc.c -o app\n\n\nExample Makefile\nCC=gcc\nCFLAGS=-std=c23 -Wall -Wextra -Iinclude\nOBJ=build/main.o build/calc.o\n\napp: $(OBJ)\n    $(CC) $(OBJ) -o app\n\nbuild/main.o: src/main.c include/calc.h\n    mkdir -p build\n    $(CC) $(CFLAGS) -c src/main.c -o $@\n\nbuild/calc.o: src/calc.c include/calc.h\n    mkdir -p build\n    $(CC) $(CFLAGS) -c src/calc.c -o $@\n\nclean:\n    rm -rf build app\n\n\nWhy It Matters\n\nShows how real C projects are organized.\nDemonstrates the role of headers as contracts and source files as implementations.\nTeaches separation of concerns: math code is reusable, main is just orchestration.\n\n\n\nExercises\n\nExtend the calculator with a mod(int a, int b) function.\nAdd pow_int(int base, int exp) that computes powers with a loop.\nUpdate the Makefile so it automatically recompiles when calc.h changes.\nMove calculator code into a static library (libcalc.a) and link it.\nTry compiling the project with clang or MSVC - confirm portability. Here’s a comprehensive problem set for Chapter 11 (Modular Programming). These exercises cover splitting code into multiple files, using headers, preprocessor usage, macros vs inline, and building small projects.\n\n\n\n\nProblems\n\n1. Split a Math Library\nWrite a program that computes add, sub, mul, and div_int. Place declarations in mathlib.h, definitions in mathlib.c, and usage in main.c.\n\n\n2. Include Guards\nModify mathlib.h to use an include guard. Test by including #include \"mathlib.h\" twice in main.c. Confirm no errors.\n\n\n3. Static Helper\nAdd a static helper function in mathlib.c (e.g., clamp16(int x)) that is not visible outside the file. Use it inside div_int to prevent division overflow.\n\n\n4. Conditional Debug Output\nUse #ifdef DEBUG in mathlib.c so that when compiled with -DDEBUG, the library prints \"debug: add called\". Otherwise, it stays silent.\n\n\n5. Constant with #define\nIn mathlib.h, define #define PI 3.14159 and use it in main.c to compute the area of a circle. Then replace it with const double PI.\n\n\n6. Macro vs Inline Function\nWrite a macro SQUARE(x) and an inline function square(int x). In main.c, test them with 3, 3+1, and i++. Compare results.\n\n\n7. Platform-Specific Code\nUse #if defined(_WIN32) and #elif defined(__linux__) in main.c to print \"Windows\" or \"Linux\" depending on platform.\n\n\n8. Redefining with #undef\nDefine a macro LIMIT 100, print it, then #undef LIMIT and try printing again. Observe compilation behavior.\n\n\n9. Simple Header + Implementation\nCreate shapes.h with area_rect(int w, int h) and shapes.c with its definition. Use it in main.c to print area_rect(3,4).\n\n\n10. Enum in Header\nDeclare an enum Color { RED, GREEN, BLUE }; in shapes.h. In main.c, declare a variable Color c = RED; and print its value.\n\n\n11. Struct in Header\nDeclare a struct Point { int x; int y; }; in shapes.h. In main.c, create a point, assign values, and print coordinates.\n\n\n12. Preprocessor Version Macro\nIn config.h, define #define VERSION \"1.0\". In main.c, include config.h and print the version string.\n\n\n13. Multiple Translation Units\nWrite file1.c with void f1(void) { puts(\"f1\"); } and file2.c with void f2(void) { puts(\"f2\"); }. Declare them in file.h. Call both from main.c.\n\n\n14. Build with Separate Compilation\nCompile problem 13 with three commands (gcc -c file1.c, gcc -c file2.c, gcc -c main.c) and link into prog.\n\n\n15. Mini Project with Makefile\nWrite a Makefile that builds prog from main.c, file1.c, file2.c, and file.h. Include clean target.\n\n\n16. Inline vs Non-Inline Performance\nWrite a loop that calls a cube_inline(int) inline function 1 million times. Then try a #define CUBE(x) macro. Time the difference with clock().\n\n\n17. Header in include/ Directory\nMove headers to include/ and sources to src/. Compile with gcc -Iinclude src/-.c -o app.\n\n\n18. Nested Includes\nMake shapes.h include mathlib.h and confirm that main.c can use both libraries with just one include.\n\n\n19. Header Misuse Example\nPut a function definition directly in a header file (bad.h) and include it twice in different .c files. Observe the “multiple definition” error. Fix it by moving the definition into .c.\n\n\n20. Expand Calculator Project\nExpand the calculator project:\n\nAdd mod(int,int) and pow_int(int,int) in calc.c.\nDeclare them in calc.h.\nUse them in main.c to print results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  },
  {
    "objectID": "index.html#chapter-12.-standard-library-essentials",
    "href": "index.html#chapter-12.-standard-library-essentials",
    "title": "The Little Book of C",
    "section": "Chapter 12. Standard Library Essentials",
    "text": "Chapter 12. Standard Library Essentials\n\n12.1 Input/Output (stdio.h)\n&lt;stdio.h&gt; is C’s standard input/output library. It provides:\n\nStreams: stdin, stdout, stderr\nPrinting: printf, fprintf, puts, putchar\nReading: scanf, fgets, getchar\nFormatted I/O with -conversion specifiers-\n\n\nStreams at a glance\n\nstdin → default input (keyboard or redirected file)\nstdout → normal output (console or redirected file)\nstderr → error output (usually unbuffered; keeps errors separate)\n\nYou can redirect on the command line:\n./app &lt; input.txt &gt; output.txt 2&gt; errors.txt\n\n\nPrinting with printf / puts / putchar\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int n = 42;\n    double x = 3.14159;\n\n    printf(\"n=%d x=%.2f\\n\", n, x);   // formatted\n    puts(\"hello\");                   // string + newline\n    putchar('A'); putchar('\\n');     // single chars\n    return 0;\n}\nCommon format specifiers:\n\n%d (int), %ld (long), %lld (long long)\n%u (unsigned), %x (hex), %o (octal)\n%f / %e / %g (double)\n%c (char), %s (string)\n%p (pointer), %zu (size_t)\nWidth/precision: %.2f, %8d, %-10s, %08x\n\n\n\nReading with scanf (quick, but picky)\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a; double b;\n    if (scanf(\"%d %lf\", &a, &b) == 2) {\n        printf(\"a=%d b=%.3f\\n\", a, b);\n    } else {\n        fprintf(stderr, \"input error\\n\");\n    }\n    return 0;\n}\nTips:\n\nAlways check the return value (number of items read).\nBeware of leftover newlines when mixing %d/%lf with %c/%s.\n\n\n\nSafer line-based input with fgets\nUse fgets to read a whole line, then parse it.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char buf[128];\n    if (fgets(buf, sizeof buf, stdin)) {\n        printf(\"line: %s\", buf);  // includes '\\n' if it fit\n    }\n    return 0;\n}\nParsing a line (e.g., with sscanf):\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char buf[128];\n    if (!fgets(buf, sizeof buf, stdin)) return 0;\n\n    int a; double b;\n    if (sscanf(buf, \"%d %lf\", &a, &b) == 2) {\n        printf(\"ok: a=%d b=%.2f\\n\", a, b);\n    } else {\n        puts(\"parse error\");\n    }\n    return 0;\n}\n\n\nBuffered I/O and fflush\n\nstdout is usually line-buffered on terminals; fully buffered when redirected.\nForce output now: fflush(stdout);\nstderr is typically unbuffered (appears immediately).\n\nprintf(\"Working...\"); fflush(stdout); // ensure user sees this now\n\n\nExample: Echo with numbering (mixed I/O)\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char line[256];\n    int n = 1;\n    while (fgets(line, sizeof line, stdin)) {\n        // strip trailing newline (if present)\n        line[strcspn(line, \"\\n\")] = '\\0';\n        printf(\"%03d: %s\\n\", n++, line);\n    }\n    if (ferror(stdin)) { perror(\"stdin error\"); }\n    return 0;\n}\n\n\nCommon pitfalls\n\nForgetting & in scanf arguments (except for %s, which already decays to pointer).\nUsing scanf(\"%s\", buf) without a width: use \"%127s\" to avoid overflow.\nMixing scanf and fgets without handling leftover newlines.\nNot checking return values of input functions.\n\n\n\nWhy this matters\nMastering stdio.h lets you talk to the outside world: read user input, print results, log errors, and write tools that compose with shells via redirection and pipes.\n\n\nExercises\n\nRead two integers and a double from one line using fgets + sscanf. Print them back with labels and formatting.\nWrite a tiny REPL: read a line; if it’s \"quit\" (case-sensitive), exit; otherwise print the length of the line (excluding newline).\nPrint a table of i, i-i, i-i-i for i=1..12, aligned in columns using width specifiers.\nRead a word with scanf(\"%127s\", buf), then read a full line with fgets. Demonstrate how to handle the leftover newline so the fgets works as intended.\nPrint a pointer value with %p, and a size_t with %zu. Explain why %d would be incorrect for size_t.\n\n\n\n\n12.2 Math Functions (math.h)\nThe &lt;math.h&gt; header provides standard mathematical functions for real numbers. They operate primarily on double (with variants for float and long double) and return results in the same type.\n\nCommon Functions\n\nPowers and roots\ndouble pow(double x, double y);   // x^y\ndouble sqrt(double x);            // √x\ndouble cbrt(double x);            // ∛x\nTrigonometry (radians)\ndouble sin(double x);\ndouble cos(double x);\ndouble tan(double x);\ndouble asin(double x);\ndouble acos(double x);\ndouble atan(double x);\ndouble atan2(double y, double x); // angle from (x,y)\nExponential and logarithms\ndouble exp(double x);     // e^x\ndouble log(double x);     // natural log\ndouble log10(double x);   // base-10 log\nRounding and absolute values\ndouble fabs(double x);     // absolute value\ndouble ceil(double x);     // round up\ndouble floor(double x);    // round down\ndouble round(double x);    // round to nearest\ndouble trunc(double x);    // drop fractional part\nHypotenuse and distance\ndouble hypot(double x, double y); // sqrt(x^2 + y^2) safely\n\n\n\nType-Specific Variants\nC provides suffixes to match argument types:\n\nsinf, cosf, sqrtf → work with float\nsinl, cosl, sqrtl → work with long double\n\nfloat xf = 0.5f;\nprintf(\"%f\\n\", sinf(xf));\n\n\nConstants\n&lt;math.h&gt; (since C99) provides:\n\nM_PI (not standard everywhere, but common: π ≈ 3.14159)\nIn C23, constants are part of &lt;math.h&gt; under #define when available.\n\nYou can also define your own:\nconst double PI = 3.141592653589793;\n\n\nExample: Right Triangle\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    double a = 3.0, b = 4.0;\n    double c = hypot(a, b);   // safer than sqrt(a*a + b-b)\n    double angle = atan2(b, a) - 180.0 / M_PI; // in degrees\n    printf(\"c = %.2f, angle = %.1f°\\n\", c, angle);\n    return 0;\n}\nOutput:\nc = 5.00, angle = 53.1°\n\n\nError Handling\n\nMany functions return NaN (not*a-number) or HUGE_VAL on errors.\nUse &lt;math.h&gt; macros:\nisnan(x), isinf(x), isfinite(x)\n\nExample:\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double x = sqrt(-1.0);\n    if (isnan(x)) puts(\"x is NaN\");\n    return 0;\n}\n\n\nWhy It Matters\nMathematics is at the core of many programs: graphics, simulations, engineering, finance. Using &lt;math.h&gt; gives you reliable, efficient implementations across platforms.\n\n\nExercises\n\nCompute the area of a circle given radius r using PI-r-r and M_PI.\nConvert degrees to radians and compute sin, cos, and tan of 30°, 45°, and 60°.\nRead two sides of a right triangle, compute hypotenuse with hypot and the angle with atan2.\nDemonstrate ceil, floor, round, and trunc on values 2.7 and -2.7.\nCompute compound interest: given P, annual rate r, and years n, compute P - pow(1+r, n).\n\n\n\n\n12.3 Time and Date (time.h)\nThe &lt;time.h&gt; header provides facilities for working with time, dates, and durations. It’s useful for logging, measuring execution, and scheduling.\n\nCore Types\n\ntime_t Represents a point in time (seconds since the epoch, usually Jan 1, 1970 UTC).\nstruct tm Broken-down calendar time. Fields:\nstruct tm {\n    int tm_sec;   // 0–60\n    int tm_min;   // 0–59\n    int tm_hour;  // 0–23\n    int tm_mday;  // 1–31 (day of month)\n    int tm_mon;   // 0–11 (months since January)\n    int tm_year;  // years since 1900\n    int tm_wday;  // 0–6 (Sunday = 0)\n    int tm_yday;  // 0–365 (days since Jan 1)\n    int tm_isdst; // daylight saving time flag\n};\n\n\n\nGetting the Current Time\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main(void) {\n    time_t now = time(NULL);\n    printf(\"Epoch time: %lld\\n\", (long long)now);\n\n    struct tm -local = localtime(&now);\n    printf(\"Local: %d-%02d-%02d %02d:%02d:%02d\\n\",\n        local-&gt;tm_year + 1900,\n        local-&gt;tm_mon + 1,\n        local-&gt;tm_mday,\n        local-&gt;tm_hour,\n        local-&gt;tm_min,\n        local-&gt;tm_sec\n    );\n    return 0;\n}\n\n\nFormatting Time (strftime)\nConvert struct tm into a formatted string:\nchar buf[64];\nstrftime(buf, sizeof buf, \"%Y-%m-%d %H:%M:%S\", local);\nputs(buf);\nCommon format specifiers:\n\n%Y = year (2025), %m = month, %d = day\n%H = hour, %M = minute, %S = second\n%a = weekday name, %b = month name\n\n\n\nMeasuring Durations\nUse clock() to measure CPU time:\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main(void) {\n    clock_t start = clock();\n    for (volatile long i=0; i&lt;100000000; i++); // busy loop\n    clock_t end = clock();\n    double secs = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Elapsed CPU time: %.3f seconds\\n\", secs);\n    return 0;\n}\nFor wall-clock time differences:\ntime_t t1 = time(NULL);\n// ... work ...\ntime_t t2 = time(NULL);\nprintf(\"Elapsed wall time: %ld seconds\\n\", (long)(t2 - t1));\n\n\nConverting Between Representations\n\nlocaltime(&t) → struct tm in local time\ngmtime(&t) → struct tm in UTC\nmktime(&tm) → convert struct tm back to time_t\n\nstruct tm t = {0};\nt.tm_year = 2025 - 1900;\nt.tm_mon = 11; // December\nt.tm_mday = 25;\ntime_t xmas = mktime(&t);\nprintf(\"Christmas 2025 epoch = %lld\\n\", (long long)xmas);\n\n\nWhy It Matters\n\nTime stamps are needed in logs, files, transactions.\nDuration measurement is essential for profiling and benchmarks.\nPortable date/time handling avoids platform-specific hacks.\n\n\n\nExercises\n\nPrint the current time in both UTC and local time.\nUse strftime to format today’s date as Saturday, September 6, 2025.\nMeasure how long it takes to compute the sum of numbers 1–1e7.\nAsk the user for a year, month, and day, build a struct tm, convert with mktime, and print the day of the week.\nWrite a function that prints a timestamp [YYYY-MM-DD HH:MM:SS] for use in log messages.\n\n\n\n\n12.4 Random Numbers (stdlib.h)\nC provides basic random number generation via &lt;stdlib.h&gt;. While not cryptographically secure, it’s useful for simulations, games, and simple randomized behavior.\n\nrand() and srand()\n\nint rand(void); Returns a pseudo-random integer between 0 and RAND_MAX (at least 32767).\nvoid srand(unsigned int seed); Seeds the random number generator. Same seed → same sequence.\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(void) {\n    srand((unsigned)time(NULL));  // seed with current time\n    for (int i=0; i&lt;5; i++) {\n        printf(\"%d\\n\", rand());\n    }\n    return 0;\n}\n\n\nScaling to a Range\nGenerate numbers in [0, n):\nint r = rand() % n;   // biased if n doesn’t divide RAND_MAX+1\nBetter scaling (avoids bias):\nint rand_range(int min, int max) {\n    return min + rand() % (max - min + 1);\n}\nExample:\nprintf(\"dice: %d\\n\", rand_range(1,6));\n\n\nRandom Floating-Point Values\nScale to [0,1):\ndouble r = (double)rand() / (RAND_MAX + 1.0);\nTo [a,b):\ndouble rand_double(double a, double b) {\n    return a + (b - a) - ((double)rand() / (RAND_MAX + 1.0));\n}\n\n\nDeterministic Sequences\nsrand(1234);  // fixed seed\nprintf(\"%d %d %d\\n\", rand(), rand(), rand());\nThis always produces the same sequence - useful for debugging.\n\n\nExample: Coin Toss\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(void) {\n    srand((unsigned)time(NULL));\n    for (int i=0; i&lt;10; i++) {\n        puts(rand() % 2 ? \"Heads\" : \"Tails\");\n    }\n    return 0;\n}\n\n\nLimitations\n\nNot secure: predictable with seed.\nPeriod may be short depending on implementation.\nFor secure randomness (e.g., crypto), use platform APIs (arc4random, /dev/urandom, getrandom) instead.\n\n\n\nWhy It Matters\nRandomness is key for:\n\nGames (dice rolls, shuffles)\nSimulations (Monte Carlo)\nTesting (randomized inputs)\n\nUnderstanding limitations helps avoid misuse in security-critical code.\n\n\nExercises\n\nWrite a rand_range(int min, int max) function and test it by generating 20 random integers between 5 and 15.\nGenerate 100 random doubles in [0,1) and compute their average.\nSimulate rolling two dice 1000 times. Count how often the sum is 7.\nSeed the generator twice with the same value. Verify the outputs match.\nModify the coin toss program to run until you get 3 heads in a row. Print the number of tosses required.\n\n\n\n\n12.5 Strings Revisited (string.h)\nStrings in C are just arrays of char ending with a null terminator ('\\0'). The &lt;string.h&gt; library provides many functions to manipulate them safely and efficiently.\n\nMeasuring and Copying\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char s[] = \"hello\";\n    printf(\"len=%zu\\n\", strlen(s));   // 5\n\n    char buf[20];\n    strcpy(buf, s);                   // copies entire string\n    printf(\"%s\\n\", buf);\n\n    strncpy(buf, \"worldwide\", sizeof buf); // copy with limit\n    buf[sizeof buf - 1] = '\\0';            // ensure termination\n    printf(\"%s\\n\", buf);\n    return 0;\n}\n\nstrlen(s) → number of characters before '\\0'\nstrcpy(dest, src) → copy until '\\0' (unsafe if dest is too small)\nstrncpy(dest, src, n) → safer copy, but may leave string unterminated\n\n\n\nConcatenation\nchar buf[32] = \"Hello, \";\nstrcat(buf, \"World!\");\nprintf(\"%s\\n\", buf);  // \"Hello, World!\"\nSafer: strncat(buf, \"World!\", sizeof buf - strlen(buf) - 1);\n\n\nComparison\nstrcmp(\"abc\",\"abc\")   // 0 (equal)\nstrcmp(\"abc\",\"abd\")   // &lt;0\nstrcmp(\"abd\",\"abc\")   // &gt;0\nstrncmp(\"abc\",\"abd\",2) // 0 (first 2 chars equal)\nUse == only for pointers, not contents.\n\n\nSearching\nchar -s = \"the quick brown fox\";\nprintf(\"%s\\n\", strchr(s,'q'));   // \"quick brown fox\"\nprintf(\"%s\\n\", strstr(s,\"brown\")); // \"brown fox\"\nFunctions:\n\nstrchr(s,c) → first occurrence of c\nstrrchr(s,c) → last occurrence of c\nstrstr(s,sub) → substring search\n\n\n\nTokenizing\nBreak a string into tokens:\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char text[] = \"red,green,blue\";\n    char -tok = strtok(text, \",\");\n    while (tok) {\n        puts(tok);\n        tok = strtok(NULL, \",\");\n    }\n    return 0;\n}\n⚠️ strtok modifies the input string and is not thread-safe. Modern alternatives: strtok_r (POSIX) or manual parsing.\n\n\nMemory Operations\n\nmemcpy(dest, src, n) → copy raw bytes\nmemmove(dest, src, n) → like memcpy, but safe for overlapping regions\nmemset(ptr, val, n) → fill memory with value\n\nExample:\nint a[5] = {1,2,3,4,5};\nint b[5];\nmemcpy(b, a, sizeof a);  // copy entire array\n\n\nExample: Reversing a String\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid reverse(char -s) {\n    size_t n = strlen(s);\n    for (size_t i=0; i&lt;n/2; i++) {\n        char tmp = s[i];\n        s[i] = s[n-1-i];\n        s[n-1-i] = tmp;\n    }\n}\n\nint main(void) {\n    char str[] = \"abcdef\";\n    reverse(str);\n    puts(str);  // \"fedcba\"\n    return 0;\n}\n\n\nWhy It Matters\nStrings are everywhere: input, output, file names, protocols. Mastering &lt;string.h&gt; is essential to handle them safely and correctly in C.\n\n\nExercises\n\nWrite a function safe_copy(char -dst, size_t n, const char -src) that copies with strncpy and ensures null termination.\nConcatenate \"Hello\" and \"World\" with a space into a buffer and print it.\nWrite a program that counts how many times \"cat\" appears in \"catapult scatter catalog\".\nTokenize a string \"one two three\" on spaces and print each token.\nImplement a function is_palindrome(const char -s) that returns 1 if a string reads the same backward and forward, ignoring case.\n\nHere’s a comprehensive problem set for Chapter 12 (Standard Library Essentials). This covers stdio.h, math.h, time.h, stdlib.h, and string.h with hands-on exercises for beginners.\n\n\n\nProblems\n\nInput/Output (stdio.h)\n\nWrite a program that reads two integers from the user using scanf and prints their sum.\nUse fgets to read a full line of text, then print the line and its length.\nPrint a table of numbers 1–10 alongside their squares and cubes, aligned in neat columns.\nRedirect program output to a file (./prog &gt; out.txt). Modify the program to write errors to stderr instead of stdout.\nWrite a program that reads words until EOF and prints them numbered (1: word, 2: word, …).\n\n\n\nMath Functions (math.h)\n\nCompute the area and circumference of a circle given its radius. Use M_PI if available.\nConvert 45 degrees into radians and print its sine, cosine, and tangent.\nWrite a program that asks for two sides of a right triangle and prints its hypotenuse using hypot.\nDemonstrate ceil, floor, round, and trunc on -2.7 and 2.7.\nImplement compound interest: given P, annual rate r, and years n, compute P - pow(1+r, n).\n\n\n\nTime and Date (time.h)\n\nPrint the current time in local time and UTC.\nFormat today’s date as Saturday, September 6, 2025 using strftime.\nMeasure how long it takes to sum integers 1–100 million.\nAsk the user for a year, month, and day, then print what day of the week it falls on.\nWrite a function timestamp() that prints [YYYY-MM-DD HH:MM:SS] for logging.\n\n\n\n\nRandom Numbers (stdlib.h)\n\nWrite a rand_range(int min, int max) function. Use it to simulate rolling a dice 10 times.\nGenerate 100 random doubles in [0,1) and compute their average.\nSimulate rolling two dice 1000 times. Count how many times the sum is 7.\nDemonstrate that seeding with the same value gives the same random sequence.\nSimulate a coin toss until you get 3 heads in a row. Print the number of tosses needed.\n\n\n\nStrings (string.h)\n\nWrite a safe_copy(char -dst, size_t n, const char -src) function using strncpy and test it.\nConcatenate \"Hello\" and \"World\" with a space in between.\nCount how many times \"cat\" appears in \"catapult scatter catalog\".\nTokenize the string \"red,green,blue\" with strtok and print each token.\nImplement is_palindrome(const char -s) that ignores case. Test with \"Radar\" and \"level\".",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Part I. First Steps</span>"
    ]
  }
]