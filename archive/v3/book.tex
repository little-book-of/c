% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={The Little Book of C},
  pdfauthor={Duc-Tam Nguyen},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{The Little Book of C}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Version 0.3.2}
\author{Duc-Tam Nguyen}
\date{2025-10-05}
\begin{document}
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter{Content}\label{content}

\emph{A 100-step journey to learn C from first principles}

\begin{itemize}
\tightlist
\item
  \href{https://github.com/little-book-of/c/blob/main/releases/book.pdf}{Download
  PDF} - print-ready
\item
  \href{https://github.com/little-book-of/c/blob/main/releases/book.epub}{Download
  EPUB} - e-reader friendly
\item
  \href{https://github.com/little-book-of/c/blob/main/releases/book.tex}{View
  LaTex} - \texttt{.tex} source
\item
  \href{https://github.com/little-book-of/c/blob/main/books/en-US/book.md}{Source
  code (Github)} - Markdown source
\item
  \href{https://little-book-of.github.io/c}{Read on GitHub Pages}
\end{itemize}

\subsection{Chapter 1. Getting Started with
C}\label{chapter-1.-getting-started-with-c}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  What Is C and Why Learn It
\item
  Installing a C Compiler
\item
  Writing Your First C Program
\item
  Understanding \texttt{main} and Return Values
\item
  Printing with \texttt{printf}
\item
  Comments and Code Readability
\item
  Variables and Basic Types
\item
  Declaring and Initializing Variables
\item
  Compiling and Running Programs
\item
  Common Beginner Mistakes
\end{enumerate}

\subsection{Chapter 2. Working with
Data}\label{chapter-2.-working-with-data}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{10}
\tightlist
\item
  Integers, Floats, and Characters
\item
  Type Conversions and Casting
\item
  Constants and Literals
\item
  Operators and Expressions
\item
  Arithmetic Operators
\item
  Comparison and Logical Operators
\item
  Operator Precedence
\item
  Reading Input with \texttt{scanf}
\item
  The \texttt{sizeof} Operator
\item
  Debugging Type Errors
\end{enumerate}

\subsection{Chapter 3. Control Flow}\label{chapter-3.-control-flow}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{20}
\tightlist
\item
  The \texttt{if} Statement
\item
  The \texttt{else} and \texttt{else\ if} Clauses
\item
  Nested Conditionals
\item
  The \texttt{switch} Statement
\item
  The \texttt{while} Loop
\item
  The \texttt{for} Loop
\item
  The \texttt{do-while} Loop
\item
  Breaking and Continuing Loops
\item
  Using \texttt{goto} Safely (and Why to Avoid It)
\item
  Patterns of Control Flow
\end{enumerate}

\subsection{Chapter 4. Functions and
Scope}\label{chapter-4.-functions-and-scope}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{30}
\tightlist
\item
  Defining and Calling Functions
\item
  Function Parameters and Return Values
\item
  Local and Global Variables
\item
  Scope and Lifetime
\item
  Header Declarations (\texttt{.h} files)
\item
  Pass by Value Explained
\item
  Recursion and Base Cases
\item
  Function Prototypes and Order
\item
  Inline Functions
\item
  Organizing Code with Functions
\end{enumerate}

\subsection{Chapter 5. Arrays and
Strings}\label{chapter-5.-arrays-and-strings}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{40}
\tightlist
\item
  Declaring Arrays
\item
  Indexing and Bounds
\item
  Multidimensional Arrays
\item
  Iterating over Arrays
\item
  Strings as Character Arrays
\item
  String Literals and Null Terminators
\item
  Common String Functions (\texttt{strlen}, \texttt{strcpy},
  \texttt{strcmp})
\item
  Inputting Strings
\item
  Arrays vs.~Pointers (A Gentle Intro)
\item
  Common Array Pitfalls
\end{enumerate}

\subsection{Chapter 6. Pointers and
Memory}\label{chapter-6.-pointers-and-memory}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{50}
\tightlist
\item
  What Is a Pointer
\item
  The Address-of (\texttt{\&}) and Dereference (\texttt{*}) Operators
\item
  Pointer Arithmetic
\item
  Arrays and Pointers Revisited
\item
  Function Parameters with Pointers
\item
  Dynamic Memory Allocation with \texttt{malloc}
\item
  Using \texttt{free} Safely
\item
  Pointer to Pointer
\item
  \texttt{NULL} and Dangling Pointers
\item
  Debugging Memory Errors
\end{enumerate}

\subsection{Chapter 7. Structures and Modular
Design}\label{chapter-7.-structures-and-modular-design}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{60}
\tightlist
\item
  Defining \texttt{struct} Types
\item
  Accessing Structure Members
\item
  Structures and Functions
\item
  Nested Structures
\item
  Arrays of Structures
\item
  Typedefs for Simpler Names
\item
  Enums and Symbolic Constants
\item
  Unions and Shared Memory
\item
  Organizing Code into Modules
\item
  Splitting Code into \texttt{.c} and \texttt{.h} Files
\end{enumerate}

\subsection{Chapter 8. The Power of the
Preprocessor}\label{chapter-8.-the-power-of-the-preprocessor}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{70}
\tightlist
\item
  What Is the Preprocessor
\item
  \texttt{\#include} and Header Guards
\item
  Defining Macros with \texttt{\#define}
\item
  Working with Paths and Filenames
\item
  Conditional Compilation (\texttt{\#if}, \texttt{\#ifdef})
\item
  Function-like Macros
\item
  Debugging with \texttt{\#error} and \texttt{\#warning}
\item
  Built-in Macros (\texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_})
\item
  The Compilation Pipeline (Preprocess → Compile → Link)
\item
  Balancing Macros and Functions
\end{enumerate}

\subsection{Chapter 9. Files, Tools, and
Concurrency}\label{chapter-9.-files-tools-and-concurrency}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{80}
\tightlist
\item
  File I/O Basics: \texttt{fopen}, \texttt{fclose}
\item
  Reading and Writing Files
\item
  Working with Binary Files
\item
  Error Handling in File Operations
\item
  Command-Line Arguments
\item
  Using \texttt{make} and Makefiles
\item
  Debugging with \texttt{gdb}
\item
  Understanding Linking and Libraries
\item
  Simple Threads with \texttt{\textless{}threads.h\textgreater{}}
\item
  Synchronization and Data Safety
\end{enumerate}

\subsection{Chapter 10. Putting It All
Together}\label{chapter-10.-putting-it-all-together}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{90}
\tightlist
\item
  Mini Project 1: Text Analyzer
\item
  Mini Project 2: Guessing Game
\item
  Mini Project 3: Calculator
\item
  Mini Project 4: File Copy Utility
\item
  Mini Project 5: Simple Logger
\item
  Mini Project 6: Contact Book
\item
  Mini Project 7: Matrix Operations
\item
  Mini Project 8: JSON-like Parser
\item
  Mini Project 9: Mini Shell
\item
  Mini Project 10: Tiny HTTP Server
\end{enumerate}

\bookmarksetup{startatroot}

\chapter{The Book}\label{the-book}

\section{Chapter 1. Getting started with
C}\label{chapter-1.-getting-started-with-c-1}

\subsection{1. What Is C and Why Learn
It}\label{what-is-c-and-why-learn-it}

C is a language that shaped the modern world of computing.\\
It is small, fast, and close to the machine, yet expressive enough to
build entire operating systems, compilers, databases, and games.\\
Learning C means learning how computers actually work, memory, data, and
control flow, all laid bare, without layers of abstraction in the way.

C has been around for decades because it is both powerful and simple.\\
It gives you a direct line to the processor and memory, and rewards
careful, thoughtful programming.\\
Almost every modern language borrows ideas from C, so mastering it gives
you a foundation for understanding them all.

When you learn C, you learn to think like a systems programmer:

\begin{itemize}
\tightlist
\item
  How data is stored in memory
\item
  How instructions are executed step by step
\item
  How to reason about performance, correctness, and clarity
\end{itemize}

C teaches discipline, precision, and clarity. It is not only a tool, but
a teacher.

\subsubsection{Tiny Code}\label{tiny-code}

Let's see the smallest C program possible:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Save it as \texttt{hello.c}, then compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

You'll see:

\begin{verbatim}
Hello, world!
\end{verbatim}

This is your first conversation with the machine.

\subsubsection{Why It Matters}\label{why-it-matters}

Every journey in programming begins with understanding how to talk to
the computer. C helps you do that at the deepest level. It shows how
your code becomes instructions and how those instructions shape the
behavior of your program.

Even if you move on to higher-level languages, C gives you a foundation
to understand what happens beneath the surface, why memory matters, why
types matter, and how to write efficient, predictable code.

\subsubsection{Try It Yourself}\label{try-it-yourself}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Modify the program to print your name instead of ``Hello, world!''
\item
  Remove the \texttt{return\ 0;} line. What happens when you compile and
  run?
\item
  Add another \texttt{printf} line. Can you print two messages?
\item
  Change \texttt{int\ main(void)} to \texttt{int\ main()}. Does it still
  compile?
\item
  Try using \texttt{puts("Hello");} instead of \texttt{printf}. What's
  the difference?
\end{enumerate}

Learning C begins with curiosity and courage. You'll write small
programs at first, but each one will bring you closer to understanding
the heart of computing.

\subsection{2. Installing a C Compiler}\label{installing-a-c-compiler}

Before you can run any C program, you need a compiler, a tool that
translates human-readable code into machine instructions your computer
can execute. C doesn't run through an interpreter like Python or
JavaScript. Every program must be compiled into an executable file.

Once your compiler is ready, you can transform code like
\texttt{hello.c} into a working program with a single command.

\subsubsection{2.1 What a Compiler Does}\label{what-a-compiler-does}

A C compiler performs several steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Preprocessing, expands macros and includes headers
\item
  Compilation, translates C code into assembly
\item
  Assembly, converts assembly into object code
\item
  Linking, combines object code with libraries into an executable
\end{enumerate}

You don't need to do these steps manually; the compiler does it all when
you run \texttt{gcc\ hello.c\ -o\ hello}. Still, understanding them
helps you appreciate how C turns text into software.

\subsubsection{2.2 Choosing a Compiler}\label{choosing-a-compiler}

There are several standard C compilers:

\begin{itemize}
\tightlist
\item
  GCC (GNU Compiler Collection), available on Linux, macOS, and Windows
  (via MinGW or WSL)
\item
  Clang, fast, modern, and available on macOS and Linux
\item
  MSVC (Microsoft Visual C++), part of Visual Studio on Windows
\end{itemize}

You can use any of these; they all follow the same standard and will
work for this book.

\subsubsection{2.3 Installing on Your
System}\label{installing-on-your-system}

On Linux Most distributions include GCC. Try:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}{-}version}
\end{Highlighting}
\end{Shaded}

If it's missing, install it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ apt install build{-}essential   }\CommentTok{\# Debian/Ubuntu}
\FunctionTok{sudo}\NormalTok{ dnf install gcc               }\CommentTok{\# Fedora}
\end{Highlighting}
\end{Shaded}

On macOS Install the Xcode Command Line Tools:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{xcode{-}select} \AttributeTok{{-}{-}install}
\end{Highlighting}
\end{Shaded}

This includes Clang, which works exactly like GCC for our purposes.

On Windows You have a few options:

\begin{itemize}
\tightlist
\item
  MinGW, lightweight and easy to install:
  \href{https://mingw-w64.org}{mingw-w64.org}
\item
  WSL, install a Linux environment inside Windows and use GCC
\item
  Visual Studio, install the C++ development workload
\end{itemize}

For simplicity, MinGW or WSL are recommended if you follow examples in
this book.

\subsubsection{Tiny Code}\label{tiny-code-1}

After installation, verify your compiler works:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}{-}version}
\end{Highlighting}
\end{Shaded}

Then compile your first program:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\ExtensionTok{./hello}
\end{Highlighting}
\end{Shaded}

If you see \texttt{Hello,\ world!}, your toolchain is ready.

\subsubsection{Why It Matters}\label{why-it-matters-1}

Your compiler is the bridge between your ideas and the machine. It
doesn't just check your syntax, it builds your program step by step,
optimizing and linking it with system libraries. Learning to use the
compiler early helps you troubleshoot, experiment, and take control of
how your programs are built.

You'll use the same compiler to handle every program in this book, from
tiny scripts to full projects.

\subsubsection{Try It Yourself}\label{try-it-yourself-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run \texttt{gcc\ -\/-version} or \texttt{clang\ -\/-version} to check
  your setup.
\item
  Compile \texttt{hello.c} with different output names using
  \texttt{-o}, for example \texttt{-o\ greet}.
\item
  Add a missing semicolon in your code. What error message do you get?
\item
  Try compiling with \texttt{clang\ hello.c\ -o\ hello} if you have
  Clang installed.
\item
  Run your program from a different directory to understand relative
  paths.
\end{enumerate}

Once your compiler is working, you're ready to dive into real
programming, learning how to express ideas in code, line by line.

\subsection{3. Writing Your First C
Program}\label{writing-your-first-c-program}

Now that your compiler is ready, it's time to write a complete C program
from scratch. A C program is just plain text that follows specific rules
of structure and syntax. Every program begins the same way, with a main
function, the entry point where execution starts.

This section will help you build your first working program step by
step.

\subsubsection{3.1 The Structure of a C
Program}\label{the-structure-of-a-c-program}

Every C program follows a basic shape:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// your code here}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\#include\ \textless{}stdio.h\textgreater{}} tells the
  compiler you want to use the Standard Input/Output library.
\item
  \texttt{int\ main(void)} defines the main function, where your program
  begins.
\item
  \texttt{\{\ ...\ \}} marks the start and end of the function body.
\item
  \texttt{return\ 0;} signals that the program finished successfully.
\end{itemize}

\subsubsection{3.2 Writing and Running the
Program}\label{writing-and-running-the-program}

Open a text editor and type this code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome to C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Save the file as \texttt{welcome.c}. Now compile and run it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ welcome.c }\AttributeTok{{-}o}\NormalTok{ welcome}
\ExtensionTok{./welcome}
\end{Highlighting}
\end{Shaded}

You should see:

\begin{verbatim}
Welcome to C!
\end{verbatim}

\subsubsection{\texorpdfstring{3.3 Understanding
\texttt{printf}}{3.3 Understanding printf}}\label{understanding-printf}

The function \texttt{printf} is used to print messages to the screen. It
takes a format string and optional arguments.

For now, you can think of it as a simple way to display text. The
special symbol \texttt{\textbackslash{}n} adds a newline, moving the
cursor to the next line.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Hello}\SpecialCharTok{\textbackslash{}n}\StringTok{World}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello
World
\end{verbatim}

\subsubsection{3.4 Comments and
Readability}\label{comments-and-readability}

Comments help others (and your future self) understand your code.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// This is a single{-}line comment}

\CommentTok{/*}
\CommentTok{ This is a multi{-}line comment.}
\CommentTok{ You can explain logic here.}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

Comments are ignored by the compiler but valued by programmers.

\subsubsection{Tiny Code}\label{tiny-code-2}

Try this short example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Print two lines}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C is powerful.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Let\textquotesingle{}s start learning!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ start.c }\AttributeTok{{-}o}\NormalTok{ start}
\ExtensionTok{./start}
\end{Highlighting}
\end{Shaded}

You'll see two lines of output.

\subsubsection{Why It Matters}\label{why-it-matters-2}

Your first C program may seem simple, but it contains every essential
element of real software:

\begin{itemize}
\tightlist
\item
  A clear entry point (\texttt{main})
\item
  Standard library usage (\texttt{stdio.h})
\item
  Output to the user (\texttt{printf})
\item
  A clean exit (\texttt{return\ 0})
\end{itemize}

This structure forms the backbone of all C programs, no matter how large
they grow.

\subsubsection{Try It Yourself}\label{try-it-yourself-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Change the text in \texttt{printf} to your favorite quote.
\item
  Add a second \texttt{printf} call with a different message.
\item
  Remove the \texttt{\textbackslash{}n} and see how the output changes.
\item
  Add comments above each line explaining what it does.
\item
  Delete \texttt{return\ 0;} and recompile. Does it still work? Why?
\end{enumerate}

Every big program begins as a small one. Once you can write and run
code, you can build anything, one line at a time.

\subsection{\texorpdfstring{4. Understanding \texttt{main} and Return
Values}{4. Understanding main and Return Values}}\label{understanding-main-and-return-values}

Every C program starts its journey in one special place, the
\texttt{main} function. When your program runs, the operating system
calls \texttt{main} first. What happens inside determines everything
that follows: what the program does, what it prints, and what it returns
when finished.

Let's explore how \texttt{main} works and why its return value matters.

\subsubsection{\texorpdfstring{4.1 The Role of
\texttt{main}}{4.1 The Role of main}}\label{the-role-of-main}

\texttt{main} is the entry point. Without it, the compiler cannot link
your program into a valid executable.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// your code here}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{int} means \texttt{main} returns an integer value to the
  operating system.
\item
  \texttt{void} means \texttt{main} takes no arguments.
\item
  The curly braces \texttt{\{\}} contain the code that runs when the
  program starts.
\end{itemize}

\subsubsection{4.2 Returning Values}\label{returning-values}

The value returned by \texttt{main} tells the operating system whether
the program succeeded or failed.

By convention:

\begin{itemize}
\tightlist
\item
  \texttt{return\ 0;} means success
\item
  Nonzero (like \texttt{return\ 1;}) means error or failure
\end{itemize}

You can check this in a terminal:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program}
\BuiltInTok{echo} \VariableTok{$?}
\end{Highlighting}
\end{Shaded}

The \texttt{echo\ \$?} command prints the exit code of the last program.

\subsubsection{\texorpdfstring{4.3 Variants of
\texttt{main}}{4.3 Variants of main}}\label{variants-of-main}

There are two valid forms:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}   \CommentTok{// No arguments}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}   \CommentTok{// With command{-}line arguments}
\end{Highlighting}
\end{Shaded}

We'll use the simpler \texttt{void} form for now. You'll learn the
version with \texttt{argc} and \texttt{argv} later when working with
command-line tools.

\subsubsection{4.4 Flow of Execution}\label{flow-of-execution}

When you run your program, this happens:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The operating system loads the program into memory
\item
  It calls \texttt{main}
\item
  Your code runs line by line
\item
  When \texttt{return} is reached (or the end of the function), control
  returns to the OS
\end{enumerate}

This is the simplest model of program execution, clear, linear, and
predictable.

\subsubsection{Tiny Code}\label{tiny-code-3}

Try this small experiment:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Program is running...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ run.c }\AttributeTok{{-}o}\NormalTok{ run}
\ExtensionTok{./run}
\BuiltInTok{echo} \VariableTok{$?}
\end{Highlighting}
\end{Shaded}

You'll see \texttt{Program\ is\ running...} and then \texttt{0},
confirming success.

Now change the code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Run again. \texttt{echo\ \$?} will print \texttt{1}.

\subsubsection{Why It Matters}\label{why-it-matters-3}

Every program must begin and end cleanly. Returning the correct value
helps you write software that interacts well with other programs and
scripts. Professional developers often check return codes in automation,
testing, and system tools.

Understanding \texttt{main} teaches you that programs are conversations
with the operating system, you say what you did through your exit code.

\subsubsection{Try It Yourself}\label{try-it-yourself-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that returns \texttt{0} and prints ``All good.''
\item
  Change it to return \texttt{1} and print ``Something went wrong.''
\item
  Run both and compare \texttt{echo\ \$?} outputs.
\item
  Remove the \texttt{return} line entirely. What does your compiler do?
\item
  Replace \texttt{int\ main(void)} with \texttt{void\ main(void)}. Does
  it compile? Why is \texttt{int\ main} preferred?
\end{enumerate}

When you understand \texttt{main}, you understand how your program
begins, how it ends, and how it communicates success or failure, the
three pillars of every executable.

\subsection{\texorpdfstring{5. Printing with
\texttt{printf}}{5. Printing with printf}}\label{printing-with-printf}

One of the first things every C program learns to do is print text to
the screen. The function \texttt{printf} (print formatted) is your main
tool for displaying messages, numbers, and results. It's part of the
Standard I/O Library (\texttt{stdio.h}) and one of the most useful
functions in all of C.

Let's explore how \texttt{printf} works and how to control its output.

\subsubsection{5.1 The Basics}\label{the-basics}

A simple \texttt{printf} call looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The text inside quotes is a string literal. The
\texttt{\textbackslash{}n} at the end is a newline character, it moves
the cursor to the next line.

Output:

\begin{verbatim}
Hello, world!
\end{verbatim}

\subsubsection{5.2 Strings and Escape
Sequences}\label{strings-and-escape-sequences}

Inside a string, you can include special sequences beginning with a
backslash:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Sequence & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\textbackslash{}n} & New line \\
\texttt{\textbackslash{}t} & Tab \\
\texttt{\textbackslash{}\textbackslash{}} & Backslash \\
\texttt{\textbackslash{}"} & Double quote \\
\texttt{\textbackslash{}a} & Alert (beep) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Name:}\SpecialCharTok{\textbackslash{}t}\StringTok{Alice}\SpecialCharTok{\textbackslash{}n}\StringTok{Age:}\SpecialCharTok{\textbackslash{}t}\StringTok{20}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Name:   Alice
Age:    20
\end{verbatim}

\subsubsection{5.3 Printing Numbers}\label{printing-numbers}

\texttt{printf} can also print numbers. You use format specifiers to
tell it what kind of value to print.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Specifier & Type & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\%d} & int & \texttt{printf("\%d",\ 42);} \\
\texttt{\%f} & double & \texttt{printf("\%f",\ 3.14);} \\
\texttt{\%c} & char &
\texttt{printf("\%c",\ \textquotesingle{}A\textquotesingle{});} \\
\texttt{\%s} & string & \texttt{printf("\%s",\ "Hi");} \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{30}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"I am }\SpecialCharTok{\%d}\StringTok{ years old.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
I am 30 years old.
\end{verbatim}

\subsubsection{5.4 Combining Text and
Values}\label{combining-text-and-values}

You can mix text and placeholders freely:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Sum of }\SpecialCharTok{\%d}\StringTok{ and }\SpecialCharTok{\%d}\StringTok{ is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{,}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Each \texttt{\%} symbol corresponds to an argument after the string.
They are matched in order.

Output:

\begin{verbatim}
Sum of 5 and 7 is 12
\end{verbatim}

\subsubsection{5.5 Formatting Numbers}\label{formatting-numbers}

You can control width and precision:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.1415926535}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"pi = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pi}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
pi = 3.14
\end{verbatim}

Here \texttt{\%.2f} means ``print 2 digits after the decimal.''

\subsubsection{Tiny Code}\label{tiny-code-4}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ apples }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ price }\OperatorTok{=} \FloatTok{1.25}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"I bought }\SpecialCharTok{\%d}\StringTok{ apples at $}\SpecialCharTok{\%.2f}\StringTok{ each.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ apples}\OperatorTok{,}\NormalTok{ price}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total cost: $}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ apples }\OperatorTok{*}\NormalTok{ price}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run to see formatted values printed neatly.

\subsubsection{Why It Matters}\label{why-it-matters-4}

Output is how programs communicate. With \texttt{printf}, you can
inspect variables, debug logic, and make programs interactive. It's not
just about text, it's about making invisible computation visible.

As you learn more, you'll use \texttt{printf} constantly to understand
what your code is doing.

\subsubsection{Try It Yourself}\label{try-it-yourself-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print your name, age, and favorite number using \texttt{\%s} and
  \texttt{\%d}.
\item
  Experiment with \texttt{\%f} and \texttt{\%.3f} to show different
  decimal places.
\item
  Print \texttt{\textbackslash{}t} and \texttt{\textbackslash{}n} to see
  how tabs and newlines affect layout.
\item
  Mix characters and numbers:
  \texttt{printf("Char:\ \%c,\ Code:\ \%d",\ \textquotesingle{}A\textquotesingle{},\ \textquotesingle{}A\textquotesingle{});}
\item
  Write a sentence combining three variables of different types.
\end{enumerate}

Every program starts by talking to you through text. Mastering
\texttt{printf} teaches you to control that voice, clear, precise, and
expressive.

\subsection{6. Comments and Code
Readability}\label{comments-and-code-readability}

Code is written for humans first, computers second. The compiler doesn't
need explanations, but future readers (including you) will. That's where
comments come in, notes you leave inside your code to describe what's
happening and why.

Good comments make your code easier to read, maintain, and extend. They
turn lines of logic into a story that others can follow.

\subsubsection{6.1 Why Comment Your Code}\label{why-comment-your-code}

Comments help you:

\begin{itemize}
\tightlist
\item
  Explain \emph{why} something is written a certain way
\item
  Mark complex sections for future reference
\item
  Remind yourself of unfinished work
\item
  Communicate intent to teammates
\end{itemize}

A program without comments might still work, but it's harder to
understand. A well-commented program tells both the \emph{what} and the
\emph{why}.

\subsubsection{6.2 Types of Comments in C}\label{types-of-comments-in-c}

C supports two styles of comments:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Single-line comment

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// This is a single{-}line comment}
\end{Highlighting}
\end{Shaded}
\item
  Multi-line comment

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* This is a }
\CommentTok{   multi{-}line comment */}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Single-line comments are best for short notes. Multi-line comments are
useful for describing longer ideas, algorithms, or sections.

\subsubsection{6.3 Where to Use Comments}\label{where-to-use-comments}

Use comments:

\begin{itemize}
\tightlist
\item
  Above a function or block to describe its purpose
\item
  Beside tricky or non-obvious code
\item
  At the top of a file to outline the program
\item
  To mark TODOs for future changes
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Print a friendly greeting}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{/* }\AlertTok{TODO}\CommentTok{:}
\CommentTok{       Add user input here later}
\CommentTok{    */}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{6.4 What Not to Do}\label{what-not-to-do}

Avoid obvious or redundant comments:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// set x to 10  ← unnecessary}
\end{Highlighting}
\end{Shaded}

Instead, focus on intent:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ retries }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// maximum number of connection attempts}
\end{Highlighting}
\end{Shaded}

Comments should add meaning, not repeat the code.

\subsubsection{Tiny Code}\label{tiny-code-5}

Try this short example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Program to calculate total price}

    \DataTypeTok{int}\NormalTok{ items }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}       \CommentTok{// number of products}
    \DataTypeTok{double}\NormalTok{ price }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}  \CommentTok{// price per item}
    \DataTypeTok{double}\NormalTok{ total }\OperatorTok{=}\NormalTok{ items }\OperatorTok{*}\NormalTok{ price}\OperatorTok{;} \CommentTok{// compute total}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total: $}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;} \CommentTok{// program ended successfully}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run, then read it as if you were a new developer. Every line
tells a story.

\subsubsection{Why It Matters}\label{why-it-matters-5}

Code is read more often than it's written. A comment today can save
hours of confusion tomorrow. By documenting your reasoning, you make
your programs friendlier, clearer, and easier to improve.

Comments are part of your craft, invisible to the machine, invaluable to
the human.

\subsubsection{Try It Yourself}\label{try-it-yourself-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add single-line comments to describe each step of a simple math
  program.
\item
  Use a multi-line comment at the top of your file to describe its
  purpose.
\item
  Write a \texttt{TODO} comment for a feature you plan to add later.
\item
  Add a confusing variable name, then explain it with a comment.
\item
  Remove redundant comments that don't add information.
\end{enumerate}

Readable code is thoughtful code. Every comment is a note to your future
self, write them with care.

\subsection{7. Variables and Basic
Types}\label{variables-and-basic-types}

Programs need a way to store information, numbers, characters, and other
data that change as your program runs. In C, you do this with variables.
A variable is a named piece of memory that can hold a value.

Before you can use a variable, you must declare it and tell C what type
of data it will store.

\subsubsection{7.1 What Is a Variable}\label{what-is-a-variable}

A variable has three parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Name, what you call it
\item
  Type, what kind of data it holds
\item
  Value, what's stored inside
\end{enumerate}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{21}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{int} is the type (integer)
\item
  \texttt{age} is the name
\item
  \texttt{21} is the value
\end{itemize}

This line creates a space in memory named \texttt{age} to hold an
integer.

\subsubsection{7.2 Declaring and
Initializing}\label{declaring-and-initializing}

You declare a variable by writing its type followed by its name:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can also give it a starting value (initialization):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You may declare multiple variables of the same type in one line:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

But clarity is often better than compactness.

\subsubsection{7.3 Basic Data Types}\label{basic-data-types}

C has several fundamental types:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int} & Whole numbers & \texttt{int\ x\ =\ 5;} \\
\texttt{float} & Decimal numbers (less precise) &
\texttt{float\ g\ =\ 9.8;} \\
\texttt{double} & Decimal numbers (more precise) &
\texttt{double\ pi\ =\ 3.1416;} \\
\texttt{char} & Single character &
\texttt{char\ grade\ =\ \textquotesingle{}A\textquotesingle{};} \\
\texttt{\_Bool} & Boolean value (0 or 1) & \texttt{\_Bool\ ok\ =\ 1;} \\
\end{longtable}

\subsubsection{7.4 Naming Variables}\label{naming-variables}

Names should be:

\begin{itemize}
\tightlist
\item
  Descriptive: \texttt{score}, \texttt{height}, \texttt{count}
\item
  Lowercase with underscores: \texttt{total\_sum}
\item
  Not keywords like \texttt{int}, \texttt{return}, or \texttt{if}
\end{itemize}

Valid examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ total}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ average\_height}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ first\_letter}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Invalid examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \DecValTok{3}\ErrorTok{number}\OperatorTok{;}   \CommentTok{// cannot start with a digit}
\DataTypeTok{int} \ControlFlowTok{return}\OperatorTok{;}    \CommentTok{// keyword not allowed}
\end{Highlighting}
\end{Shaded}

\subsubsection{7.5 Changing Values}\label{changing-values}

Once declared, you can assign new values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{score }\OperatorTok{=} \DecValTok{15}\OperatorTok{;} \CommentTok{// overwrite with new value}
\end{Highlighting}
\end{Shaded}

The latest assignment replaces the old one.

\subsubsection{Tiny Code}\label{tiny-code-6}

Here's a short example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ apples }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ price }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ currency }\OperatorTok{=} \CharTok{\textquotesingle{}$\textquotesingle{}}\OperatorTok{;}

    \DataTypeTok{double}\NormalTok{ total }\OperatorTok{=}\NormalTok{ apples }\OperatorTok{*}\NormalTok{ price}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total cost: }\SpecialCharTok{\%c\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ currency}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Total cost: $12.50
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-6}

Variables are the building blocks of all programs. They hold the data
your code will process, transform, and display. By understanding types,
you gain control over how much memory your data uses and how the
compiler interprets it.

Knowing what each variable represents keeps your programs precise and
readable.

\subsubsection{Try It Yourself}\label{try-it-yourself-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare an \texttt{int} called \texttt{age} and print it.
\item
  Add a \texttt{double} called \texttt{height} and print it with
  \texttt{\%.2f}.
\item
  Create a \texttt{char} called \texttt{initial} and print it using
  \texttt{\%c}.
\item
  Change a variable's value and print before and after.
\item
  Try naming a variable with an invalid character and read the error
  message.
\end{enumerate}

Variables give life to your programs. Once you can store and name data,
you can begin to calculate, compare, and create.

\subsection{8. Declaring and Initializing
Variables}\label{declaring-and-initializing-variables}

Declaring a variable tells the compiler what kind of data you want to
store and what name you'll use to refer to it. Initializing a variable
gives it a starting value. Both are essential: declaration defines the
shape, initialization gives it life.

In C, uninitialized variables contain garbage values, random data left
in memory, so it's always a good habit to initialize them before use.

\subsubsection{8.1 Declaration}\label{declaration}

To declare a variable, specify its type followed by a name:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ price}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ letter}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

At this stage, memory is reserved for each variable, but their contents
are undefined.

If you print \texttt{count} before giving it a value, you'll get
unpredictable results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);} \CommentTok{// undefined behavior}
\end{Highlighting}
\end{Shaded}

Always assign a value before using a variable.

\subsubsection{8.2 Initialization}\label{initialization}

You can give a variable a value as soon as you declare it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ grade }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is called initialization, setting the initial value at creation.
It's the safest, clearest way to define variables.

\subsubsection{8.3 Combined Declarations}\label{combined-declarations}

You can declare multiple variables of the same type in one line:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is valid, but avoid combining different types:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}  \CommentTok{// ok}
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{1}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}  \CommentTok{// invalid}
\end{Highlighting}
\end{Shaded}

Each type must be declared separately.

\subsubsection{8.4 Initialization Later}\label{initialization-later}

Sometimes you know a variable's type, but not its value yet:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score}\OperatorTok{;}
\NormalTok{score }\OperatorTok{=} \DecValTok{100}\OperatorTok{;} \CommentTok{// assign later}
\end{Highlighting}
\end{Shaded}

That's fine, as long as you assign before use.

\subsubsection{8.5 Constants
vs.~Variables}\label{constants-vs.-variables}

If a value should never change, mark it as constant:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ TAX\_RATE }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Trying to modify it later causes a compile error. Constants make your
code safer and clearer.

\subsubsection{Tiny Code}\label{tiny-code-7}

Try this short program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}           \CommentTok{// initialized}
    \DataTypeTok{double}\NormalTok{ height}\OperatorTok{;}          \CommentTok{// declared}
\NormalTok{    height }\OperatorTok{=} \FloatTok{1.75}\OperatorTok{;}          \CommentTok{// assigned later}
    \DataTypeTok{const} \DataTypeTok{double}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;} \CommentTok{// constant}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Height: }\SpecialCharTok{\%.2f}\StringTok{ m}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ height}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"PI: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ PI}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Age: 25
Height: 1.75 m
PI: 3.14
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-7}

Uninitialized variables are one of the most common beginner mistakes.
They lead to unpredictable behavior and subtle bugs. By initializing
variables early, you ensure your program behaves consistently and is
easier to read.

Constants also help communicate intent, if something should never
change, declare it so.

\subsubsection{Try It Yourself}\label{try-it-yourself-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare and initialize three variables: \texttt{int}, \texttt{double},
  and \texttt{char}.
\item
  Print them all with correct format specifiers.
\item
  Create a \texttt{const\ int} called \texttt{MAX\_SCORE} and try
  changing it. What happens?
\item
  Declare a variable without initializing it, print it, and observe the
  output.
\item
  Fix your program by initializing every variable properly.
\end{enumerate}

Initialization turns empty memory into meaningful data. By giving every
variable a clear starting point, you build reliable and predictable
programs.

\subsection{9. Compiling and Running
Programs}\label{compiling-and-running-programs}

Writing code is only the first half of programming. To see your program
in action, you must compile it, transform human-readable C code into
machine code the computer can execute. This process is handled by a
compiler, and understanding how it works helps you fix errors and
control your builds.

\subsubsection{9.1 From Source to
Executable}\label{from-source-to-executable}

A C file like \texttt{hello.c} is source code, plain text. To run it,
you must translate it into a binary executable.

When you use a command like:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c }\AttributeTok{{-}o}\NormalTok{ hello}
\end{Highlighting}
\end{Shaded}

the compiler does several steps internally:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Preprocessing, handles \texttt{\#include} and \texttt{\#define}
\item
  Compilation, translates code into assembly
\item
  Assembly, converts assembly into object code (\texttt{.o} file)
\item
  Linking, combines your code with libraries (like \texttt{stdio})
\end{enumerate}

The final result is an executable file (\texttt{hello}) that your system
can run.

\subsubsection{9.2 Using GCC or Clang}\label{using-gcc-or-clang}

Most systems use GCC or Clang to compile C programs. They share the same
basic commands:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ file.c }\AttributeTok{{-}o}\NormalTok{ program}
\FunctionTok{clang}\NormalTok{ file.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

Run the program with:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program}
\end{Highlighting}
\end{Shaded}

If you omit \texttt{-o}, the compiler outputs a default file called
\texttt{a.out}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ hello.c}
\ExtensionTok{./a.out}
\end{Highlighting}
\end{Shaded}

\subsubsection{9.3 Handling Errors}\label{handling-errors}

If there's a mistake, the compiler prints an error:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ bad.c }\AttributeTok{{-}o}\NormalTok{ bad}
\ExtensionTok{bad.c:}\NormalTok{ In function }\StringTok{\textquotesingle{}main\textquotesingle{}}\NormalTok{:}
\ExtensionTok{bad.c:3:5:}\NormalTok{ error: expected }\StringTok{\textquotesingle{};\textquotesingle{}}\NormalTok{ before }\StringTok{\textquotesingle{}return\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Read error messages carefully, they show file, line number, and reason.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!"}\OperatorTok{)} \CommentTok{// missing semicolon}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Fix: add \texttt{;} at the end of the \texttt{printf} line.

\subsubsection{9.4 Warnings}\label{warnings}

Even if your code compiles, the compiler may issue warnings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ test.c }\AttributeTok{{-}o}\NormalTok{ test}
\ExtensionTok{test.c:4:5:}\NormalTok{ warning: unused variable }\StringTok{\textquotesingle{}x\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Warnings aren't fatal but often signal bugs or bad habits. You can
enable stricter checks with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}pedantic}\NormalTok{ file.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

Always treat warnings seriously.

\subsubsection{9.5 Running the Program}\label{running-the-program}

Once compiled, run your program from the terminal:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{./program}
\end{Highlighting}
\end{Shaded}

The computer now executes your compiled code line by line.

\subsubsection{Tiny Code}\label{tiny-code-8}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and run:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ sum.c }\AttributeTok{{-}o}\NormalTok{ sum}
\ExtensionTok{./sum}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum: 15
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-8}

Understanding the build process helps you troubleshoot and improve your
workflow. You'll learn what errors mean, how linking works, and how to
organize large projects. Compiling isn't a black box, it's a
step-by-step transformation you control.

Each time you compile, you move from \emph{idea} to \emph{executable
reality}.

\subsubsection{Try It Yourself}\label{try-it-yourself-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a simple program that prints a message. Compile and run it.
\item
  Remove a semicolon and observe the compiler error.
\item
  Add \texttt{-Wall} and fix all warnings.
\item
  Compile two programs: one with \texttt{-o\ hello} and one without.
  Compare results.
\item
  Introduce a typo in \texttt{printf} and read the error carefully.
\end{enumerate}

Compilation is the bridge from writing to running. Once you master it,
your ideas can come alive on any computer.

\subsection{10. Common Beginner
Mistakes}\label{common-beginner-mistakes}

Every new C programmer stumbles on the same kinds of problems. That's
perfectly normal, these mistakes are how you learn what the compiler
expects and how C actually works. Recognizing them early saves hours of
confusion and helps you debug with confidence.

Let's look at the most common ones, why they happen, and how to fix
them.

\subsubsection{10.1 Missing Semicolons}\label{missing-semicolons}

Every C statement must end with a semicolon:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Hello, world!"}\OperatorTok{)}   \CommentTok{// ❌ missing semicolon}
\end{Highlighting}
\end{Shaded}

Fix it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Hello, world!"}\OperatorTok{);}  \CommentTok{// ✅ correct}
\end{Highlighting}
\end{Shaded}

The compiler will stop with an error like ``expected `;' before
`return'\,''. Whenever you see a syntax error, first check for a missing
\texttt{;}.

\subsubsection{\texorpdfstring{10.2 Forgetting
\texttt{\#include}}{10.2 Forgetting \#include}}\label{forgetting-include}

If you use \texttt{printf} or \texttt{scanf} without including
\texttt{\textless{}stdio.h\textgreater{}}, you'll see errors like:

\begin{verbatim}
undefined reference to printf
\end{verbatim}

Always include necessary headers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

This tells the compiler what functions you're using and their correct
signatures.

\subsubsection{10.3 Using Uninitialized
Variables}\label{using-uninitialized-variables}

C doesn't automatically set variables to zero. If you forget to give
them a value, they contain random memory data:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// ❌ unpredictable result}
\end{Highlighting}
\end{Shaded}

Fix it by initializing:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Always initialize before use.

\subsubsection{10.4 Wrong Format
Specifiers}\label{wrong-format-specifiers}

Each format specifier in \texttt{printf} must match the type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// ❌ wrong: \%f expects double}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// ✅ matches int}
\end{Highlighting}
\end{Shaded}

Mismatched specifiers lead to nonsense output or crashes.

\subsubsection{\texorpdfstring{10.5 Forgetting Return Type in
\texttt{main}}{10.5 Forgetting Return Type in main}}\label{forgetting-return-type-in-main}

Always declare \texttt{main} with a return type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main}\OperatorTok{()} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ❌ old{-}style declaration}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ✅ standard form}
\end{Highlighting}
\end{Shaded}

Without \texttt{int}, the compiler may issue warnings or misinterpret
the function.

\subsubsection{10.6 Mismatched Braces or
Parentheses}\label{mismatched-braces-or-parentheses}

Each \texttt{\{} must have a matching \texttt{\}}. If you see errors
like \emph{``expected `\}' at end of input''}, check your brackets.

Good editors highlight matching pairs, use them to spot missing ones
quickly.

\subsubsection{\texorpdfstring{10.7 Using \texttt{=} Instead of
\texttt{==}}{10.7 Using = Instead of ==}}\label{using-instead-of}

\texttt{=} assigns, \texttt{==} compares.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ❌ assigns 5 to x}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ✅ checks equality}
\end{Highlighting}
\end{Shaded}

Assignment inside conditions can cause subtle bugs. Many compilers warn
about this if you enable \texttt{-Wall}.

\subsubsection{10.8 Ignoring Warnings}\label{ignoring-warnings}

Warnings are hints from the compiler. Even if your program runs,
warnings often mean hidden problems.

Always compile with:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}pedantic}\NormalTok{ file.c }\AttributeTok{{-}o}\NormalTok{ file}
\end{Highlighting}
\end{Shaded}

and read every message carefully.

\subsubsection{Tiny Code}\label{tiny-code-9}

Here's a buggy example, can you spot the mistakes?

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age is: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Problems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Missing semicolon after \texttt{int\ age}
\item
  \texttt{age} not initialized before printing
\end{enumerate}

Fixed version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age is: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-9}

Mistakes are not failures, they're feedback. Every error message teaches
you something about C's rules and precision. By studying common errors,
you develop instincts that prevent them before they happen.

Learning to fix bugs is as valuable as writing code itself.

\subsubsection{Try It Yourself}\label{try-it-yourself-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program and intentionally forget a semicolon. Read the
  error.
\item
  Use the wrong format specifier, then correct it.
\item
  Declare a variable but don't initialize it, print it, then fix it.
\item
  Remove a brace and see what error the compiler gives.
\item
  Turn on \texttt{-Wall} and clean up all warnings.
\end{enumerate}

Every expert started by breaking their code. The difference is that they
kept fixing it.

\section{Chapter 2. Working with
Data}\label{chapter-2.-working-with-data-1}

\subsection{11. Integers, Floats, and
Characters}\label{integers-floats-and-characters}

Every program works with data, and in C, each piece of data has a type.
The three most common types you'll use from the start are integers,
floating-point numbers, and characters. They represent whole numbers,
real numbers, and single symbols, the building blocks of computation.

Let's explore each one and how to use them correctly.

\subsubsection{11.1 Integers}\label{integers}

An integer stores whole numbers, positive or negative, without decimals.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ apples }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ temperature }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{10}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{int} typically uses 4 bytes of memory, storing values roughly
between -2 billion and +2 billion (platform dependent).

Other integer types:

\begin{itemize}
\tightlist
\item
  \texttt{short}, smaller range, 2 bytes
\item
  \texttt{long}, larger range, often 8 bytes
\item
  \texttt{unsigned\ int}, only nonnegative numbers, doubles the positive
  range
\end{itemize}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{short}\NormalTok{ s }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
\DataTypeTok{long}\NormalTok{ big }\OperatorTok{=} \DecValTok{1000000}\BuiltInTok{L}\OperatorTok{;}
\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ u }\OperatorTok{=} \DecValTok{42}\BuiltInTok{U}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Suffixes like \texttt{L} or \texttt{U} make intent clear.

\subsubsection{11.2 Floating-Point
Numbers}\label{floating-point-numbers}

A float or double stores decimal numbers.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14}\BuiltInTok{f}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ radius }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{float} is single-precision (around 6--7 digits)
\item
  \texttt{double} is double-precision (around 15--16 digits)
\end{itemize}

Always use \texttt{double} when you need accuracy. Use the suffix
\texttt{f} for floats (\texttt{3.14f}), or leave it off for doubles.

Operations:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ area }\OperatorTok{=} \FloatTok{3.14} \OperatorTok{*}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{11.3 Characters}\label{characters}

A character (\texttt{char}) stores a single symbol, like
\texttt{\textquotesingle{}A\textquotesingle{}} or
\texttt{\textquotesingle{}3\textquotesingle{}}. Use single quotes
\texttt{\textquotesingle{}\ \textquotesingle{}}, not double quotes
\texttt{"\ "} which are for strings.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ grade }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ symbol }\OperatorTok{=} \CharTok{\textquotesingle{}\#\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Under the hood, a \texttt{char} is actually a small integer representing
an ASCII code:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ letter }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ letter}\OperatorTok{,}\NormalTok{ letter}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
A 65
\end{verbatim}

You can treat characters as numbers and perform arithmetic on them:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ next }\OperatorTok{=}\NormalTok{ letter }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// \textquotesingle{}B\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{11.4 Mixed Operations}\label{mixed-operations}

When you combine types, C automatically promotes smaller types to larger
ones.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ result }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{;} \CommentTok{// x converted to double}
\end{Highlighting}
\end{Shaded}

Be careful when dividing integers:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);} \CommentTok{// prints 2 (integer division)}
\end{Highlighting}
\end{Shaded}

Use a float or double for precise results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);} \CommentTok{// prints 2.50}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-10}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ height }\OperatorTok{=} \FloatTok{1.75}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ initial }\OperatorTok{=} \CharTok{\textquotesingle{}J\textquotesingle{}}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Height: }\SpecialCharTok{\%.2f}\StringTok{ m}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ height}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Initial: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ initial}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Age: 25
Height: 1.75 m
Initial: J
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-10}

Choosing the right type helps your program store values accurately and
efficiently. Integers count, floats measure, and chars label. As your
programs grow, you'll combine these types in arrays, structures, and
functions, everything starts here.

C gives you control over precision, size, and interpretation, essential
for reliable software.

\subsubsection{Try It Yourself}\label{try-it-yourself-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare three variables: \texttt{int\ score},
  \texttt{double\ temperature}, and \texttt{char\ grade}. Print them.
\item
  Perform integer division (\texttt{7\ /\ 2}) and floating-point
  division (\texttt{7.0\ /\ 2}). Compare results.
\item
  Print both \texttt{\%c} and \texttt{\%d} of
  \texttt{\textquotesingle{}A\textquotesingle{}} to see its ASCII value.
\item
  Create an \texttt{unsigned\ int} and assign \texttt{-1}. What happens?
\item
  Add two \texttt{char} letters
  (\texttt{\textquotesingle{}A\textquotesingle{}\ +\ 1}) and print the
  result.
\end{enumerate}

Numbers count the world. Characters name it. Together, they give your
programs a voice.

\subsection{12. Type Conversions and
Casting}\label{type-conversions-and-casting}

C is a strongly typed language, which means every value has a specific
type, and operations depend on it. However, C also allows type
conversion, turning one type into another, either automatically or
manually. Understanding when and how conversions happen keeps your
programs correct and precise.

\subsubsection{12.1 Implicit Conversions}\label{implicit-conversions}

An implicit conversion happens automatically when C promotes one type to
another during an expression.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ result }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{;} \CommentTok{// x is promoted to double}
\end{Highlighting}
\end{Shaded}

The integer \texttt{x} is automatically converted to \texttt{double}
before addition. This rule is called type promotion.

When different types meet, C usually promotes smaller or narrower types
to larger ones to preserve precision.

Promotion hierarchy (small → large):

\begin{verbatim}
char → int → float → double
\end{verbatim}

\subsubsection{12.2 Integer Division and
Promotion}\label{integer-division-and-promotion}

If both operands are integers, the result is an integer, even if you
store it in a float:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ result }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;} \CommentTok{// result = 2.0, not 2.5}
\end{Highlighting}
\end{Shaded}

Why? Because \texttt{a\ /\ b} is done as integer division first.

To fix it, convert one operand:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ result }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;} \CommentTok{// now result = 2.5}
\end{Highlighting}
\end{Shaded}

Promotion must happen before the operation.

\subsubsection{12.3 Explicit Casting}\label{explicit-casting}

You can force a conversion using a cast:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{(}\NormalTok{type}\OperatorTok{)}\NormalTok{expression}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{7}\OperatorTok{,}\NormalTok{ count }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ average }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{total }\OperatorTok{/}\NormalTok{ count}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{(double)total} tells the compiler to treat \texttt{total} as a
double before division.

Without casting, \texttt{7\ /\ 2} would give \texttt{3}, not
\texttt{3.5}.

\subsubsection{12.4 Narrowing Conversions}\label{narrowing-conversions}

Converting from a larger type to a smaller one can lose information:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ truncated }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{pi}\OperatorTok{;} \CommentTok{// truncated = 3}
\end{Highlighting}
\end{Shaded}

The fractional part is dropped.

Similarly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ big }\OperatorTok{=} \DecValTok{1000}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ small }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{char}\OperatorTok{)}\NormalTok{big}\OperatorTok{;} \CommentTok{// may overflow}
\end{Highlighting}
\end{Shaded}

If \texttt{char} holds only -128 to 127, \texttt{1000} wraps around to
another value. Use narrowing conversions carefully.

\subsubsection{12.5 Mixed-Type
Expressions}\label{mixed-type-expressions}

In mixed operations, C promotes operands to a common type before
computing:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{4.5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ c }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ result }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ c}\OperatorTok{;} \CommentTok{// a→float→double}
\end{Highlighting}
\end{Shaded}

The compiler ensures both sides of an operator are of compatible types.

\subsubsection{Tiny Code}\label{tiny-code-11}

Try this short program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Integer division: }\SpecialCharTok{\%d}\StringTok{ / }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Float division (cast): }\SpecialCharTok{\%d}\StringTok{ / }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}

    \DataTypeTok{double}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ truncated }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{pi}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Truncated value of pi: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ truncated}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Integer division: 5 / 2 = 2
Float division (cast): 5 / 2 = 2.50
Truncated value of pi: 3
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-11}

Type conversion is subtle but powerful. It decides whether your results
are precise or rounded, correct or wrong. Knowing when to cast ensures
your calculations match your intentions. Professional C programmers cast
deliberately, never accidentally.

\subsubsection{Try It Yourself}\label{try-it-yourself-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute \texttt{7\ /\ 3} as both integer and floating-point division.
\item
  Cast a \texttt{double} to \texttt{int} and observe truncation.
\item
  Print \texttt{(char)65} and see what character it produces.
\item
  Store \texttt{300} in a \texttt{char} and print it, what happens?
\item
  Experiment with \texttt{(float)(a\ /\ b)} vs \texttt{(float)a\ /\ b}.
  What's the difference?
\end{enumerate}

Casting gives you control over precision and intent. In C, a single cast
can turn confusion into clarity.

\subsection{13. Constants and Literals}\label{constants-and-literals}

In programming, some values never change. They might represent physical
constants, configuration values, or fixed parameters your program
depends on. In C, these unchanging values are called constants, and the
values you write directly in code, like \texttt{42} or
\texttt{\textquotesingle{}A\textquotesingle{}}, are called literals.

Learning to define and use constants properly makes your code clearer,
safer, and easier to maintain.

\subsubsection{13.1 What Are Constants}\label{what-are-constants}

A constant is a named value that cannot be modified once set. You
declare one with the keyword \texttt{const}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ DAYS\_IN\_WEEK }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Trying to change it later will cause a compiler error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{PI }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}  \CommentTok{// ❌ error: assignment of read{-}only variable}
\end{Highlighting}
\end{Shaded}

Constants behave like regular variables in every way except that their
values cannot change.

\subsubsection{13.2 Why Use Constants}\label{why-use-constants}

Constants improve your code in three ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clarity -- names describe what values mean
\item
  Safety -- prevents accidental changes
\item
  Maintainability -- change once, apply everywhere
\end{enumerate}

Instead of repeating a literal value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{area }\OperatorTok{=} \FloatTok{3.14159} \OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Use a constant:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\NormalTok{area }\OperatorTok{=}\NormalTok{ PI }\OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now, if you ever adjust the value, you only change it in one place.

\subsubsection{13.3 Literals}\label{literals}

A literal is a value written directly in the code. Each literal has a
type determined by its form:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Example & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Integer & \texttt{42}, \texttt{-10}, \texttt{0xFF} & decimal, negative,
hexadecimal \\
Floating & \texttt{3.14}, \texttt{2e3} & decimal or scientific
notation \\
Character & \texttt{\textquotesingle{}A\textquotesingle{}},
\texttt{\textquotesingle{}9\textquotesingle{}},
\texttt{\textquotesingle{}\textbackslash{}n\textquotesingle{}} & single
character \\
String & \texttt{"Hello"} & sequence of characters \\
\end{longtable}

You can also use suffixes:

\begin{itemize}
\tightlist
\item
  \texttt{L} for \texttt{long}: \texttt{100L}
\item
  \texttt{U} for \texttt{unsigned}: \texttt{42U}
\item
  \texttt{F} for \texttt{float}: \texttt{3.14F}
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ f }\OperatorTok{=} \FloatTok{1.0}\BuiltInTok{F}\OperatorTok{;}
\DataTypeTok{unsigned} \DataTypeTok{int}\NormalTok{ u }\OperatorTok{=} \DecValTok{42}\BuiltInTok{U}\OperatorTok{;}
\DataTypeTok{long}\NormalTok{ n }\OperatorTok{=} \DecValTok{1000000}\BuiltInTok{L}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{13.4 Constant Expressions}\label{constant-expressions}

You can build constants from other constants:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ RADIUS }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{const} \DataTypeTok{double}\NormalTok{ AREA }\OperatorTok{=} \FloatTok{3.14159} \OperatorTok{*}\NormalTok{ RADIUS }\OperatorTok{*}\NormalTok{ RADIUS}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

As long as all operands are constants, the result is a constant too.

\subsubsection{\texorpdfstring{13.5 The \texttt{\#define}
Directive}{13.5 The \#define Directive}}\label{the-define-directive}

Before \texttt{const}, C programmers used macros to define constants:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\PreprocessorTok{\#define DAYS }\DecValTok{7}
\end{Highlighting}
\end{Shaded}

Macros don't reserve memory, they're replaced by the preprocessor before
compilation. However, \texttt{const} is safer and preferred in modern C
because it respects type checking.

Use \texttt{\#define} for compile-time flags, not numeric constants,
unless necessary.

\subsubsection{Tiny Code}\label{tiny-code-12}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define TAX\_RATE }\FloatTok{0.08}\PreprocessorTok{  }\CommentTok{// macro constant}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{double}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}  \CommentTok{// const variable}

    \DataTypeTok{double}\NormalTok{ radius }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ area }\OperatorTok{=}\NormalTok{ PI }\OperatorTok{*}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Area: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ area}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Tax rate: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ TAX\_RATE}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Area: 12.57
Tax rate: 0.08
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-12}

Constants make your code self-documenting. A literal like \texttt{7}
means little by itself, but \texttt{DAYS\_IN\_WEEK} tells a clear story.
They protect important values and make updates easy, one edit,
everywhere fixed.

Good C programs are full of meaningful names, not magic numbers.

\subsubsection{Try It Yourself}\label{try-it-yourself-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define constants for \texttt{PI}, \texttt{E}, and \texttt{G}
  (gravity). Print them.
\item
  Replace a repeated number (like \texttt{60}) with a named constant.
\item
  Create a macro \texttt{\#define\ MAX\_SCORE\ 100} and print it.
\item
  Try changing a \texttt{const} variable after declaration, read the
  compiler error.
\item
  Mix literals: assign \texttt{3.14F}, \texttt{42U}, and \texttt{100L}
  to variables and print them.
\end{enumerate}

Constants express intention and stability. They remind both you and the
compiler that some values are meant to stay the same.

\subsection{14. Operators and
Expressions}\label{operators-and-expressions}

An expression is a combination of values, variables, and operators that
produces a result. Operators are the symbols that tell C what to do,
add, subtract, compare, assign, and more. Together, they form the
grammar of computation in your programs.

Understanding operators is key to writing clear, correct, and efficient
code.

\subsubsection{14.1 What Is an Expression}\label{what-is-an-expression}

An expression can be as simple as a single value:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}
\end{Highlighting}
\end{Shaded}

Or as complex as:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{{-}}\NormalTok{ d }\OperatorTok{/}\NormalTok{ e}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Every expression has a type and a value. When the compiler evaluates it,
it computes and returns that value.

\subsubsection{14.2 Basic Categories of
Operators}\label{basic-categories-of-operators}

C groups operators by purpose:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2258}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2151}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1613}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1935}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Category
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Examples
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Arithmetic & \texttt{+\ -\ *\ /\ \%} & math operations & & \\
Assignment & \texttt{=\ +=\ -=\ *=\ /=} & store results & & \\
Comparison &
\texttt{==\ !=\ \textgreater{}\ \textless{}\ \textgreater{}=\ \textless{}=}
& compare values & & \\
Logical &
\texttt{\&\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar{}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar{}\ !}
& combine conditions & & \\
Bitwise &
\texttt{\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar{}\ \^{}\ \textasciitilde{}\ \textless{}\textless{}\ \textgreater{}\textgreater{}}
& manipulate bits & & \\
Increment / Decrement & \texttt{++\ -\/-} & increase or decrease & & \\
Miscellaneous & \texttt{sizeof}, \texttt{,}, \texttt{?:} & special
operators & & \\
\end{longtable}

You'll use arithmetic and comparison most often early on.

\subsubsection{14.3 Arithmetic Operators}\label{arithmetic-operators}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+} & addition & \texttt{5\ +\ 2} & \texttt{7} \\
\texttt{-} & subtraction & \texttt{5\ -\ 2} & \texttt{3} \\
\texttt{*} & multiplication & \texttt{5\ *\ 2} & \texttt{10} \\
\texttt{/} & division & \texttt{5\ /\ 2} & \texttt{2} (integer
division) \\
\texttt{\%} & remainder & \texttt{5\ \%\ 2} & \texttt{1} \\
\end{longtable}

If both operands are integers, the result is integer. For real division,
cast one operand to \texttt{double}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ r }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\DecValTok{5} \OperatorTok{/} \DecValTok{2}\OperatorTok{;} \CommentTok{// 2.5}
\end{Highlighting}
\end{Shaded}

\subsubsection{14.4 Assignment Operators}\label{assignment-operators}

The \texttt{=} operator stores a value in a variable:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can combine operations with assignment:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Example & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+=} & \texttt{x\ +=\ 2} & \texttt{x\ =\ x\ +\ 2} \\
\texttt{-=} & \texttt{x\ -=\ 3} & \texttt{x\ =\ x\ -\ 3} \\
\texttt{*=} & \texttt{x\ *=\ 2} & \texttt{x\ =\ x\ *\ 2} \\
\texttt{/=} & \texttt{x\ /=\ 5} & \texttt{x\ =\ x\ /\ 5} \\
\texttt{\%=} & \texttt{x\ \%=\ 3} & \texttt{x\ =\ x\ \%\ 3} \\
\end{longtable}

These make updates concise and expressive.

\subsubsection{14.5 Comparison Operators}\label{comparison-operators}

Used to compare values in conditions. Each returns 1 (true) or 0
(false):

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Meaning & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{==} & equal to & \texttt{x\ ==\ y} \\
\texttt{!=} & not equal & \texttt{x\ !=\ y} \\
\texttt{\textgreater{}} & greater than &
\texttt{x\ \textgreater{}\ y} \\
\texttt{\textless{}} & less than & \texttt{x\ \textless{}\ y} \\
\texttt{\textgreater{}=} & greater or equal &
\texttt{x\ \textgreater{}=\ y} \\
\texttt{\textless{}=} & less or equal & \texttt{x\ \textless{}=\ y} \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Adult}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{14.6 Logical Operators}\label{logical-operators}

Combine or invert boolean results:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.1538}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.1346}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.3462}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.0385}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.1538}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.0192}}
  >{\raggedright\arraybackslash}p{(\linewidth - 12\tabcolsep) * \real{0.1538}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&\&} & AND &
\texttt{(x\ \textgreater{}\ 0\ \&\&\ y\ \textgreater{}\ 0)} & & & & \\
\texttt{\textbar{}\ \ \ \ \ \ \ \ \ \textbar{}} & OR &
\texttt{(x\ ==\ 0\ \textbar{}\ \ \ \textbar{}\ y\ ==\ 0)} & & & & \\
\texttt{!} & NOT & \texttt{!(x\ \textgreater{}\ 5)} & & & & \\
\end{longtable}

Used in \texttt{if}, \texttt{while}, and other conditional statements.

\subsubsection{14.7 Increment and
Decrement}\label{increment-and-decrement}

Quickly increase or decrease a variable by 1:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{++;} \CommentTok{// same as x = x + 1}
\NormalTok{x}\OperatorTok{{-}{-};} \CommentTok{// same as x = x {-} 1}
\end{Highlighting}
\end{Shaded}

Two forms:

\begin{itemize}
\tightlist
\item
  Postfix (\texttt{x++}), use value, then increment
\item
  Prefix (\texttt{++x}), increment, then use value
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{++);} \CommentTok{// prints 5, then x becomes 6}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{++}\NormalTok{x}\OperatorTok{);} \CommentTok{// increments first, prints 7}
\end{Highlighting}
\end{Shaded}

\subsubsection{14.8 Combining Operators}\label{combining-operators}

You can mix operators in expressions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{*}\NormalTok{ c }\OperatorTok{{-}}\NormalTok{ d }\OperatorTok{/}\NormalTok{ e}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Use parentheses to control order of evaluation, they make your intent
explicit.

\subsubsection{Tiny Code}\label{tiny-code-13}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a {-} b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a * b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a / b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a }\SpecialCharTok{\%\%}\StringTok{ b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}\OperatorTok{);}

\NormalTok{    a }\OperatorTok{+=} \DecValTok{3}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a after += 3: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Is a \textgreater{} b? }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{\textgreater{}}\NormalTok{ b}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
a + b = 7
a - b = 3
a * b = 10
a / b = 2
a % b = 1
a after += 3: 8
Is a > b? 1
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-13}

Operators are the verbs of programming. They let you compute, compare,
and combine values. By mastering them, you gain expressive power to
build logic, perform math, and make decisions.

Every algorithm you write is built from these small, precise actions.

\subsubsection{Try It Yourself}\label{try-it-yourself-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create two integers and test all arithmetic operators.
\item
  Use compound assignments (\texttt{+=}, \texttt{*=}) to update values.
\item
  Compare two numbers and print the results of all six comparisons.
\item
  Combine conditions using \texttt{\&\&} and
  \texttt{\textbar{}\textbar{}}.
\item
  Experiment with \texttt{x++} vs \texttt{++x} in \texttt{printf} to see
  the difference.
\end{enumerate}

Operators are the language of thought in C. Once fluent, you can
translate any idea into computation.

\subsection{15. Arithmetic Operators}\label{arithmetic-operators-1}

Arithmetic operators are the foundation of numerical computation in C.
They let you perform mathematical operations on numbers, adding,
subtracting, multiplying, dividing, and finding remainders. Even complex
algorithms start with these simple actions.

In this section, you'll see how each operator works, how C handles
division, and where small details matter.

\subsubsection{15.1 The Basic Operators}\label{the-basic-operators}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{+} & Addition & \texttt{5\ +\ 2} & \texttt{7} \\
\texttt{-} & Subtraction & \texttt{5\ -\ 2} & \texttt{3} \\
\texttt{*} & Multiplication & \texttt{5\ *\ 2} & \texttt{10} \\
\texttt{/} & Division & \texttt{5\ /\ 2} & \texttt{2} (integer
division) \\
\texttt{\%} & Modulus (remainder) & \texttt{5\ \%\ 2} & \texttt{1} \\
\end{longtable}

These five operators work with both constants and variables:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}      \CommentTok{// 13}
\DataTypeTok{int}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}     \CommentTok{// 7}
\DataTypeTok{int}\NormalTok{ prod }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}     \CommentTok{// 30}
\DataTypeTok{int}\NormalTok{ quot }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}     \CommentTok{// 3}
\DataTypeTok{int}\NormalTok{ rem }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}\OperatorTok{;}      \CommentTok{// 1}
\end{Highlighting}
\end{Shaded}

\subsubsection{15.2 Integer Division}\label{integer-division}

When both operands are integers, division truncates toward zero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{5} \OperatorTok{/} \DecValTok{2}\OperatorTok{);}  \CommentTok{// prints 2}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{7} \OperatorTok{/} \DecValTok{3}\OperatorTok{);}  \CommentTok{// prints 2}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{7} \OperatorTok{/} \DecValTok{3}\OperatorTok{);} \CommentTok{// prints {-}2}
\end{Highlighting}
\end{Shaded}

If you want fractional results, convert at least one operand to
\texttt{double}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\DecValTok{5} \OperatorTok{/} \DecValTok{2}\OperatorTok{);} \CommentTok{// 2.50}
\end{Highlighting}
\end{Shaded}

\subsubsection{15.3 The Modulus Operator}\label{the-modulus-operator}

\texttt{\%} gives the remainder after integer division:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{10} \OperatorTok{\%} \DecValTok{3}\OperatorTok{);} \CommentTok{// 1}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{9} \OperatorTok{\%} \DecValTok{3}\OperatorTok{);}  \CommentTok{// 0}
\end{Highlighting}
\end{Shaded}

It's often used in:

\begin{itemize}
\tightlist
\item
  Checking even/odd numbers (\texttt{x\ \%\ 2\ ==\ 0})
\item
  Wrapping counters (\texttt{i\ =\ (i\ +\ 1)\ \%\ 10})
\item
  Detecting multiples (\texttt{n\ \%\ 5\ ==\ 0})
\end{itemize}

It works only with integers, not floats.

\subsubsection{15.4 Order of Operations}\label{order-of-operations}

C follows standard operator precedence:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Parentheses \texttt{(\ )}
\item
  Multiplication, Division, Modulus (\texttt{*\ /\ \%})
\item
  Addition, Subtraction (\texttt{+\ -})
\end{enumerate}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ r }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{3} \OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// 2 + 12 = 14}
\end{Highlighting}
\end{Shaded}

Use parentheses to make your intent clear:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ r }\OperatorTok{=} \OperatorTok{(}\DecValTok{2} \OperatorTok{+} \DecValTok{3}\OperatorTok{)} \OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// 20}
\end{Highlighting}
\end{Shaded}

Parentheses improve both correctness and readability.

\subsubsection{15.5 Unary Plus and Minus}\label{unary-plus-and-minus}

You can use \texttt{+} or \texttt{-} before a number or variable:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ b }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{a}\OperatorTok{;}  \CommentTok{// {-}5}
\DataTypeTok{int}\NormalTok{ c }\OperatorTok{=} \OperatorTok{+}\NormalTok{a}\OperatorTok{;}  \CommentTok{// 5}
\end{Highlighting}
\end{Shaded}

This doesn't add or subtract, it simply indicates the sign.

\subsubsection{15.6 Overflow and
Underflow}\label{overflow-and-underflow}

C doesn't check for arithmetic overflow. If a result is too large for
the type, it wraps around:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ big }\OperatorTok{=} \DecValTok{2147483647}\OperatorTok{;} \CommentTok{// max 32{-}bit int}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ big }\OperatorTok{+} \DecValTok{1}\OperatorTok{);} \CommentTok{// overflow {-}\textgreater{} {-}2147483648}
\end{Highlighting}
\end{Shaded}

Use larger types (\texttt{long\ long}) or libraries for critical
arithmetic.

\subsubsection{15.7 Mixing Types}\label{mixing-types}

When operands differ, C promotes smaller types automatically:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ z }\OperatorTok{=}\NormalTok{ x }\OperatorTok{/}\NormalTok{ y}\OperatorTok{;} \CommentTok{// x promoted to double}
\end{Highlighting}
\end{Shaded}

Be aware of implicit conversions to avoid surprises.

\subsubsection{Tiny Code}\label{tiny-code-14}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{7}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a {-} b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a * b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a / b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a }\SpecialCharTok{\%\%}\StringTok{ b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}\OperatorTok{);}

    \DataTypeTok{double}\NormalTok{ precise }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Precise division: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ precise}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
a + b = 10
a - b = 4
a * b = 21
a / b = 2
a % b = 1
Precise division: 2.33
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-14}

Arithmetic is the heartbeat of every program. From counting iterations
to computing results, these five operators appear everywhere.
Understanding how C performs math, especially integer division and
precedence, prevents subtle bugs.

In C, precision is power.

\subsubsection{Try It Yourself}\label{try-it-yourself-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute the sum, difference, product, and remainder of any two
  numbers.
\item
  Use integer division and floating-point division side by side.
\item
  Write an expression using parentheses to change order of evaluation.
\item
  Test \texttt{x\ \%\ 2} for even or odd numbers.
\item
  Add 1 to \texttt{2147483647} (max \texttt{int}) and see what happens.
\end{enumerate}

Arithmetic operators are small symbols with big consequences. Once you
master them, you can build logic that measures, counts, and calculates
everything your programs need.

\subsection{16. Comparison and Logical
Operators}\label{comparison-and-logical-operators}

Programs often need to make decisions, to choose one path if something
is true and another if it isn't. Comparison and logical operators let
you express those decisions clearly. They evaluate conditions and return
either true (1) or false (0).

Together, they're the foundation of all conditional logic in C.

\subsubsection{16.1 Comparison Operators}\label{comparison-operators-1}

Comparison (or relational) operators compare two values. They don't
change the values, they just check relationships.

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{==} & equal to & \texttt{5\ ==\ 5} & \texttt{1} \\
\texttt{!=} & not equal to & \texttt{5\ !=\ 3} & \texttt{1} \\
\texttt{\textgreater{}} & greater than & \texttt{5\ \textgreater{}\ 3} &
\texttt{1} \\
\texttt{\textless{}} & less than & \texttt{3\ \textless{}\ 5} &
\texttt{1} \\
\texttt{\textgreater{}=} & greater or equal &
\texttt{5\ \textgreater{}=\ 5} & \texttt{1} \\
\texttt{\textless{}=} & less or equal & \texttt{3\ \textless{}=\ 4} &
\texttt{1} \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{18}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{);} \CommentTok{// prints 1 (true)}
\end{Highlighting}
\end{Shaded}

These expressions return integers, \texttt{1} for true, \texttt{0} for
false.

\subsubsection{\texorpdfstring{16.2 Common Pitfall: \texttt{=} vs
\texttt{==}}{16.2 Common Pitfall: = vs ==}}\label{common-pitfall-vs}

A single \texttt{=} assigns a value, while \texttt{==} compares values.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ❌ assigns 5 to x, always true}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// ✅ compares x to 5}
\end{Highlighting}
\end{Shaded}

Always double-check equality conditions.

\subsubsection{16.3 Logical Operators}\label{logical-operators-1}

Logical operators combine multiple conditions:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.2286}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.0857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 14\tabcolsep) * \real{0.1571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
True When
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&\&} & AND &
\texttt{x\ \textgreater{}\ 0\ \&\&\ y\ \textgreater{}\ 0} & both true &
& & & \\
\texttt{\textbar{}\ \ \ \ \ \ \ \ \ \textbar{}} & OR &
\texttt{x\ \textgreater{}\ 0\ \textbar{}\ \ \ \textbar{}\ y\ \textgreater{}\ 0}
& either true & & & & \\
\texttt{!} & NOT & \texttt{!(x\ \textgreater{}\ 0)} & condition false &
& & & \\
\end{longtable}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ y }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Both positive}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{0} \OperatorTok{||}\NormalTok{ y }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"At least one zero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\ControlFlowTok{if} \OperatorTok{(!(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{10}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x is not greater than 10}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{16.4 Short-Circuit
Evaluation}\label{short-circuit-evaluation}

C uses short-circuit logic:

\begin{itemize}
\tightlist
\item
  In \texttt{\&\&}, if the first condition is false, the second is not
  checked.
\item
  In \texttt{\textbar{}\textbar{}}, if the first condition is true, the
  second is not checked.
\end{itemize}

This saves time and prevents unnecessary work.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{ptr }\OperatorTok{!=}\NormalTok{ NULL }\OperatorTok{\&\&} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{==} \DecValTok{10}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{*ptr} is only evaluated if \texttt{ptr} is not null,
avoiding crashes.

\subsubsection{16.5 Combining Conditions}\label{combining-conditions}

You can group conditions with parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{((}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ y }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{||}\NormalTok{ z }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"At least one positive value}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Parentheses make intent clear and control evaluation order.

\subsubsection{16.6 Boolean Results in C}\label{boolean-results-in-c}

C doesn't have a separate boolean type before C99. Conditions return
integers:

\begin{itemize}
\tightlist
\item
  \texttt{1} means true
\item
  \texttt{0} means false
\end{itemize}

You can include \texttt{\textless{}stdbool.h\textgreater{}} for
\texttt{bool}, \texttt{true}, and \texttt{false}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\DataTypeTok{bool}\NormalTok{ valid }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{valid}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"OK}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-15}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"x == y: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{==}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x != y: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{!=}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x \textless{} y: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{\textless{}}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x \textgreater{} y: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{\textgreater{}}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(x \textless{} y) \&\& (y \textless{} 20): }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textless{}}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\&\&} \OperatorTok{(}\NormalTok{y }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(x \textgreater{} 0) || (y \textless{} 0): }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{||} \OperatorTok{(}\NormalTok{y }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"!(x == 5): }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{!(}\NormalTok{x }\OperatorTok{==} \DecValTok{5}\OperatorTok{));}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
x == y: 0
x != y: 1
x < y: 1
x > y: 0
(x < y) && (y < 20): 1
(x > 0) || (y < 0): 1
!(x == 5): 0
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-15}

Comparison and logical operators turn data into decisions. They're how
programs react, testing conditions, guiding flow, and enabling
reasoning. From simple checks to complex algorithms, these operators
power every \texttt{if}, \texttt{while}, and \texttt{for}.

Without them, programs couldn't think.

\subsubsection{Try It Yourself}\label{try-it-yourself-15}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write conditions to test if a number is positive, negative, or zero.
\item
  Combine conditions: check if a value is between 10 and 20.
\item
  Practice \texttt{\&\&}, \texttt{\textbar{}\textbar{}}, and \texttt{!}
  in one expression.
\item
  Use short-circuit logic with a null pointer check.
\item
  Print results of comparisons directly with \texttt{\%d}.
\end{enumerate}

Logic gives your programs intelligence. With comparisons and conditions,
C starts to \emph{decide} instead of just \emph{compute}.

\subsection{17. Operator Precedence}\label{operator-precedence}

When an expression contains multiple operators, C must decide which
operation to perform first. This order is called operator precedence.
It's like arithmetic: multiplication happens before addition unless you
use parentheses.

Understanding precedence and associativity ensures your code does what
you mean, not just what you write.

\subsubsection{17.1 Why Precedence
Matters}\label{why-precedence-matters}

Consider:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{3} \OperatorTok{*} \DecValTok{4}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Is \texttt{x} equal to 20 or 14? C follows mathematical rules,
multiplication happens first, so \texttt{x\ =\ 14}.

If you want addition first:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \OperatorTok{(}\DecValTok{2} \OperatorTok{+} \DecValTok{3}\OperatorTok{)} \OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// x = 20}
\end{Highlighting}
\end{Shaded}

Parentheses always override precedence. Use them to make your intent
clear.

\subsubsection{17.2 Precedence Table}\label{precedence-table}

Here's a simplified table of operator precedence (from highest to
lowest):

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.0980}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2255}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.3235}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1275}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.0980}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1275}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Precedence
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Operator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Associativity
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & \texttt{()} & Parentheses & Left to right & & \\
2 & \texttt{++} \texttt{-\/-} & Increment, Decrement & Right to left &
& \\
3 & \texttt{*} \texttt{/} \texttt{\%} & Multiplication, Division,
Modulus & Left to right & & \\
4 & \texttt{+} \texttt{-} & Addition, Subtraction & Left to right & & \\
5 & \texttt{\textless{}} \texttt{\textless{}=} \texttt{\textgreater{}}
\texttt{\textgreater{}=} & Comparisons & Left to right & & \\
6 & \texttt{==} \texttt{!=} & Equality & Left to right & & \\
7 & \texttt{\&\&} & Logical AND & Left to right & & \\
8 &
\texttt{\textbar{}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar{}}
& Logical OR & Left to right & & \\
9 & \texttt{=} \texttt{+=} \texttt{-=} \texttt{*=} \texttt{/=} &
Assignment & Right to left & & \\
\end{longtable}

Operators higher in the table are evaluated first.

\subsubsection{17.3 Associativity}\label{associativity}

When two operators have the same precedence, associativity decides the
direction of evaluation.

Example (left to right):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \DecValTok{10} \OperatorTok{/} \DecValTok{2} \OperatorTok{*} \DecValTok{3}\OperatorTok{;} \CommentTok{// (10 / 2) * 3 = 15}
\end{Highlighting}
\end{Shaded}

Example (right to left):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=}\NormalTok{ y }\OperatorTok{=}\NormalTok{ z }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// same as x = (y = (z = 1))}
\end{Highlighting}
\end{Shaded}

\subsubsection{17.4 Combining Operators}\label{combining-operators-1}

Without parentheses, mixed operators can surprise you:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{3}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ c}\OperatorTok{;} \CommentTok{// 2 + (3 * 4) = 14}
\end{Highlighting}
\end{Shaded}

Parentheses clarify meaning:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=} \OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{*}\NormalTok{ c}\OperatorTok{;} \CommentTok{// (2 + 3) * 4 = 20}
\end{Highlighting}
\end{Shaded}

Always use parentheses for clarity, even if you know the precedence.

\subsubsection{17.5 Unary vs Binary
Operators}\label{unary-vs-binary-operators}

Unary operators (\texttt{-x}, \texttt{++x}, \texttt{-\/-x}) have higher
precedence than binary ones:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;} \CommentTok{// same as ({-}5) * 2 = {-}10}
\end{Highlighting}
\end{Shaded}

Postfix \texttt{x++} is evaluated after the value is used, while prefix
\texttt{++x} increments before use.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{++} \OperatorTok{*} \DecValTok{2}\OperatorTok{);} \CommentTok{// prints 10, then a = 6}
\end{Highlighting}
\end{Shaded}

\subsubsection{17.6 Logical Expressions}\label{logical-expressions}

When combining conditions, remember:

\begin{itemize}
\tightlist
\item
  \texttt{\&\&} has higher precedence than \texttt{\textbar{}\textbar{}}
\item
  Always use parentheses for clarity
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ b }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{||}\NormalTok{ c }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}
\CommentTok{// same as: if ((a \textgreater{} 0 \&\& b \textgreater{} 0) || c \textgreater{} 0)}
\end{Highlighting}
\end{Shaded}

If you wanted
\texttt{a\ \textgreater{}\ 0\ \&\&\ (b\ \textgreater{}\ 0\ \textbar{}\textbar{}\ c\ \textgreater{}\ 0)},
add parentheses.

\subsubsection{Tiny Code}\label{tiny-code-16}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{3}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + b * c = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ c}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(a + b) * c = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(}\NormalTok{a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{)} \OperatorTok{*}\NormalTok{ c}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + b \textgreater{} c = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{\textgreater{}}\NormalTok{ c}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"a + (b \textgreater{} c) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+} \OperatorTok{(}\NormalTok{b }\OperatorTok{\textgreater{}}\NormalTok{ c}\OperatorTok{));}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
a + b * c = 14
(a + b) * c = 20
a + b > c = 1
a + (b > c) = 2
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-16}

Operator precedence is one of C's most common sources of subtle bugs.
The compiler always follows the rules, even when you didn't intend them.
Parentheses make code predictable, readable, and error-free.

When in doubt, add them.

\subsubsection{Try It Yourself}\label{try-it-yourself-16}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write \texttt{2\ +\ 3\ *\ 4} and \texttt{(2\ +\ 3)\ *\ 4}. Compare
  results.
\item
  Evaluate \texttt{10\ /\ 2\ *\ 3}, why isn't it
  \texttt{10\ /\ (2\ *\ 3)}?
\item
  Experiment with \texttt{++a\ *\ 2} and \texttt{a++\ *\ 2}.
\item
  Combine \texttt{\&\&} and \texttt{\textbar{}\textbar{}} in one
  \texttt{if} statement and observe.
\item
  Rewrite a complex expression using parentheses for clarity.
\end{enumerate}

Precedence defines \emph{how} C thinks. Parentheses define \emph{what
you mean}. Always make your intent explicit.

\subsection{\texorpdfstring{18. Reading Input with
\texttt{scanf}}{18. Reading Input with scanf}}\label{reading-input-with-scanf}

So far, your programs have only printed information. Now it's time to
make them interactive, to let users type values that your program can
read and use. In C, the standard way to read input is with the function
\texttt{scanf}, part of \texttt{\textless{}stdio.h\textgreater{}}.

Understanding how \texttt{scanf} works gives your programs a voice that
listens.

\subsubsection{\texorpdfstring{18.1 What Is
\texttt{scanf}}{18.1 What Is scanf}}\label{what-is-scanf}

\texttt{scanf} reads formatted input from standard input (usually the
keyboard). Its name comes from \emph{scan formatted}.

Basic usage:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scanf}\OperatorTok{(}\StringTok{"format"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{variable}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The first argument is a format string, like \texttt{"\%d"} or
  \texttt{"\%f"}.
\item
  The second is the address of the variable where the result will be
  stored.
\end{itemize}

The ampersand (\texttt{\&}) gives \texttt{scanf} a pointer to the
variable.

\subsubsection{18.2 Reading Different
Types}\label{reading-different-types}

Use format specifiers matching the type of data:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Format & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int} & \texttt{\%d} & \texttt{scanf("\%d",\ \&x);} \\
\texttt{double} & \texttt{\%lf} & \texttt{scanf("\%lf",\ \&d);} \\
\texttt{float} & \texttt{\%f} & \texttt{scanf("\%f",\ \&f);} \\
\texttt{char} & \texttt{\%c} & \texttt{scanf("\%c",\ \&ch);} \\
\texttt{string} (char array) & \texttt{\%s} &
\texttt{scanf("\%s",\ name);} (no \texttt{\&}) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ height}\OperatorTok{;}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{,} \OperatorTok{\&}\NormalTok{height}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This reads two values separated by space.

\subsubsection{\texorpdfstring{18.3 The \texttt{\&}
Operator}{18.3 The \& Operator}}\label{the-operator}

\texttt{scanf} needs the address of each variable so it can store input
there.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Without \texttt{\&}, \texttt{scanf} wouldn't know where to put the data,
the program may crash.

Exception: strings already represent addresses, so no \texttt{\&} is
used:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{18.4 Handling Multiple
Inputs}\label{handling-multiple-inputs}

You can read several values at once:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter two numbers: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{a}\OperatorTok{,} \OperatorTok{\&}\NormalTok{b}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

When the user types \texttt{3\ 5} and presses Enter, both values are
read.

\subsubsection{18.5 Dealing with
Whitespace}\label{dealing-with-whitespace}

\texttt{scanf} skips whitespace (spaces, tabs, newlines) before numbers
and strings, but not before \texttt{\%c}. To skip whitespace when
reading a character, add a space before \texttt{\%c}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scanf}\OperatorTok{(}\StringTok{" }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ch}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

That leading space tells \texttt{scanf} to ignore any leftover newlines.

\subsubsection{18.6 Input Validation}\label{input-validation}

Always check if \texttt{scanf} succeeded:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You entered }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Invalid input!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{scanf} returns the number of values successfully read.

\subsubsection{Tiny Code}\label{tiny-code-17}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ height}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ initial}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your age, height, and initial: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%lf}\StringTok{ }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{,} \OperatorTok{\&}\NormalTok{height}\OperatorTok{,} \OperatorTok{\&}\NormalTok{initial}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Age: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Height: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ height}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Initial: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ initial}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input:

\begin{verbatim}
25 1.75 J
\end{verbatim}

Output:

\begin{verbatim}
Age: 25
Height: 1.75
Initial: J
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-17}

Input is what turns static programs into interactive tools. With
\texttt{scanf}, you can read numbers, words, and characters, building
programs that respond to users. Every calculator, menu, or configuration
system starts with reading data.

Learning to use \texttt{scanf} safely is a rite of passage in C.

\subsubsection{Try It Yourself}\label{try-it-yourself-17}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that asks for two integers and prints their sum.
\item
  Read a \texttt{char} after reading a number, test the \texttt{"\ \%c"}
  fix.
\item
  Ask for name and age, then print ``Hello, NAME, you are AGE.''
\item
  Try entering the wrong type (e.g., letters for \texttt{\%d}) and see
  what happens.
\item
  Check \texttt{scanf}'s return value to handle invalid input
  gracefully.
\end{enumerate}

When programs can read, they can think. \texttt{scanf} is your first
step toward true interaction.

\subsection{\texorpdfstring{19. The \texttt{sizeof}
Operator}{19. The sizeof Operator}}\label{the-sizeof-operator}

In C, every variable and type occupies a specific amount of memory. The
\texttt{sizeof} operator lets you ask exactly how much, in bytes.
Knowing the size of data is crucial for memory management, portability,
and understanding how your program interacts with hardware.

With \texttt{sizeof}, you can measure the building blocks of your
program.

\subsubsection{\texorpdfstring{19.1 What Is
\texttt{sizeof}}{19.1 What Is sizeof}}\label{what-is-sizeof}

\texttt{sizeof} is a compile-time operator that returns the size (in
bytes) of a type or variable. You can use it in two forms:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{type}\OperatorTok{)}
\KeywordTok{sizeof}\NormalTok{ expression}
\end{Highlighting}
\end{Shaded}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}        \CommentTok{// size of the int type}
\KeywordTok{sizeof}\NormalTok{ x           }\CommentTok{// size of the variable x}
\end{Highlighting}
\end{Shaded}

It returns a value of type \texttt{size\_t} (an unsigned integer).

\subsubsection{19.2 Sizes of Basic Types}\label{sizes-of-basic-types}

Sizes can vary by platform, but typical 64-bit systems follow:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Example & Typical Size (bytes) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{char} & \texttt{\textquotesingle{}A\textquotesingle{}} & 1 \\
\texttt{int} & \texttt{42} & 4 \\
\texttt{short} & \texttt{10} & 2 \\
\texttt{long} & \texttt{1000L} & 8 \\
\texttt{float} & \texttt{3.14f} & 4 \\
\texttt{double} & \texttt{3.14} & 8 \\
\texttt{long\ double} & , & 16 \\
\end{longtable}

Check your system by printing them yourself.

\subsubsection{\texorpdfstring{19.3 Using \texttt{sizeof} with
Variables}{19.3 Using sizeof with Variables}}\label{using-sizeof-with-variables}

You can pass a variable instead of a type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"x is }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The \texttt{\%zu} format specifier is for \texttt{size\_t}.

This works even if you change the type of \texttt{x}.

\subsubsection{\texorpdfstring{19.4 Using \texttt{sizeof} with
Arrays}{19.4 Using sizeof with Arrays}}\label{using-sizeof-with-arrays}

For arrays, \texttt{sizeof} returns the total size in bytes, not the
number of elements.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ arr}\OperatorTok{);} \CommentTok{// 5 * sizeof(int)}
\end{Highlighting}
\end{Shaded}

To find the element count:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \KeywordTok{sizeof}\NormalTok{ arr }\OperatorTok{/} \KeywordTok{sizeof}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Number of elements: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This trick is common in C programming.

\subsubsection{19.5 Parentheses Rules}\label{parentheses-rules}

For types, you must use parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}  \CommentTok{// ✅}
\end{Highlighting}
\end{Shaded}

For variables, parentheses are optional:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sizeof}\NormalTok{ x     }\CommentTok{// ✅}
\KeywordTok{sizeof}\OperatorTok{(}\NormalTok{x}\OperatorTok{)}    \CommentTok{// ✅}
\end{Highlighting}
\end{Shaded}

But many developers always include them for consistency.

\subsubsection{19.6 Portable Programming}\label{portable-programming}

Different machines may have different type sizes. Instead of assuming,
measure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"int: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{printf}\OperatorTok{(}\StringTok{"double: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{double}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{sizeof} helps you write portable programs that adapt to any
system.

\subsubsection{Tiny Code}\label{tiny-code-18}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ d}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Size of int: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Size of double: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ d}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Size of char: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ c}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Size of arr: }\SpecialCharTok{\%zu}\StringTok{ bytes}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ arr}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Number of elements in arr: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,} \KeywordTok{sizeof}\NormalTok{ arr }\OperatorTok{/} \KeywordTok{sizeof}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Sample Output:

\begin{verbatim}
Size of int: 4 bytes
Size of double: 8 bytes
Size of char: 1 bytes
Size of arr: 40 bytes
Number of elements in arr: 10
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-18}

\texttt{sizeof} connects you to the physical reality of your program,
how much memory it uses. It's essential when allocating memory
dynamically, designing data structures, or writing portable code.
Knowing your sizes makes you a precise and careful programmer.

C gives you control; \texttt{sizeof} tells you what you're controlling.

\subsubsection{Try It Yourself}\label{try-it-yourself-18}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print the size of every basic type on your machine.
\item
  Create an array of 20 doubles and calculate its element count.
\item
  Compare \texttt{sizeof(5)} and \texttt{sizeof(5.0)}. What's different?
\item
  Create a \texttt{struct} with 3 fields and measure its size.
\item
  Use \texttt{sizeof} with a pointer, what does it return?
\end{enumerate}

Every byte matters in C. With \texttt{sizeof}, you can see exactly how
your code shapes memory.

\subsection{20. Debugging Type Errors}\label{debugging-type-errors}

Every programmer makes mistakes, especially when learning C's strict
type system. Type errors happen when you use a value in a way that
doesn't match its declared type. Fortunately, the compiler catches most
of them for you. Learning to read and fix type errors is a vital skill
for writing correct programs.

\subsubsection{20.1 What Is a Type Error}\label{what-is-a-type-error}

A type error occurs when an operation or function receives the wrong
kind of data.

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);} \CommentTok{// ❌ using \%d for a double}
\end{Highlighting}
\end{Shaded}

Here, \texttt{\%d} expects an \texttt{int}, but \texttt{y} is a
\texttt{double}. The output will be incorrect, and the compiler should
warn you.

Type errors don't always stop your program, sometimes they cause
undefined behavior, where results are unpredictable.

\subsubsection{20.2 Common Type Mistakes}\label{common-type-mistakes}

Here are typical beginner errors and how to fix them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Mismatched format specifier

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pi}\OperatorTok{);} \CommentTok{// ❌ wrong}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pi}\OperatorTok{);} \CommentTok{// ✅ correct}
\end{Highlighting}
\end{Shaded}
\item
  Using incompatible operands

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ b }\OperatorTok{=} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \CommentTok{// ✅ allowed (char promoted to int)}
\DataTypeTok{int}\NormalTok{ wrong }\OperatorTok{=} \StringTok{"Hello"} \OperatorTok{+}\NormalTok{ a}\OperatorTok{;} \CommentTok{// ❌ invalid types}
\end{Highlighting}
\end{Shaded}
\item
  Assigning one type to another without casting

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ x }\OperatorTok{=}\NormalTok{ n }\OperatorTok{/} \DecValTok{2}\OperatorTok{;} \CommentTok{// ❌ integer division, result is 2.0}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{n }\OperatorTok{/} \DecValTok{2}\OperatorTok{;} \CommentTok{// ✅ cast for precision}
\end{Highlighting}
\end{Shaded}
\item
  Pointer type mismatch

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ d}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{d}\OperatorTok{;} \CommentTok{// ❌ pointer types incompatible}
\end{Highlighting}
\end{Shaded}
\item
  Calling functions with wrong argument types

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \FloatTok{3.14}\OperatorTok{);} \CommentTok{// ❌ expects int}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{20.3 Reading Compiler
Errors}\label{reading-compiler-errors}

Compilers are your friends. When you see a message like:

\begin{verbatim}
warning: format ‘%d' expects argument of type ‘int', but argument 2 has type ‘double'
\end{verbatim}

Break it down:

\begin{itemize}
\tightlist
\item
  \texttt{\%d} means you told the compiler to print an \texttt{int}
\item
  The second argument was a \texttt{double}
\item
  You need \texttt{\%f} instead
\end{itemize}

Always read errors carefully, they tell you exactly what went wrong.

\subsubsection{20.4 Using Compiler
Warnings}\label{using-compiler-warnings}

Turn on all warnings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall} \AttributeTok{{-}Wextra} \AttributeTok{{-}pedantic}\NormalTok{ program.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

Warnings aren't fatal, but they highlight risky code. Treat them as
errors to fix, not messages to ignore.

\subsubsection{20.5 Implicit Type
Conversions}\label{implicit-type-conversions}

Sometimes C converts types for you, but not always safely:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{double}\NormalTok{ y }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{);} \CommentTok{// ✅ x promoted to double}
\end{Highlighting}
\end{Shaded}

But mixing types can cause precision loss:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ result }\OperatorTok{=} \DecValTok{5} \OperatorTok{/} \DecValTok{2}\OperatorTok{;} \CommentTok{// ❌ both int → result = 2.0}
\end{Highlighting}
\end{Shaded}

Fix with explicit casting:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ result }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\DecValTok{5} \OperatorTok{/} \DecValTok{2}\OperatorTok{;} \CommentTok{// ✅ result = 2.5}
\end{Highlighting}
\end{Shaded}

\subsubsection{20.6 Warnings vs Errors}\label{warnings-vs-errors}

\begin{itemize}
\tightlist
\item
  Warnings: the program can compile, but something looks suspicious
\item
  Errors: the compiler cannot produce an executable
\end{itemize}

Even one warning is a sign of possible bugs, clean them all.

\subsubsection{Tiny Code}\label{tiny-code-19}

Try this buggy code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
    \DataTypeTok{double}\NormalTok{ b }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%f}\StringTok{ = }\SpecialCharTok{\%f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);} \CommentTok{// ❌ wrong format specifiers}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with warnings:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}Wall}\NormalTok{ bug.c }\AttributeTok{{-}o}\NormalTok{ bug}
\end{Highlighting}
\end{Shaded}

Fix it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%.1f}\StringTok{ = }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);} \CommentTok{// ✅}
\end{Highlighting}
\end{Shaded}

\subsubsection{20.7 Strategies for Debugging Type
Issues}\label{strategies-for-debugging-type-issues}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Check format specifiers for \texttt{printf} and \texttt{scanf}
\item
  Verify variable types, does the type match its usage?
\item
  Add casts for mixed-type arithmetic
\item
  Enable warnings and fix all of them
\item
  Simplify expressions when errors get confusing
\end{enumerate}

A quick \texttt{printf} test can help you inspect variable types and
values.

\subsubsection{Why It Matters}\label{why-it-matters-19}

C gives you power and precision, but it expects discipline. Type
mismatches can lead to silent errors or crashes. By paying attention to
types, you make your programs robust and portable.

Good C programmers write code the compiler never complains about.

\subsubsection{Try It Yourself}\label{try-it-yourself-19}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print a \texttt{double} with \texttt{\%d} and fix the warning.
\item
  Assign \texttt{5\ /\ 2} to a double, then fix it with casting.
\item
  Read input into a \texttt{char} using \texttt{\%d}, observe the
  warning.
\item
  Mix an \texttt{int} and a string (\texttt{"Hello"\ +\ 2}), read the
  error message.
\item
  Turn on \texttt{-Wall} and clean all warnings from your last program.
\end{enumerate}

C's type system isn't an obstacle, it's a guide. Follow its rules, and
your programs will be safer, faster, and more reliable.

\section{Chapter 3. Control Flow}\label{chapter-3.-control-flow-1}

\subsection{\texorpdfstring{21. The \texttt{if}
Statement}{21. The if Statement}}\label{the-if-statement}

Every useful program needs to make choices. Sometimes you want to do
something only if a condition is true, like printing a message, checking
a score, or skipping an action. That's exactly what the \texttt{if}
statement does. It's how your program starts to \emph{think} for itself.

\subsubsection{\texorpdfstring{21.1 What Is an \texttt{if}
Statement}{21.1 What Is an if Statement}}\label{what-is-an-if-statement}

The \texttt{if} statement lets you run a block of code only when a
condition is true.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{condition}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// code runs only if condition is true}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If the condition is true (non-zero), the code inside the braces
\texttt{\{\}} executes. If it's false (zero), the code is skipped.

\subsubsection{21.2 A Simple Example}\label{a-simple-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{85}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Program finished.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
You passed!
Program finished.
\end{verbatim}

If you change \texttt{score} to \texttt{40}, only
\texttt{Program\ finished.} prints, the condition failed, so the
\texttt{if} block is skipped.

\subsubsection{21.3 Conditions Are Just
Expressions}\label{conditions-are-just-expressions}

Any expression can be used as a condition. C treats:

\begin{itemize}
\tightlist
\item
  \texttt{0} as false
\item
  any non-zero value as true
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Always runs!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \OperatorTok{\}}
\ControlFlowTok{if} \OperatorTok{(}\DecValTok{0}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Never runs!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You can also use variables:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ flag }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{flag}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ printf}\OperatorTok{(}\StringTok{"True!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \OperatorTok{\}} \CommentTok{// nonzero → true}
\end{Highlighting}
\end{Shaded}

\subsubsection{21.4 Without Braces}\label{without-braces}

If your \texttt{if} controls only one statement, braces are optional:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

But it's safer to always use braces, especially as programs grow:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This avoids mistakes when adding new lines later.

\subsubsection{\texorpdfstring{21.5 Common Pitfall: \texttt{=} vs
\texttt{==}}{21.5 Common Pitfall: = vs ==}}\label{common-pitfall-vs-1}

Remember:

\begin{itemize}
\tightlist
\item
  \texttt{=} assigns a value
\item
  \texttt{==} compares values
\end{itemize}

So this is wrong:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// assigns 5 to x, always true}
\end{Highlighting}
\end{Shaded}

It should be:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}} \CommentTok{// compares x to 5}
\end{Highlighting}
\end{Shaded}

A common beginner bug, always double-check your equality signs.

\subsubsection{\texorpdfstring{21.6 Nesting \texttt{if}
Statements}{21.6 Nesting if Statements}}\label{nesting-if-statements}

You can place one \texttt{if} inside another:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Excellent!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, a score of 95 prints both messages, while 75 prints only
``Passed!''.

\subsubsection{Tiny Code}\label{tiny-code-20}

Try this program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your age: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You can vote.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You get a senior discount!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you input \texttt{65}, you'll see both messages. If you input
\texttt{17}, you'll see only ``Goodbye!''.

\subsubsection{Why It Matters}\label{why-it-matters-20}

The \texttt{if} statement is your program's first decision-maker. It
lets you control flow, doing different things based on data. Without it,
your program would be a straight line. With it, your program starts
responding, branching, and reasoning.

\subsubsection{Try It Yourself}\label{try-it-yourself-20}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write an \texttt{if} that checks if a number is even
  (\texttt{x\ \%\ 2\ ==\ 0}).
\item
  Ask the user for a grade, and print ``Passed'' if it's at least 50.
\item
  Check if a value is negative, zero, or positive using nested
  \texttt{if}s.
\item
  Use a variable as a condition (\texttt{if\ (flag)}) and test different
  values.
\item
  Experiment with \texttt{if\ (x\ =\ 5)}, see why it always runs.
\end{enumerate}

With \texttt{if}, your code stops being a script and starts becoming
interactive logic, reacting to data and making choices just like you do.

\subsection{\texorpdfstring{22. The \texttt{else} and \texttt{else\ if}
Clauses}{22. The else and else if Clauses}}\label{the-else-and-else-if-clauses}

Life isn't just \emph{yes} or \emph{no}, sometimes there's a second path
to take when a condition fails. That's what \texttt{else} is for. It
lets your program say, ``If not this, then do that.'' And when you have
multiple possibilities, \texttt{else\ if} helps you chain them together.

With these, your program can handle all outcomes, not just one.

\subsubsection{\texorpdfstring{22.1 Adding an
\texttt{else}}{22.1 Adding an else}}\label{adding-an-else}

An \texttt{if} checks a condition, an \texttt{else} catches what happens
when that condition isn't true.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{condition}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do this if true}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
    \CommentTok{// do this if false}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{45}\OperatorTok{;}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You failed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{score} is 75, it prints ``You passed!''. If \texttt{score} is
45, it prints ``You failed.''

One condition, two paths, true or false.

\subsubsection{\texorpdfstring{22.2 Using \texttt{else\ if} for Multiple
Choices}{22.2 Using else if for Multiple Choices}}\label{using-else-if-for-multiple-choices}

What if you have more than two outcomes? That's where \texttt{else\ if}
comes in:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: A}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{80}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: B}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{70}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: C}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: F}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C checks these in order, top to bottom:

\begin{itemize}
\tightlist
\item
  If one condition is true, that block runs and the rest are skipped.
\item
  If none match, the final \texttt{else} runs.
\end{itemize}

This creates a decision ladder.

\subsubsection{22.3 How It Works}\label{how-it-works}

Let's say \texttt{score\ =\ 85}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{score\ \textgreater{}=\ 90}? No.~Skip.
\item
  \texttt{score\ \textgreater{}=\ 80}? Yes. Run ``Grade: B.''
\item
  Stop, no need to check further.
\end{enumerate}

Only one branch runs per chain.

\subsubsection{22.4 Nesting vs Chaining}\label{nesting-vs-chaining}

You could write nested \texttt{if}s:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Excellent!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Good job!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But \texttt{else\ if} chains are easier to read and maintain. Use them
when conditions are mutually exclusive.

\subsubsection{22.5 Common Mistakes}\label{common-mistakes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Dangling \texttt{else}, every \texttt{else} matches the nearest
  unmatched \texttt{if}. Always use braces \texttt{\{\}} to avoid
  confusion:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Small}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Big}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \CommentTok{// attaches to inner if}
\end{Highlighting}
\end{Shaded}
\item
  Missing braces, causes unexpected grouping. Always write:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Positive}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Non{-}positive}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\subsubsection{Tiny Code}\label{tiny-code-21}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ temp}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter temperature: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{temp}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{temp }\OperatorTok{\textgreater{}=} \DecValTok{30}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s hot!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{temp }\OperatorTok{\textgreater{}=} \DecValTok{20}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s warm.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{temp }\OperatorTok{\textgreater{}=} \DecValTok{10}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s cool.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"It\textquotesingle{}s cold!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input → \texttt{25} Output → \texttt{It\textquotesingle{}s\ warm.}

\subsubsection{22.6 The Order Matters}\label{the-order-matters}

Always start with the most specific or highest condition first.
Otherwise, broader conditions may trigger early and skip later checks.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)}      \CommentTok{// triggers first}
\ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \CommentTok{// never reached}
\end{Highlighting}
\end{Shaded}

Reverse the order to handle top cases first.

\subsubsection{Why It Matters}\label{why-it-matters-21}

\texttt{if}, \texttt{else\ if}, and \texttt{else} form the decision tree
of your program. They allow branching logic, responding differently to
every situation. With them, you can model real-world thinking: ``If this
is true, do that; otherwise, try this; if all else fails, do something
else.''

\subsubsection{Try It Yourself}\label{try-it-yourself-21}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask for a number and print if it's positive, negative, or zero.
\item
  Ask for an age and print if someone is a child, teen, adult, or
  senior.
\item
  Grade a test score from 0--100 using \texttt{if-else\ if-else}.
\item
  Change the order of checks, see how it changes results.
\item
  Add an \texttt{else} to catch invalid input (like negative scores).
\end{enumerate}

With \texttt{else} and \texttt{else\ if}, your programs start thinking
in complete sentences --- handling not just ``yes'' but ``otherwise''
and ``maybe.''

\subsection{23. Nested Conditionals}\label{nested-conditionals}

Sometimes, one decision isn't enough. You might want to make a choice
inside another choice, for example, first check if a user passed, then
check \emph{how well} they passed. That's where nested conditionals come
in.

A nested \texttt{if} is simply an \texttt{if} statement inside another
\texttt{if} block. It's how you build step-by-step decisions, just like
real thinking.

\subsubsection{\texorpdfstring{23.1 What Are Nested
\texttt{if}s}{23.1 What Are Nested ifs}}\label{what-are-nested-ifs}

You can place any \texttt{if} or \texttt{else} inside another
\texttt{if}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{condition1}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{condition2}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// runs only if both condition1 and condition2 are true}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each layer adds one more level of decision-making.

\subsubsection{23.2 A Simple Example}\label{a-simple-example-1}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{95}\OperatorTok{;}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You passed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Excellent!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The first \texttt{if} checks if you passed.
\item
  The second \texttt{if} checks if your score is also excellent.
\end{itemize}

Output:

\begin{verbatim}
You passed!
Excellent!
\end{verbatim}

If \texttt{score\ =\ 70}, you only get \texttt{You\ passed!}. If
\texttt{score\ =\ 40}, neither condition runs.

\subsubsection{23.3 Real-World Example}\label{real-world-example}

Imagine a login system:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ logged\_in }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ admin }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{logged\_in}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{admin}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Admin panel unlocked.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Standard user access.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Please log in first.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Depending on your flags, the program prints different paths. This is
decision layering, logic inside logic.

\subsubsection{23.4 Nested vs Combined
Conditions}\label{nested-vs-combined-conditions}

Nested conditions can sometimes be simplified using logical operators:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textless{}} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Good job!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This can become:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{60} \OperatorTok{\&\&}\NormalTok{ score }\OperatorTok{\textless{}} \DecValTok{90}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Good job!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Both do the same thing. When possible, combine conditions for clarity.
When logic grows complex, keep nesting, it's okay!

\subsubsection{23.5 Indentation Matters}\label{indentation-matters}

Indentation helps you see structure clearly:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Both positive}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Without indentation, nested logic becomes confusing. Always align braces
and indent inner blocks so they're easy to read.

\subsubsection{\texorpdfstring{23.6 Using \texttt{else} in Nested
Structures}{23.6 Using else in Nested Structures}}\label{using-else-in-nested-structures}

Each \texttt{if} can have its own \texttt{else}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Positive even number}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Positive odd number}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Not positive}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input → \texttt{4} → \texttt{Positive\ even\ number} Input → \texttt{3}
→ \texttt{Positive\ odd\ number} Input → \texttt{-5} →
\texttt{Not\ positive}

Every branch is now covered.

\subsubsection{Tiny Code}\label{tiny-code-22}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ age}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your age: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{18}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You are an adult.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{age }\OperatorTok{\textgreater{}=} \DecValTok{65}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"You are also eligible for senior benefits.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"You are a minor.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output for \texttt{70}:

\begin{verbatim}
You are an adult.
You are also eligible for senior benefits.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-22}

Nested conditionals let your programs handle multi-step logic, one
question leading to another. They're perfect for menus, game rules, and
complex checks. When your program needs to say, ``If this, then check
that,'' nesting is the way.

\subsubsection{Try It Yourself}\label{try-it-yourself-22}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that checks if a number is positive. Inside, check if
  it's even or odd.
\item
  Ask for a score. If it's passing, check if it's an A, B, or C.
\item
  Simulate a login: if logged in, greet; if admin, show a special
  message.
\item
  Combine two nested conditions into one using \texttt{\&\&}.
\item
  Add indentation and braces to a messy nested \texttt{if}, see how much
  clearer it looks.
\end{enumerate}

Nested conditionals let your programs think in layers, just like you.
Each level adds more nuance, helping your code make smarter decisions.

\subsection{\texorpdfstring{24. The \texttt{switch}
Statement}{24. The switch Statement}}\label{the-switch-statement}

Sometimes you want your program to choose between many options, not just
two or three. You could write a long chain of \texttt{if},
\texttt{else\ if}, \texttt{else}, but that quickly becomes messy. C
gives you a cleaner tool for this job: the \texttt{switch} statement.

Think of \texttt{switch} like a menu. You pick a value, and C jumps
straight to the matching option.

\subsubsection{\texorpdfstring{24.1 What Is a
\texttt{switch}}{24.1 What Is a switch}}\label{what-is-a-switch}

A \texttt{switch} compares a single value against a list of constant
cases. When it finds a match, it runs the code for that case.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{expression}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case}\NormalTok{ value1}\OperatorTok{:}
        \CommentTok{// code for value1}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case}\NormalTok{ value2}\OperatorTok{:}
        \CommentTok{// code for value2}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}
        \CommentTok{// code if no case matches}
        \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The \texttt{expression} is usually an integer or character.
\item
  Each \texttt{case} is like a label, if it matches, that block runs.
\item
  The optional \texttt{default} runs when nothing else matches.
\end{itemize}

\subsubsection{24.2 A Simple Example}\label{a-simple-example-2}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{day}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Monday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Tuesday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Wednesday}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Invalid day}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Wednesday
\end{verbatim}

The program jumps straight to \texttt{case\ 3}.

\subsubsection{\texorpdfstring{24.3 The Role of
\texttt{break}}{24.3 The Role of break}}\label{the-role-of-break}

After each \texttt{case}, you usually write \texttt{break;} to exit the
\texttt{switch}.

If you forget it, C will fall through, it keeps running the next cases
too:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}

\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"One}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Two}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Three}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Two
Three
\end{verbatim}

C didn't stop after \texttt{case\ 2}. To prevent this, always include
\texttt{break;} unless you want fall-through intentionally.

\subsubsection{\texorpdfstring{24.4 Using
\texttt{default}}{24.4 Using default}}\label{using-default}

\texttt{default} catches anything that doesn't match:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{grade}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Excellent}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}B\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Good}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Invalid grade}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It's like the \texttt{else} in an \texttt{if} chain, always optional but
useful.

\subsubsection{24.5 Grouping Cases}\label{grouping-cases}

You can group multiple cases that share the same code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{ch}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}a\textquotesingle{}}\OperatorTok{:}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}A\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Vowel A}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{:}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}E\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Vowel E}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Not A or E}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Grouped cases help handle upper/lowercase or related values easily.

\subsubsection{24.6 Switch vs If}\label{switch-vs-if}

Use \texttt{switch} when:

\begin{itemize}
\tightlist
\item
  You're checking one variable against fixed values
\item
  You want clear, organized options
\end{itemize}

Use \texttt{if} when:

\begin{itemize}
\tightlist
\item
  You need ranges, conditions, or complex logic
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)} \OperatorTok{...}  \CommentTok{// can\textquotesingle{}t do this in switch}
\end{Highlighting}
\end{Shaded}

\texttt{switch} is simpler when your values are exact (like menu numbers
or keys).

\subsubsection{Tiny Code}\label{tiny-code-23}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ option}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Choose an option (1{-}3): "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{option}\OperatorTok{);}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{option}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Start game}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Load game}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Quit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Invalid choice}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input → \texttt{2} Output → \texttt{Load\ game}

\subsubsection{24.7 Nested Switches
(Optional)}\label{nested-switches-optional}

You can nest \texttt{switch} statements, but keep them readable:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{userType}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}
        \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{permission}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{case} \DecValTok{0}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Guest}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
            \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Member}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \OperatorTok{\}}
        \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use indentation and braces to stay organized.

\subsubsection{Why It Matters}\label{why-it-matters-23}

The \texttt{switch} statement helps you handle many fixed options
cleanly. Instead of long \texttt{if} chains, you get a simple structure,
easy to read, easy to extend. It's perfect for menus, commands, and
settings.

Think of it as your program's choice board.

\subsubsection{Try It Yourself}\label{try-it-yourself-23}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that prints the day of the week (1--7).
\item
  Create a grade system using
  \texttt{\textquotesingle{}A\textquotesingle{}},
  \texttt{\textquotesingle{}B\textquotesingle{}},
  \texttt{\textquotesingle{}C\textquotesingle{}},
  \texttt{\textquotesingle{}D\textquotesingle{}},
  \texttt{\textquotesingle{}F\textquotesingle{}}.
\item
  Add a menu with 3 options and a \texttt{default} for invalid ones.
\item
  Test what happens when you remove a \texttt{break}.
\item
  Group two cases together (like
  \texttt{\textquotesingle{}a\textquotesingle{}} and
  \texttt{\textquotesingle{}A\textquotesingle{}}).
\end{enumerate}

With \texttt{switch}, your programs start feeling menu-driven --- they
don't just think, they \emph{offer choices}.

\subsection{\texorpdfstring{25. The \texttt{while}
Loop}{25. The while Loop}}\label{the-while-loop}

In many programs, you'll need to repeat something over and over, like
printing numbers, reading input, or waiting for a condition. Instead of
copying the same code many times, you can use a loop. The \texttt{while}
loop is the simplest kind: it repeats a block of code as long as a
condition is true.

Think of it like saying, ``While it's still raining, keep the umbrella
open.''

\subsubsection{\texorpdfstring{25.1 What Is a \texttt{while}
Loop}{25.1 What Is a while Loop}}\label{what-is-a-while-loop}

A \texttt{while} loop runs again and again until its condition becomes
false.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{condition}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// code runs while condition is true}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each time it reaches the end of the block, it checks the condition
again. If the condition is still true, it repeats. If false, it exits
and moves on.

\subsubsection{25.2 A Simple Example}\label{a-simple-example-3}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{count }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\NormalTok{        count}\OperatorTok{++;} \CommentTok{// don\textquotesingle{}t forget to update!}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Done!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Done!
\end{verbatim}

This loop runs 5 times because the condition
\texttt{count\ \textless{}=\ 5} starts true, then eventually becomes
false.

\subsubsection{25.3 The Condition Must
Change}\label{the-condition-must-change}

If you forget to update the variable inside the loop, it'll never end:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
    \CommentTok{// missing x++}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This creates an infinite loop, the condition is always true. Always make
sure something inside the loop moves it toward stopping.

\subsubsection{25.4 Counting Down}\label{counting-down}

You can loop backward too:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\NormalTok{    n}\OperatorTok{{-}{-};}
\OperatorTok{\}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Blast off!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
5...
4...
3...
2...
1...
Blast off!
\end{verbatim}

\subsubsection{\texorpdfstring{25.5 Using \texttt{while} for User
Input}{25.5 Using while for User Input}}\label{using-while-for-user-input}

You can loop until a certain value appears:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ number }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{number }\OperatorTok{!=} \DecValTok{42}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a number (42 to quit): "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{number}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"You found the answer!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The loop continues until you enter \texttt{42}.

\subsubsection{25.6 Infinite Loops
(Intentional)}\label{infinite-loops-intentional}

Sometimes infinite loops are useful, especially in programs that should
run forever (like servers or games). You can write one with
\texttt{while\ (1)}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do something forever}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You'll need a \texttt{break} or exit condition inside to stop it safely.

\subsubsection{25.7 Nested Loops}\label{nested-loops}

You can put one \texttt{while} loop inside another:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{j }\OperatorTok{\textless{}=} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i=}\SpecialCharTok{\%d}\StringTok{, j=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
\NormalTok{        j}\OperatorTok{++;}
    \OperatorTok{\}}
\NormalTok{    i}\OperatorTok{++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i=1, j=1
i=1, j=2
i=2, j=1
i=2, j=2
i=3, j=1
i=3, j=2
\end{verbatim}

\subsubsection{Tiny Code}\label{tiny-code-24}

Try this countdown:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{        i}\OperatorTok{{-}{-};}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Liftoff!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 9 8 7 6 5 4 3 2 1 
Liftoff!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-24}

The \texttt{while} loop gives your program repetition with control. You
decide the rule, and C keeps repeating until that rule breaks. Loops
turn one action into many, saving time, space, and effort.

Once you understand loops, you'll see them everywhere --- from reading
files to running games.

\subsubsection{Try It Yourself}\label{try-it-yourself-24}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print numbers from 1 to 10 using a \texttt{while} loop.
\item
  Write a program that sums numbers from 1 to 100.
\item
  Loop until the user enters a negative number.
\item
  Create a countdown from 5 to 1, then print ``Go!''.
\item
  Make a guessing loop that stops when the user guesses \texttt{7}.
\end{enumerate}

The \texttt{while} loop is your first taste of repetition and
automation. Tell it the rule, and it'll handle the rest, patiently and
precisely.

\subsection{\texorpdfstring{26. The \texttt{for}
Loop}{26. The for Loop}}\label{the-for-loop}

The \texttt{for} loop is one of the most common loops in C. It's perfect
when you know exactly how many times you want something to repeat, like
printing numbers from 1 to 10 or iterating over an array.

You can think of it like a built-in counter that says: ``Start here,
repeat until this condition, and change this each time.''

\subsubsection{\texorpdfstring{26.1 What Is a \texttt{for}
Loop}{26.1 What Is a for Loop}}\label{what-is-a-for-loop}

A \texttt{for} loop has three parts, start, condition, and update, all
in one line:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\NormalTok{start}\OperatorTok{;}\NormalTok{ condition}\OperatorTok{;}\NormalTok{ update}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// code runs while condition is true}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each time the loop runs:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The start sets up your variable (usually a counter).
\item
  The condition is checked, if true, run the body.
\item
  After the body, the update runs (like \texttt{i++}).
\end{enumerate}

Then it loops again.

\subsubsection{26.2 A Simple Example}\label{a-simple-example-4}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i = 1  
i = 2  
i = 3  
i = 4  
i = 5
\end{verbatim}

Let's break it down:

\begin{itemize}
\tightlist
\item
  Start → \texttt{int\ i\ =\ 1}
\item
  Condition → \texttt{i\ \textless{}=\ 5}
\item
  Update → \texttt{i++} (adds 1 each loop)
\end{itemize}

When \texttt{i} reaches 6, the condition fails, and the loop stops.

\subsubsection{26.3 Counting Down}\label{counting-down-1}

You can count backward too:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}\NormalTok{ n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{;}\NormalTok{ n}\OperatorTok{{-}{-})} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Blast off!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
5...
4...
3...
2...
1...
Blast off!
\end{verbatim}

\subsubsection{26.4 Skipping Steps}\label{skipping-steps}

You can increase by more than one:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i }\OperatorTok{+=} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output: \texttt{0\ 2\ 4\ 6\ 8\ 10}

The \texttt{update} can do anything, add, subtract, multiply, or even
call a function.

\subsubsection{26.5 Omitting Parts}\label{omitting-parts}

Each part of the \texttt{for} loop is optional:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for} \OperatorTok{(;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;} \OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{    i}\OperatorTok{++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Even this works (infinite loop):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(;;)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Forever!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Though usually you'll use a \texttt{while} for that.

\subsubsection{\texorpdfstring{26.6 Nested \texttt{for}
Loops}{26.6 Nested for Loops}}\label{nested-for-loops}

You can nest loops to repeat patterns in two dimensions:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{2}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i=}\SpecialCharTok{\%d}\StringTok{, j=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i=1, j=1  
i=1, j=2  
i=2, j=1  
i=2, j=2  
i=3, j=1  
i=3, j=2
\end{verbatim}

Great for grids, tables, and matrices.

\subsubsection{\texorpdfstring{26.7 When to Use
\texttt{for}}{26.7 When to Use for}}\label{when-to-use-for}

Use \texttt{for} when:

\begin{itemize}
\tightlist
\item
  You know how many times to loop
\item
  You're counting or iterating over a sequence
\item
  The variable naturally updates each time
\end{itemize}

If the number of repetitions is unknown, use a \texttt{while} instead.

\subsubsection{Tiny Code}\label{tiny-code-25}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        sum }\OperatorTok{+=}\NormalTok{ i}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum = 55
\end{verbatim}

The loop runs 10 times and keeps adding \texttt{i} to \texttt{sum}.

\subsubsection{Why It Matters}\label{why-it-matters-25}

The \texttt{for} loop is your structured repeater, short, clean, and
powerful. It keeps counting for you, so you can focus on what to do each
step. Once you get used to it, you'll use \texttt{for} loops all the
time, from simple counters to array processing.

\subsubsection{Try It Yourself}\label{try-it-yourself-25}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print numbers from 1 to 10 using a \texttt{for} loop.
\item
  Print only even numbers from 0 to 20.
\item
  Count down from 10 to 1 and print ``Go!''.
\item
  Calculate the sum of numbers from 1 to 100.
\item
  Create a multiplication table (nested loop).
\end{enumerate}

With \texttt{for}, repetition becomes neat and predictable. It's your
programmable timer, set it, and let it run.

\subsection{\texorpdfstring{27. The \texttt{do-while}
Loop}{27. The do-while Loop}}\label{the-do-while-loop}

So far, you've seen loops that check first, then run. The
\texttt{do-while} loop flips that order, it runs first, then checks.
That means it always runs at least once, no matter what.

Think of it like saying, ``Do this thing once, and if it's still okay,
keep doing it.''

\subsubsection{\texorpdfstring{27.1 What Is a \texttt{do-while}
Loop}{27.1 What Is a do-while Loop}}\label{what-is-a-do-while-loop}

The \texttt{do-while} loop looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{do} \OperatorTok{\{}
    \CommentTok{// code to repeat}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{condition}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Notice the semicolon at the end, that's important! The body runs first,
then the condition is tested. If the condition is true, the loop
repeats.

\subsubsection{27.2 A Simple Example}\label{a-simple-example-5}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}

    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\NormalTok{        count}\OperatorTok{++;}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{count }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Done!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Count: 1  
Count: 2  
Count: 3  
Count: 4  
Count: 5  
Done!
\end{verbatim}

Even if \texttt{count} started larger than 5, the body would still run
once.

\subsubsection{27.3 Always Runs at Least
Once}\label{always-runs-at-least-once}

Compare this to a regular \texttt{while} loop:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

\ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"This never prints!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But with \texttt{do-while}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

\ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"This runs once!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Even though \texttt{n\ \textless{}\ 5} is false, you'll still see one
print. That's the main difference, check later, not before.

\subsubsection{27.4 A Common Use: Input
Validation}\label{a-common-use-input-validation}

\texttt{do-while} is perfect when you want the user to do something at
least once, like entering a number until it's valid.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ number}\OperatorTok{;}

    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a positive number: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{number}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{number }\OperatorTok{\textless{}=} \DecValTok{0}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"You entered: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ number}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The prompt appears at least once, even if the first input is wrong.

\subsubsection{27.5 The Condition at the
End}\label{the-condition-at-the-end}

Unlike \texttt{for} and \texttt{while}, the \texttt{do-while} condition
goes after the block. So don't forget the semicolon:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{do} \OperatorTok{\{}
    \CommentTok{// body}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{condition}\OperatorTok{);} \CommentTok{// ← required}
\end{Highlighting}
\end{Shaded}

Leaving it out causes a compile error.

\subsubsection{\texorpdfstring{27.6 Infinite
\texttt{do-while}}{27.6 Infinite do-while}}\label{infinite-do-while}

You can make an intentional infinite loop:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{do} \OperatorTok{\{}
    \CommentTok{// repeat forever}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Useful when you always want one full run before checking a break.

\subsubsection{Tiny Code}\label{tiny-code-26}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}

    \ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\NormalTok{        i}\OperatorTok{{-}{-};}
    \OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Loop finished.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i = 3  
i = 2  
i = 1  
Loop finished.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-26}

The \texttt{do-while} loop gives you at least one guaranteed run, which
makes it great for tasks like user input, menus, and retries. Whenever
you want to ``try first, check later,'' this is your go-to loop.

It's another tool in your looping toolbox, one that always \emph{gets
things started}.

\subsubsection{Try It Yourself}\label{try-it-yourself-26}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print ``Hello!'' three times with a \texttt{do-while} loop.
\item
  Ask for a password until the user types \texttt{1234}.
\item
  Count down from 5 using \texttt{do-while}.
\item
  Make a menu that repeats until the user enters \texttt{0}.
\item
  Compare a \texttt{while} and a \texttt{do-while} that both check
  \texttt{x\ \textless{}\ 0}. What happens?
\end{enumerate}

The \texttt{do-while} is your one-time starter, it makes sure your code
runs at least once before asking, ``Should I keep going?''

\subsection{28. Breaking and Continuing
Loops}\label{breaking-and-continuing-loops}

Sometimes you don't want a loop to run all the way to the end. Maybe you
want to stop early when something happens, or skip one step and move to
the next.

That's exactly what \texttt{break} and \texttt{continue} do --- they
give you extra control inside any loop.

Think of them as ``emergency exits'' and ``shortcuts'' for your loop.

\subsubsection{\texorpdfstring{28.1 The \texttt{break}
Statement}{28.1 The break Statement}}\label{the-break-statement}

\texttt{break} stops the loop completely and jumps out right away. The
program continues with the first line after the loop.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{condition}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{something\_happened}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// exit loop}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{28.2 Example: Stop When
Found}\label{example-stop-when-found}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Found 5! Stopping.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \OperatorTok{\}}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Loop ended.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 3 4 Found 5! Stopping.
Loop ended.
\end{verbatim}

When \texttt{i\ ==\ 5}, the \texttt{break} runs, loop ends instantly.
Numbers 6 to 10 are skipped.

\subsubsection{\texorpdfstring{28.3 The \texttt{continue}
Statement}{28.3 The continue Statement}}\label{the-continue-statement}

\texttt{continue} skips the rest of the loop body and jumps back to the
next iteration. The loop doesn't stop, it just moves on early.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{3}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 4 5
\end{verbatim}

When \texttt{i\ ==\ 3}, \texttt{continue} skips the \texttt{printf}. The
loop jumps right back to the top.

\subsubsection{\texorpdfstring{28.4 Using \texttt{break} and
\texttt{continue} in \texttt{while}
Loops}{28.4 Using break and continue in while Loops}}\label{using-break-and-continue-in-while-loops}

They work in any kind of loop, \texttt{for}, \texttt{while}, or
\texttt{do-while}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}} \DecValTok{10}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    n}\OperatorTok{++;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{3}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;}  \CommentTok{// skip 3}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{8}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}     \CommentTok{// stop at 8}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 4 5 6 7
\end{verbatim}

\subsubsection{\texorpdfstring{28.5 Nested Loops and
\texttt{break}}{28.5 Nested Loops and break}}\label{nested-loops-and-break}

If you have loops inside loops, \texttt{break} only exits the current
one.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{j }\OperatorTok{==} \DecValTok{2}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"i=}\SpecialCharTok{\%d}\StringTok{ j=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i=1 j=1
i=2 j=1
i=3 j=1
\end{verbatim}

Each inner loop stops at \texttt{j\ ==\ 2}, but the outer one keeps
going.

\subsubsection{28.6 Why Use Them}\label{why-use-them}

\begin{itemize}
\tightlist
\item
  \texttt{break} is great when you find what you're looking for early.
\item
  \texttt{continue} is great when you want to skip certain cases but
  keep looping.
\end{itemize}

They make loops more flexible, you don't always have to go all the way.

\subsubsection{Tiny Code}\label{tiny-code-27}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a number (0 to quit): "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{num}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{num }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// exit the loop}
        \OperatorTok{\}}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{num }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Negative skipped.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{continue}\OperatorTok{;} \CommentTok{// skip to next input}
        \OperatorTok{\}}

\NormalTok{        printf}\OperatorTok{(}\StringTok{"You entered }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try entering positive, negative, and zero values. You'll see how
\texttt{break} and \texttt{continue} shape the loop's path.

\subsubsection{Why It Matters}\label{why-it-matters-27}

Loops aren't always simple start-to-finish runs. Real logic often needs
early exits or skipped steps. With \texttt{break} and \texttt{continue},
you get fine-grained control --- you decide when to stop or move on.

\subsubsection{Try It Yourself}\label{try-it-yourself-27}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print numbers from 1 to 10, but stop when you reach 7.
\item
  Print numbers 1 to 10, skipping all even numbers.
\item
  Read numbers until you get \texttt{0}, but skip negatives.
\item
  In a \texttt{for} loop, break early when the sum exceeds 50.
\item
  Create a nested loop and use \texttt{break} in the inner one.
\end{enumerate}

\texttt{break} is your exit key, \texttt{continue} is your skip button
--- together they make your loops smarter and more dynamic.

\subsection{\texorpdfstring{29. Using \texttt{goto} Safely (and Why to
Avoid
It)}{29. Using goto Safely (and Why to Avoid It)}}\label{using-goto-safely-and-why-to-avoid-it}

There's a little keyword in C called \texttt{goto}. It lets you jump
directly to another part of your program, like teleporting to a label.
It can be powerful, but also confusing if used too much. That's why
experienced programmers say:

\begin{quote}
``Use it only when you really need to.''
\end{quote}

Let's see how it works, and when it's better to use something else.

\subsubsection{\texorpdfstring{29.1 What Is
\texttt{goto}}{29.1 What Is goto}}\label{what-is-goto}

The \texttt{goto} statement jumps straight to a label, a line in your
program marked with a name and a colon.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{goto}\NormalTok{ label}\OperatorTok{;}
\CommentTok{// ...}
\NormalTok{label}\OperatorTok{:}
    \CommentTok{// code here}
\end{Highlighting}
\end{Shaded}

When \texttt{goto} runs, the program skips everything between the jump
and the label. Execution continues at the label.

\subsubsection{29.2 A Simple Example}\label{a-simple-example-6}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{==} \DecValTok{1}\OperatorTok{)}
        \ControlFlowTok{goto}\NormalTok{ skip}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"This line is skipped!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{skip}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Jumped to label.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Jumped to label.
\end{verbatim}

Because \texttt{x\ ==\ 1}, \texttt{goto\ skip;} jumps straight to the
label. The line before it is never executed.

\subsubsection{29.3 Common Use: Breaking Out of Nested
Loops}\label{common-use-breaking-out-of-nested-loops}

Sometimes you want to escape multiple loops at once. A single
\texttt{break} only exits the current loop, but a \texttt{goto} can jump
out of all of them.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{*}\NormalTok{ j }\OperatorTok{==} \DecValTok{4}\OperatorTok{)}
                \ControlFlowTok{goto}\NormalTok{ found}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{found}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Stopped when i * j = 4}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Stopped when i * j = 4
\end{verbatim}

Once the condition is met, \texttt{goto} jumps straight out.

\subsubsection{29.4 Why Many Programmers Avoid
It}\label{why-many-programmers-avoid-it}

\texttt{goto} can make code hard to read and debug. If used often, your
program's flow jumps all over the place --- it's easy to lose track of
what happens next.

Compare:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{goto}\NormalTok{ step2}\OperatorTok{;}
\CommentTok{// ...}
\NormalTok{step2}\OperatorTok{:}
\ControlFlowTok{goto}\NormalTok{ step3}\OperatorTok{;}
\CommentTok{// ...}
\NormalTok{step3}\OperatorTok{:}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Done!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

vs.~a clean loop or function, much easier to follow!

That's why most of the time, loops, functions, or \texttt{break}
statements are better choices.

\subsubsection{29.5 When It's Useful}\label{when-its-useful}

\texttt{goto} is okay for:

\begin{itemize}
\tightlist
\item
  Exiting deeply nested loops
\item
  Handling errors (jump to cleanup)
\item
  Early exits when code is too repetitive
\end{itemize}

Here's an example from system programming:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{file }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{file}\OperatorTok{)} \ControlFlowTok{goto}\NormalTok{ error}\OperatorTok{;}

\DataTypeTok{char} \OperatorTok{*}\NormalTok{buffer }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(!}\NormalTok{buffer}\OperatorTok{)} \ControlFlowTok{goto}\NormalTok{ cleanup}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"File opened and buffer allocated.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{cleanup}\OperatorTok{:}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{file}\OperatorTok{)}\NormalTok{ fclose}\OperatorTok{(}\NormalTok{file}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{buffer}\OperatorTok{)}\NormalTok{ free}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{);}
\NormalTok{error}\OperatorTok{:}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Here, \texttt{goto} jumps to cleanup code safely, instead of repeating
\texttt{fclose} and \texttt{free} in many places.

\subsubsection{29.6 Best Practices}\label{best-practices}

If you use \texttt{goto}:

\begin{itemize}
\tightlist
\item
  Only jump forward, not backward (avoid loops with \texttt{goto})
\item
  Keep labels close to the \texttt{goto}
\item
  Use clear label names (like \texttt{cleanup:} or \texttt{exit:})
\item
  Prefer loops or functions for normal flow
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-28}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a number (0 to quit): "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{goto}\NormalTok{ end}\OperatorTok{;}

\NormalTok{        printf}\OperatorTok{(}\StringTok{"You entered }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{end}\OperatorTok{:}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Enter a number (0 to quit): 5
You entered 5
Enter a number (0 to quit): 0
Goodbye!
\end{verbatim}

The \texttt{goto} jumps straight to \texttt{end:} when the user enters
\texttt{0}.

\subsubsection{Why It Matters}\label{why-it-matters-28}

\texttt{goto} is part of C's toolbox, but it's a sharp tool. You can use
it to escape tricky situations, but if you rely on it too much, your
program becomes a maze.

Learn it, understand it, but reach for loops, breaks, and functions
first.

\subsubsection{Try It Yourself}\label{try-it-yourself-28}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a loop that jumps to a label when the user types \texttt{-1}.
\item
  Create nested loops and use \texttt{goto} to break out of both.
\item
  Try replacing a \texttt{goto} with a \texttt{break}, see which looks
  clearer.
\item
  Write a small program with a \texttt{cleanup:} label to close files.
\item
  Experiment with labels placed before and after the \texttt{goto}.
\end{enumerate}

\texttt{goto} is like an emergency exit --- nice to know where it is,
but you hope you never have to use it!

\subsection{30. Patterns of Control
Flow}\label{patterns-of-control-flow}

Now that you've learned about if statements, loops, break, continue, and
even goto, you've got all the tools to control how your program flows,
when it chooses, repeats, or stops.

This section is about putting it all together. You'll see the common
patterns of control flow that appear in almost every C program. Think of
these as the building blocks of logic.

\subsubsection{30.1 What Is Control Flow?}\label{what-is-control-flow}

Control flow means \emph{the order in which your program's statements
run}. By default, C executes from top to bottom, one line at a time.

But with conditionals and loops, you can:

\begin{itemize}
\tightlist
\item
  Branch, choose one path or another (\texttt{if}, \texttt{else})
\item
  Repeat, run something again and again (\texttt{while}, \texttt{for},
  \texttt{do-while})
\item
  Jump, move somewhere else (\texttt{break}, \texttt{continue},
  \texttt{goto})
\end{itemize}

Good programs combine these patterns clearly and simply.

\subsubsection{30.2 The Sequence Pattern}\label{the-sequence-pattern}

The simplest pattern: do things one after another.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Start}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Step 1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Step 2}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Done}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is straight-line control flow, no conditions, no loops. Great for
simple scripts or steps that always happen in order.

\subsubsection{30.3 The Selection Pattern}\label{the-selection-pattern}

Use \texttt{if}, \texttt{else\ if}, \texttt{else}, or \texttt{switch}
when you need to choose between actions.

Example (using if):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{90}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"A}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{score }\OperatorTok{\textgreater{}=} \DecValTok{80}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"B}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{else}\NormalTok{ printf}\OperatorTok{(}\StringTok{"C or lower}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example (using switch):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{menu}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Play}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Settings}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Exit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Invalid}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is branching control flow, only one path runs.

\subsubsection{30.4 The Repetition
Pattern}\label{the-repetition-pattern}

Loops let you repeat actions while conditions hold true. You've met
three kinds:

\begin{itemize}
\tightlist
\item
  \texttt{while}, repeat \emph{while true}
\item
  \texttt{for}, repeat a fixed number of times
\item
  \texttt{do-while}, run once, then check again
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output: \texttt{1\ 2\ 3\ 4\ 5}

This is iterative control flow, doing something many times.

\subsubsection{30.5 The Nested Pattern}\label{the-nested-pattern}

You can combine decisions and loops, one inside another.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ is even}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ is odd}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each loop iteration includes its own decision. This is a nested flow,
logic inside logic.

\subsubsection{30.6 The Early Exit
Pattern}\label{the-early-exit-pattern}

Sometimes you want to leave early when a condition is met. That's where
\texttt{break}, \texttt{continue}, and return come in.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{10}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{5}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;} \CommentTok{// stop at 5}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or skip certain cases:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{3}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;} \CommentTok{// skip 3}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

These are shortcut flows, stop early, skip ahead, or exit cleanly.

\subsubsection{30.7 The Guard Pattern}\label{the-guard-pattern}

A guard checks that a condition is safe before running a block. It's
like a door that opens only if the key fits.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{ptr }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer is valid.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or inside a loop:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{input }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do work}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Guards prevent bad states, they're everywhere in robust programs.

\subsubsection{30.8 The Menu Pattern}\label{the-menu-pattern}

You'll see this often in interactive programs:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ option}\OperatorTok{;}
\ControlFlowTok{do} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"1. Add}\SpecialCharTok{\textbackslash{}n}\StringTok{2. Subtract}\SpecialCharTok{\textbackslash{}n}\StringTok{3. Quit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{option}\OperatorTok{);}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{option}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \DecValTok{1}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Adding...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{2}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Subtracting...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \DecValTok{3}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Invalid choice.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}} \ControlFlowTok{while} \OperatorTok{(}\NormalTok{option }\OperatorTok{!=} \DecValTok{3}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This combines loops, switch, and input, a classic pattern!

\subsubsection{30.9 Combining Patterns}\label{combining-patterns}

Most real programs use multiple control flow patterns together:

\begin{itemize}
\tightlist
\item
  A loop that reads data
\item
  An \texttt{if} that checks for errors
\item
  A \texttt{break} to exit early
\item
  Another loop for retrying
\end{itemize}

Your job is to combine them clearly, each part should make sense on its
own.

\subsubsection{Tiny Code}\label{tiny-code-29}

Try this full example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a number (0 to quit): "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{break}\OperatorTok{;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ is even}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
        \ControlFlowTok{else}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ is odd}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This program:

\begin{itemize}
\tightlist
\item
  Loops until \texttt{0}
\item
  Branches with \texttt{if}
\item
  Breaks early A perfect example of combined flow.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-29}

Control flow is the heart of programming. It's how you make your program
\emph{do the right thing at the right time}. By mixing these simple
patterns, you can express almost any logic --- decisions, repetitions,
early exits, or menus.

You're not just writing code, you're designing behavior.

\subsubsection{Try It Yourself}\label{try-it-yourself-29}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Combine \texttt{for} and \texttt{if} to print all even numbers between
  1--20.
\item
  Write a guessing game loop with a \texttt{break} when the user is
  correct.
\item
  Make a menu that loops until the user chooses to exit.
\item
  Add guards (safety checks) before using variables.
\item
  Mix \texttt{if}, \texttt{for}, and \texttt{continue} in one program.
\end{enumerate}

Now you've seen every major flow pattern in C. They're your logic
toolkit, combine them, and your programs can handle anything!

\section{Chapter 4. Functions and
Scope}\label{chapter-4.-functions-and-scope-1}

\subsection{31. Defining and Calling
Functions}\label{defining-and-calling-functions}

As your programs grow, you'll notice some code starts repeating,
printing menus, adding numbers, checking inputs. Instead of copying and
pasting, you can wrap those steps into a function.

A function is like a mini-program inside your program. It takes input,
does some work, and can return an answer. Functions make your code
clearer, shorter, and easier to fix.

\subsubsection{31.1 What Is a Function}\label{what-is-a-function}

A function is a named block of code that performs one task.

It usually has:

\begin{itemize}
\tightlist
\item
  A return type, what it gives back
\item
  A name, how you call it
\item
  Parameters, inputs it uses
\item
  A body, the work it does
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ sum}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{int} → the return type (an integer)
\item
  \texttt{add} → the name of the function
\item
  \texttt{(int\ a,\ int\ b)} → parameters
\item
  \texttt{\{\ int\ sum\ =\ a\ +\ b;\ return\ sum;\ \}} → the function
  body
\end{itemize}

\subsubsection{31.2 Calling a Function}\label{calling-a-function}

Once you define a function, you can call it by name anywhere:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}  \CommentTok{// prints 8}
\end{Highlighting}
\end{Shaded}

The program jumps to the function, runs it, returns a value, then
continues.

Think of it as sending a message:

\begin{quote}
``Hey \texttt{add}, can you sum 3 and 5 for me?'' ``Sure, here's 8!''
\end{quote}

\subsubsection{31.3 Anatomy of a Function}\label{anatomy-of-a-function}

A function definition has this form:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{return\_type name}\OperatorTok{(}\NormalTok{parameters}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// body (what to do)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{void} means no return value.

\subsubsection{31.4 Functions with No
Parameters}\label{functions-with-no-parameters}

Some tasks don't need input. You can leave the parentheses empty:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ say\_hi}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hi there!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    say\_hi}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hi there!
\end{verbatim}

\subsubsection{31.5 Functions That Return
Nothing}\label{functions-that-return-nothing}

If your function just does something (like printing) and doesn't need to
give back a result, use \texttt{void}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_line}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You call it the same way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print\_line}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

\subsubsection{31.6 Return Values}\label{return-values}

If you want to send a value back, use \texttt{return}. It ends the
function and hands back the result:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ square}\OperatorTok{(}\NormalTok{x}\OperatorTok{));}  \CommentTok{// prints 16}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{31.7 Where to Define
Functions}\label{where-to-define-functions}

You can define functions:

\begin{itemize}
\tightlist
\item
  Before \texttt{main()} → so they're known early
\item
  After \texttt{main()} → but then you need a prototype (we'll cover
  soon)
\end{itemize}

For now, place your functions above \texttt{main()} for simplicity.

\subsubsection{31.8 Naming Functions}\label{naming-functions}

Choose clear names, what they \emph{do}:

\begin{itemize}
\tightlist
\item
  \texttt{add\_numbers}
\item
  \texttt{print\_menu}
\item
  \texttt{find\_max}
\end{itemize}

Avoid vague ones like \texttt{doit()} or \texttt{thing()}. Good names
make code read like a story.

\subsubsection{31.9 Multiple Functions}\label{multiple-functions}

You can have as many functions as you want. Each one should do one thing
well:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet\_user}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ sum}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet\_user}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Welcome!
Sum: 5
\end{verbatim}

\subsubsection{Tiny Code}\label{tiny-code-30}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ double\_number}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter a number: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{value}\OperatorTok{);}

    \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ double\_number}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Twice that is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-30}

Functions are your first step toward modular programming. They help
break big problems into small, reusable parts. When each function does
one clear job, your code becomes easier to read, test, and reuse.

Every great program, even huge ones, is built from lots of small, clear
functions.

\subsubsection{Try It Yourself}\label{try-it-yourself-30}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that prints ``Hello, world!''.
\item
  Write a function \texttt{square()} that returns \texttt{n\ *\ n}.
\item
  Write a function \texttt{sum()} that adds two numbers.
\item
  Write a function \texttt{average()} that takes two floats and returns
  their mean.
\item
  Write a function \texttt{greet(name)} that prints ``Hello, name!''.
\end{enumerate}

Once you start thinking in functions, programming feels natural --- each
one is a small helper, ready when you call.

\subsection{32. Function Parameters and Return
Values}\label{function-parameters-and-return-values}

Functions become really useful when they can take input and send back
output. That's what parameters and return values are for. They let your
functions act like mini machines: you give them data, they do some work,
and they hand you back a result.

Think of it like a vending machine: You put in coins (parameters) and
get a snack (return value).

\subsubsection{32.1 Parameters: Giving Input to a
Function}\label{parameters-giving-input-to-a-function}

A parameter is a variable that lives inside a function. It receives a
value when the function is called.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[])} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{name} is a parameter. When you call
\texttt{greet("Alice")}, it prints:

\begin{verbatim}
Hello, Alice!
\end{verbatim}

Each call can give a different input, and the function works with it.

\subsubsection{32.2 Multiple Parameters}\label{multiple-parameters}

You can pass as many parameters as you want, separated by commas:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{a} and \texttt{b} are parameters. You pass arguments
(actual values) when calling it: \texttt{add(3,\ 5)}.

\subsubsection{32.3 Parameter Types
Matter}\label{parameter-types-matter}

Each parameter must have a type. If you pass the wrong type, the
compiler warns you (or errors out).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C is strongly typed, so your arguments should match.

\subsubsection{32.4 The Return Value}\label{the-return-value}

A return value is what a function gives back. Use \texttt{return}
followed by a value:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{main()}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ square}\OperatorTok{(}\DecValTok{4}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Result: 16
\end{verbatim}

Once \texttt{return} runs, the function ends immediately.

\subsubsection{32.5 Functions That Return
Nothing}\label{functions-that-return-nothing-1}

If your function just performs an action (like printing), and doesn't
need to return anything, use \texttt{void}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ say\_hi}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hi!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{32.6 Functions That Take No
Parameters}\label{functions-that-take-no-parameters}

You can also define functions that don't need any input:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ get\_magic\_number}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \DecValTok{42}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{void} inside the parentheses means ``no parameters.''

\subsubsection{32.7 Input and Output
Together}\label{input-and-output-together}

Many functions both take input and return output:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ triple}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \DecValTok{3}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ triple}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Triple: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ result}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Triple: 21
\end{verbatim}

\subsubsection{32.8 Expressions with Return
Values}\label{expressions-with-return-values}

Since functions can return a value, you can use them inside expressions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ double\_it}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ double\_it}\OperatorTok{(}\DecValTok{3}\OperatorTok{)} \OperatorTok{+}\NormalTok{ double\_it}\OperatorTok{(}\DecValTok{4}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum: 14
\end{verbatim}

\subsubsection{32.9 Returning Early}\label{returning-early}

You can have multiple return statements inside one function --- useful
for checking conditions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sign}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{;}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The function ends as soon as one \texttt{return} runs.

\subsubsection{32.10 Matching the Return
Type}\label{matching-the-return-type}

If a function says it returns \texttt{int}, you must return an
\texttt{int}, or you'll get a warning.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}  \CommentTok{// correct}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If it says \texttt{void}, you can't return a value.

\subsubsection{Tiny Code}\label{tiny-code-31}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{float}\NormalTok{ area\_of\_circle}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{const} \DataTypeTok{float}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14159}\BuiltInTok{f}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ pi }\OperatorTok{*}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter radius: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%f}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{r}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Area = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ area\_of\_circle}\OperatorTok{(}\NormalTok{r}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Input → \texttt{2} Output → \texttt{Area\ =\ 12.57}

\subsubsection{Why It Matters}\label{why-it-matters-31}

Functions are communication points in your program. Parameters let you
send data in, return values send results back out.

Once you master this, you can start building libraries of reusable
helpers that handle tasks all over your programs.

\subsubsection{Try It Yourself}\label{try-it-yourself-31}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function \texttt{square(int\ n)} that returns the square.
\item
  Write \texttt{max(int\ a,\ int\ b)} that returns the larger number.
\item
  Write \texttt{sum3(int\ a,\ int\ b,\ int\ c)} that adds three numbers.
\item
  Write \texttt{convert\_to\_celsius(float\ f)} that converts Fahrenheit
  to Celsius.
\item
  Write a function \texttt{is\_even(int\ n)} that returns 1 if even, 0
  if odd.
\end{enumerate}

Every function is like a little conversation --- you give it something
to work with, and it answers back.

\subsection{33. Local and Global
Variables}\label{local-and-global-variables}

When you write a program, variables live in different places. Some exist
only inside a function, others can be seen everywhere. These two kinds
are called local and global variables.

Understanding their scope (where they can be used) helps you avoid bugs,
name clashes, and confusion.

\subsubsection{33.1 What Are Local
Variables}\label{what-are-local-variables}

A local variable is declared inside a function. It's created when the
function starts, and destroyed when the function ends.

You can only use it inside that function.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}  \CommentTok{// local variable}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello }\SpecialCharTok{\%d}\StringTok{ time!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
    \CommentTok{// printf("\%d", count); // ❌ Error: count not visible here}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{count} lives only inside \texttt{greet()}. Outside, it
doesn't exist.

\subsubsection{33.2 Why Use Local
Variables}\label{why-use-local-variables}

Local variables are private to their function. They prevent name
conflicts and keep your logic clean.

You can use the same name in different functions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ f1}\OperatorTok{()} \OperatorTok{\{} \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}\NormalTok{ printf}\OperatorTok{(}\StringTok{"x in f1 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ f2}\OperatorTok{()} \OperatorTok{\{} \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}\NormalTok{ printf}\OperatorTok{(}\StringTok{"x in f2 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each \texttt{x} is separate. This is safe and clear, each function
manages its own data.

\subsubsection{33.3 What Are Global
Variables}\label{what-are-global-variables}

A global variable is declared outside all functions. It can be used by
any function in the file (or even others with \texttt{extern}).

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}  \CommentTok{// global variable}

\DataTypeTok{void}\NormalTok{ add\_one}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    total}\OperatorTok{++;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    add\_one}\OperatorTok{();}
\NormalTok{    add\_one}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Total = 2
\end{verbatim}

Here, \texttt{total} is shared by both \texttt{add\_one()} and
\texttt{main()}.

\subsubsection{33.4 Lifetime and Storage}\label{lifetime-and-storage}

\begin{itemize}
\tightlist
\item
  Local variables: created each time the function runs, destroyed when
  it ends
\item
  Global variables: created once, stay alive until the program finishes
\end{itemize}

Globals ``remember'' their values across function calls.

\subsubsection{33.5 When Globals Help}\label{when-globals-help}

Use globals when:

\begin{itemize}
\tightlist
\item
  You need to share a single value across many functions
\item
  It's something central (like a global config or score)
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ score }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ increase}\OperatorTok{()} \OperatorTok{\{}\NormalTok{ score}\OperatorTok{++;} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ reset}\OperatorTok{()} \OperatorTok{\{}\NormalTok{ score }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But be careful, too many globals make code hard to track.

\subsubsection{33.6 When Globals Hurt}\label{when-globals-hurt}

Globals are visible everywhere, which can cause trouble:

\begin{itemize}
\tightlist
\item
  Harder to see \emph{who} changes them
\item
  Possible naming conflicts
\item
  Difficult to test functions independently
\end{itemize}

If a function can use local data, keep it local.

\subsubsection{33.7 Local vs Global:
Summary}\label{local-vs-global-summary}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1587}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3968}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Local Variable
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Global Variable
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Declared & Inside a function & Outside all functions \\
Visible in & That function only & All functions (same file) \\
Lifetime & Created when function starts & Lives for entire program \\
Storage & Stack & Static memory \\
Best for & Temporary data & Shared state \\
\end{longtable}

\subsubsection{33.8 Shadowing (Careful!)}\label{shadowing-careful}

If a local variable has the same name as a global one, the local one
hides the global inside that function.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ demo}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// shadows the global x}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// prints 5}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Inside \texttt{demo()}, the local \texttt{x} wins. Outside, the global
\texttt{x} is still 10.

\subsubsection{33.9 Static Local
Variables}\label{static-local-variables}

You can give a local variable a memory across calls using
\texttt{static}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ counter}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    count}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Count: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each call remembers the previous value. This is useful for counters,
caches, and state.

\subsubsection{Tiny Code}\label{tiny-code-32}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// global}

\DataTypeTok{void}\NormalTok{ add\_points}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    total }\OperatorTok{+=}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ show\_total}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Total points: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ bonus }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// local}
\NormalTok{    add\_points}\OperatorTok{(}\DecValTok{10}\OperatorTok{);}
\NormalTok{    add\_points}\OperatorTok{(}\NormalTok{bonus}\OperatorTok{);}
\NormalTok{    show\_total}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Total points: 15
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-32}

Variables live in scopes, like rooms in a house. Local ones stay
private; globals live in the open. When you organize them wisely, your
programs become clean, safe, and predictable.

\subsubsection{Try It Yourself}\label{try-it-yourself-32}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that has a local counter and prints it.
\item
  Add a global score variable and update it from two functions.
\item
  Try shadowing a global variable, see what happens.
\item
  Create a \texttt{static} local variable that remembers how many times
  it's called.
\item
  Compare what happens when you print locals vs globals from different
  functions.
\end{enumerate}

Good programs are like good stories, each part knows its role. Keep most
variables local, use globals sparingly, and your code will stay easy to
read and reason about.

\subsection{34. Scope and Lifetime}\label{scope-and-lifetime}

Every variable in C lives in a certain place (its \emph{scope}) and for
a certain time (its \emph{lifetime}). These two ideas go hand in hand,
they tell you where you can use a variable, and how long it exists in
memory.

Understanding scope and lifetime helps you avoid surprises like ``Why
can't I see that variable?'' or ``Why did it disappear?''

Let's explore these ideas step by step.

\subsubsection{34.1 What Is Scope}\label{what-is-scope}

Scope means \emph{where} a variable can be used. It's the part of your
program where the variable's name is visible and valid.

C has several kinds of scope:

\begin{itemize}
\tightlist
\item
  Block scope (inside \texttt{\{\ ...\ \}})
\item
  Function scope
\item
  File scope (global variables)
\item
  Prototype scope (temporary, in declarations)
\end{itemize}

Most of the time, you'll work with block scope and file scope.

\subsubsection{34.2 Block Scope (Local
Variables)}\label{block-scope-local-variables}

A block is anything inside \texttt{\{\ ...\ \}}, like the body of a
function, loop, or \texttt{if} statement. Variables declared inside are
only visible inside that block.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{x }\OperatorTok{\textgreater{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;} \CommentTok{// visible only inside if{-}block}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d}\StringTok{, y = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
    \OperatorTok{\}}

    \CommentTok{// printf("\%d", y); // ❌ Error: y not visible here}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{y} lives only inside the \texttt{if} block. Once the block
ends, \texttt{y} is gone.

\subsubsection{34.3 File Scope (Global
Variables)}\label{file-scope-global-variables}

If you declare a variable outside all functions, it's visible from
anywhere in the same file, this is called file scope.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// file scope}

\DataTypeTok{void}\NormalTok{ add\_one}\OperatorTok{()} \OperatorTok{\{}\NormalTok{ total}\OperatorTok{++;} \OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    add\_one}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ total}\OperatorTok{);} \CommentTok{// OK: total is visible}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Global variables like \texttt{total} are always in memory, they never
vanish.

\subsubsection{\texorpdfstring{34.4 Function Scope (Labels and
\texttt{goto})}{34.4 Function Scope (Labels and goto)}}\label{function-scope-labels-and-goto}

This one's rare. Labels used with \texttt{goto} are visible throughout a
function, even before they appear in the code.

You don't need to worry much, just remember labels belong to the whole
function.

\subsubsection{34.5 Lifetime: How Long a Variable
Exists}\label{lifetime-how-long-a-variable-exists}

A variable's lifetime is how long it stays alive in memory.

\begin{itemize}
\tightlist
\item
  Local variables: created when the function starts, destroyed when it
  ends
\item
  Static variables: created once, live until the program ends
\item
  Global variables: created when the program starts, destroyed when it
  ends
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ demo}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}        \CommentTok{// new x each time}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{1}\OperatorTok{;} \CommentTok{// one y forever}

\NormalTok{    x}\OperatorTok{++;}
\NormalTok{    y}\OperatorTok{++;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"x=}\SpecialCharTok{\%d}\StringTok{, y=}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you call \texttt{demo()} three times, output is:

\begin{verbatim}
x=2, y=2  
x=2, y=3  
x=2, y=4
\end{verbatim}

\texttt{x} resets each call; \texttt{y} remembers across calls.

\subsubsection{34.6 Scope Inside Loops}\label{scope-inside-loops}

Each loop is its own little block. Variables declared inside exist only
inside that loop.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}
\CommentTok{// printf("\%d", i); // ❌ Error: i not visible here}
\end{Highlighting}
\end{Shaded}

Once the loop ends, \texttt{i} is gone.

\subsubsection{34.7 Shadowing}\label{shadowing}

If you declare a new variable with the same name in an inner scope, it
hides the outer one:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// shadows global x}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// prints 5}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Be careful, shadowing can confuse you if used too much.

\subsubsection{34.8 Scope Rules in
Functions}\label{scope-rules-in-functions}

Each function is like its own world. Local variables in one function
aren't visible in another:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ f1}\OperatorTok{()} \OperatorTok{\{} \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{void}\NormalTok{ f2}\OperatorTok{()} \OperatorTok{\{} \CommentTok{/* a not visible here */} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you need data across functions, pass it as a parameter or use a
global.

\subsubsection{34.9 Best Practices}\label{best-practices-1}

\begin{itemize}
\tightlist
\item
  Keep scopes small, declare variables where you need them
\item
  Use local variables by default
\item
  Avoid reusing the same name in nested scopes
\item
  Use static only when you need persistence
\item
  Use globals sparingly, only for truly shared data
\end{itemize}

\subsubsection{Tiny Code}\label{tiny-code-33}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}         \CommentTok{// block scope}
    \DataTypeTok{static} \DataTypeTok{int}\NormalTok{ called }\OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// remembers across calls}

\NormalTok{    called}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Greet \#}\SpecialCharTok{\%d}\StringTok{ (called }\SpecialCharTok{\%d}\StringTok{ times)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ count}\OperatorTok{,}\NormalTok{ called}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
\NormalTok{    greet}\OperatorTok{();}
\NormalTok{    greet}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Greet #1 (called 1 times)  
Greet #1 (called 2 times)  
Greet #1 (called 3 times)
\end{verbatim}

\texttt{count} is recreated every time, but \texttt{called} stays alive
between calls.

\subsubsection{Why It Matters}\label{why-it-matters-33}

Scope and lifetime make your code predictable. They tell you exactly
where a variable lives and when it goes away. Once you master them,
you'll never wonder ``Why can't I see that variable?'' again.

\subsubsection{Try It Yourself}\label{try-it-yourself-33}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare a variable inside an \texttt{if}, try printing it outside.
\item
  Make a loop with a variable inside, try printing it after.
\item
  Write a function with a \texttt{static} counter.
\item
  Shadow a global with a local variable, see which one wins.
\item
  Combine a local, static, and global variable in one program.
\end{enumerate}

Every variable has its own \emph{life story} --- where it's born, where
it lives, and when it disappears. Once you know its journey, your
programs will feel much more under control.

\subsection{\texorpdfstring{35. Header Declarations (\texttt{.h}
files)}{35. Header Declarations (.h files)}}\label{header-declarations-.h-files}

As your programs grow, you'll start splitting them into multiple files.
Maybe one file for math functions, another for printing, another for
your main logic. To make them work together, you'll need header files.

Header files (\texttt{.h} files) are like blueprints, they tell the
compiler \emph{what exists}, so you can use it before it's actually
defined.

Think of them as introductions between parts of your code:

\begin{quote}
``Hey, there's a function called \texttt{add()}, you'll meet it later!''
\end{quote}

\subsubsection{35.1 Why We Need Headers}\label{why-we-need-headers}

In small programs, you can put everything in one file. But as you build
bigger projects, that gets messy. You'll want to split your code into
modules:

\begin{itemize}
\tightlist
\item
  \texttt{math.c} → math functions
\item
  \texttt{main.c} → main program
\item
  \texttt{math.h} → declarations (the header)
\end{itemize}

Headers help C know about things before they're used. They act as
contracts, describing the functions and types each file provides.

\subsubsection{35.2 What Goes in a Header
File}\label{what-goes-in-a-header-file}

A header file usually contains:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Function declarations (prototypes)
\item
  Constant definitions (\texttt{\#define}, \texttt{const})
\item
  Type definitions (\texttt{typedef}, \texttt{struct})
\item
  Includes for dependencies
\end{enumerate}

No actual function \emph{bodies}, just declarations.

Example: \texttt{math.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_H}
\PreprocessorTok{\#define MATH\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\subsubsection{35.3 Including a Header}\label{including-a-header}

To use a header, include it with \texttt{\#include\ "file.h"}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The compiler now knows \texttt{add()} exists, even if it's defined
elsewhere.

\subsubsection{35.4 Where to Put Function
Definitions}\label{where-to-put-function-definitions}

The definitions (the actual code) live in \texttt{.c} files.

Example: \texttt{math.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Your program might look like this:

\begin{verbatim}
project/
├── main.c
├── math.c
└── math.h
\end{verbatim}

Compile together:

\begin{verbatim}
gcc main.c math.c -o program
\end{verbatim}

\subsubsection{35.5 Header Guards}\label{header-guards}

Headers can be included by many files, but you only want them once.
Otherwise, you'll get ``redefinition'' errors.

So, every header should have header guards:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef FILE\_NAME\_H}
\PreprocessorTok{\#define FILE\_NAME\_H}

\CommentTok{// your declarations}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

They tell the compiler:

\begin{quote}
``If this file is already included, skip it.''
\end{quote}

\subsubsection{35.6 Example Project}\label{example-project}

Let's build a small program step by step.

math.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_H}
\PreprocessorTok{\#define MATH\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

math.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"2 + 3 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"2 * 3 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ multiply}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{verbatim}
gcc main.c math.c -o mathprog
\end{verbatim}

Run:

\begin{verbatim}
2 + 3 = 5  
2 * 3 = 6
\end{verbatim}

\subsubsection{\texorpdfstring{35.7 The Difference Between \texttt{.h}
and
\texttt{.c}}{35.7 The Difference Between .h and .c}}\label{the-difference-between-.h-and-.c}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
File Type & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{.h} (header) & Declarations, tells what exists \\
\texttt{.c} (source) & Definitions, actual code \\
\end{longtable}

Your \texttt{.h} says \emph{``this is what you can call''}, your
\texttt{.c} says \emph{``this is how it works''}.

\subsubsection{35.8 Including System
Headers}\label{including-system-headers}

Use angle brackets for system headers (like \texttt{stdio.h}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

Use quotes for your own headers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}
\end{Highlighting}
\end{Shaded}

\subsubsection{35.9 When to Make a Header}\label{when-to-make-a-header}

Create a header when:

\begin{itemize}
\tightlist
\item
  You split code into multiple files
\item
  You want to share functions or types
\item
  You're building a library
\end{itemize}

If your program fits in one file, you don't need one, yet.

\subsubsection{Tiny Code}\label{tiny-code-34}

Try this:

greet.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef GREET\_H}
\PreprocessorTok{\#define GREET\_H}

\DataTypeTok{void}\NormalTok{ say\_hello}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

greet.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"greet.h"}

\DataTypeTok{void}\NormalTok{ say\_hello}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, C world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"greet.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    say\_hello}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{verbatim}
gcc main.c greet.c -o greet
\end{verbatim}

Run:

\begin{verbatim}
Hello, C world!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-34}

Headers make your code organized and reusable. They let you build
libraries, modules, and projects with many files. Without them, large
programs would quickly turn into spaghetti!

\subsubsection{Try It Yourself}\label{try-it-yourself-34}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a header and source for simple math functions.
\item
  Add header guards and test including it twice.
\item
  Split a program into \texttt{main.c} and \texttt{helper.c} +
  \texttt{helper.h}.
\item
  Try including your header from two different \texttt{.c} files.
\item
  Add a \texttt{typedef\ struct} to a header, use it in \texttt{main.c}.
\end{enumerate}

Headers are your program's road signs --- they tell every file what's
available and how to find it.

\subsection{36. Pass by Value Explained}\label{pass-by-value-explained}

When you call a function in C, your data doesn't \emph{travel} there ---
instead, a copy is made and sent in. This idea is called pass by value.

It's one of the most important things to understand in C, because it
affects how changes inside functions behave. Let's break it down step by
step.

\subsubsection{36.1 What Does ``Pass by Value''
Mean}\label{what-does-pass-by-value-mean}

When you call a function with arguments, C copies the values into its
parameters. That means the function gets its own independent copies.

Any change made to those copies does not affect the original variables.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ double\_it}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Inside: x = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    double\_it}\OperatorTok{(}\NormalTok{n}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Outside: n = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Inside: x = 10  
Outside: n = 5
\end{verbatim}

See what happened? \texttt{x} changed inside the function, but
\texttt{n} stayed the same. That's because C made a copy of \texttt{n}
and passed it in.

\subsubsection{36.2 Memory View}\label{memory-view}

Imagine variables as boxes in memory. When you pass one into a function,
C makes a new box with the same value.

The two boxes are separate, changing one doesn't touch the other.

\begin{verbatim}
main:   n = 5
double_it: x = 5 → changed to 10
\end{verbatim}

After \texttt{double\_it} finishes, its \texttt{x} is destroyed.
\texttt{n} is still 5 in \texttt{main()}.

\subsubsection{36.3 Why This Matters}\label{why-this-matters}

If you expect your function to modify a variable (like updating a
score), pass by value won't work, the changes won't be seen outside.

To actually change the original, you need to pass its address, that's
called pass by reference, and you'll learn that soon when we study
pointers.

\subsubsection{36.4 Multiple Parameters}\label{multiple-parameters-1}

Each parameter is copied separately:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Inside: a = }\SpecialCharTok{\%d}\StringTok{, b = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{2}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{    add}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Outside: x = }\SpecialCharTok{\%d}\StringTok{, y = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Inside: a = 5, b = 3  
Outside: x = 2, y = 3
\end{verbatim}

Again, nothing changed in \texttt{main}.

\subsubsection{36.5 Safe and Predictable}\label{safe-and-predictable}

Pass by value is safe, functions can't accidentally overwrite your data.
They work only with copies, so each call is isolated.

This makes debugging easier, you always know where changes happen.

\subsubsection{36.6 Returning New Values}\label{returning-new-values}

If you want a function to give back a new value, you can return it
instead of modifying the input.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ double\_it}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    n }\OperatorTok{=}\NormalTok{ double\_it}\OperatorTok{(}\NormalTok{n}\OperatorTok{);} \CommentTok{// save returned value}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"n = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
n = 10
\end{verbatim}

You're not modifying \texttt{n} inside the function --- you're taking
the result and storing it outside.

\subsubsection{36.7 Pass by Value with Arrays (Sneak
Peek)}\label{pass-by-value-with-arrays-sneak-peek}

Arrays behave a little differently, when you pass an array, it
\emph{acts like} passing a pointer (more on that later).

But for basic types (int, float, char), C always passes by value.

\subsubsection{36.8 Common Mistake}\label{common-mistake}

Beginners often expect this to work:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ add\_one}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    n}\OperatorTok{++;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    add\_one}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// ❌ still 5, not 6}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{x} doesn't change because you only modified the copy. To fix it,
you'll learn how to pass by reference using pointers soon.

\subsubsection{Tiny Code}\label{tiny-code-35}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ reset}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    n }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Inside reset: n = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    reset}\OperatorTok{(}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Outside reset: value = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Inside reset: n = 0  
Outside reset: value = 10
\end{verbatim}

Your variable outside is safe and untouched.

\subsubsection{Why It Matters}\label{why-it-matters-35}

Pass by value is how C keeps your functions independent and predictable.
You can trust that variables won't be changed accidentally. When you
\emph{do} want to modify something, you'll use pointers to pass its
address (coming soon!).

\subsubsection{Try It Yourself}\label{try-it-yourself-35}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that tries to change an integer, check if it sticks.
\item
  Return a new value instead of modifying the input.
\item
  Try passing two variables and print both inside and outside.
\item
  Predict the output before running, then check!
\item
  Rewrite a pass-by-value function to return a new result.
\end{enumerate}

In C, functions get their own copies --- they can \emph{read} your data,
but not \emph{touch} it, unless you explicitly give them the key (a
pointer).

\subsection{37. Recursion and Base
Cases}\label{recursion-and-base-cases}

You've already learned that loops let you repeat actions. But C has
another elegant way to repeat: recursion.

Recursion means a function calls itself. It's like saying, ``I'll solve
this big problem by solving a smaller one of the same kind.''

Recursion sounds fancy, but once you get it, it's a beautiful tool for
breaking problems into smaller steps.

\subsubsection{37.1 What Is Recursion}\label{what-is-recursion}

A recursive function is one that calls itself, usually with simpler
input.

It must always have two parts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Base case, when to stop
\item
  Recursive case, when to call itself again
\end{enumerate}

Without a base case, it would run forever (and crash your program).

\subsubsection{37.2 A Simple Example}\label{a-simple-example-7}

Let's print numbers from 1 to 5 using recursion:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ count\_up}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return}\OperatorTok{;} \CommentTok{// base case}

\NormalTok{    count\_up}\OperatorTok{(}\NormalTok{n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}    \CommentTok{// recursive call}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    count\_up}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1 2 3 4 5
\end{verbatim}

Here's what happens:

\begin{itemize}
\tightlist
\item
  \texttt{count\_up(5)} calls \texttt{count\_up(4)}
\item
  \texttt{count\_up(4)} calls \texttt{count\_up(3)} \ldots{} and so on,
  until \texttt{n\ ==\ 0} Then each call prints its number on the way
  back up.
\end{itemize}

\subsubsection{37.3 The Base Case}\label{the-base-case}

The base case is what stops recursion. It's like saying, ``If we're
done, don't call again.''

Without it, you'll get an infinite recursion → your program will crash
with a ``stack overflow.''

Example of missing base case (❌):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ recurse}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hi}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    recurse}\OperatorTok{();} \CommentTok{// never stops}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

So always include a clear base case!

\subsubsection{37.4 Factorial Example}\label{factorial-example}

Let's compute \texttt{n!} (factorial):

\begin{itemize}
\tightlist
\item
  \texttt{0!\ =\ 1}
\item
  \texttt{n!\ =\ n\ *\ (n-1)!}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ factorial}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}       \CommentTok{// base case}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ factorial}\OperatorTok{(}\NormalTok{n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);} \CommentTok{// recursive case}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{main()}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ factorial}\OperatorTok{(}\DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
120
\end{verbatim}

Flow:

\begin{verbatim}
factorial(5)
= 5 * factorial(4)
= 5 * 4 * factorial(3)
= 5 * 4 * 3 * factorial(2)
= 5 * 4 * 3 * 2 * factorial(1)
= 5 * 4 * 3 * 2 * 1
= 120
\end{verbatim}

Each call \emph{waits} for the next one's answer.

\subsubsection{37.5 Recursion vs Loops}\label{recursion-vs-loops}

Recursion and loops both repeat, but they think differently:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2917}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3889}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Loop
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Recursion
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Uses & \texttt{for}, \texttt{while} & Function calls itself \\
State & Controlled by variables & Controlled by function calls \\
Needs base condition? & Yes & Yes (base case) \\
Easier for & Counting, iteration & Trees, divide-and-conquer \\
\end{longtable}

Use recursion when a problem can be broken down into smaller versions of
itself.

\subsubsection{37.6 Another Example: Sum of
Numbers}\label{another-example-sum-of-numbers}

We can write a function to sum numbers from 1 to \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sum\_to\_n}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}            \CommentTok{// base case}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{+}\NormalTok{ sum\_to\_n}\OperatorTok{(}\NormalTok{n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}      \CommentTok{// recursive case}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum\_to\_n}\OperatorTok{(}\DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum = 15
\end{verbatim}

\subsubsection{37.7 Be Careful with Large
Input}\label{be-careful-with-large-input}

Each recursive call uses memory on the call stack. Too many calls can
cause stack overflow. For very large inputs, prefer loops.

\subsubsection{37.8 Combining Base and Recursive
Steps}\label{combining-base-and-recursive-steps}

The pattern always looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{type function}\OperatorTok{(}\NormalTok{args}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{base\_condition}\OperatorTok{)}
        \ControlFlowTok{return}\NormalTok{ base\_value}\OperatorTok{;}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ smaller\_problem}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Once you spot this pattern, recursion feels natural.

\subsubsection{37.9 Real-World Uses}\label{real-world-uses}

Recursion is powerful for:

\begin{itemize}
\tightlist
\item
  Searching through files or trees
\item
  Traversing linked lists
\item
  Solving divide-and-conquer problems (like quicksort)
\item
  Generating combinations, permutations, etc.
\end{itemize}

Even though you might not use it every day, understanding it helps you
think like a programmer.

\subsubsection{Tiny Code}\label{tiny-code-36}

Try this recursive countdown:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ countdown}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{n }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Go!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\NormalTok{    countdown}\OperatorTok{(}\NormalTok{n }\OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    countdown}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
5...
4...
3...
2...
1...
Go!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-36}

Recursion is a new way to think about problems --- breaking big tasks
into smaller ones until they're easy to solve. Once you understand base
cases, recursion becomes a simple and elegant tool.

\subsubsection{Try It Yourself}\label{try-it-yourself-36}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a recursive function to count down from 10 to 1.
\item
  Write a function to print all numbers from 1 to \texttt{n}.
\item
  Compute \texttt{factorial(n)} recursively.
\item
  Write \texttt{sum\_to\_n(n)} that adds all numbers from 1 to
  \texttt{n}.
\item
  Write a recursive function \texttt{power(a,\ b)} to compute
  \texttt{a\^{}b}.
\end{enumerate}

Recursion is like a mirror, each call reflects the same task, but a
little smaller, until finally it ends.

\subsection{38. Function Prototypes and
Order}\label{function-prototypes-and-order}

In C, your program is read top to bottom. So when you call a function,
the compiler must already know it exists --- what it's called, what it
returns, and what parameters it takes.

But sometimes, you want to call a function that's defined later in the
file. That's where function prototypes come in.

Think of a prototype like a forward declaration --- a promise to the
compiler:

\begin{quote}
``This function exists, you'll see its full code soon.''
\end{quote}

\subsubsection{38.1 The Problem Without a
Prototype}\label{the-problem-without-a-prototype}

Let's look at what happens when you don't declare a function before
calling it:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();} \CommentTok{// ❌ Compiler doesn\textquotesingle{}t know what greet is}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The compiler reads from top to bottom. When it reaches \texttt{greet();}
in \texttt{main}, it hasn't seen \texttt{greet} yet. So it doesn't know
what kind of function it is, that's an error.

\subsubsection{38.2 The Fix: Add a
Prototype}\label{the-fix-add-a-prototype}

You can fix this by telling C ahead of time what \texttt{greet()} looks
like.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{// Function prototype}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();} \CommentTok{// ✅ Compiler knows greet exists}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Function definition}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now C knows:

\begin{itemize}
\tightlist
\item
  The function's name (\texttt{greet})
\item
  Its return type (\texttt{void})
\item
  Its parameter list (\texttt{void}, meaning none)
\end{itemize}

\subsubsection{38.3 What Is a Function
Prototype}\label{what-is-a-function-prototype}

A function prototype is just the function header followed by a
semicolon:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{return\_type name}\OperatorTok{(}\NormalTok{parameter\_list}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ print\_hello}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ x}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

No body, just the declaration.

\subsubsection{38.4 Why Prototypes Matter}\label{why-prototypes-matter}

Prototypes let you:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Call functions before they're defined
\item
  Catch type errors early
\item
  Organize code cleanly
\item
  Split code into multiple files
\end{enumerate}

Without them, the compiler can't check if your arguments or return types
match.

\subsubsection{38.5 Example with
Parameters}\label{example-with-parameters}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);} \CommentTok{// prototype}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Sum = 5
\end{verbatim}

Because the prototype comes first, the compiler knows \texttt{add()}
takes two \texttt{int}s and returns an \texttt{int}.

\subsubsection{38.6 Matching Prototype and
Definition}\label{matching-prototype-and-definition}

The prototype and definition must match exactly:

\begin{itemize}
\tightlist
\item
  Same return type
\item
  Same parameter types and order
\end{itemize}

If they don't, the compiler may throw a warning or error.

Example (❌ wrong prototype):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}    \CommentTok{// says it returns int}
\DataTypeTok{void}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{\}} \CommentTok{// actually returns void, mismatch}
\end{Highlighting}
\end{Shaded}

Always copy the function header exactly and just add a semicolon.

\subsubsection{38.7 Where to Put
Prototypes}\label{where-to-put-prototypes}

Usually, prototypes go:

\begin{itemize}
\tightlist
\item
  At the top of your file, before \texttt{main()}, or
\item
  In a header file (\texttt{.h}), if the function lives in another
  \texttt{.c} file
\end{itemize}

This way, every file that uses the function can \texttt{\#include} the
header to learn about it.

Example:

math.h

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

math.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{38.8 Prototypes Help Catch
Mistakes}\label{prototypes-help-catch-mistakes}

If you call a function with the wrong arguments, the compiler can catch
it early, thanks to the prototype.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    add}\OperatorTok{(}\DecValTok{2}\OperatorTok{);} \CommentTok{// ❌ compiler error: missing argument}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Without a prototype, C wouldn't warn you --- and you'd get undefined
behavior at runtime. So prototypes make your programs safer.

\subsubsection{38.9 When You Don't Need
Them}\label{when-you-dont-need-them}

If your function is defined before it's used, you don't need a
prototype:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hi!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();} \CommentTok{// OK: defined earlier}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But adding prototypes is still a good habit --- especially for bigger
projects.

\subsubsection{Tiny Code}\label{tiny-code-37}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{// Prototype}
\DataTypeTok{float}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ b}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ x }\OperatorTok{=} \FloatTok{2.5}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ x }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{,}\NormalTok{ multiply}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Definition}
\DataTypeTok{float}\NormalTok{ multiply}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
2.50 x 4.00 = 10.00
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-37}

Function prototypes are promises you make to the compiler. They let you
build programs top-to-bottom without worrying about order. You can
organize code neatly and catch errors early --- a habit every good C
programmer develops.

\subsubsection{Try It Yourself}\label{try-it-yourself-37}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program where \texttt{main()} calls a function defined
  \emph{below}. Add a prototype at the top.
\item
  Try removing the prototype, see the error.
\item
  Create a prototype that takes two ints and returns a float.
\item
  Put a prototype in a header file and include it in your \texttt{.c}
  file.
\item
  Try mismatching the prototype and definition, watch what happens.
\end{enumerate}

With prototypes, your compiler becomes a helpful teammate --- it checks
your work and keeps your program organized.

\subsection{39. Inline Functions}\label{inline-functions}

You've seen how functions make code cleaner and reusable. But sometimes,
calling a function can be a bit slower than running the code directly
--- especially when the function is tiny and called many times.

That's where inline functions come in. They're a way of telling the
compiler,

\begin{quote}
``Instead of jumping to this function, just copy its code right here.''
\end{quote}

It's like giving the compiler a shortcut: no extra call, no return, just
straight execution.

\subsubsection{39.1 What Is an Inline
Function}\label{what-is-an-inline-function}

Normally, when you call a function:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The program jumps to that function's code.
\item
  Runs it.
\item
  Returns back to where it left off.
\end{enumerate}

For large functions, that's fine. But for tiny ones, the overhead can be
noticeable.

An inline function suggests to the compiler:

\begin{quote}
``Skip the jump, insert the body right at the call site.''
\end{quote}

\subsubsection{39.2 Syntax}\label{syntax}

Use the \texttt{inline} keyword before the return type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now, when you call \texttt{square(5)}, the compiler \emph{may} replace
it with \texttt{5\ *\ 5} directly.

\subsubsection{39.3 Example}\label{example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ add\_one}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add\_one}\OperatorTok{(}\NormalTok{x}\OperatorTok{));} \CommentTok{// may become printf("\%d\textbackslash{}n", x + 1);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
6
\end{verbatim}

The behavior is the same --- the difference is how the compiler executes
it.

\subsubsection{39.4 Inline Is a Hint}\label{inline-is-a-hint}

Important: \texttt{inline} is just a suggestion. The compiler can ignore
it if it decides inlining isn't worthwhile.

You can think of it like saying,

\begin{quote}
``Hey compiler, this function is small, maybe inline it?''
\end{quote}

You'll still get the same result, whether it inlines or not.

\subsubsection{39.5 When to Use Inline}\label{when-to-use-inline}

Good candidates for \texttt{inline} are:

\begin{itemize}
\tightlist
\item
  Very short functions (1--3 lines)
\item
  Functions called many times
\item
  Functions that don't do I/O or complex logic
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ min}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textless{}}\NormalTok{ b}\OperatorTok{)} \OperatorTok{?}\NormalTok{ a }\OperatorTok{:}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Avoid inlining large or complicated functions --- that can make your
compiled program bigger and even slower.

\subsubsection{39.6 Inline vs Macros}\label{inline-vs-macros}

Before \texttt{inline}, programmers used macros for small helpers:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)*(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

But macros don't respect types or syntax rules --- they're just text
replacements.

Inline functions are safer:

\begin{itemize}
\tightlist
\item
  Type-checked by the compiler
\item
  Easier to debug
\item
  No weird surprises with parentheses
\end{itemize}

So, prefer inline functions over macros whenever possible.

\subsubsection{39.7 Inline with Header
Files}\label{inline-with-header-files}

Inline functions are often defined in header files. That way, each file
that includes the header can see the full definition.

Example: \texttt{math\_utils.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Then include it in your \texttt{.c} files:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\end{Highlighting}
\end{Shaded}

Each file gets its own inline copy.

\subsubsection{\texorpdfstring{39.8 Inline with
\texttt{static}}{39.8 Inline with static}}\label{inline-with-static}

If you mark a function as both \texttt{static} and \texttt{inline}, it
becomes private to the file --- each \texttt{.c} file has its own local
version.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Useful for small helpers that shouldn't be visible outside.

\subsubsection{39.9 When Not to Use
Inline}\label{when-not-to-use-inline}

Avoid using \texttt{inline} on:

\begin{itemize}
\tightlist
\item
  Large functions
\item
  Recursive functions (can't inline themselves)
\item
  Functions that you rarely call
\end{itemize}

Inlining huge functions can increase code size and reduce performance.

\subsubsection{Tiny Code}\label{tiny-code-38}

Try this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ triple}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*} \DecValTok{3}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Triple of }\SpecialCharTok{\%d}\StringTok{ is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ triple}\OperatorTok{(}\NormalTok{i}\OperatorTok{));}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Triple of 1 is 3  
Triple of 2 is 6  
Triple of 3 is 9  
Triple of 4 is 12  
Triple of 5 is 15
\end{verbatim}

Simple, fast, and clean.

\subsubsection{Why It Matters}\label{why-it-matters-38}

Inline functions combine the clarity of normal functions with the speed
of direct code. They help you write clean helpers without worrying about
overhead.

Remember: \texttt{inline} is not magic, just a helpful suggestion for
small, frequently used functions.

\subsubsection{Try It Yourself}\label{try-it-yourself-38}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write an \texttt{inline} function \texttt{square()} and call it in a
  loop.
\item
  Compare performance between \texttt{SQUARE(x)} macro and
  \texttt{inline\ square(x)}.
\item
  Try inlining a large function, see if your compiler warns you.
\item
  Put an inline helper in a header file and include it.
\item
  Add \texttt{static} to make it file-local.
\end{enumerate}

\texttt{inline} is like saying to the compiler, ``Hey, this one's tiny,
just drop it in right here!'' A small trick for big clarity.

\subsection{40. Organizing Code with
Functions}\label{organizing-code-with-functions}

By now, you've learned how to write, call, and declare functions, and
even how to use prototypes and inline helpers. Now it's time to see the
big picture: how functions help you organize your program.

Functions aren't just about saving keystrokes, they're about structuring
your code like a well-arranged toolbox, where every tool has a clear
name and purpose.

Let's learn how to think in functions, building your programs piece by
piece.

\subsubsection{40.1 Why Organize with
Functions}\label{why-organize-with-functions}

Imagine writing everything in \texttt{main()}: you'd have 100 lines for
setup, 50 lines for logic, 30 for output, total chaos.

Functions let you break that chaos into logical sections:

\begin{itemize}
\tightlist
\item
  Each part does one thing well
\item
  You can test parts separately
\item
  You can reuse them later
\end{itemize}

It's the difference between a messy desk and a neat one with labeled
drawers.

\subsubsection{40.2 Think ``One Task = One
Function''}\label{think-one-task-one-function}

Every function should do one clear job. If you can describe it with a
short verb phrase --- like \texttt{print\_menu}, \texttt{get\_input},
\texttt{compute\_total}, you're on the right track.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_menu}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"1. Add}\SpecialCharTok{\textbackslash{}n}\StringTok{2. Subtract}\SpecialCharTok{\textbackslash{}n}\StringTok{3. Quit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This makes your code self-documenting, easy to read and understand.

\subsubsection{40.3 Breaking a Program into
Parts}\label{breaking-a-program-into-parts}

Let's say we're writing a simple calculator. Instead of stuffing
everything into \texttt{main()}, we can organize it like this:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ show\_menu}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ choice}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}

\NormalTok{    show\_menu}\OperatorTok{();}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Choose: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{choice}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter two numbers: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{,} \OperatorTok{\&}\NormalTok{y}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{choice }\OperatorTok{==} \DecValTok{1}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
    \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{choice }\OperatorTok{==} \DecValTok{2}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Result: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ subtract}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ show\_menu}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"1. Add}\SpecialCharTok{\textbackslash{}n}\StringTok{2. Subtract}\SpecialCharTok{\textbackslash{}n}\StringTok{3. Quit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each function has one tiny, clear job. If something breaks, you know
exactly where to look.

\subsubsection{40.4 Avoid ``God Functions''}\label{avoid-god-functions}

A God function does \emph{everything}. It's long, hard to read, and easy
to break.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ program}\OperatorTok{()} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{a}\OperatorTok{,} \OperatorTok{\&}\NormalTok{b}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ c }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ c}\OperatorTok{);}
    \CommentTok{// many more lines...}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ get\_numbers}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{*}\NormalTok{b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{void}\NormalTok{ show\_result}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ sum}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Small, simple pieces fit together like building blocks.

\subsubsection{40.5 Group by Purpose}\label{group-by-purpose}

Keep related functions together:

\begin{itemize}
\tightlist
\item
  All math helpers in one place
\item
  All printing functions together
\item
  All input functions together
\end{itemize}

Later, you'll learn to split these into separate \texttt{.c} and
\texttt{.h} files --- but even within one file, grouping helps clarity.

Example structure:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Math}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(...);}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(...);}

\CommentTok{// Input}
\DataTypeTok{void}\NormalTok{ get\_numbers}\OperatorTok{(...);}

\CommentTok{// Output}
\DataTypeTok{void}\NormalTok{ show\_result}\OperatorTok{(...);}
\end{Highlighting}
\end{Shaded}

\subsubsection{40.6 Reuse Functions}\label{reuse-functions}

Once you've written a clean, general function, you can use it
everywhere. No need to rewrite the same logic.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ max}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}}\NormalTok{ b}\OperatorTok{)} \OperatorTok{?}\NormalTok{ a }\OperatorTok{:}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now you can call \texttt{max()} in any program that needs a quick
comparison.

\subsubsection{40.7 Top-Down Design}\label{top-down-design}

Start by sketching the big picture, the main steps, then fill in
details.

Example outline:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet\_user}\OperatorTok{();}
    \DataTypeTok{int}\NormalTok{ choice }\OperatorTok{=}\NormalTok{ menu}\OperatorTok{();}
\NormalTok{    handle\_choice}\OperatorTok{(}\NormalTok{choice}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Later, write those functions one by one. This keeps \texttt{main()}
short, more like a storyboard than a script.

\subsubsection{40.8 Testing Each Function}\label{testing-each-function}

Because functions are independent, you can test them easily.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Add test: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{));} \CommentTok{// should print 5}
\end{Highlighting}
\end{Shaded}

You can build confidence piece by piece instead of debugging a huge file
all at once.

\subsubsection{40.9 Refactoring into
Functions}\label{refactoring-into-functions}

If you notice the same code appearing twice, extract it into a new
function.

Before:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter number: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

After:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ get\_number}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter number: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now you can just call \texttt{get\_number()} whenever you need it.

\subsubsection{Tiny Code}\label{tiny-code-39}

Try this mini-program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ get\_input}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter a number: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{);}
    \ControlFlowTok{return}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ show\_double}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Twice that is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n }\OperatorTok{*} \DecValTok{2}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
    \DataTypeTok{int}\NormalTok{ num }\OperatorTok{=}\NormalTok{ get\_input}\OperatorTok{();}
\NormalTok{    show\_double}\OperatorTok{(}\NormalTok{num}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Clean, simple, and easy to follow --- each step is its own function.

\subsubsection{Why It Matters}\label{why-it-matters-39}

Functions turn messy code into organized chapters. They make your
programs easier to read, debug, and expand. When each part has one
purpose, you can grow your code without fear.

\subsubsection{Try It Yourself}\label{try-it-yourself-39}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take one of your earlier programs and break it into functions.
\item
  Keep \texttt{main()} short, just 5-10 lines describing the flow.
\item
  Give each function a clear, action-based name.
\item
  Group related functions together.
\item
  Test each function on its own before combining them.
\end{enumerate}

Functions are the building blocks of every C program. Use them like
paragraphs in an essay --- each one should say one clear thing.

\section{Chapter 5. Arrays and
Strings}\label{chapter-5.-arrays-and-strings-1}

\subsection{41. Declaring Arrays}\label{declaring-arrays}

So far, you've learned how to store single values, one \texttt{int}, one
\texttt{float}, one \texttt{char}. But what if you want to store many
values of the same type, like a list of numbers, or a word made of
letters?

That's where arrays come in. An array is like a row of boxes, each
holding one value of the same type. You can access each box by its
position, called an index.

\subsubsection{41.1 What Is an Array}\label{what-is-an-array}

An array is a collection of elements of the same type, stored side by
side in memory.

For example, an array of 5 integers looks like this:

\begin{verbatim}
+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  4 |
+----+----+----+----+----+
\end{verbatim}

Each slot has an index, starting from 0. So the first element is at
index \texttt{0}, not \texttt{1}.

\subsubsection{41.2 Declaring an Array}\label{declaring-an-array}

To declare an array, you write the type, the name, and the size in
square brackets:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

This creates space for 5 integers, all initialized with garbage values
(whatever happens to be in memory).

You can also declare arrays of other types:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ prices}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}
\DataTypeTok{char}\NormalTok{ letters}\OperatorTok{[}\DecValTok{26}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

\subsubsection{41.3 Initializing Arrays}\label{initializing-arrays}

You can give an array initial values at the same time:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

If you leave out the size, C will count for you:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

You can also partially fill an array, C fills the rest with zeros:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ scores}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{\};} \CommentTok{// \{10, 20, 0, 0, 0\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{41.4 Accessing Elements}\label{accessing-elements}

You can access (read or write) each element using its index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}        \CommentTok{// set first element}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// read first element}
\end{Highlighting}
\end{Shaded}

Indexes go from \texttt{0} to \texttt{size\ -\ 1}. If your array has 5
elements, valid indexes are \texttt{0,\ 1,\ 2,\ 3,\ 4}.

\subsubsection{41.5 Arrays and Loops}\label{arrays-and-loops}

Arrays and loops go hand in hand. You can use a \texttt{for} loop to set
or print all elements:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now \texttt{numbers} contains \texttt{\{0,\ 2,\ 4,\ 6,\ 8\}}.

\subsubsection{41.6 Memory Layout}\label{memory-layout}

All elements in an array are stored contiguously, one after another.
This makes arrays fast and efficient.

You can imagine them as one long shelf of identical boxes.

\subsubsection{41.7 Fixed Size}\label{fixed-size}

In C, array sizes are fixed, once you choose a size, you can't change it
later. If you need a flexible list, you'll use pointers and dynamic
memory (coming soon in Chapter 6).

\subsubsection{Tiny Code}\label{tiny-code-40}

Here's a simple example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ scores}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{90}\OperatorTok{,} \DecValTok{85}\OperatorTok{,} \DecValTok{88}\OperatorTok{,} \DecValTok{92}\OperatorTok{,} \DecValTok{95}\OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Scores:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ scores}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Scores:
90 85 88 92 95
\end{verbatim}

You just created a list of scores, neat and tidy in memory.

\subsubsection{Why It Matters}\label{why-it-matters-40}

Arrays are the foundation of data handling in C. They let you store and
work with groups of values efficiently, whether it's numbers,
characters, or more complex data later. Once you master arrays, you'll
unlock strings, matrices, and even dynamic memory.

\subsubsection{Try It Yourself}\label{try-it-yourself-40}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare an array of 5 integers and fill it with your favorite numbers.
\item
  Write a loop to print all elements.
\item
  Try changing one element and print again.
\item
  Create an array of \texttt{char} with the first 5 letters of the
  alphabet.
\item
  Leave out the size, let C count for you.
\end{enumerate}

Arrays are your first step from single values to collections --- they
let your programs remember not just one thing, but many, all in order.

\subsection{42. Indexing and Bounds}\label{indexing-and-bounds}

Arrays give you many boxes, but you need to know exactly which box
you're working with. That's what indexing is for, it lets you access
each element in an array by its position.

In C, array indexes always start at 0, not 1. That means the first
element is \texttt{array{[}0{]}}, and the last element is
\texttt{array{[}size\ -\ 1{]}}.

\subsubsection{42.1 Index Basics}\label{index-basics}

To access an element, write the array name followed by the index in
square brackets:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// prints 10}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);} \CommentTok{// prints 20}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);} \CommentTok{// prints 30}
\end{Highlighting}
\end{Shaded}

Each index gives you direct access to one slot in memory.

You can also assign values the same way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{99}\OperatorTok{;} \CommentTok{// change second element}
\end{Highlighting}
\end{Shaded}

Now \texttt{numbers} becomes \texttt{\{10,\ 99,\ 30\}}.

\subsubsection{42.2 Zero-Based Indexing}\label{zero-based-indexing}

Since counting starts at 0, an array with \texttt{n} elements has
indexes from 0 to n-1. If you create an array of 5 elements, the valid
indexes are \texttt{0,\ 1,\ 2,\ 3,\ 4}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

Valid indexes: \texttt{data{[}0{]}} \ldots{} \texttt{data{[}4{]}}

Trying to access \texttt{data{[}5{]}} is a mistake, that index doesn't
exist.

\subsubsection{42.3 Out-of-Bounds Access}\label{out-of-bounds-access}

C will not stop you from going outside an array's range. It won't warn
you, it won't crash immediately, but it will lead to undefined behavior.

Example of a bug:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ values}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{values}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DecValTok{100}\OperatorTok{;} \CommentTok{// ❌ out of bounds}
\end{Highlighting}
\end{Shaded}

This writes to memory that doesn't belong to the array. Sometimes
nothing seems wrong, sometimes the program crashes, it's unpredictable.
Always make sure your indexes are within range.

\subsubsection{42.4 Using Loops Safely}\label{using-loops-safely}

When looping through arrays, use the correct condition to stay in
bounds:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{10}\OperatorTok{\};}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The loop runs from \texttt{i\ =\ 0} to \texttt{i\ =\ 4}. If you write
\texttt{i\ \textless{}=\ 5}, you'll go one step too far.

\subsubsection{42.5 Calculating the Last
Index}\label{calculating-the-last-index}

If you know the size, the last index is always \texttt{size\ -\ 1}.

You can also compute the number of elements using \texttt{sizeof}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\DataTypeTok{int}\NormalTok{ length }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{)} \OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

Now \texttt{length} holds \texttt{5}, so you can loop safely:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \CommentTok{// safe access}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{42.6 Reading and Writing
Elements}\label{reading-and-writing-elements}

You can use indexes to both read and write values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ scores}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
\NormalTok{scores}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{70}\OperatorTok{;}
\NormalTok{scores}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{80}\OperatorTok{;}
\NormalTok{scores}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DecValTok{90}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"First score: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ scores}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

Each element acts like its own variable.

\subsubsection{42.7 Indexes as Variables}\label{indexes-as-variables}

You don't have to use numbers directly; variables work too:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);} \CommentTok{// prints third element}
\end{Highlighting}
\end{Shaded}

This is handy in loops and calculations.

\subsubsection{42.8 Accessing in Reverse}\label{accessing-in-reverse}

You can loop backward from the last element to the first:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textgreater{}=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-})} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This prints elements in reverse order.

\subsubsection{Tiny Code}\label{tiny-code-41}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{,} \DecValTok{15}\OperatorTok{,} \DecValTok{20}\OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Forward: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ data}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Reverse: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textgreater{}=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-})} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ data}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Forward: 5 10 15 20
Reverse: 20 15 10 5
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-41}

Indexing is how you reach into arrays to use or change their contents.
Learning to stay within bounds keeps your programs safe and bug-free.
Every loop over an array depends on correct indexing.

\subsubsection{Try It Yourself}\label{try-it-yourself-41}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an array of 5 numbers and print each with its index.
\item
  Change the middle element and print the array again.
\item
  Write a loop that prints the array in reverse.
\item
  Try using a variable index to access an element.
\item
  Experiment with an out-of-bounds index and observe what happens (but
  don't rely on it).
\end{enumerate}

Arrays are precise, know your indexes, and they'll always work exactly
as expected.

\subsection{43. Multidimensional Arrays}\label{multidimensional-arrays}

So far, arrays have been a simple line of boxes, a single row. But what
if you want a grid of numbers, like a table, or a matrix with rows and
columns?

That's when you use multidimensional arrays. They let you store data in
rows and columns, or even more dimensions if you need them.

\subsubsection{43.1 What Is a Multidimensional
Array}\label{what-is-a-multidimensional-array}

A multidimensional array is just an array of arrays. Each row is its own
array, and all rows are grouped together.

For example, a 2D array of 3 rows and 4 columns looks like this:

\begin{verbatim}
+----------------------+
|  row 0  | [0][0] [0][1] [0][2] [0][3]
|  row 1  | [1][0] [1][1] [1][2] [1][3]
|  row 2  | [2][0] [2][1] [2][2] [2][3]
+----------------------+
\end{verbatim}

You can imagine it like a spreadsheet, each element has a row and a
column index.

\subsubsection{43.2 Declaring a 2D Array}\label{declaring-a-2d-array}

To declare a 2D array, write both sizes in square brackets:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ matrix}\OperatorTok{[}\DecValTok{3}\OperatorTok{][}\DecValTok{4}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

This creates 3 rows and 4 columns, for a total of
\texttt{3\ *\ 4\ =\ 12} integers.

You can also declare higher dimensions, but 2D is the most common.

\subsubsection{43.3 Initializing a 2D
Array}\label{initializing-a-2d-array}

You can fill a 2D array at once using nested braces:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ matrix}\OperatorTok{[}\DecValTok{2}\OperatorTok{][}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This creates:

\begin{verbatim}
1 2 3  
4 5 6
\end{verbatim}

You can also leave out the first size if you give all rows:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ grid}\OperatorTok{[][}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{30}\OperatorTok{,} \DecValTok{40}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{50}\OperatorTok{,} \DecValTok{60}\OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

C will count the rows for you.

\subsubsection{43.4 Accessing Elements}\label{accessing-elements-1}

Each element needs two indexes, one for the row, one for the column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ matrix}\OperatorTok{[}\DecValTok{1}\OperatorTok{][}\DecValTok{2}\OperatorTok{]);} \CommentTok{// row 1, column 2}
\end{Highlighting}
\end{Shaded}

In the earlier example, \texttt{matrix{[}1{]}{[}2{]}} is \texttt{6}.

You can assign the same way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix}\OperatorTok{[}\DecValTok{0}\OperatorTok{][}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{99}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now the top-left element is \texttt{99}.

\subsubsection{43.5 Using Nested Loops}\label{using-nested-loops}

You can loop through a 2D array with nested loops, one for rows, one for
columns:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ matrix}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This prints all elements row by row.

\subsubsection{43.6 Changing Elements}\label{changing-elements}

You can update individual elements just like in 1D arrays:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{matrix}\OperatorTok{[}\DecValTok{0}\OperatorTok{][}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{matrix}\OperatorTok{[}\DecValTok{1}\OperatorTok{][}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{99}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

After these changes, the array becomes:

\begin{verbatim}
1 42 3  
99 5 6
\end{verbatim}

\subsubsection{43.7 Arrays with More
Dimensions}\label{arrays-with-more-dimensions}

You can make 3D arrays too, arrays of arrays of arrays:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{[}\DecValTok{2}\OperatorTok{][}\DecValTok{3}\OperatorTok{][}\DecValTok{4}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

But start simple. Most problems can be solved with 1D or 2D arrays.

\subsubsection{43.8 Memory Layout}\label{memory-layout-1}

All elements are stored contiguously in memory, just like 1D arrays. C
stores them row by row, the first row, then the second, and so on.

This is called row-major order.

\subsubsection{43.9 Real Examples}\label{real-examples}

You might use 2D arrays for:

\begin{itemize}
\tightlist
\item
  A tic-tac-toe board (\texttt{3x3})
\item
  A chess board (\texttt{8x8})
\item
  A matrix in math or graphics
\item
  Tables of scores or coordinates
\end{itemize}

Whenever you need rows and columns, 2D arrays are the natural fit.

\subsubsection{Tiny Code}\label{tiny-code-42}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ table}\OperatorTok{[}\DecValTok{2}\OperatorTok{][}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\},}
        \OperatorTok{\{}\DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{\}}
    \OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Table:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ table}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
        \OperatorTok{\}}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Table:
1 2 3
4 5 6
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-42}

Multidimensional arrays let you model structured data, grids, tables,
maps, matrices, with ease. They're a key building block for games,
graphics, and numerical computing.

\subsubsection{Try It Yourself}\label{try-it-yourself-42}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{3x3} matrix of numbers and print it.
\item
  Use nested loops to fill a table with \texttt{i\ +\ j}.
\item
  Change one element and print again.
\item
  Make a 2D array of grades (rows = students, columns = tests).
\item
  Practice accessing elements at different positions.
\end{enumerate}

Once you understand rows and columns, arrays start to feel like little
worlds of data you can navigate freely.

\subsection{44. Iterating over Arrays}\label{iterating-over-arrays}

Arrays are powerful because they hold many values, but to use those
values, you need a way to go through them one by one. That process is
called iteration.

When you \emph{iterate} over an array, you visit each element in order,
often using a loop. It's like checking each box in a row and reading
what's inside.

\subsubsection{44.1 Why Iterate}\label{why-iterate}

If you want to:

\begin{itemize}
\tightlist
\item
  Print all elements
\item
  Compute a total or average
\item
  Modify each value
\item
  Search for something
\end{itemize}

You'll need to loop over the array.

Doing this manually for every element would be slow and error-prone:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

Instead, you use a loop to handle it automatically.

\subsubsection{44.2 Using a for Loop}\label{using-a-for-loop}

The \texttt{for} loop is perfect for arrays because it gives you a
counter variable (an index):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{,} \DecValTok{40}\OperatorTok{,} \DecValTok{50}\OperatorTok{\};}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This starts from index \texttt{0}, goes up to \texttt{4}, and prints
every element.

Each time through the loop:

\begin{itemize}
\tightlist
\item
  \texttt{i} moves to the next index
\item
  \texttt{numbers{[}i{]}} accesses that element
\end{itemize}

\subsubsection{44.3 Counting
Automatically}\label{counting-automatically}

You can use \texttt{sizeof} to compute the array length, so your loop
always fits:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ length }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{)} \OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now if you change the array size later, the loop still works correctly.

\subsubsection{44.4 Using while Loops}\label{using-while-loops}

You can also use a \texttt{while} loop, though \texttt{for} is more
common:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    i}\OperatorTok{++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Same result, just a different style.

\subsubsection{44.5 Iterating in Reverse}\label{iterating-in-reverse}

You don't always need to go forward. You can loop backward too:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textgreater{}=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i}\OperatorTok{{-}{-})} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This prints the array in reverse order.

\subsubsection{44.6 Doing Work Inside the
Loop}\label{doing-work-inside-the-loop}

You can do more than just print, any logic works inside:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    sum }\OperatorTok{+=}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\OperatorTok{\}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can also update each element:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{*=} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now every value is doubled.

\subsubsection{44.7 Nested Loops for 2D
Arrays}\label{nested-loops-for-2d-arrays}

If you're working with a 2D array, use one loop for rows and one for
columns:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ matrix}\OperatorTok{[}\DecValTok{2}\OperatorTok{][}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{\}}
\OperatorTok{\};}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ matrix}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each \texttt{i} goes through a row, and each \texttt{j} walks across the
columns.

\subsubsection{44.8 Be Careful with
Bounds}\label{be-careful-with-bounds}

Never let your loop index go outside the array's range. If your array
has 5 elements, stop at \texttt{i\ \textless{}\ 5}. Going to
\texttt{i\ \textless{}=\ 5} causes undefined behavior, it might crash or
print garbage.

\subsubsection{44.9 Useful Patterns}\label{useful-patterns}

Here are some common array patterns:

Sum of elements:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ sum }\OperatorTok{+=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

Find maximum:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ max }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{];}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{\textgreater{}}\NormalTok{ max}\OperatorTok{)}\NormalTok{ max }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

Count positives:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)}\NormalTok{ count}\OperatorTok{++;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-43}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
    \DataTypeTok{int}\NormalTok{ sum }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Data: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ data}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{        sum }\OperatorTok{+=}\NormalTok{ data}\OperatorTok{[}\NormalTok{i}\OperatorTok{];}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Sum = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ sum}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Data: 3 7 2 8 5
Sum = 25
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-43}

Iteration is how you work with collections. Instead of handling elements
one by one, you write one clean loop that handles them all. It's
efficient, readable, and a key part of almost every C program.

\subsubsection{Try It Yourself}\label{try-it-yourself-43}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an array of 10 integers and print each one.
\item
  Write a loop to calculate the sum and average.
\item
  Loop backward and print in reverse order.
\item
  Double every element inside the loop.
\item
  Write a loop to find the largest number in the array.
\end{enumerate}

Once you can iterate confidently, you can explore, transform, and
analyze any data stored in arrays.

\subsection{45. Strings as Character
Arrays}\label{strings-as-character-arrays}

In C, a string isn't a special type, it's just an array of characters.
Each letter is stored in one slot, side by side, ending with a special
symbol that marks the end of the string.

That's why learning strings is really about understanding character
arrays.

\subsubsection{45.1 What Is a String}\label{what-is-a-string}

A string is a sequence of characters terminated by a null character,
written as
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. This
special character tells C,

\begin{quote}
``Stop reading, this is the end of the string.''
\end{quote}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}o\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

You can picture it like this:

\begin{verbatim}
+---+---+---+---+---+----+
| H | e | l | l | o | \0 |
+---+---+---+---+---+----+
\end{verbatim}

Every string in C must end with
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

\subsubsection{45.2 Using String Literals}\label{using-string-literals}

Typing all the characters by hand can be tedious, so C lets you create
strings more easily with string literals:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

C automatically adds the
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} at the
end for you.

That means these two lines are the same:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ a}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{\};}
\DataTypeTok{char}\NormalTok{ b}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hi"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Both store \texttt{"Hi"} in memory.

\subsubsection{45.3 Declaring Strings}\label{declaring-strings}

You can declare a string with a fixed size:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

This creates space for up to 9 visible characters, plus one
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} at the
end.

Always leave room for the terminator --- if your string has 9 letters,
the array must be at least size 10.

\subsubsection{45.4 Accessing Characters}\label{accessing-characters}

Strings are just arrays, so you can use indexes:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Cat"}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// prints C}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);} \CommentTok{// prints a}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);} \CommentTok{// prints t}
\end{Highlighting}
\end{Shaded}

You can also change individual characters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}B\textquotesingle{}}\OperatorTok{;} \CommentTok{// now "Bat"}
\end{Highlighting}
\end{Shaded}

\subsubsection{45.5 Printing Strings}\label{printing-strings}

Use \texttt{\%s} with \texttt{printf} to print an entire string:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ greeting}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello, world!"}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ greeting}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

C will print characters one by one until it hits
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

\subsubsection{45.6 Reading Strings}\label{reading-strings}

Later, you'll learn how to read strings using \texttt{scanf} and safer
alternatives. For now, you can assign string literals directly or use
them in output.

\subsubsection{45.7 Strings vs Characters}\label{strings-vs-characters}

A character is a single letter, like
\texttt{\textquotesingle{}A\textquotesingle{}}. A string is an array of
letters, like \texttt{"A"}.

Notice the difference:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}A\textquotesingle{}} uses single quotes, a
  \texttt{char}
\item
  \texttt{"A"} uses double quotes, a string (2 chars:
  \texttt{\textquotesingle{}A\textquotesingle{}} and
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}})
\end{itemize}

\subsubsection{45.8 Strings in Memory}\label{strings-in-memory}

C stores all string characters in contiguous memory, just like arrays.
The \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} marks
where the string ends, not necessarily the end of the array. That's why
you should never forget it, otherwise C will keep reading random memory!

\subsubsection{45.9 Changing a String}\label{changing-a-string}

You can modify elements of a string you've declared as an array:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Tom"}\OperatorTok{;}
\NormalTok{name}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}i\textquotesingle{}}\OperatorTok{;} \CommentTok{// now "Tim"}
\end{Highlighting}
\end{Shaded}

But if you declare it as a pointer to a literal:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{name }\OperatorTok{=} \StringTok{"Tom"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can't change it safely, string literals are read-only. Always use
\texttt{char\ name{[}{]}\ =\ "..."} if you plan to modify it.

\subsubsection{Tiny Code}\label{tiny-code-44}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Word: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"First letter: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}

\NormalTok{    word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}Y\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New word: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Word: Hello  
First letter: H  
New word: Yello
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-44}

Strings are how you handle text in C, names, messages, words, anything
made of letters. They're built on top of character arrays, so
understanding them helps you work with text safely and clearly.

\subsubsection{Try It Yourself}\label{try-it-yourself-44}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare a string \texttt{"Hello"} and print it.
\item
  Print each character using a loop.
\item
  Change one character and print again.
\item
  Create an array of size 6 and fill it with \texttt{"World"}.
\item
  Try forgetting
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}, see
  what happens (it may print garbage!).
\end{enumerate}

Strings in C are simple but powerful, once you see them as arrays with a
clear end, they make perfect sense.

\subsection{46. String Literals and Null
Terminators}\label{string-literals-and-null-terminators}

Every string in C ends with a special invisible character:
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}, called
the null terminator. This single symbol tells C where the string stops.
Without it, your program would keep reading into memory, printing
garbage or crashing.

String literals, words in double quotes like \texttt{"Hello"},
automatically include this terminator. So when you write \texttt{"Hi"},
C really stores three characters:
\texttt{\textquotesingle{}H\textquotesingle{}},
\texttt{\textquotesingle{}i\textquotesingle{}}, and
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

\subsubsection{46.1 What Are String
Literals}\label{what-are-string-literals}

A string literal is text inside double quotes, like
\texttt{"C\ programming"}. It's stored in memory as an array of
characters ending with
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ greeting}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hi"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Memory looks like:

\begin{verbatim}
+---+---+----+
| H | i | \0 |
+---+---+----+
\end{verbatim}

C automatically adds
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} at the
end, you don't need to type it.

\subsubsection{46.2 Declaring with String
Literals}\label{declaring-with-string-literals}

The easiest way to make a string is with a literal:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This array has 6 elements: 5 letters + 1 terminator. If you print it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You'll see \texttt{Hello},
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} isn't
shown because it's not a visible character.

\subsubsection{46.3 Null Terminator: Why It
Matters}\label{null-terminator-why-it-matters}

C does not store the string's length anywhere. Instead, it depends on
the terminator to know where to stop reading.

So \texttt{printf("\%s",\ word);} works like this:

\begin{itemize}
\tightlist
\item
  Start at the first character.
\item
  Keep printing until you find
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.
\item
  Stop right there.
\end{itemize}

If \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} is
missing, it just keeps going into memory, printing whatever it finds,
total chaos!

\subsubsection{46.4 Adding Your Own
Terminator}\label{adding-your-own-terminator}

If you build a string manually, don't forget to add
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ msg}\OperatorTok{[}\DecValTok{6}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}o\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Without it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ bad}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}o\textquotesingle{}}\OperatorTok{\};} \CommentTok{// ❌ no terminator}
\end{Highlighting}
\end{Shaded}

\texttt{printf("\%s",\ bad);} may print random characters after
``Hello''.

\subsubsection{46.5 Changing Strings
Safely}\label{changing-strings-safely}

You can modify a string declared as an array:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Tom"}\OperatorTok{;}
\NormalTok{name}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}J\textquotesingle{}}\OperatorTok{;} \CommentTok{// now "Jom"}
\end{Highlighting}
\end{Shaded}

But you cannot modify a string literal directly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{name }\OperatorTok{=} \StringTok{"Tom"}\OperatorTok{;} \CommentTok{// stored in read{-}only memory}
\NormalTok{name}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}J\textquotesingle{}}\OperatorTok{;}      \CommentTok{// ❌ undefined behavior}
\end{Highlighting}
\end{Shaded}

If you want to change it, always declare with square brackets.

\subsubsection{46.6 Measuring Length}\label{measuring-length}

To measure a string's visible length (not counting
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}), use the
function \texttt{strlen()} from
\texttt{\textless{}string.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ text}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hi"}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Length = }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{text}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Length = 2
\end{verbatim}

\texttt{strlen} counts characters until it finds
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

\subsubsection{46.7 Adding the Terminator
Manually}\label{adding-the-terminator-manually}

Sometimes you might build a string in pieces. Remember to add
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} at the
end yourself:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[}\DecValTok{6}\OperatorTok{];}
\NormalTok{word}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}H\textquotesingle{}}\OperatorTok{;}
\NormalTok{word}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}e\textquotesingle{}}\OperatorTok{;}
\NormalTok{word}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{;}
\NormalTok{word}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}l\textquotesingle{}}\OperatorTok{;}
\NormalTok{word}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}o\textquotesingle{}}\OperatorTok{;}
\NormalTok{word}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now it's a valid string.

\subsubsection{46.8 Strings Are Arrays with a
Rule}\label{strings-are-arrays-with-a-rule}

Every string is an array of \texttt{char} that must end with
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. That's
the only rule, but it's a very important one. Follow it, and your
strings will behave perfectly.

\subsubsection{Tiny Code}\label{tiny-code-45}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ greeting}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"String: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ greeting}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Length: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{greeting}\OperatorTok{));}

\NormalTok{    greeting}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \CharTok{\textquotesingle{}Y\textquotesingle{}}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New String: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ greeting}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
String: Hello  
Length: 5  
New String: Yello
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-45}

The null terminator is the heartbeat of every string in C. It marks the
end, keeps your program safe, and makes functions like \texttt{printf}
and \texttt{strlen} work correctly.

Once you understand it, you'll never be surprised by stray characters
again.

\subsubsection{Try It Yourself}\label{try-it-yourself-45}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare a string \texttt{"World"} and print it.
\item
  Count its length using \texttt{strlen()}.
\item
  Change one character and print again.
\item
  Try removing the terminator (leave it out) and see what happens.
\item
  Build a string manually, adding
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}
  yourself.
\end{enumerate}

Strings in C are friendly and simple, as long as you never forget to
close them with
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

\subsection{47. Common String Functions (strlen, strcpy,
strcmp)}\label{common-string-functions-strlen-strcpy-strcmp}

C gives you a collection of handy tools for working with strings. They
live in the \texttt{\textless{}string.h\textgreater{}} library, and they
help you do things like measure, copy, and compare strings, safely and
quickly.

Let's explore the three most common ones:

\begin{itemize}
\tightlist
\item
  \texttt{strlen} -- find the length
\item
  \texttt{strcpy} -- copy one string into another
\item
  \texttt{strcmp} -- compare two strings
\end{itemize}

Once you know these, you'll be able to handle most everyday string tasks
with confidence.

\subsubsection{\texorpdfstring{47.1 Measuring Length with
\texttt{strlen}}{47.1 Measuring Length with strlen}}\label{measuring-length-with-strlen}

\texttt{strlen()} tells you how many visible characters are in a string,
not counting the null terminator.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{size\_t}\NormalTok{ strlen}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{str}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hello"}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Length: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{word}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Length: 5
\end{verbatim}

\texttt{strlen} counts letters until it reaches
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. If your
string is \texttt{"Hi"}, it returns \texttt{2}. If it's
\texttt{"Hello"}, it returns \texttt{5}.

\subsubsection{\texorpdfstring{47.2 Copying Strings with
\texttt{strcpy}}{47.2 Copying Strings with strcpy}}\label{copying-strings-with-strcpy}

\texttt{strcpy()} copies the content of one string into another.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{char} \OperatorTok{*}\NormalTok{strcpy}\OperatorTok{(}\DataTypeTok{char} \OperatorTok{*}\NormalTok{dest}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{src}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You need to make sure the destination has enough space for the source
string plus
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ src}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Apple"}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ dest}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{dest}\OperatorTok{,}\NormalTok{ src}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Copied string: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ dest}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Copied string: Apple
\end{verbatim}

Be careful: if the destination array is too small, \texttt{strcpy} will
overflow, so always size it large enough!

A safer alternative is \texttt{strncpy(dest,\ src,\ size)}, which limits
the number of characters copied.

\subsubsection{\texorpdfstring{47.3 Comparing Strings with
\texttt{strcmp}}{47.3 Comparing Strings with strcmp}}\label{comparing-strings-with-strcmp}

You can't compare strings with \texttt{==}, that would only check if
they're in the same memory location, not if they have the same content.
Use \texttt{strcmp()} instead.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ strcmp}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s1}\OperatorTok{,} \DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{s2}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

It returns:

\begin{itemize}
\tightlist
\item
  \texttt{0} if the strings are equal
\item
  A negative number if \texttt{s1} comes before \texttt{s2}
\item
  A positive number if \texttt{s1} comes after \texttt{s2}
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ a}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Cat"}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ b}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Dog"}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Same!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Different!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Different!
\end{verbatim}

If you compare \texttt{"Apple"} and \texttt{"Banana"},
\texttt{strcmp("Apple",\ "Banana")} is negative, because
\texttt{"Apple"} would come first alphabetically.

\subsubsection{47.4 Summary of Key String
Functions}\label{summary-of-key-string-functions}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2059}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4118}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3824}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{strlen(s)} & Length of string (no
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}) &
\texttt{strlen("Hi")} → 2 \\
\texttt{strcpy(d,\ s)} & Copy string \texttt{s} into \texttt{d} &
\texttt{strcpy(dest,\ "Hello")} \\
\texttt{strcmp(a,\ b)} & Compare two strings &
\texttt{strcmp("Cat",\ "Cat")} → 0 \\
\end{longtable}

Remember: all these functions rely on
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} to know
where the string ends. If a string isn't terminated, the results are
unpredictable.

\subsubsection{47.5 Practical Example}\label{practical-example}

Let's combine them:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ first}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ second}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{first}\OperatorTok{,} \StringTok{"Hello"}\OperatorTok{);}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{second}\OperatorTok{,} \StringTok{"World"}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"First: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%zu}\StringTok{ letters)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ first}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{first}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Second: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%zu}\StringTok{ letters)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ second}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{second}\OperatorTok{));}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{first}\OperatorTok{,}\NormalTok{ second}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Strings are the same!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Strings are different!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
First: Hello (5 letters)  
Second: World (5 letters)  
Strings are different!
\end{verbatim}

\subsubsection{47.6 Common Mistakes}\label{common-mistakes-1}

\begin{itemize}
\tightlist
\item
  Forgetting to include \texttt{\textless{}string.h\textgreater{}}
\item
  Copying into an array that's too small
\item
  Comparing strings with \texttt{==} instead of \texttt{strcmp()}
\item
  Using \texttt{strlen} on uninitialized data
\end{itemize}

If you always initialize and terminate your strings properly, these
functions will behave perfectly.

\subsubsection{Tiny Code}\label{tiny-code-46}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ src}\OperatorTok{[]} \OperatorTok{=} \StringTok{"C language"}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ dest}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{dest}\OperatorTok{,}\NormalTok{ src}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Copied: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ dest}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Length: }\SpecialCharTok{\%zu\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{dest}\OperatorTok{));}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{src}\OperatorTok{,}\NormalTok{ dest}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"They match!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Copied: C language  
Length: 10  
They match!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-46}

String functions save you from reinventing the wheel. Instead of writing
loops to count, copy, or compare, you can use these tested, reliable
tools. They're part of the core skillset for every C programmer.

\subsubsection{Try It Yourself}\label{try-it-yourself-46}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use \texttt{strlen} to find the length of \texttt{"Programming"}.
\item
  Copy \texttt{"Hello"} into another string using \texttt{strcpy}.
\item
  Compare \texttt{"Dog"} and \texttt{"Cat"} with \texttt{strcmp}.
\item
  Try copying a long string into a small array and see what happens.
\item
  Rewrite your own version of \texttt{strlen()} using a loop for
  practice.
\end{enumerate}

Once you master these, strings will start to feel easy and familiar,
just arrays with some friendly helper tools.

\subsection{48. Inputting Strings}\label{inputting-strings}

You've learned how to declare, print, and modify strings, now it's time
to learn how to read them from the user. Getting text input is a big
part of interactive programs, and in C, you have a few simple ways to do
it.

Let's go step by step and learn how to safely take string input from the
keyboard.

\subsubsection{\texorpdfstring{48.1 Using
\texttt{scanf}}{48.1 Using scanf}}\label{using-scanf}

The simplest way to read a string is with \texttt{scanf()} and the
\texttt{\%s} format specifier:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your name: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you type \texttt{Alice}, it prints:

\begin{verbatim}
Hello, Alice!
\end{verbatim}

When you use \texttt{\%s}, \texttt{scanf} reads characters until the
first space. So if you type \texttt{Alice\ Smith}, it only reads
\texttt{"Alice"}.

\subsubsection{48.2 Always Leave Room}\label{always-leave-room}

C doesn't know how big your array is. You must make sure your buffer
(array) is big enough to hold all characters plus the
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}
terminator.

If your array is \texttt{char\ name{[}20{]};}, you can safely read up to
19 visible characters.

If you want to be extra careful, you can tell \texttt{scanf} to limit
the input length:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%19s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This tells C: ``read at most 19 characters.''

\subsubsection{\texorpdfstring{48.3 Reading Full Lines with
\texttt{fgets}}{48.3 Reading Full Lines with fgets}}\label{reading-full-lines-with-fgets}

If you want to read spaces, use \texttt{fgets()} instead. It reads an
entire line (including spaces) up to a maximum number of characters or
until Enter is pressed.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ sentence}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter a sentence: "}\OperatorTok{);}
\NormalTok{    fgets}\OperatorTok{(}\NormalTok{sentence}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{sentence}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You wrote: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ sentence}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you type:

\begin{verbatim}
Hello world from C!
\end{verbatim}

It prints:

\begin{verbatim}
You wrote: Hello world from C!
\end{verbatim}

\texttt{fgets} includes the newline \texttt{\textbackslash{}n} at the
end if there's space. You can remove it if needed (we'll learn how
later).

\subsubsection{\texorpdfstring{48.4 Comparing \texttt{scanf} and
\texttt{fgets}}{48.4 Comparing scanf and fgets}}\label{comparing-scanf-and-fgets}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1940}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1940}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2537}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3582}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Reads Spaces?
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Needs Size Limit?
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stops At
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{scanf("\%s")} & ❌ No & ✅ Recommended & First space \\
\texttt{fgets()} & ✅ Yes & ✅ Required & Newline or end of buffer \\
\end{longtable}

If you're reading names without spaces, \texttt{scanf} is fine. If
you're reading sentences or phrases, use \texttt{fgets}.

\subsubsection{48.5 Avoiding Buffer
Overflows}\label{avoiding-buffer-overflows}

A buffer overflow happens when you read more characters than your array
can hold. Always provide a limit with \texttt{scanf} or use
\texttt{fgets}, which is safer.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);} \CommentTok{// ❌ dangerous}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%4s}\StringTok{"}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);} \CommentTok{// ✅ room for 4 chars + \textquotesingle{}\textbackslash{}0\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{48.6 Example: Asking for Two
Words}\label{example-asking-for-two-words}

You can read multiple strings by calling \texttt{scanf} multiple times:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ first}\OperatorTok{[}\DecValTok{20}\OperatorTok{],}\NormalTok{ last}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter first and last name: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ first}\OperatorTok{,}\NormalTok{ last}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{ }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ first}\OperatorTok{,}\NormalTok{ last}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you input:

\begin{verbatim}
John Smith
\end{verbatim}

You get:

\begin{verbatim}
Hello, John Smith!
\end{verbatim}

\subsubsection{\texorpdfstring{48.7 Mixing \texttt{scanf} and
\texttt{fgets}}{48.7 Mixing scanf and fgets}}\label{mixing-scanf-and-fgets}

If you mix \texttt{scanf} (which leaves a newline in the buffer) with
\texttt{fgets}, you might need to clear the input buffer first. To keep
things simple, try sticking with one method per program until you're
comfortable.

\subsubsection{48.8 Strings and Safety}\label{strings-and-safety}

Reading strings is one of the most common sources of errors in C. Follow
these safety rules:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Always declare arrays large enough.
\item
  Always limit input size.
\item
  Use \texttt{fgets()} when reading full lines.
\item
  Remember strings must end with
  \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.
\end{enumerate}

Follow those, and your input will always behave nicely.

\subsubsection{Tiny Code}\label{tiny-code-47}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{30}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ quote}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"What is your name? "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%29s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{! What\textquotesingle{}s your favorite quote?}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\NormalTok{    getchar}\OperatorTok{();} \CommentTok{// clear newline left by scanf}
\NormalTok{    fgets}\OperatorTok{(}\NormalTok{quote}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{quote}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Nice quote, }\SpecialCharTok{\%s}\StringTok{!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You said: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ quote}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Example run:

\begin{verbatim}
What is your name? Alex
Hello, Alex! What's your favorite quote?
Practice makes perfect.
Nice quote, Alex!
You said: Practice makes perfect.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-47}

Inputting strings lets your programs talk to people. It's how you turn
your program from something fixed into something interactive and
personal. With \texttt{scanf} and \texttt{fgets}, you can build forms,
quizzes, chatbots, and more.

\subsubsection{Try It Yourself}\label{try-it-yourself-47}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask the user for their first name and greet them.
\item
  Use \texttt{fgets()} to read a full sentence and print it.
\item
  Try \texttt{scanf("\%10s",\ name)} to see how length limits work.
\item
  Combine \texttt{scanf} and \texttt{fgets} in one program, handle the
  newline correctly.
\item
  Write a program that reads two words and prints them reversed.
\end{enumerate}

Once you master reading strings, you'll be ready to create friendly,
interactive programs that respond to the user's words.

\subsection{49. Arrays vs.~Pointers (A Gentle
Intro)}\label{arrays-vs.-pointers-a-gentle-intro}

Arrays and pointers look a lot alike in C, and that can be confusing at
first. They both deal with memory, they both use indexes, and sometimes
you can even use them interchangeably.

But they're not the same thing. An array is a block of memory, while a
pointer is a variable that holds an address.

Let's walk through the connection step by step.

\subsubsection{49.1 Arrays Are Blocks of
Memory}\label{arrays-are-blocks-of-memory}

When you write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

C creates 3 slots in memory, side by side:

\begin{verbatim}
+----+----+----+
| 10 | 20 | 30 |
+----+----+----+
  ^    ^    ^
  |    |    |
 [0] [1]  [2]
\end{verbatim}

Each element lives at a specific address. The array's name
(\texttt{numbers}) points to the address of the first element.

So, \texttt{numbers} is like saying ``the memory starting at
numbers{[}0{]}''.

\subsubsection{49.2 The Array Name as a
Pointer}\label{the-array-name-as-a-pointer}

You can use the array name as a pointer to its first element:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{);}      \CommentTok{// address of first element}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}  \CommentTok{// same address}
\end{Highlighting}
\end{Shaded}

They both print the same location in memory.

That's why this works:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{*}\NormalTok{numbers }\OperatorTok{=} \DecValTok{42}\OperatorTok{;} \CommentTok{// change first element}
\end{Highlighting}
\end{Shaded}

Here, \texttt{*numbers} means ``the value at the address of
numbers{[}0{]}''.

Now \texttt{numbers{[}0{]}} becomes \texttt{42}.

\subsubsection{49.3 Using Pointer
Arithmetic}\label{using-pointer-arithmetic}

C lets you move through memory with pointer arithmetic. When you add
\texttt{1} to a pointer, it moves to the next element, not just the next
byte.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}  \CommentTok{// pointer to first element}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}     \CommentTok{// 10}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{ptr}\OperatorTok{+}\DecValTok{1}\OperatorTok{));} \CommentTok{// 20}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{ptr}\OperatorTok{+}\DecValTok{2}\OperatorTok{));} \CommentTok{// 30}
\end{Highlighting}
\end{Shaded}

Notice the pattern:

\begin{itemize}
\tightlist
\item
  \texttt{*(ptr\ +\ 0)} is the first element
\item
  \texttt{*(ptr\ +\ 1)} is the second
\item
  \texttt{*(ptr\ +\ 2)} is the third
\end{itemize}

That's exactly what \texttt{numbers{[}0{]}}, \texttt{numbers{[}1{]}},
\texttt{numbers{[}2{]}} do.

So in C, these are equivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{==} \OperatorTok{*(}\NormalTok{numbers }\OperatorTok{+}\NormalTok{ i}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

\subsubsection{49.4 But Arrays Are Not
Pointers}\label{but-arrays-are-not-pointers}

Even though \texttt{numbers} can act like a pointer, it's not truly one.
A pointer is a variable that stores an address, you can reassign it. An
array name is fixed, it's a label for a memory block.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}

\NormalTok{ptr }\OperatorTok{=}\NormalTok{ ptr }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}    \CommentTok{// OK}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ numbers }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// ❌ Error: array name is not assignable}
\end{Highlighting}
\end{Shaded}

Arrays and pointers are \emph{related}, but not the same kind of
variable.

\subsubsection{49.5 Arrays Decay to
Pointers}\label{arrays-decay-to-pointers}

When you pass an array to a function, it decays into a pointer --- only
the address of the first element is passed.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_first}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[])} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{arr} is really a pointer, not a full array copy. That's
why functions can see changes to arrays, they both point to the same
data.

\subsubsection{49.6 Visual Summary}\label{visual-summary}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1538}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5231}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3231}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Concept
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Array & Fixed block of memory & \texttt{int\ a{[}5{]};} \\
Pointer & Variable holding an address & \texttt{int\ *p;} \\
Array name & Acts like pointer to first element &
\texttt{a\ ==\ \&a{[}0{]}} \\
Difference & Arrays can't be reassigned & \texttt{p\ =\ a;} ✅
\texttt{a\ =\ p;} ❌ \\
\end{longtable}

\subsubsection{49.7 Arrays and Strings}\label{arrays-and-strings}

This connection explains why strings (arrays of \texttt{char}) work with
pointers too:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[]} \OperatorTok{=} \StringTok{"Hi"}\OperatorTok{;}
\DataTypeTok{char} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ word}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}       \CommentTok{// \textquotesingle{}H\textquotesingle{}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{ptr }\OperatorTok{+} \DecValTok{1}\OperatorTok{));} \CommentTok{// \textquotesingle{}i\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

You'll use this idea often when working with string functions, most take
\texttt{char\ *}.

\subsubsection{Tiny Code}\label{tiny-code-48}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;} \CommentTok{// points to first element}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"First: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Second: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Third: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{2}\OperatorTok{));}

    \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{=} \DecValTok{99}\OperatorTok{;} \CommentTok{// change second element}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Updated second: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
First: 10  
Second: 20  
Third: 30  
Updated second: 99
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-48}

Understanding how arrays and pointers connect is one of the big leaps in
C. It helps you write functions that handle arrays, work with strings,
and explore memory safely.

Once you see arrays as ``blocks'' and pointers as ``addresses,'' C
starts to feel clear and logical.

\subsubsection{Try It Yourself}\label{try-it-yourself-48}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an array and print the address of each element with
  \texttt{\&array{[}i{]}}.
\item
  Use a pointer to walk through the array with \texttt{*(ptr\ +\ i)}.
\item
  Try changing an element through the pointer.
\item
  Pass the array to a function and print its elements.
\item
  Experiment with strings, print each character using pointer
  arithmetic.
\end{enumerate}

Arrays are like houses; pointers are like maps. Learn how they line up,
and you'll never get lost in memory again.

\subsection{50. Common Array Pitfalls}\label{common-array-pitfalls}

Arrays are simple once you understand them, but they also come with a
few easy-to-miss traps. Because C gives you a lot of freedom, it also
expects you to be careful. If you know the most common mistakes, you can
avoid hours of debugging and strange behavior.

Let's walk through the biggest pitfalls one by one.

\subsubsection{50.1 Off-by-One Errors}\label{off-by-one-errors}

The most common mistake is going one step too far. Remember, array
indexes start at \texttt{0} and end at \texttt{size\ -\ 1}.

If your array has 5 elements, the valid indexes are
\texttt{0,\ 1,\ 2,\ 3,\ 4}. Accessing \texttt{array{[}5{]}} is out of
bounds.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{\};}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{} \CommentTok{// ❌ runs one too far}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This tries to print \texttt{nums{[}5{]}}, which doesn't exist, and C
won't warn you. It may print garbage or crash your program.

✅ Fix: use \texttt{\textless{}\ size}, not
\texttt{\textless{}=\ size\ -\ 1}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{50.2 Forgetting Array
Bounds}\label{forgetting-array-bounds}

C does not check array boundaries. If you write outside the valid range,
you're overwriting memory that belongs to something else.

This is called undefined behavior. Your program might seem fine, then
suddenly fail later for no clear reason.

Always use indexes you can trust, often from a loop counter or
\texttt{sizeof} calculation.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ length }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{nums}\OperatorTok{)} \OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{nums}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

\subsubsection{50.3 Forgetting the Null
Terminator}\label{forgetting-the-null-terminator}

When working with strings, every array must end with
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. If you
forget it, C doesn't know where the string stops.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}C\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}a\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}t\textquotesingle{}}\OperatorTok{\};} \CommentTok{// ❌ no \textquotesingle{}\textbackslash{}0\textquotesingle{}}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ name}\OperatorTok{);} \CommentTok{// unpredictable output}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\CharTok{\textquotesingle{}C\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}a\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}t\textquotesingle{}}\OperatorTok{,} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

If you use a string literal (\texttt{"Cat"}), C adds
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}
automatically.

\subsubsection{50.4 Mixing Up Size and
Count}\label{mixing-up-size-and-count}

An array's size is the number of slots, but you may only use part of it.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ scores}\OperatorTok{[}\DecValTok{10}\OperatorTok{];}
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Only \texttt{scores{[}0{]}}, \texttt{scores{[}1{]}}, and
\texttt{scores{[}2{]}} contain real data. You can't safely loop through
all 10 unless you know the rest are valid.

✅ Fix: always track how many elements are actually used.

\subsubsection{50.5 Forgetting Arrays Are Fixed
Size}\label{forgetting-arrays-are-fixed-size}

You can't resize a normal array after it's created. This fails:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DecValTok{4}\OperatorTok{;} \CommentTok{// ❌ can\textquotesingle{}t extend}
\end{Highlighting}
\end{Shaded}

If you need more space, use dynamic memory (\texttt{malloc}), you'll
learn that soon.

\subsubsection{50.6 Passing Wrong Size to
Functions}\label{passing-wrong-size-to-functions}

When you pass an array to a function, it becomes a pointer. That means
the function can't know the size automatically.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \OperatorTok{???;}\NormalTok{ i}\OperatorTok{++)} \CommentTok{// ❌ no size info}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

✅ Fix: always pass the size along:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Then call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print\_array}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{50.7 Using Uninitialized
Elements}\label{using-uninitialized-elements}

When you create an array without setting values, the elements contain
garbage, random memory leftovers.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ data}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// ❌ unpredictable}
\end{Highlighting}
\end{Shaded}

✅ Fix: initialize your arrays:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};} \CommentTok{// fills all with 0}
\end{Highlighting}
\end{Shaded}

\subsubsection{50.8 Confusing Arrays with
Pointers}\label{confusing-arrays-with-pointers}

Arrays and pointers are related but not identical. You can use pointer
arithmetic, but you can't reassign an array name.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ nums}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=}\NormalTok{ p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}      \CommentTok{// ✅ moves pointer}
\NormalTok{nums }\OperatorTok{=}\NormalTok{ nums }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// ❌ not allowed}
\end{Highlighting}
\end{Shaded}

Keep in mind: arrays are fixed blocks, not movable variables.

\subsubsection{\texorpdfstring{50.9 Wrong \texttt{sizeof}
Usage}{50.9 Wrong sizeof Usage}}\label{wrong-sizeof-usage}

\texttt{sizeof(array)} gives total bytes of the whole array, but
\texttt{sizeof(pointer)} gives only the pointer size (usually 8).

So inside functions, \texttt{sizeof(arr)} no longer works, you'll just
get pointer size. Use it only in the same scope where the array is
defined.

✅ Outside functions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ len }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{)} \OperatorTok{/} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{arr}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

❌ Inside functions:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// not reliable, arr is now a pointer}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code}\label{tiny-code-49}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ print\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{,} \DecValTok{40}\OperatorTok{,} \DecValTok{50}\OperatorTok{\};}

\NormalTok{    print\_array}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}

    \CommentTok{// data[5] = 60; // ❌ out of bounds, don\textquotesingle{}t do this}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 20 30 40 50
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-49}

Arrays are fast and powerful, but they trust you completely. C won't
stop you from stepping out of bounds or using bad data. Once you
understand the common pitfalls, you'll write safer, more reliable code.

\subsubsection{Try It Yourself}\label{try-it-yourself-49}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a loop that accidentally goes one index too far, see what
  happens.
\item
  Create a string manually, try forgetting the null terminator.
\item
  Initialize an array partially and print all elements.
\item
  Pass an array to a function along with its size.
\item
  Compare \texttt{sizeof(arr)} in main vs inside a function.
\end{enumerate}

Learning these lessons early means you'll spend more time coding with
confidence and less time chasing mysterious bugs.

\section{Chapter 6. Pointers and
Memory}\label{chapter-6.-pointers-and-memory-1}

\subsection{51. What Is a Pointer}\label{what-is-a-pointer}

Up until now, every variable you've used has stored a value, a number, a
letter, or a piece of text. A pointer is different. Instead of holding a
value, it holds the address of a value, where that value lives in
memory.

You can think of it like this:

\begin{itemize}
\tightlist
\item
  A normal variable is the house (it contains the value).
\item
  A pointer is the address written on a piece of paper (it tells you
  where the house is).
\end{itemize}

Once you understand pointers, you'll unlock some of C's most powerful
abilities: working with arrays, strings, and dynamic memory.

\subsubsection{51.1 Memory and Addresses}\label{memory-and-addresses}

Every variable in your program lives somewhere in memory. That location
is called its address, it's like a street number that identifies the
exact spot.

You can see a variable's address using the address-of operator
\texttt{\&}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{21}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{\%p} prints a memory address. You might see something like:

\begin{verbatim}
0x7ffee3b3a6c4
\end{verbatim}

That's the address where \texttt{age} is stored.

\subsubsection{51.2 Declaring a Pointer}\label{declaring-a-pointer}

A pointer is a variable designed to store an address. You declare it
with a \texttt{*} after the type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This means: ``\texttt{p} is a pointer to an int.''

You can then assign it the address of an integer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{21}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{age}\OperatorTok{;}  \CommentTok{// p now stores the address of age}
\end{Highlighting}
\end{Shaded}

So \texttt{p} doesn't hold \texttt{21}, it holds something like
\texttt{0x7ffee3b3a6c4}.

\subsubsection{51.3 Dereferencing a
Pointer}\label{dereferencing-a-pointer}

If \texttt{p} holds an address, how do you get the value stored there?
You use the dereference operator \texttt{*}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{*p} means ``go to the address stored in \texttt{p} and read the
value there.'' So this prints \texttt{21}.

Now you have two ways to reach the same value:

\begin{itemize}
\tightlist
\item
  \texttt{age} → directly
\item
  \texttt{*p} → indirectly through the pointer
\end{itemize}

\subsubsection{51.4 Visualizing It}\label{visualizing-it}

Let's see it in memory:

\begin{verbatim}
age = 21
p   = &age
*p  = 21
\end{verbatim}

Or in a picture:

\begin{verbatim}
   +------+      +----+
age|  21  |      |  p |----> [address of age]
   +------+      +----+
\end{verbatim}

The arrow shows that \texttt{p} ``points'' to \texttt{age}.

\subsubsection{51.5 Using Pointers to Change
Values}\label{using-pointers-to-change-values}

Because \texttt{*p} is another way of accessing the same memory, you can
change the original value through the pointer:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{30}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);} \CommentTok{// prints 30}
\end{Highlighting}
\end{Shaded}

You didn't touch \texttt{age} directly, you modified it through its
pointer.

This is why pointers are powerful: they let you work with memory itself,
not just copies of values.

\subsubsection{51.6 Pointer Types Must
Match}\label{pointer-types-must-match}

A pointer's type must match the value it points to. You can't store the
address of an \texttt{int} in a \texttt{char\ *} pointer.

✅ Correct:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{n}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

❌ Wrong:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{n}\OperatorTok{;} \CommentTok{// incompatible types}
\end{Highlighting}
\end{Shaded}

The type tells C how to interpret the memory.

\subsubsection{51.7 Null Pointers}\label{null-pointers}

A pointer that doesn't point anywhere should be set to NULL. This is a
safe ``empty'' value that says ``I'm not pointing at anything.''

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can check before using it:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Never try to use \texttt{*p} if \texttt{p} is NULL, it will crash your
program.

\subsubsection{51.8 Summary}\label{summary}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Concept & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\&} & Address-of operator & \texttt{p\ =\ \&age;} \\
\texttt{*} & Dereference operator & \texttt{value\ =\ *p;} \\
Pointer & Stores address of a value & \texttt{int\ *p;} \\
\texttt{NULL} & Pointer to nowhere & \texttt{int\ *p\ =\ NULL;} \\
\end{longtable}

\subsubsection{Tiny Code}\label{tiny-code-50}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Address of x = }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"ptr points to = }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ptr}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value at ptr = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}

    \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"x after change = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
x = 10  
Address of x = 0x7ffee3b3a6c4  
ptr points to = 0x7ffee3b3a6c4  
Value at ptr = 10  
x after change = 20
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-50}

Pointers let you share memory between parts of your program. They're
essential for arrays, strings, functions, and dynamic memory. Once you
see pointers as ``addresses to values,'' they stop being scary and start
feeling useful.

\subsubsection{Try It Yourself}\label{try-it-yourself-50}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an \texttt{int} variable and a pointer to it.
\item
  Print both the value and address.
\item
  Change the value using the pointer.
\item
  Set a pointer to \texttt{NULL} and check before dereferencing.
\item
  Add another pointer pointing to the same variable and print through
  both.
\end{enumerate}

Pointers are your key to understanding how C truly works under the hood.
You're now ready to explore how they interact with operators in the next
section!

\subsection{52. The Address-of (\&) and Dereference (*)
Operators}\label{the-address-of-and-dereference-operators}

Pointers come alive through two special symbols:

\begin{itemize}
\tightlist
\item
  \texttt{\&} gets the address of a variable (where it lives in memory)
\item
  \texttt{*} gets the value stored at that address
\end{itemize}

Together, they let you move easily between values and their memory
locations, like having a GPS to find a house and a key to open its door.

Let's walk through them step by step.

\subsubsection{\texorpdfstring{52.1 The Address-of Operator
\texttt{\&}}{52.1 The Address-of Operator \&}}\label{the-address-of-operator}

The \texttt{\&} symbol means ``give me the address of this variable.''

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{age}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
0x7ffeef3c6b24
\end{verbatim}

That number is where \texttt{age} is stored in memory.

You can store that address inside a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{age}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{p} points to \texttt{age}.

\subsubsection{\texorpdfstring{52.2 The Dereference Operator
\texttt{*}}{52.2 The Dereference Operator *}}\label{the-dereference-operator}

If \texttt{p} holds an address, then \texttt{*p} means ``go to that
address and get the value there.''

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ age }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{age}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// prints 25}
\end{Highlighting}
\end{Shaded}

The \texttt{*} in front of a pointer means ``use the thing it points
to.''

You can also change the value stored there:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{30}\OperatorTok{;} \CommentTok{// updates age}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ age}\OperatorTok{);} \CommentTok{// prints 30}
\end{Highlighting}
\end{Shaded}

You didn't change \texttt{age} directly, you updated it through its
pointer.

\subsubsection{\texorpdfstring{52.3 Two Meanings of
\texttt{*}}{52.3 Two Meanings of *}}\label{two-meanings-of}

The \texttt{*} symbol appears in two contexts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In a declaration, it defines a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

  ``\texttt{p} is a pointer to int.''
\item
  In an expression, it accesses the pointed value:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

  ``Set the value stored at the address inside \texttt{p}.''
\end{enumerate}

You'll learn to tell them apart from context.

\subsubsection{\texorpdfstring{52.4 Combining \texttt{\&} and
\texttt{*}}{52.4 Combining \& and *}}\label{combining-and}

\texttt{\&} and \texttt{*} are opposites, one finds an address, the
other follows it.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(\&}\NormalTok{x}\OperatorTok{));} \CommentTok{// same as x}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&(*}\NormalTok{p}\OperatorTok{));} \CommentTok{// same as p}
\end{Highlighting}
\end{Shaded}

Think of them like this:

\begin{itemize}
\tightlist
\item
  \texttt{\&} → ``take the address of''
\item
  \texttt{*} → ``follow the address''
\end{itemize}

Used together, they cancel out.

\subsubsection{52.5 Example in Action}\label{example-in-action}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;} \CommentTok{// store address}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Address of value: }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer holds: }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ptr}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value at pointer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}

    \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 10  
Address of value: 0x7ffee3b3a6c4  
Pointer holds: 0x7ffee3b3a6c4  
Value at pointer: 10  
New value: 50
\end{verbatim}

\subsubsection{52.6 Visual Picture}\label{visual-picture}

\begin{verbatim}
+------------+       +------------+
|  variable  |       |   pointer  |
|   value=10 |<------| address=&variable |
+------------+       +------------+
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{\&variable} gives you the arrow
\item
  \texttt{*pointer} lets you follow it back
\end{itemize}

\subsubsection{52.7 Common Mistakes}\label{common-mistakes-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{\&} when assigning to a pointer
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}     \CommentTok{// ❌ Wrong: n is not an address}
\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{n}\OperatorTok{;}    \CommentTok{// ✅ Correct: \&n is the address of n}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Forgetting \texttt{*} when printing the value
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{n}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}   \CommentTok{// ❌ Wrong: prints address}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}  \CommentTok{// ✅ Correct: prints value}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Dereferencing an uninitialized pointer
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}   \CommentTok{// ❌ Wrong: p doesn\textquotesingle{}t point anywhere yet}
\end{Highlighting}
\end{Shaded}

✅ Always assign a valid address first or set it to \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{52.8 Step-by-Step Thought
Process}\label{step-by-step-thought-process}

When you see a pointer, ask yourself:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  What type of value does it point to?
\item
  Does it currently hold a valid address?
\item
  Am I trying to access the address (\texttt{\&}) or the value
  (\texttt{*})?
\end{enumerate}

These questions make pointers clear and safe to use.

\subsubsection{Tiny Code}\label{tiny-code-51}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{num}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"num = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"\&num = }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{num}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"p = }\SpecialCharTok{\%p\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"*p = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
num = 100  
&num = 0x7ffee3b3a6c4  
p = 0x7ffee3b3a6c4  
*p = 100
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-51}

These two operators are the gateway to working with memory in C. They
allow you to share data between functions, build complex data
structures, and control memory directly. Understanding them now makes
arrays, strings, and dynamic allocation much easier later.

\subsubsection{Try It Yourself}\label{try-it-yourself-51}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare a variable and a pointer to it. Print both address and value.
\item
  Change the variable through the pointer.
\item
  Use \texttt{*(\&variable)}, see it's the same as \texttt{variable}.
\item
  Print a pointer with and without \texttt{*}, note the difference.
\item
  Set a pointer to \texttt{NULL} and check before dereferencing.
\end{enumerate}

Master \texttt{\&} and \texttt{*}, and you'll have full control over how
your data lives and moves inside memory.

\subsection{53. Pointer Arithmetic}\label{pointer-arithmetic}

Pointers can do more than just store addresses, you can also move them.
Because pointers represent memory locations, adding or subtracting
values lets you step through memory. This feature is called pointer
arithmetic, and it's especially useful when working with arrays.

\subsubsection{53.1 Moving Through Memory}\label{moving-through-memory}

When you add \texttt{1} to a pointer, it moves forward by the size of
the type it points to. It doesn't move one byte, it moves one element.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{;}
\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// moves by sizeof(int)}
\end{Highlighting}
\end{Shaded}

If \texttt{sizeof(int)} is 4 bytes, then \texttt{p\ +\ 1} advances 4
bytes in memory. So:

\begin{itemize}
\tightlist
\item
  \texttt{p\ +\ 1} moves to the next element
\item
  \texttt{p\ +\ 2} moves two elements ahead
\item
  \texttt{p\ -\ 1} moves one element back
\end{itemize}

\subsubsection{53.2 Example with an Array}\label{example-with-an-array}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;} \CommentTok{// points to first element}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"First: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Second: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Third: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{2}\OperatorTok{));}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each step moves to the next element in the array because arrays occupy
contiguous memory.

\subsubsection{53.3 Using Pointers Like
Indexes}\label{using-pointers-like-indexes}

These two expressions are equivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]}
\OperatorTok{*(}\NormalTok{numbers }\OperatorTok{+}\NormalTok{ i}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

That means you can loop with either an index or a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+}\NormalTok{ i}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or move the pointer directly:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}\NormalTok{ ptr }\OperatorTok{\textless{}}\NormalTok{ numbers }\OperatorTok{+} \DecValTok{3}\OperatorTok{;}\NormalTok{ ptr}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*}\NormalTok{ptr}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Both print:

\begin{verbatim}
10 20 30
\end{verbatim}

\subsubsection{53.4 Subtracting Pointers}\label{subtracting-pointers}

You can find the distance between two pointers that point into the same
array:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{start }\OperatorTok{=} \OperatorTok{\&}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{];}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{end }\OperatorTok{=} \OperatorTok{\&}\NormalTok{numbers}\OperatorTok{[}\DecValTok{2}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ end }\OperatorTok{{-}}\NormalTok{ start}\OperatorTok{);} \CommentTok{// prints 2}
\end{Highlighting}
\end{Shaded}

The result is the number of elements between them, not the number of
bytes.

\subsubsection{53.5 Staying Within Bounds}\label{staying-within-bounds}

You can move a pointer inside an array, or one past the last element,
but never before the first or beyond the end.

Incorrect:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ arr }\OperatorTok{+} \DecValTok{4}\OperatorTok{;} \CommentTok{// out of range}
\end{Highlighting}
\end{Shaded}

Only pointers that refer to positions within the same array are valid
for arithmetic.

\subsubsection{53.6 Different Step Sizes for Different
Types}\label{different-step-sizes-for-different-types}

The amount a pointer moves depends on its type:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{pi}\OperatorTok{;}
\DataTypeTok{char} \OperatorTok{*}\NormalTok{pc}\OperatorTok{;}
\DataTypeTok{double} \OperatorTok{*}\NormalTok{pd}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If you add 1:

\begin{itemize}
\tightlist
\item
  \texttt{pi\ +\ 1} moves 4 bytes (size of \texttt{int})
\item
  \texttt{pc\ +\ 1} moves 1 byte (size of \texttt{char})
\item
  \texttt{pd\ +\ 1} moves 8 bytes (size of \texttt{double})
\end{itemize}

C adjusts the step automatically based on the type.

\subsubsection{53.7 Increment and
Decrement}\label{increment-and-decrement-1}

You can also use \texttt{++} and \texttt{-\/-} on pointers:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{,} \DecValTok{15}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ data}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// 5}
\NormalTok{p}\OperatorTok{++;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// 10}
\NormalTok{p}\OperatorTok{++;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// 15}
\end{Highlighting}
\end{Shaded}

Each increment moves one element forward.

\subsubsection{53.8 Using Pointers in
Loops}\label{using-pointers-in-loops}

You can iterate through an array using pointer comparisons:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ data}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{end }\OperatorTok{=}\NormalTok{ data }\OperatorTok{+} \DecValTok{3}\OperatorTok{;}

\ControlFlowTok{while} \OperatorTok{(}\NormalTok{p }\OperatorTok{\textless{}}\NormalTok{ end}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\NormalTok{    p}\OperatorTok{++;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This pattern works well when you know where the array starts and ends.

\subsubsection{53.9 Tiny Code Example}\label{tiny-code-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{8}\OperatorTok{\};}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Using pointer arithmetic:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+}\NormalTok{ i}\OperatorTok{));}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Using pointer increment:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{q }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{;}\NormalTok{ q }\OperatorTok{\textless{}}\NormalTok{ arr }\OperatorTok{+} \DecValTok{4}\OperatorTok{;}\NormalTok{ q}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*}\NormalTok{q}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Using pointer arithmetic:
2 4 6 8
Using pointer increment:
2 4 6 8
\end{verbatim}

\subsubsection{53.10 Common Mistakes}\label{common-mistakes-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting pointer step size
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ arr}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=}\NormalTok{ p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// moves one int ahead (not one byte)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Going out of bounds
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ arr }\OperatorTok{+} \DecValTok{5}\OperatorTok{;} \CommentTok{// invalid memory access}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Mixing pointer types
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{char} \OperatorTok{*)}\NormalTok{arr}\OperatorTok{;} \CommentTok{// reinterprets memory, risky}
\end{Highlighting}
\end{Shaded}

Pointer arithmetic should only be used on pointers of the correct type
and within valid bounds.

\subsubsection{Why It Matters}\label{why-it-matters-52}

Pointer arithmetic gives you fine-grained control over how you move
through arrays. It's what makes C powerful for working close to the
hardware, you can navigate memory directly, one element at a time.

\subsubsection{Try It Yourself}\label{try-it-yourself-52}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an array and print elements using \texttt{*(p\ +\ i)}.
\item
  Use \texttt{p++} in a loop to step through the array.
\item
  Compute the difference between two pointers.
\item
  Test pointer arithmetic with \texttt{char}, \texttt{int}, and
  \texttt{double} arrays.
\item
  Practice writing loops that use pointers instead of indexes.
\end{enumerate}

Pointer arithmetic takes practice, but once it clicks, you'll see how
naturally it fits with arrays and memory in C.

\subsection{54. Arrays and Pointers
Revisited}\label{arrays-and-pointers-revisited}

You've already seen that arrays and pointers are closely related, now
it's time to connect the dots clearly. This section ties together what
you've learned about both topics so far, showing when they behave the
same, when they don't, and how to use them safely and confidently.

\subsubsection{54.1 The Array Name Is (Almost) a
Pointer}\label{the-array-name-is-almost-a-pointer}

When you declare an array like this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

the name \texttt{numbers} represents the address of its first element.
That means these two expressions are equivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{==} \OperatorTok{\&}\NormalTok{numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]}
\end{Highlighting}
\end{Shaded}

You can even assign that address to a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;} \CommentTok{// same as \&numbers[0]}
\end{Highlighting}
\end{Shaded}

Now \texttt{p} points to the same place as \texttt{numbers}.

\subsubsection{54.2 Accessing Elements}\label{accessing-elements-2}

You can use either array notation or pointer arithmetic, both work the
same:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);} \CommentTok{// array style}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{numbers}\OperatorTok{);}   \CommentTok{// pointer style}
\end{Highlighting}
\end{Shaded}

Similarly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{==} \OperatorTok{*(}\NormalTok{numbers }\OperatorTok{+} \DecValTok{2}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

So in many cases, arrays and pointers are interchangeable in
expressions.

\subsubsection{54.3 Arrays in Memory}\label{arrays-in-memory}

Arrays are stored in contiguous memory, one element after another.

Visualize \texttt{int\ numbers{[}3{]}\ =\ \{10,\ 20,\ 30\};} like this:

\begin{verbatim}
Address:  0x100  0x104  0x108
Values:    10     20     30
Indexes:    0      1      2
\end{verbatim}

If you start with \texttt{numbers},

\begin{itemize}
\tightlist
\item
  \texttt{numbers\ +\ 1} is the address of \texttt{numbers{[}1{]}},
\item
  \texttt{numbers\ +\ 2} is the address of \texttt{numbers{[}2{]}}.
\end{itemize}

C automatically adjusts by \texttt{sizeof(int)} for each step.

\subsubsection{54.4 Pointers Are More
Flexible}\label{pointers-are-more-flexible}

A pointer can move. You can make it point anywhere:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=}\NormalTok{ p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// now points to numbers[1]}
\end{Highlighting}
\end{Shaded}

But an array name is fixed, you cannot change it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}
\NormalTok{p }\OperatorTok{=}\NormalTok{ p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}     \CommentTok{// allowed}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ numbers }\OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// error: array name is not assignable}
\end{Highlighting}
\end{Shaded}

So think of the array name as a constant pointer.

\subsubsection{54.5 Passing Arrays to
Functions}\label{passing-arrays-to-functions}

When you pass an array to a function, it decays into a pointer. That
means only the address of the first element is passed, not a full copy.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_array}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{    print\_array}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Inside \texttt{print\_array}, \texttt{arr} is actually a pointer to the
first element of \texttt{data}.

That's why you must also pass the size, C has no way to tell how big the
array is from just the pointer.

\subsubsection{54.6 Modifying Arrays Through
Pointers}\label{modifying-arrays-through-pointers}

Because arrays and pointers refer to the same memory, you can modify an
array's elements through a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}

\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}         \CommentTok{// changes numbers[0]}
\OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{=} \DecValTok{20}\OperatorTok{;}   \CommentTok{// changes numbers[1]}
\OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{2}\OperatorTok{)} \OperatorTok{=} \DecValTok{30}\OperatorTok{;}   \CommentTok{// changes numbers[2]}
\end{Highlighting}
\end{Shaded}

Afterward, \texttt{numbers} becomes \texttt{\{10,\ 20,\ 30\}}.

\subsubsection{54.7 Arrays of Different
Types}\label{arrays-of-different-types}

Pointers must match the type of the array they point to:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ nums}\OperatorTok{;}   \CommentTok{// correct}
\DataTypeTok{char} \OperatorTok{*}\NormalTok{c }\OperatorTok{=}\NormalTok{ nums}\OperatorTok{;}  \CommentTok{// wrong: type mismatch}
\end{Highlighting}
\end{Shaded}

Each pointer type understands its element size. A \texttt{char\ *} moves
one byte at a time, an \texttt{int\ *} moves \texttt{sizeof(int)} bytes
at a time.

\subsubsection{54.8 Summary of the
Relationship}\label{summary-of-the-relationship}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2254}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4366}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3380}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Concept
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Array
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pointer
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Memory & Fixed block of elements & Can point anywhere \\
Name & Constant (cannot be reassigned) & Variable (can move) \\
Access & \texttt{arr{[}i{]}} & \texttt{*(p\ +\ i)} \\
Pass to function & Decays to pointer & Passed by value \\
Size info & Known at compile time & Must be tracked manually \\
\end{longtable}

Remember: arrays and pointers often look similar, but arrays are blocks,
while pointers are labels that can move.

\subsubsection{54.9 Tiny Code Example}\label{tiny-code-example-1}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ print\_elements}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,} \OperatorTok{*(}\NormalTok{p }\OperatorTok{+}\NormalTok{ i}\OperatorTok{));}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ numbers}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Using array indexing: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ numbers}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Using pointer arithmetic: "}\OperatorTok{);}
\NormalTok{    print\_elements}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Using array indexing: 10 20 30  
Using pointer arithmetic: 10 20 30
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-53}

Understanding how arrays and pointers connect is essential in C. It
explains how functions receive data, how strings work, and how memory is
laid out. Once you see that \texttt{array{[}i{]}} and
\texttt{*(array\ +\ i)} are two views of the same thing, you'll move
smoothly between the two worlds.

\subsubsection{Try It Yourself}\label{try-it-yourself-53}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an array and a pointer to it. Print each element using both
  syntax styles.
\item
  Move the pointer using \texttt{p++} and print the values.
\item
  Pass the array to a function and print all elements inside.
\item
  Try to reassign the array name (you'll see a compiler error).
\item
  Compare \texttt{array{[}i{]}} and \texttt{*(array\ +\ i)} and verify
  they're identical.
\end{enumerate}

Once this connection clicks, C starts to feel much simpler, you'll see
arrays and pointers as two faces of the same idea.

\subsection{55. Function Parameters with
Pointers}\label{function-parameters-with-pointers}

When you pass a variable to a function in C, the function usually
receives a copy. That means any changes inside the function don't affect
the original.

But what if you \emph{want} the function to change something directly,
like updating a value, filling an array, or swapping two numbers? That's
where pointers come in.

By passing a pointer instead of a copy, you let the function work with
the original data.

\subsubsection{55.1 Passing by Value (the
Default)}\label{passing-by-value-the-default}

Normally, C passes by value. The function gets its own copy of the data.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ add\_one}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    n }\OperatorTok{=}\NormalTok{ n }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    add\_one}\OperatorTok{(}\NormalTok{x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// still 5}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Even though \texttt{n} becomes \texttt{6} inside \texttt{add\_one},
\texttt{x} outside stays \texttt{5} because \texttt{n} is a separate
copy.

\subsubsection{55.2 Passing by Pointer}\label{passing-by-pointer}

If you pass a pointer, the function can follow it back to the original
variable.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ add\_one}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{*}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    add\_one}\OperatorTok{(\&}\NormalTok{x}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);} \CommentTok{// now 6}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here's what's happening:

\begin{itemize}
\tightlist
\item
  \texttt{\&x} gives the address of \texttt{x}
\item
  \texttt{p} receives that address
\item
  \texttt{*p} means ``go to the original x and change it''
\end{itemize}

Now the function can update the real variable, not a copy.

\subsubsection{55.3 Visualizing the
Difference}\label{visualizing-the-difference}

Pass by value:

\begin{verbatim}
main: x = 5
add_one: n = 5 (copy)
\end{verbatim}

Pass by pointer:

\begin{verbatim}
main: x = 5
add_one: p -> x (same variable)
\end{verbatim}

When you use a pointer, you're handing the function a reference to the
same memory location.

\subsubsection{55.4 Example: Swapping Two
Values}\label{example-swapping-two-values}

Let's write a simple \texttt{swap} function.

Incorrect version (by value):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ swap}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ temp }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;}
\NormalTok{    a }\OperatorTok{=}\NormalTok{ b}\OperatorTok{;}
\NormalTok{    b }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call it like this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{swap}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

After calling, \texttt{x} is still \texttt{10} and \texttt{y} is still
\texttt{20}, the swap happened only inside the function.

Correct version (by pointer):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ swap}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{a}\OperatorTok{,} \DataTypeTok{int} \OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ temp }\OperatorTok{=} \OperatorTok{*}\NormalTok{a}\OperatorTok{;}
    \OperatorTok{*}\NormalTok{a }\OperatorTok{=} \OperatorTok{*}\NormalTok{b}\OperatorTok{;}
    \OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ temp}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call it with addresses:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{swap}\OperatorTok{(\&}\NormalTok{x}\OperatorTok{,} \OperatorTok{\&}\NormalTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now the original \texttt{x} and \texttt{y} are swapped.

\subsubsection{55.5 Using Pointers with
Arrays}\label{using-pointers-with-arrays}

When you pass an array to a function, it decays to a pointer
automatically. That means the function already has access to the
original memory.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ fill\_with\_zeros}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ size}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ size}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;} \CommentTok{// modifies original array}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call it like this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ data}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{fill\_with\_zeros}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
\CommentTok{// now data = \{0, 0, 0\}}
\end{Highlighting}
\end{Shaded}

No need to use \texttt{\&} when passing arrays, they're already
pointers.

\subsubsection{55.6 Pointers Make Functions More
Powerful}\label{pointers-make-functions-more-powerful}

Using pointers, functions can:

\begin{itemize}
\tightlist
\item
  Modify variables in the caller
\item
  Fill or update arrays
\item
  Return multiple results (by updating several variables)
\end{itemize}

This is how standard library functions like \texttt{scanf} work:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{);} \CommentTok{// gives scanf the address of x}
\end{Highlighting}
\end{Shaded}

\texttt{scanf} follows the pointer and stores the input directly into
\texttt{x}.

\subsubsection{55.7 Checking for NULL}\label{checking-for-null}

Sometimes a function might receive a pointer that doesn't point
anywhere. It's a good habit to check for \texttt{NULL} before using it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ safe\_add\_one}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
        \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{*}\NormalTok{p }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Never dereference (\texttt{*p}) a pointer unless you're sure it's valid.

\subsubsection{55.8 Summary}\label{summary-1}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Concept & Pass by Value & Pass by Pointer \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
What's passed & Copy of value & Address of value \\
Can modify original? & No & Yes \\
Used with arrays? & Yes (decays to pointer) & Yes \\
Needs \texttt{*} and \texttt{\&}? & No & Yes \\
\end{longtable}

\subsubsection{55.9 Tiny Code Example}\label{tiny-code-example-2}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ double\_value}\OperatorTok{(}\DataTypeTok{int} \OperatorTok{*}\NormalTok{p}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{*}\NormalTok{p }\OperatorTok{*} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\NormalTok{    double\_value}\OperatorTok{(\&}\NormalTok{num}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Doubled: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Doubled: 14
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-54}

Passing by pointer is one of the most important skills in C. It lets you
share data between functions without returning it. Once you get
comfortable with \texttt{*} and \texttt{\&}, you'll be able to write
more flexible and efficient programs.

\subsubsection{Try It Yourself}\label{try-it-yourself-54}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function \texttt{reset(int\ *p)} that sets a variable to zero.
\item
  Write a function \texttt{square(int\ *p)} that replaces a number with
  its square.
\item
  Create a function
  \texttt{fill\_array(int\ *arr,\ int\ size,\ int\ value)} that fills an
  array.
\item
  Modify a string inside a function using \texttt{char\ *}.
\item
  Try removing \texttt{\&} or \texttt{*} in your calls and see what
  happens, watch how the behavior changes.
\end{enumerate}

Once you understand how to pass by pointer, you'll have a solid
foundation for building real programs that modify data directly.

\subsection{\texorpdfstring{56. Dynamic Memory Allocation with
\texttt{malloc}}{56. Dynamic Memory Allocation with malloc}}\label{dynamic-memory-allocation-with-malloc}

So far, every variable and array you've used had a fixed size, decided
at compile time. But what if you don't know how much data you'll need
until the program is running? For example, maybe you're reading user
input, loading a file, or building a list that grows.

In those cases, you can use dynamic memory allocation, asking the
computer for memory \emph{while your program runs}. In C, this is done
with the function \texttt{malloc}.

\subsubsection{56.1 Static vs Dynamic
Memory}\label{static-vs-dynamic-memory}

Let's compare the two:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1094}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2344}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3594}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2969}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When Decided
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Lifespan
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Static & At compile time & \texttt{int\ arr{[}10{]};} & Freed
automatically \\
Dynamic & At runtime & \texttt{int\ *p\ =\ malloc(...);} & You must free
it \\
\end{longtable}

With \texttt{malloc}, you decide how much memory to get while your
program runs. You can make arrays of any size, based on user input or
other conditions.

\subsubsection{\texorpdfstring{56.2 Including
\texttt{\textless{}stdlib.h\textgreater{}}}{56.2 Including \textless stdlib.h\textgreater{}}}\label{including-stdlib.h}

All memory management functions live in
\texttt{\textless{}stdlib.h\textgreater{}}, so always include it at the
top:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{56.3 Using
\texttt{malloc}}{56.3 Using malloc}}\label{using-malloc}

\texttt{malloc} stands for memory allocation. It takes the number of
bytes you want and returns a pointer to the new memory block.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \OperatorTok{*}\NormalTok{malloc}\OperatorTok{(}\DataTypeTok{size\_t}\NormalTok{ size}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

This requests enough space for 5 integers. \texttt{malloc} returns the
address of the first byte, we store it in an \texttt{int\ *} because
that's the type of data we'll store.

\subsubsection{56.4 Checking the Return
Value}\label{checking-the-return-value}

If \texttt{malloc} fails (for example, not enough memory), it returns
\texttt{NULL}. Always check before using the pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Memory allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If it's not \texttt{NULL}, the memory is ready to use.

\subsubsection{56.5 Using the Allocated
Memory}\label{using-the-allocated-memory}

Once you have memory, use it like an array:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{*} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or with pointer arithmetic:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{*(}\NormalTok{p }\OperatorTok{+} \DecValTok{2}\OperatorTok{)} \OperatorTok{=} \DecValTok{25}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{56.6 Example: Create and Print an
Array}\label{example-create-and-print-an-array}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter number of elements: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{);}

    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{arr }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Memory allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"You created an array:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ n}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);} \CommentTok{// free memory when done}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Sample run:

\begin{verbatim}
Enter number of elements: 5  
You created an array:  
1 2 3 4 5
\end{verbatim}

\subsubsection{\texorpdfstring{56.7 Why Use
\texttt{sizeof}}{56.7 Why Use sizeof}}\label{why-use-sizeof}

Never assume the size of a type, it can vary between systems. Always use
\texttt{sizeof} when allocating:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\DataTypeTok{double} \OperatorTok{*}\NormalTok{d }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\NormalTok{n }\OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{double}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

This makes your code portable and safe.

\subsubsection{56.8 The Memory You Get}\label{the-memory-you-get}

\texttt{malloc} doesn't set the contents to zero, it gives you
uninitialized memory. The values inside are unpredictable until you
assign them.

If you want memory filled with zeros, use \texttt{calloc} instead
(you'll learn this soon).

\subsubsection{56.9 Don't Forget to Free
Memory}\label{dont-forget-to-free-memory}

Any memory you get from \texttt{malloc} must be released using
\texttt{free()} once you're done. Otherwise, your program will leak
memory (use it but never return it).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

After freeing, you can set the pointer to \texttt{NULL} to avoid
accidental reuse:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{56.10 Common Mistakes}\label{common-mistakes-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Forgetting to free: Allocating repeatedly without freeing causes
  memory leaks.
\item
  Using memory after freeing:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid {-} memory no longer yours}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Forgetting \texttt{sizeof}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10}\OperatorTok{);} \CommentTok{// allocates only 10 bytes, not 10 ints}
\end{Highlighting}
\end{Shaded}

Always multiply by \texttt{sizeof(type)}.

\subsubsection{Tiny Code Example}\label{tiny-code-example-3}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{data }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{data }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    data}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    data}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{    data}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DecValTok{30}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ data}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{data}\OperatorTok{);}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 20 30
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-55}

Dynamic memory lets your programs adapt to real-world data. You're no
longer limited to fixed-size arrays, you can create exactly as much
space as you need, when you need it.

It's one of the most powerful features of C, but also one that demands
responsibility, you manage the memory yourself.

\subsubsection{Try It Yourself}\label{try-it-yourself-55}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask the user for a number, allocate an array of that size, fill it,
  and print it.
\item
  Create an array of \texttt{double} using \texttt{malloc}.
\item
  Practice checking for \texttt{NULL} before using the memory.
\item
  Try forgetting \texttt{free()} and run your program multiple times,
  see how memory usage changes.
\item
  Combine \texttt{malloc} and \texttt{free} in a loop to allocate and
  release memory safely.
\end{enumerate}

Once you master \texttt{malloc}, your programs become flexible, ready to
handle data of any size.

\subsection{\texorpdfstring{57. Using \texttt{free}
Safely}{57. Using free Safely}}\label{using-free-safely}

Whenever you use \texttt{malloc} (or any function that allocates
memory), you're borrowing space from the computer's memory. But borrowed
memory must be returned. If you don't, your program will keep holding on
to memory it no longer needs, this is called a memory leak.

The tool for returning memory in C is the function \texttt{free()}.

\subsubsection{\texorpdfstring{57.1 What \texttt{free}
Does}{57.1 What free Does}}\label{what-free-does}

The \texttt{free()} function releases a block of memory that you
previously allocated with \texttt{malloc}, \texttt{calloc}, or
\texttt{realloc}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\NormalTok{free}\OperatorTok{(}\NormalTok{pointer}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

After calling \texttt{free}, the memory is returned to the system for
reuse. You can't access or use that memory anymore, it no longer belongs
to your program.

\subsubsection{57.2 Basic Example}\label{basic-example}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    p}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DecValTok{30}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ p}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \CommentTok{// release the memory}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
10 20 30
\end{verbatim}

After \texttt{free(p);}, the memory used by \texttt{p} is no longer
yours. Accessing it again would be undefined behavior.

\subsubsection{57.3 Why You Must Free
Memory}\label{why-you-must-free-memory}

When your program runs, it asks the operating system for memory. If you
keep allocating but never freeing, memory usage keeps growing, and
eventually, your program might slow down or crash.

This problem is called a memory leak.

Example of a leak:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{100} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\CommentTok{// forgot to call free(p)}
\end{Highlighting}
\end{Shaded}

Each time you run this, your program uses a little more memory that
never gets released.

\subsubsection{57.4 Safe Freeing
Practices}\label{safe-freeing-practices}

Here are good habits to make \texttt{free} safe and easy:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Always pair every malloc with a free. If you allocate memory, you
  should free it once you're done.
\item
  Free only once. Calling \texttt{free()} twice on the same pointer is
  undefined behavior. It may crash or corrupt memory.
\item
  Never use freed memory. Once freed, don't read or write through that
  pointer.
\item
  Set the pointer to NULL after freeing. That way, you can safely check
  before using it again.
\end{enumerate}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now, if you accidentally try to use it:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{42}\OperatorTok{;} \CommentTok{// this won\textquotesingle{}t run, because p is NULL}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{57.5 Common Mistakes}\label{common-mistakes-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting to free:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{data }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\CommentTok{// No free, memory leak}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Freeing twice:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{data}\OperatorTok{);}
\NormalTok{free}\OperatorTok{(}\NormalTok{data}\OperatorTok{);} \CommentTok{// invalid, already freed}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Using after free:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{data}\OperatorTok{);}
\NormalTok{data}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// invalid, memory no longer valid}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Freeing unallocated memory:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(\&}\NormalTok{a}\OperatorTok{);} \CommentTok{// invalid, \textquotesingle{}a\textquotesingle{} wasn\textquotesingle{}t allocated with malloc}
\end{Highlighting}
\end{Shaded}

These mistakes can cause subtle, hard-to-find bugs. Good pointer
hygiene, clear naming, proper freeing, and setting to \texttt{NULL},
prevents them.

\subsubsection{57.6 Freeing Arrays and Multiple
Pointers}\label{freeing-arrays-and-multiple-pointers}

If you allocate multiple pointers, each must be freed separately:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{a }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{5} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\DataTypeTok{double} \OperatorTok{*}\NormalTok{b }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{double}\OperatorTok{));}

\NormalTok{free}\OperatorTok{(}\NormalTok{a}\OperatorTok{);}
\NormalTok{free}\OperatorTok{(}\NormalTok{b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You only need to call \texttt{free()} once per allocation.

If you allocate an array of pointers (like a list of strings), you must
free each element and then the array itself, you'll learn that pattern
later.

\subsubsection{57.7 Visualizing}\label{visualizing}

Before freeing:

\begin{verbatim}
p ───> [10][20][30]
\end{verbatim}

After freeing:

\begin{verbatim}
p ───> (invalid memory)
\end{verbatim}

Setting to \texttt{NULL} helps:

\begin{verbatim}
p = NULL
\end{verbatim}

Now you can easily check:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer is safe.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tiny Code Example}\label{tiny-code-example-4}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{nums }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{4} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{nums }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Array: "}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{4}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ nums}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{nums}\OperatorTok{);}
\NormalTok{    nums }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \CommentTok{// reset pointer}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{nums }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Memory freed safely.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Array: 1 2 3 4  
Memory freed safely.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-56}

Memory in C is manual, you're in charge of asking for it \emph{and}
giving it back. By using \texttt{free()} carefully, your programs stay
efficient, stable, and leak-free.

It's like borrowing library books, always return what you take.

\subsubsection{Try It Yourself}\label{try-it-yourself-56}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Allocate an array of integers with \texttt{malloc}, fill it, print it,
  then free it.
\item
  Forget to call \texttt{free}, run the program multiple times and watch
  memory usage.
\item
  Free a pointer and then set it to \texttt{NULL}. Try accessing it
  again and check.
\item
  Try freeing twice, see how your program behaves (expect a crash or
  warning).
\item
  Make freeing part of your habit, always pair allocation and cleanup.
\end{enumerate}

Once you build the habit of freeing memory properly, you'll write
reliable programs that can run for hours without leaks or crashes.

\subsection{58. Pointer to Pointer}\label{pointer-to-pointer}

By now, you've learned how a pointer stores the address of a variable.
But did you know you can also have a pointer that stores the address of
another pointer? That's called a pointer to pointer, and it might sound
confusing at first, but it's just one more level of indirection.

Let's break it down step by step.

\subsubsection{58.1 One Step Back: A Simple
Pointer}\label{one-step-back-a-simple-pointer}

When you write this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{x} stores the value \texttt{10}
\item
  \texttt{p} stores the address of \texttt{x}
\end{itemize}

We can draw it like this:

\begin{verbatim}
x: 10
p: &x
\end{verbatim}

So:

\begin{itemize}
\tightlist
\item
  \texttt{x} → value (10)
\item
  \texttt{p} → points to x
\item
  \texttt{*p} → value at x (10)
\end{itemize}

\subsubsection{58.2 Adding Another Layer}\label{adding-another-layer}

Now, let's add a pointer to that pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ pp }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Here's what's happening:

\begin{itemize}
\tightlist
\item
  \texttt{pp} stores the address of \texttt{p}
\item
  \texttt{*pp} is the value stored in \texttt{p} (which is \texttt{\&x})
\item
  \texttt{pp} is the value stored in \texttt{x} (which is \texttt{10})
\end{itemize}

So:

\begin{verbatim}
x = 10
p = &x
pp = &p
\end{verbatim}

This chain means \texttt{pp} = 10.

\subsubsection{58.3 Visualizing It}\label{visualizing-it-1}

\begin{verbatim}
pp ──> p ──> x
             ↑
             10
\end{verbatim}

Think of it as a chain of arrows:

\begin{itemize}
\tightlist
\item
  \texttt{pp} points to \texttt{p}
\item
  \texttt{p} points to \texttt{x}
\item
  \texttt{x} holds 10
\end{itemize}

Each \texttt{*} you use follows one arrow.

\subsubsection{58.4 Accessing Values}\label{accessing-values}

Using the example above:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{);}     \CommentTok{// prints 10}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}    \CommentTok{// prints 10}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pp}\OperatorTok{);}  \CommentTok{// prints 10}
\end{Highlighting}
\end{Shaded}

They all get the same value, you're just reaching it through different
levels of pointers.

\subsubsection{58.5 Why Use a Pointer to
Pointer?}\label{why-use-a-pointer-to-pointer}

Pointer-to-pointer variables show up often in C, especially when:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You need to modify a pointer inside a function
\item
  You work with arrays of strings (\texttt{char\ argv})
\item
  You manage dynamic memory, like a list of lists or a 2D array
\end{enumerate}

Example 1: modifying a pointer inside a function

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ allocate\_memory}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ ptr}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{ptr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{    ptr }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call it like this:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{allocate\_memory}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// prints 42}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The function receives the address of the pointer, so it can update it
directly.

\subsubsection{58.6 Example: Double Pointer in
Action}\label{example-double-pointer-in-action}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ set\_value}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ pp}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{pp }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{pp }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        pp }\OperatorTok{=} \DecValTok{99}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\NormalTok{    set\_value}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\NormalTok{        free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 99
\end{verbatim}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{p} is a pointer to int
\item
  \texttt{\&p} is a pointer to pointer
\item
  The function allocates memory and sets the value safely
\end{itemize}

\subsubsection{58.7 Common Mistakes}\label{common-mistakes-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Confusing \texttt{*} count: Each \texttt{*} represents one level of
  indirection. If you have \texttt{int\ pp}, then:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{pp} points to a pointer
\item
  \texttt{*pp} is a pointer to int
\item
  \texttt{pp} is the actual int
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Forgetting to initialize: Never use a pointer-to-pointer without
  setting its target.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ pp}\OperatorTok{;}
\NormalTok{pp }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// invalid, pp is uninitialized}
\end{Highlighting}
\end{Shaded}

Always initialize step by step.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Forgetting to free memory: If your pointer-to-pointer was used to
  allocate memory, remember to free it at the end.
\end{enumerate}

\subsubsection{58.8 Arrays of Strings
Example}\label{arrays-of-strings-example}

You'll often see \texttt{char\ argv} in \texttt{main()}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char}\NormalTok{ argv}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Program name: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{argv} is a pointer to a list of strings:

\begin{itemize}
\tightlist
\item
  \texttt{argv} points to the first element (a pointer to a string)
\item
  \texttt{argv{[}i{]}} is a \texttt{char\ *}
\item
  \texttt{*argv{[}i{]}} is a character
\end{itemize}

\subsubsection{Tiny Code Example}\label{tiny-code-example-5}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{value}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ pp }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"*p: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"pp: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ pp}\OperatorTok{);}

\NormalTok{    pp }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Updated Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 10  
*p: 10  
pp: 10  
Updated Value: 20
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-57}

A pointer to pointer is just one more layer of address following. It may
seem abstract now, but it's essential for working with:

\begin{itemize}
\tightlist
\item
  Functions that allocate memory
\item
  Command-line arguments
\item
  Dynamic arrays and matrices
\end{itemize}

Understanding this concept opens the door to more advanced data
structures in C.

\subsubsection{Try It Yourself}\label{try-it-yourself-57}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare an integer, a pointer, and a pointer to pointer. Print their
  values.
\item
  Change the original integer using \texttt{pp} and confirm it updates.
\item
  Write a function that takes \texttt{int} and allocates memory for an
  int.
\item
  Print all addresses: \texttt{\&x}, \texttt{p}, and \texttt{pp}, see
  how they relate.
\item
  Practice counting stars (\texttt{*}), each one moves you one level
  deeper.
\end{enumerate}

Once you get comfortable, pointer-to-pointer code starts feeling like
following a clear path, one \texttt{*} at a time.

\subsection{59. NULL and Dangling
Pointers}\label{null-and-dangling-pointers}

When working with pointers, two very common and important ideas are NULL
pointers and dangling pointers. Both help you manage memory safely, and
avoiding mistakes with them will save you hours of debugging later.

Let's walk through what they mean and how to handle them step by step.

\subsubsection{59.1 What Is a NULL
Pointer}\label{what-is-a-null-pointer}

A NULL pointer is a pointer that points to nothing. It doesn't hold the
address of any valid variable or memory block.

In code:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Here, \texttt{p} is a pointer, but it doesn't point anywhere, it's
safely ``empty''.

Think of it as a mailbox with no address. You can check if it's empty,
but you can't deliver mail to it.

\subsubsection{59.2 Why NULL Is Useful}\label{why-null-is-useful}

NULL pointers are useful for three reasons:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Initialization, Start all pointers with a known value (\texttt{NULL}
  instead of random garbage).
\item
  Checking before use, You can safely test if a pointer is valid:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Resetting after free, Once memory is released, setting the pointer to
  \texttt{NULL} avoids accidental reuse.
\end{enumerate}

Using \texttt{NULL} is like putting up a clear sign: ``This pointer
isn't pointing to anything right now.''

\subsubsection{59.3 What Happens If You Dereference
NULL}\label{what-happens-if-you-dereference-null}

Dereferencing (\texttt{*p}) a NULL pointer is a serious error. It leads
to undefined behavior, often a crash called a segmentation fault.

Example (don't do this):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid {-} p doesn\textquotesingle{}t point to valid memory}
\end{Highlighting}
\end{Shaded}

Always check before dereferencing:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{59.4 What Is a Dangling
Pointer}\label{what-is-a-dangling-pointer}

A dangling pointer is a pointer that used to point to valid memory, but
that memory has since been freed or gone out of scope.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \CommentTok{// memory released}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid {-} dangling pointer}
\end{Highlighting}
\end{Shaded}

Now \texttt{p} still has the old address, but that address is no longer
valid.

Another example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{q}\OperatorTok{;}
\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    q }\OperatorTok{=} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;}
\OperatorTok{\}}
\CommentTok{// x goes out of scope here}
\OperatorTok{*}\NormalTok{q }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid {-} q now dangles}
\end{Highlighting}
\end{Shaded}

Dangling pointers point to memory that no longer exists.

\subsubsection{59.5 How to Avoid Dangling
Pointers}\label{how-to-avoid-dangling-pointers}

Here are some good habits:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set pointers to NULL after freeing

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}
\item
  Never return the address of a local variable

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{bad\_pointer}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;} \CommentTok{// wrong: x will disappear after function ends}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Be careful with pointer copies If two pointers point to the same
  memory, freeing one leaves the other dangling. You'll need to manage
  ownership carefully.
\end{enumerate}

\subsubsection{59.6 Visual Example}\label{visual-example}

Before freeing:

\begin{verbatim}
p ──> [ 42 ]
\end{verbatim}

After freeing:

\begin{verbatim}
p ──> ??? (invalid)
\end{verbatim}

Setting to NULL helps:

\begin{verbatim}
p ──> NULL
\end{verbatim}

Now you can check:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer is safe.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{59.7 Combining Checks}\label{combining-checks}

You can write safe, clear code by checking before use:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}
\OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Pointer not set.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It's better to skip a line of code than crash your program.

\subsubsection{59.8 Tiny Code Example}\label{tiny-code-example-6}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

\NormalTok{    p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Allocation failed}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{    p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \CommentTok{// prevent dangling}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Pointer is now safe.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value: 100  
Pointer is now safe.
\end{verbatim}

\subsubsection{59.9 Common Mistakes}\label{common-mistakes-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Dereferencing NULL:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// invalid {-} crash}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Using after free:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{*}\NormalTok{p}\OperatorTok{);} \CommentTok{// invalid {-} memory not yours anymore}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Returning address of local variable:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{make\_pointer}\OperatorTok{()} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{x}\OperatorTok{;} \CommentTok{// invalid {-} x disappears after return}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each of these leads to unpredictable behavior, sometimes immediate
crashes, sometimes silent corruption.

\subsubsection{Why It Matters}\label{why-it-matters-58}

Pointers are powerful, but they must always point to something valid.
NULL gives you a safe, predictable starting point. By setting freed
pointers to NULL, you keep your code clean and easy to debug.

A good rule:

\begin{quote}
Every pointer is either valid and ready to use, or safely set to NULL.
\end{quote}

\subsubsection{Try It Yourself}\label{try-it-yourself-58}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Declare a pointer, set it to NULL, and check before using it.
\item
  Allocate memory, free it, and try using it before setting to NULL, see
  what happens.
\item
  Write a function that returns a pointer. Try returning the address of
  a local variable and watch your compiler warn you.
\item
  Practice setting every pointer to NULL after freeing.
\item
  Use \texttt{if\ (p\ !=\ NULL)} before every dereference, make it a
  habit.
\end{enumerate}

Once you get comfortable managing NULL and avoiding dangling pointers,
you'll write programs that are both safe and stable, even when working
directly with memory.

\subsection{60. Debugging Memory Errors}\label{debugging-memory-errors}

By now, you've seen how to use pointers, \texttt{malloc}, and
\texttt{free}. But even careful programmers sometimes make mistakes with
memory, forgetting to free, freeing twice, using NULL by accident, or
stepping past array bounds.

These are called memory errors, and learning how to spot and fix them is
a big part of becoming confident in C. This section will help you
develop good debugging habits.

\subsubsection{60.1 What Are Memory
Errors}\label{what-are-memory-errors}

A memory error happens when your program misuses memory. Common examples
include:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Memory leaks -- not freeing memory you've allocated
\item
  Use after free -- trying to use memory that's already been freed
\item
  Invalid reads/writes -- accessing memory outside valid bounds
\item
  NULL dereference -- using a pointer that points to nothing
\item
  Double free -- freeing the same pointer twice
\end{enumerate}

Each one can cause your program to behave unpredictably, sometimes it
crashes, sometimes it silently corrupts data.

\subsubsection{60.2 Why They're Hard to
Catch}\label{why-theyre-hard-to-catch}

Unlike syntax errors, memory errors often don't show up immediately.
Your program might compile fine, even run fine for a while, and then
crash randomly later.

That's because C doesn't protect you from invalid memory access, it
trusts you completely. So your best defense is awareness and good tools.

\subsubsection{60.3 Build with Debug
Information}\label{build-with-debug-information}

Always compile with debugging symbols so you can trace problems:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ program.c }\AttributeTok{{-}o}\NormalTok{ program}
\end{Highlighting}
\end{Shaded}

The \texttt{-g} flag stores extra info for tools like \texttt{gdb}
(debugger) and \texttt{valgrind} (memory checker).

\subsubsection{\texorpdfstring{60.4 Using
\texttt{valgrind}}{60.4 Using valgrind}}\label{using-valgrind}

\texttt{valgrind} is a tool that watches every memory operation. It can
tell you if you forgot to free memory, wrote past array bounds, or freed
something twice.

Run your program like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{valgrind}\NormalTok{ ./program}
\end{Highlighting}
\end{Shaded}

You'll get a report showing:

\begin{itemize}
\tightlist
\item
  How much memory you allocated and freed
\item
  Where leaks occurred
\item
  What line caused an invalid access
\end{itemize}

Example output:

\begin{verbatim}
==12345== Invalid read of size 4
==12345== at 0x40055A: main (program.c:15)
==12345== Address 0x520304c is 0 bytes after a block of size 16
\end{verbatim}

This tells you exactly where something went wrong.

\subsubsection{60.5 Common Memory Mistakes and
Fixes}\label{common-memory-mistakes-and-fixes}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting to free
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{10} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\CommentTok{// missing free(p)}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Using after free
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid {-} p is freed}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;} \CommentTok{// prevents accidental reuse}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Writing past the end of an array
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{arr}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DecValTok{10}\OperatorTok{;} \CommentTok{// invalid index (0,1,2 valid)}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Dereferencing NULL
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;} \CommentTok{// crash}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \OperatorTok{*}\NormalTok{p }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Freeing twice
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \CommentTok{// invalid}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{60.6 Step-by-Step Debugging with
\texttt{gdb}}{60.6 Step-by-Step Debugging with gdb}}\label{step-by-step-debugging-with-gdb}

You can also use the GNU Debugger (\texttt{gdb}) to trace your program
line by line.

Start it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./program}
\end{Highlighting}
\end{Shaded}

Then run:

\begin{verbatim}
(gdb) run
\end{verbatim}

If your program crashes, type:

\begin{verbatim}
(gdb) backtrace
\end{verbatim}

It will show you which function and line caused the crash.

\subsubsection{60.7 Using Assertions}\label{using-assertions}

Assertions are sanity checks that help catch bugs early:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}assert.h\textgreater{}}

\DataTypeTok{int} \OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
\NormalTok{assert}\OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{);} \CommentTok{// stop if allocation failed}
\end{Highlighting}
\end{Shaded}

If the condition fails, the program stops immediately, helping you catch
issues before they spread.

\subsubsection{60.8 Good Debugging Habits}\label{good-debugging-habits}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initialize all pointers to NULL
\item
  Check before using a pointer
\item
  Set pointers to NULL after freeing
\item
  Track every malloc with a matching free
\item
  Test small parts of code often
\end{enumerate}

If something behaves strangely, suspect memory first.

\subsubsection{60.9 Tiny Code Example}\label{tiny-code-example-7}

Here's a small program with a hidden memory bug:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int} \OperatorTok{*}\NormalTok{arr }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\DecValTok{3} \OperatorTok{*} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{));}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}=} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{} \CommentTok{// mistake: should be i \textless{} 3}
\NormalTok{        arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\OperatorTok{,}\NormalTok{ arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    free}\OperatorTok{(}\NormalTok{arr}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

It compiles and runs, but it writes past the end of the array. Run it
with \texttt{valgrind} and you'll see the warning.

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    arr}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Why It Matters}\label{why-it-matters-59}

Debugging memory errors is a skill that separates careful programmers
from frustrated ones. Once you know how to use tools like
\texttt{valgrind}, and adopt habits like checking \texttt{NULL} and
pairing every \texttt{malloc} with \texttt{free}, you'll spend less time
hunting bugs and more time building cool programs.

\subsubsection{Try It Yourself}\label{try-it-yourself-59}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program with a memory leak, then find it using
  \texttt{valgrind}.
\item
  Intentionally go out of bounds on an array and watch the tool's
  output.
\item
  Practice pairing each allocation with a \texttt{free}.
\item
  Add \texttt{assert} statements to check that pointers are valid.
\item
  Run your programs with \texttt{gcc\ -g} and step through with
  \texttt{gdb} when you crash.
\end{enumerate}

Over time, debugging will feel less like guesswork and more like
detective work, clear, logical, and satisfying.

\section{Chapter 7. Structures and modular
design}\label{chapter-7.-structures-and-modular-design-1}

\subsection{\texorpdfstring{61. Defining \texttt{struct}
Types}{61. Defining struct Types}}\label{defining-struct-types}

So far, you've worked with basic data types, integers, floats, and
characters. But what if you want to group related pieces of data
together? For example, a student has a name, an ID, and a grade, three
different types, but all part of one concept.

In C, you can build your own custom data types using \texttt{struct},
short for structure.

\subsubsection{\texorpdfstring{61.1 What Is a
\texttt{struct}}{61.1 What Is a struct}}\label{what-is-a-struct}

A \texttt{struct} lets you combine variables of different types into one
single unit. It's like a container that holds fields, each with its own
name and type.

Here's the basic pattern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This defines a new type, \texttt{struct\ Student}, which has three
members:

\begin{itemize}
\tightlist
\item
  \texttt{id}, an integer
\item
  \texttt{name}, a string
\item
  \texttt{grade}, a floating-point number
\end{itemize}

Think of it like a mini record, one box with multiple labeled slots.

\subsubsection{\texorpdfstring{61.2 Declaring and Using a
\texttt{struct}}{61.2 Declaring and Using a struct}}\label{declaring-and-using-a-struct}

Once you've defined a structure, you can create variables of that type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student alice}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You now have a student record named \texttt{alice} with its own
\texttt{id}, \texttt{name}, and \texttt{grade}.

You can access each field using the dot operator (\texttt{.}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice}\OperatorTok{.}\NormalTok{id }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{alice}\OperatorTok{.}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}
\NormalTok{alice}\OperatorTok{.}\NormalTok{grade }\OperatorTok{=} \FloatTok{95.5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Then print them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"ID: }\SpecialCharTok{\%d}\StringTok{, Name: }\SpecialCharTok{\%s}\StringTok{, Grade: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{grade}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{61.3 Initializing a
\texttt{struct}}{61.3 Initializing a struct}}\label{initializing-a-struct}

You can set values when you create it, just like arrays:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student bob }\OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{,} \FloatTok{88.0}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Each value is assigned in order, first \texttt{id}, then \texttt{name},
then \texttt{grade}.

You can also use designated initializers (a nice, modern feature):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student carol }\OperatorTok{=} \OperatorTok{\{.}\NormalTok{name }\OperatorTok{=} \StringTok{"Carol"}\OperatorTok{,} \OperatorTok{.}\NormalTok{id }\OperatorTok{=} \DecValTok{3}\OperatorTok{,} \OperatorTok{.}\NormalTok{grade }\OperatorTok{=} \FloatTok{91.2}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This makes your code clearer, especially for large structures.

\subsubsection{61.4 Multiple Variables}\label{multiple-variables}

You can declare multiple variables at once:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student s1}\OperatorTok{,}\NormalTok{ s2}\OperatorTok{,}\NormalTok{ s3}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Each one is an independent copy with its own fields.

\subsubsection{61.5 Array of Structures}\label{array-of-structures}

You can store many \texttt{struct} values in an array, great for
managing records:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student students}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.5}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{,} \FloatTok{88.0}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \StringTok{"Carol"}\OperatorTok{,} \FloatTok{91.2}\OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Loop through them easily:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{61.6 Copying Structures}\label{copying-structures}

You can assign one structure to another directly, C copies all fields:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student temp }\OperatorTok{=}\NormalTok{ alice}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{temp} is an exact copy of \texttt{alice}. (But be careful
later, with pointers inside structs, this behaves differently.)

\subsubsection{\texorpdfstring{61.7 Anonymous
\texttt{struct}}{61.7 Anonymous struct}}\label{anonymous-struct}

Sometimes you don't need a type name, you can define and use a
\texttt{struct} right away:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ point}\OperatorTok{;}

\NormalTok{point}\OperatorTok{.}\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{point}\OperatorTok{.}\NormalTok{y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is handy for one-off uses where you don't plan to reuse the type
elsewhere.

\subsubsection{61.8 Combining Types}\label{combining-types}

You can even have structures inside structures:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Date birthdate}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now each student has their own birthday, a structure within a structure!

\subsubsection{61.9 Tiny Code Example}\label{tiny-code-example-8}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Student alice}\OperatorTok{;}

\NormalTok{    alice}\OperatorTok{.}\NormalTok{id }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{alice}\OperatorTok{.}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}
\NormalTok{    alice}\OperatorTok{.}\NormalTok{grade }\OperatorTok{=} \FloatTok{95.5}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Student Info:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"ID: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{id}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Name: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{grade}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Student Info:
ID: 1
Name: Alice
Grade: 95.5
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-60}

\texttt{struct} is your first step toward structured programming. It
lets you create your own data types that model real-world things,
students, books, cars, customers, clearly and naturally.

Once you learn how to define and organize structures, you'll start
building programs that deal with complex data, not just numbers and
strings.

\subsubsection{Try It Yourself}\label{try-it-yourself-60}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{struct\ Book} with fields for title, author, and
  price.
\item
  Make two book variables, fill them, and print them.
\item
  Store several books in an array of \texttt{struct\ Book}.
\item
  Copy one structure to another and confirm all fields match.
\item
  Add a nested \texttt{struct\ Date} for a publish date and print it.
\end{enumerate}

With \texttt{struct}, you're no longer just storing data, you're
designing it.

\subsection{62. Accessing Structure
Members}\label{accessing-structure-members}

Now that you know how to define a \texttt{struct}, let's learn how to
work with its members, the individual fields inside it. You'll use these
fields all the time, whether to store values, read them, or pass them
around in your program.

Once you see the patterns, it becomes second nature.

\subsubsection{\texorpdfstring{62.1 The Dot Operator
(\texttt{.})}{62.1 The Dot Operator (.)}}\label{the-dot-operator-.}

If you have a structure variable, you access its members using the dot
(\texttt{.}) operator. It's short for ``go inside this structure and get
this field.''

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Point p}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{y }\OperatorTok{=} \DecValTok{20}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"x = }\SpecialCharTok{\%d}\StringTok{, y = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{p.x} means ``the \texttt{x} field of structure \texttt{p}''
\item
  \texttt{p.y} means ``the \texttt{y} field of structure \texttt{p}''
\end{itemize}

The dot is your ``member access'' tool.

\subsubsection{62.2 Initializing and Printing
Members}\label{initializing-and-printing-members}

You can set each field manually:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}\OperatorTok{.}\NormalTok{x }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{y }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or initialize when you create it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{7}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Printing fields is just like printing any variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Point: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{62.3 Assigning One Structure to
Another}\label{assigning-one-structure-to-another}

C allows full structure assignment, it copies every field.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point a }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{\};}
\KeywordTok{struct}\NormalTok{ Point b }\OperatorTok{=}\NormalTok{ a}\OperatorTok{;} \CommentTok{// copies x and y}
\end{Highlighting}
\end{Shaded}

Now \texttt{b.x\ ==\ 1} and \texttt{b.y\ ==\ 2}.

Each field is duplicated automatically, no need to copy one by one.

\subsubsection{62.4 Nested Access}\label{nested-access}

If a structure contains another structure, use multiple dots to reach
deep inside.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \OperatorTok{\{}\DecValTok{15}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{2000}\OperatorTok{\}\};}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ was born on }\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{       s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can chain dots as far as needed, each one steps one level deeper.

\subsubsection{62.5 Accessing Through
Pointers}\label{accessing-through-pointers}

If you have a pointer to a structure, use the arrow operator
(\texttt{-\textgreater{}}) instead of the dot. The arrow means ``follow
the pointer, then access the field.''

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{\};}
\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{ptr }\OperatorTok{=} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(*}\NormalTok{ptr}\OperatorTok{).}\NormalTok{x}\OperatorTok{);}  \CommentTok{// long form}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ ptr}\OperatorTok{{-}\textgreater{}}\NormalTok{x}\OperatorTok{);}    \CommentTok{// short form, easier to read}
\end{Highlighting}
\end{Shaded}

Both lines mean the same thing. \texttt{ptr-\textgreater{}x} is just
shorthand for \texttt{(*ptr).x}.

\subsubsection{62.6 Visual Picture}\label{visual-picture-1}

Think of the dot and arrow like this:

\begin{itemize}
\tightlist
\item
  \texttt{p.x}, ``take p, then go inside to x''
\item
  \texttt{ptr-\textgreater{}x}, ``follow pointer ptr, then go inside to
  x''
\end{itemize}

The arrow combines dereference (\texttt{*}) and access (\texttt{.}) into
one step.

\subsubsection{\texorpdfstring{62.7 Example: Using
\texttt{-\textgreater{}} with Dynamic
Memory}{62.7 Example: Using -\textgreater{} with Dynamic Memory}}\label{example-using---with-dynamic-memory}

Let's allocate a structure with \texttt{malloc} and use
\texttt{-\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{=} \DecValTok{9}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{y}\OperatorTok{);}

\NormalTok{    free}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\NormalTok{    p }\OperatorTok{=}\NormalTok{ NULL}\OperatorTok{;}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
(7, 9)
\end{verbatim}

Notice we never used \texttt{(*p).x}, the arrow is simpler and safer.

\subsubsection{62.8 Modifying Members}\label{modifying-members}

You can change fields directly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}\OperatorTok{.}\NormalTok{x }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\NormalTok{x }\OperatorTok{+} \DecValTok{5}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{y }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or through a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ptr}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{=} \DecValTok{25}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

These updates affect only the field you change, the rest stay the same.

\subsubsection{62.9 Passing Structures to
Functions}\label{passing-structures-to-functions}

You can pass a structure to a function by value or by pointer.

By value (copies all fields):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_point}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

By pointer (modifies the original):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ move\_point}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{+=}\NormalTok{ dx}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{+=}\NormalTok{ dy}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This choice depends on whether you want to modify or just view the data.

\subsubsection{62.10 Tiny Code Example}\label{tiny-code-example-9}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ move}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{+=}\NormalTok{ dx}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{+=}\NormalTok{ dy}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{\};}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Before: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}

\NormalTok{    move}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{10}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"After: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Before: (10, 20)
After: (15, 10)
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-61}

Being able to access and modify structure members is what makes
\texttt{struct} so powerful. You can organize your data, read and write
specific fields, and pass whole records to functions easily.

Whether you're working with coordinates, students, books, or bank
accounts, you'll use the dot and arrow operators constantly, they're the
keys to navigating your data.

\subsubsection{Try It Yourself}\label{try-it-yourself-61}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{struct\ Rectangle} with \texttt{width} and
  \texttt{height} and print its area.
\item
  Write a function that doubles both fields of a \texttt{struct\ Point}
  using a pointer.
\item
  Create a nested structure and practice chaining dots (\texttt{.}).
\item
  Allocate a structure with \texttt{malloc} and use the arrow
  (\texttt{-\textgreater{}}) to fill its fields.
\item
  Copy one structure to another and confirm both have the same values.
\end{enumerate}

Once you're comfortable with \texttt{.} and \texttt{-\textgreater{}},
structures become your best tool for building clear, organized programs.

\subsection{63. Structures and
Functions}\label{structures-and-functions}

You've learned how to define structures and how to access their members,
now let's make them work together with functions. This is a key skill
because real programs often use functions to create, modify, and display
structured data.

You'll learn how to pass structures by value (copying them) or by
pointer (sharing them), and when to use each.

\subsubsection{63.1 Why Use Structures with
Functions}\label{why-use-structures-with-functions}

Structures group related data. Functions group related behavior.
Combining the two gives you clean, readable programs that handle data in
a clear, modular way.

For example, if you have a \texttt{struct\ Point}, you might want
functions to:

\begin{itemize}
\tightlist
\item
  create a new point
\item
  print a point
\item
  move a point
\end{itemize}

Each function focuses on one task, keeping your code simple and
reusable.

\subsubsection{63.2 Passing a Structure by
Value}\label{passing-a-structure-by-value}

When you pass a structure by value, C makes a copy of the structure. The
function can read or modify the copy, but the original remains
unchanged.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_point}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Point: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{\};}
\NormalTok{    print\_point}\OperatorTok{(}\NormalTok{p}\OperatorTok{);} \CommentTok{// sends a copy}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here, \texttt{p} is copied when passed. Changes inside
\texttt{print\_point} won't affect the original \texttt{p}.

\subsubsection{63.3 Passing a Structure by
Pointer}\label{passing-a-structure-by-pointer}

When you pass a pointer to a structure, the function works directly on
the original. This is more efficient (no copying large data) and allows
the function to modify the actual structure.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ move\_point}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{+=}\NormalTok{ dx}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{+=}\NormalTok{ dy}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{\};}
\NormalTok{move\_point}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Moved to: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Moved to: (8, 8)
\end{verbatim}

The \texttt{\&} operator gives the function the address of \texttt{p},
and the \texttt{-\textgreater{}} operator accesses its members inside
the function.

\subsubsection{63.4 When to Use Value vs
Pointer}\label{when-to-use-value-vs-pointer}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1772}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3797}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4430}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Approach
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
What Happens
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use When
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
By Value & Structure is copied & You only need to read or print data \\
By Pointer & Function works on the original & You want to modify the
structure \\
\end{longtable}

For small structures, passing by value is fine. For large ones (many
fields), pointers are faster and save memory.

\subsubsection{63.5 Returning a Structure}\label{returning-a-structure}

Functions can also return structures. This is useful when you want to
create and send back a filled record.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point create\_point}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{\};}
    \ControlFlowTok{return}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=}\NormalTok{ create\_point}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Created: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

C copies the structure on return, just like returning an integer.

\subsubsection{63.6 Returning a Pointer}\label{returning-a-pointer}

You can also return a pointer, but be careful, never return the address
of a local variable (it disappears when the function ends).

Wrong:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point}\OperatorTok{*}\NormalTok{ bad\_point}\OperatorTok{()} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{\};}
    \ControlFlowTok{return} \OperatorTok{\&}\NormalTok{p}\OperatorTok{;} \CommentTok{// invalid: p is local}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Right:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Point}\OperatorTok{*}\NormalTok{ make\_point}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ y}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p }\OperatorTok{=}\NormalTok{ malloc}\OperatorTok{(}\KeywordTok{sizeof}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point}\OperatorTok{));}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{p }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{=}\NormalTok{ x}\OperatorTok{;}
\NormalTok{        p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{=}\NormalTok{ y}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Just remember to \texttt{free()} the memory later.

\subsubsection{63.7 Example: Functions for a
Rectangle}\label{example-functions-for-a-rectangle}

Let's see structures and functions in action together.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Rectangle }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ width}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ height}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ area}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Rectangle r}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ r}\OperatorTok{.}\NormalTok{width }\OperatorTok{*}\NormalTok{ r}\OperatorTok{.}\NormalTok{height}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ double\_size}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Rectangle }\OperatorTok{*}\NormalTok{r}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{width }\OperatorTok{*=} \DecValTok{2}\OperatorTok{;}
\NormalTok{    r}\OperatorTok{{-}\textgreater{}}\NormalTok{height }\OperatorTok{*=} \DecValTok{2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Rectangle box }\OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Area: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ area}\OperatorTok{(}\NormalTok{box}\OperatorTok{));}

\NormalTok{    double\_size}\OperatorTok{(\&}\NormalTok{box}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New area: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ area}\OperatorTok{(}\NormalTok{box}\OperatorTok{));}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Area: 15  
New area: 60
\end{verbatim}

You pass by value when you only need to read data, and by pointer when
you want to change it.

\subsubsection{63.8 Combining Functions and Arrays of
Structures}\label{combining-functions-and-arrays-of-structures}

You can pass an array of structures to a function using a pointer.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_all}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{points}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ count}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ points}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{x}\OperatorTok{,}\NormalTok{ points}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{y}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This works because arrays decay into pointers when passed to functions.

\subsubsection{63.9 Tiny Code Example}\label{tiny-code-example-10}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ shift}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{+=}\NormalTok{ dx}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{+=}\NormalTok{ dy}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void}\NormalTok{ print}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Point p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Point: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}
\NormalTok{    print}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}

\NormalTok{    shift}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{);}
\NormalTok{    print}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Point: (2, 3)  
Point: (6, 8)
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-62}

Using structures with functions helps you organize your code around
real-world data and actions. Instead of passing multiple variables, you
pass a single meaningful package. This keeps your functions focused,
your code neat, and your logic easier to follow.

\subsubsection{Try It Yourself}\label{try-it-yourself-62}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{struct\ Circle} with a radius. Write a function to
  compute its area.
\item
  Write a function
  \texttt{void\ scale(struct\ Circle\ *c,\ double\ factor)} that
  multiplies the radius.
\item
  Write a function that creates and returns a new
  \texttt{struct\ Point}.
\item
  Try passing a structure by value and by pointer, see the difference.
\item
  Build a small program managing 3 students, functions to create, print,
  and update their grades.
\end{enumerate}

Once you master structures and functions, your programs start feeling
like small systems, each part clear, modular, and easy to understand.

\subsection{64. Nested Structures}\label{nested-structures}

Sometimes, one structure alone isn't enough to describe something fully.
A student has a name and grade, sure, but also a birth date, maybe an
address, or a course record. Instead of stuffing all this data into one
flat list of fields, you can use nested structures, structures
\emph{inside} other structures.

This helps you model real-world data clearly and keeps your code
organized.

\subsubsection{64.1 Why Nest Structures}\label{why-nest-structures}

Think of nested structures as ``building blocks.'' Each block models one
part of a bigger idea, and you can combine them to form complete
objects.

Example: You might want to describe a \texttt{Student} like this:

\begin{itemize}
\tightlist
\item
  ID
\item
  Name
\item
  Birthday (which has day, month, year)
\end{itemize}

So you create a separate \texttt{struct\ Date}, and use it inside
\texttt{struct\ Student}.

\subsubsection{64.2 Defining a Nested
Structure}\label{defining-a-nested-structure}

Start by defining the smaller structure first:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ month}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Then use it as a field in another structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now every \texttt{Student} automatically includes a \texttt{Date}.

\subsubsection{64.3 Initializing a Nested
Structure}\label{initializing-a-nested-structure}

You can set nested values directly using chained dots:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student s}\OperatorTok{;}
\NormalTok{s}\OperatorTok{.}\NormalTok{id }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}
\NormalTok{s}\OperatorTok{.}\NormalTok{grade }\OperatorTok{=} \FloatTok{95.0}\OperatorTok{;}

\NormalTok{s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day }\OperatorTok{=} \DecValTok{15}\OperatorTok{;}
\NormalTok{s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year }\OperatorTok{=} \DecValTok{2000}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or use a single initializer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.0}\OperatorTok{,} \OperatorTok{\{}\DecValTok{15}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{2000}\OperatorTok{\}\};}
\end{Highlighting}
\end{Shaded}

This sets the outer structure, then the inner one in order.

\subsubsection{64.4 Accessing Nested
Members}\label{accessing-nested-members}

Use the dot (\texttt{.}) to step deeper into the structure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ was born on }\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{       s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can chain as many dots as needed:

\begin{verbatim}
outer.inner.field
\end{verbatim}

It's just like reading a path, ``from the student, go to the birthday,
then to the day.''

\subsubsection{64.5 With Pointers}\label{with-pointers}

If you have a pointer to a structure that contains another structure,
use \texttt{-\textgreater{}} for the outer access, then \texttt{.} for
the inner.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{*}\NormalTok{p }\OperatorTok{=} \OperatorTok{\&}\NormalTok{s}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{{-}\textgreater{}}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Or combine both with parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \OperatorTok{(*}\NormalTok{p}\OperatorTok{).}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

But \texttt{p-\textgreater{}birthday.year} is easier to read, use it
whenever possible.

\subsubsection{64.6 Example: Student
Record}\label{example-student-record}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Student alice }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.5}\OperatorTok{,} \OperatorTok{\{}\DecValTok{15}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{2000}\OperatorTok{\}\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"ID: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{id}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Name: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Grade: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ alice}\OperatorTok{.}\NormalTok{grade}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Birthday: }\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           alice}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}
\NormalTok{           alice}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}
\NormalTok{           alice}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
ID: 1  
Name: Alice  
Grade: 95.5  
Birthday: 15/05/2000
\end{verbatim}

\subsubsection{64.7 Multiple Levels}\label{multiple-levels}

You can nest more than once, structures can contain structures that
contain others.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Address }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ city}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ country}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ Address address}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now you can do:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{s}\OperatorTok{.}\NormalTok{address}\OperatorTok{.}\NormalTok{city}\OperatorTok{,} \StringTok{"Paris"}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ lives in }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{address}\OperatorTok{.}\NormalTok{city}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Each layer adds more detail in a clear, structured way.

\subsubsection{64.8 Passing Nested Structures to
Functions}\label{passing-nested-structures-to-functions}

You can pass them the same way as normal structs, by value or pointer.

By value:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Student s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

By pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_student\_ptr}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{*}\NormalTok{s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           s}\OperatorTok{{-}\textgreater{}}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{{-}\textgreater{}}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Pointers are more efficient, especially if your structure is large.

\subsubsection{64.9 Tiny Code Example}\label{tiny-code-example-11}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Student s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ was born on }\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%02d}\StringTok{/}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{day}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{month}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Student bob }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Bob"}\OperatorTok{,} \OperatorTok{\{}\DecValTok{23}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{1999}\OperatorTok{\}\};}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{bob}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Bob was born on 23/08/1999
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-63}

Nested structures help you design data the way you think about it.
Instead of juggling multiple separate variables, you describe real
objects clearly: students with birthdays, cars with engines, orders with
dates and totals.

They make your programs more readable, more logical, and easier to
extend later.

\subsubsection{Try It Yourself}\label{try-it-yourself-63}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{struct\ Date} and \texttt{struct\ Book}, each book
  has a title, author, and publish date.
\item
  Fill in a few books and print their info with dates.
\item
  Add another level: each book has a \texttt{struct\ Price} with
  \texttt{currency} and \texttt{amount}.
\item
  Write a function that prints all fields cleanly.
\item
  Use pointers (\texttt{-\textgreater{}}) to modify inner structures.
\end{enumerate}

Once you get the hang of nesting, you'll see structures as building
blocks, small, reusable pieces that describe anything you want.

\subsection{65. Arrays of Structures}\label{arrays-of-structures}

You've seen how to make a single \texttt{struct} that groups related
data, now imagine you want to store many of them. For example, a school
doesn't have just one student, it has hundreds. A library doesn't have
just one book, it has shelves full.

That's where arrays of structures come in. They let you keep a
collection of structured records, all of the same type, in one neat
package.

\subsubsection{65.1 Why Use Arrays of
Structures}\label{why-use-arrays-of-structures}

An array stores multiple items of the same type. If each item is a
\texttt{struct}, you can manage lots of related objects together.

Example: a list of students, each with an ID, name, and grade.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student students}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

Now you can store 3 \texttt{Student} records in one array,
\texttt{students{[}0{]}}, \texttt{students{[}1{]}},
\texttt{students{[}2{]}}.

\subsubsection{65.2 Initializing the
Array}\label{initializing-the-array}

You can fill each element one by one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{students}\OperatorTok{[}\DecValTok{0}\OperatorTok{].}\NormalTok{id }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{students}\OperatorTok{[}\DecValTok{0}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{);}
\NormalTok{students}\OperatorTok{[}\DecValTok{0}\OperatorTok{].}\NormalTok{grade }\OperatorTok{=} \FloatTok{95.0}\OperatorTok{;}

\NormalTok{students}\OperatorTok{[}\DecValTok{1}\OperatorTok{].}\NormalTok{id }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{students}\OperatorTok{[}\DecValTok{1}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{);}
\NormalTok{students}\OperatorTok{[}\DecValTok{1}\OperatorTok{].}\NormalTok{grade }\OperatorTok{=} \FloatTok{88.5}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or, use a single initializer list for all of them:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student students}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.0}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{,} \FloatTok{88.5}\OperatorTok{\},}
    \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \StringTok{"Carol"}\OperatorTok{,} \FloatTok{91.2}\OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This sets up the whole table at once, clean and clear.

\subsubsection{65.3 Accessing Fields}\label{accessing-fields}

Accessing a structure inside an array is easy, use the index, then the
field:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ got }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ students}\OperatorTok{[}\DecValTok{0}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ students}\OperatorTok{[}\DecValTok{0}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

In general:

\begin{verbatim}
array[index].field
\end{verbatim}

The \texttt{.} operator always comes after the index.

\subsubsection{65.4 Looping Over an Array of
Structures}\label{looping-over-an-array-of-structures}

Because it's an array, you can loop through it with a simple
\texttt{for} loop:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%.1f}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{           students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{id}\OperatorTok{,}
\NormalTok{           students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{           students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This prints every record in one go.

Output:

\begin{verbatim}
1: Alice (95.0)  
2: Bob (88.5)  
3: Carol (91.2)
\end{verbatim}

\subsubsection{65.5 Using Arrays with
Functions}\label{using-arrays-with-functions}

You can pass the array to a function just like any other array, it
decays to a pointer. The function can then work with all the records.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print\_students}\OperatorTok{(}\KeywordTok{struct}\NormalTok{ Student list}\OperatorTok{[],} \DataTypeTok{int}\NormalTok{ count}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%.1f}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{               list}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{id}\OperatorTok{,}
\NormalTok{               list}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{               list}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call it like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{print\_students}\OperatorTok{(}\NormalTok{students}\OperatorTok{,} \DecValTok{3}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This keeps your main code simple and your logic reusable.

\subsubsection{65.6 Adding New Records}\label{adding-new-records}

You can modify elements in place:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{students}\OperatorTok{[}\DecValTok{2}\OperatorTok{].}\NormalTok{id }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{students}\OperatorTok{[}\DecValTok{2}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"Dave"}\OperatorTok{);}
\NormalTok{students}\OperatorTok{[}\DecValTok{2}\OperatorTok{].}\NormalTok{grade }\OperatorTok{=} \FloatTok{89.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Arrays let you easily update, add, or replace records by index.

\subsubsection{65.7 Searching for a
Record}\label{searching-for-a-record}

You can search an array of structures by looping through its elements:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Found Bob: grade = }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is a simple way to find data until you learn more advanced data
structures later.

\subsubsection{65.8 Arrays of Nested
Structures}\label{arrays-of-nested-structures}

If your structure contains another structure, you can still store many
of them in an array.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Date }\OperatorTok{\{} \DataTypeTok{int}\NormalTok{ day}\OperatorTok{,}\NormalTok{ month}\OperatorTok{,}\NormalTok{ year}\OperatorTok{;} \OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \KeywordTok{struct}\NormalTok{ Date birthday}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student class}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
    \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \OperatorTok{\{}\DecValTok{15}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{2000}\OperatorTok{\}\},}
    \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{,} \OperatorTok{\{}\DecValTok{20}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{1999}\OperatorTok{\}\}}
\OperatorTok{\};}

\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ was born in }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ class}\OperatorTok{[}\DecValTok{1}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}\NormalTok{ class}\OperatorTok{[}\DecValTok{1}\OperatorTok{].}\NormalTok{birthday}\OperatorTok{.}\NormalTok{year}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can mix arrays and nested structures freely, C handles it all.

\subsubsection{65.9 Tiny Code Example}\label{tiny-code-example-12}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Student students}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}
        \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.0}\OperatorTok{\},}
        \OperatorTok{\{}\DecValTok{2}\OperatorTok{,} \StringTok{"Bob"}\OperatorTok{,} \FloatTok{88.5}\OperatorTok{\},}
        \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \StringTok{"Carol"}\OperatorTok{,} \FloatTok{91.2}\OperatorTok{\}}
    \OperatorTok{\};}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Student List:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{. }\SpecialCharTok{\%s}\StringTok{ {-} Grade: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{               students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{id}\OperatorTok{,}
\NormalTok{               students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{               students}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{grade}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Student List:  
1. Alice - Grade: 95.0  
2. Bob - Grade: 88.5  
3. Carol - Grade: 91.2
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-64}

Arrays of structures let you manage collections of complex data easily.
Whether it's students, books, employees, or inventory, you'll use this
pattern again and again to build real-world programs.

It's the first step toward databases and records, storing, retrieving,
and managing lots of information clearly.

\subsubsection{Try It Yourself}\label{try-it-yourself-64}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{struct\ Book} with title, author, and price.
\item
  Make an array of 5 books and print all their titles.
\item
  Write a function that searches for a book by name.
\item
  Add a field \texttt{in\_stock} and update some records in a loop.
\item
  Print only the books that cost more than 20.
\end{enumerate}

Arrays of structures are your first taste of structured data management,
a skill you'll use in nearly every program you write from now on.

\subsection{\texorpdfstring{66. \texttt{typedefs} for Simpler
Names}{66. typedefs for Simpler Names}}\label{typedefs-for-simpler-names}

As your programs grow, your structure names can get pretty long, like
\texttt{struct\ StudentRecord} or \texttt{struct\ NetworkConfiguration}.
Typing \texttt{struct} every time can quickly become tiresome.

That's where \texttt{typedef} comes in. It lets you create shorter,
simpler names for your types, making your code easier to read and write.

\subsubsection{\texorpdfstring{66.1 What \texttt{typedef}
Does}{66.1 What typedef Does}}\label{what-typedef-does}

The \texttt{typedef} keyword creates a type alias, a new name for an
existing type. It doesn't create a new kind of data, it just gives an
existing one a nickname.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{int}\NormalTok{ Length}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{Length} means exactly the same as \texttt{int}. So you can
write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Length x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is useful when you want your code to be self-documenting.
\texttt{Length} clearly means ``this value represents a length,'' not
just any integer.

\subsubsection{\texorpdfstring{66.2 \texttt{typedef} with
\texttt{struct}}{66.2 typedef with struct}}\label{typedef-with-struct}

You can use \texttt{typedef} to remove the need to write \texttt{struct}
all the time.

Without \texttt{typedef}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Point p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

With \texttt{typedef}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}

\NormalTok{Point p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can use \texttt{Point} like a built-in type, no \texttt{struct}
keyword needed.

\subsubsection{66.3 Two Common Styles}\label{two-common-styles}

There are two popular ways to use \texttt{typedef} with structures:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Anonymous struct + typedef
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Here, you don't name the struct separately, you only use \texttt{Point}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Named struct + typedef
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Point }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This gives both the struct \emph{and} the type a name. You can still
refer to it as \texttt{struct\ Point} if needed.

Both styles are valid, choose whichever feels clearer to you.

\subsubsection{\texorpdfstring{66.4 Example Without and With
\texttt{typedef}}{66.4 Example Without and With typedef}}\label{example-without-and-with-typedef}

Without \texttt{typedef}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Student }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\};}

\KeywordTok{struct}\NormalTok{ Student s}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

With \texttt{typedef}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Student}\OperatorTok{;}

\NormalTok{Student s}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Cleaner, right? You get the same structure, but less typing and clutter.

\subsubsection{\texorpdfstring{66.5 \texttt{typedef} for
Pointers}{66.5 typedef for Pointers}}\label{typedef-for-pointers}

You can also create aliases for pointer types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{int}\OperatorTok{*}\NormalTok{ IntPtr}\OperatorTok{;}

\NormalTok{IntPtr p1}\OperatorTok{,}\NormalTok{ p2}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Be careful though, \texttt{IntPtr\ p1,\ p2;} makes both \texttt{p1} and
\texttt{p2} pointers, while \texttt{int\ *p1,\ p2;} makes only
\texttt{p1} a pointer. So typedefs can make pointer declarations
clearer.

\subsubsection{\texorpdfstring{66.6 Using \texttt{typedef} for
Readability}{66.6 Using typedef for Readability}}\label{using-typedef-for-readability}

Using descriptive typedefs makes code easier to understand:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \DataTypeTok{float}\NormalTok{ Temperature}\OperatorTok{;}
\KeywordTok{typedef} \DataTypeTok{unsigned} \DataTypeTok{long}\NormalTok{ ID}\OperatorTok{;}

\NormalTok{Temperature room }\OperatorTok{=} \FloatTok{24.5}\OperatorTok{;}
\NormalTok{ID user }\OperatorTok{=} \DecValTok{12345}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can instantly tell what each value represents, even though they're
just basic types.

\subsubsection{66.7 Combining with Arrays and
Functions}\label{combining-with-arrays-and-functions}

Once you define a typedef, you can use it everywhere, in arrays,
functions, or pointers.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ print\_point}\OperatorTok{(}\NormalTok{Point p}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Point points}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{\},} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\},} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{\}\};}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        print\_point}\OperatorTok{(}\NormalTok{points}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

No \texttt{struct} keyword needed anywhere.

\subsubsection{66.8 Another Example: Complex
Types}\label{another-example-complex-types}

Let's define a structure with nested fields:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ price}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Product}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    Product item}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ quantity}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Order}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{Order} is just a clean, readable type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Order o }\OperatorTok{=} \OperatorTok{\{\{}\StringTok{"Notebook"}\OperatorTok{,} \FloatTok{2.5}\OperatorTok{\},} \DecValTok{10}\OperatorTok{\};}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ x }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ o}\OperatorTok{.}\NormalTok{item}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ o}\OperatorTok{.}\NormalTok{quantity}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{66.9 Tiny Code Example}\label{tiny-code-example-13}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Point}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ move}\OperatorTok{(}\NormalTok{Point }\OperatorTok{*}\NormalTok{p}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dx}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ dy}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{x }\OperatorTok{+=}\NormalTok{ dx}\OperatorTok{;}
\NormalTok{    p}\OperatorTok{{-}\textgreater{}}\NormalTok{y }\OperatorTok{+=}\NormalTok{ dy}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Point p }\OperatorTok{=} \OperatorTok{\{}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{\};}
\NormalTok{    move}\OperatorTok{(\&}\NormalTok{p}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"New position: (}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{x}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\NormalTok{y}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
New position: (5, 5)
\end{verbatim}

Notice how clean it looks, no \texttt{struct} in sight!

\subsubsection{Why It Matters}\label{why-it-matters-65}

\texttt{typedef} makes your code friendlier and more expressive. It's
like giving your data types human-readable names. Instead of thinking in
terms of ``integers and structs,'' you can think in terms of Points,
Students, Orders, and Temperatures, just like in real life.

When your programs get bigger, small readability improvements make a big
difference.

\subsubsection{Try It Yourself}\label{try-it-yourself-65}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{typedef\ struct} named \texttt{Book} with
  \texttt{title} and \texttt{price}.
\item
  Make an array \texttt{Book\ library{[}3{]}} and fill it with data.
\item
  Write a function \texttt{void\ print\_book(Book\ b)} to display one
  record.
\item
  Add another \texttt{typedef} for \texttt{Price} as \texttt{float} and
  use it in your \texttt{Book}.
\item
  Compare the code before and after \texttt{typedef}, which looks easier
  to read?
\end{enumerate}

Once you start using \texttt{typedef}, you'll wonder how you ever lived
without it, it's one of those small tools that makes C feel smooth and
elegant.

\subsection{67. Enums and Symbolic
Constants}\label{enums-and-symbolic-constants}

So far, you've used numbers to represent values, \texttt{0}, \texttt{1},
\texttt{2}, and so on. But what if your program needs to deal with
categories, like days of the week, colors, or menu options?

You \emph{could} use numbers for them, but then your code ends up full
of mysterious values:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{mode }\OperatorTok{==} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{} \CommentTok{/* ??? */} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

What does \texttt{2} mean here? It's not obvious.

To make code clearer, C gives you enums, a way to give names to sets of
related integer constants.

\subsubsection{\texorpdfstring{67.1 What Is an
\texttt{enum}}{67.1 What Is an enum}}\label{what-is-an-enum}

An enumeration (or \texttt{enum}) is a type that lets you list named
constants.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Day }\OperatorTok{\{}\NormalTok{ MONDAY}\OperatorTok{,}\NormalTok{ TUESDAY}\OperatorTok{,}\NormalTok{ WEDNESDAY}\OperatorTok{,}\NormalTok{ THURSDAY}\OperatorTok{,}\NormalTok{ FRIDAY}\OperatorTok{,}\NormalTok{ SATURDAY}\OperatorTok{,}\NormalTok{ SUNDAY }\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Here, \texttt{MONDAY} is \texttt{0}, \texttt{TUESDAY} is \texttt{1}, and
so on, unless you say otherwise.

Now you can write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Day today }\OperatorTok{=}\NormalTok{ WEDNESDAY}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Much clearer than:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ today }\OperatorTok{=} \DecValTok{2}\OperatorTok{;} \CommentTok{// what does 2 mean?}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{67.2 Using \texttt{enum}
Values}{67.2 Using enum Values}}\label{using-enum-values}

You can compare or switch on them like normal integers:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{today }\OperatorTok{==}\NormalTok{ FRIDAY}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Weekend is near!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or use them in a \texttt{switch}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{today}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case}\NormalTok{ MONDAY}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Start of week!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case}\NormalTok{ FRIDAY}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Almost weekend!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Another day...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each name stands for a specific integer, but you don't have to remember
which one.

\subsubsection{67.3 Assigning Custom
Values}\label{assigning-custom-values}

By default, counting starts at \texttt{0}, but you can set your own
starting values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ ErrorCode }\OperatorTok{\{}\NormalTok{ SUCCESS }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ WARNING }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ ERROR }\OperatorTok{=} \DecValTok{2} \OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Or assign any number:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{enum}\NormalTok{ Month }\OperatorTok{\{}\NormalTok{ JAN }\OperatorTok{=} \DecValTok{1}\OperatorTok{,}\NormalTok{ FEB}\OperatorTok{,}\NormalTok{ MAR}\OperatorTok{,}\NormalTok{ APR }\OperatorTok{\};} \CommentTok{// continues as 1, 2, 3, 4}
\end{Highlighting}
\end{Shaded}

C automatically counts up from the last value.

\subsubsection{\texorpdfstring{67.4 \texttt{typedef} with
\texttt{enum}}{67.4 typedef with enum}}\label{typedef-with-enum}

You can pair \texttt{typedef} with \texttt{enum} to make it easier to
use:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    RED}\OperatorTok{,}
\NormalTok{    GREEN}\OperatorTok{,}
\NormalTok{    BLUE}
\OperatorTok{\}}\NormalTok{ Color}\OperatorTok{;}

\NormalTok{Color background }\OperatorTok{=}\NormalTok{ BLUE}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you don't need to write \texttt{enum\ Color} every time, just
\texttt{Color}.

\subsubsection{67.5 Example: Menu Options}\label{example-menu-options}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    MENU\_START}\OperatorTok{,}
\NormalTok{    MENU\_OPTIONS}\OperatorTok{,}
\NormalTok{    MENU\_EXIT}
\OperatorTok{\}}\NormalTok{ Menu}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Menu choice }\OperatorTok{=}\NormalTok{ MENU\_START}\OperatorTok{;}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{choice}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case}\NormalTok{ MENU\_START}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Game started!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ MENU\_OPTIONS}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Options menu.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case}\NormalTok{ MENU\_EXIT}\OperatorTok{:}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);} \ControlFlowTok{break}\OperatorTok{;}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Game started!
\end{verbatim}

Each option has a name, so your program reads like a story.

\subsubsection{\texorpdfstring{67.6 Mixing \texttt{enum} and
\texttt{switch}}{67.6 Mixing enum and switch}}\label{mixing-enum-and-switch}

Enums and switches work beautifully together. They make your control
flow expressive and easy to change later, just add new cases!

If you later add \texttt{MENU\_CREDITS}, you simply extend both the
\texttt{enum} and the \texttt{switch}.

\subsubsection{67.7 Enums Inside Structs}\label{enums-inside-structs}

You can even put enums inside structures:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    TASK\_TODO}\OperatorTok{,}
\NormalTok{    TASK\_IN\_PROGRESS}\OperatorTok{,}
\NormalTok{    TASK\_DONE}
\OperatorTok{\}}\NormalTok{ Status}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ title}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\NormalTok{    Status state}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Task}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Task t }\OperatorTok{=} \OperatorTok{\{}\StringTok{"Write Chapter"}\OperatorTok{,}\NormalTok{ TASK\_IN\_PROGRESS}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Enums keep your data meaningful and tidy.

\subsubsection{\texorpdfstring{67.8 Symbolic Constants with
\texttt{\#define}}{67.8 Symbolic Constants with \#define}}\label{symbolic-constants-with-define}

Before enums, many C programs used macros for named constants:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MONDAY }\DecValTok{0}
\PreprocessorTok{\#define TUESDAY }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

This works, but \texttt{enum} is safer, it creates a real type, not just
text substitution.

You can still use macros for single constants:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX\_SIZE }\DecValTok{100}
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\end{Highlighting}
\end{Shaded}

These are handy for fixed values, while enums are best for sets of
related values.

\subsubsection{67.9 Tiny Code Example}\label{tiny-code-example-14}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}
\NormalTok{    NORTH}\OperatorTok{,}
\NormalTok{    EAST}\OperatorTok{,}
\NormalTok{    SOUTH}\OperatorTok{,}
\NormalTok{    WEST}
\OperatorTok{\}}\NormalTok{ Direction}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Direction move }\OperatorTok{=}\NormalTok{ EAST}\OperatorTok{;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{move }\OperatorTok{==}\NormalTok{ EAST}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Going east!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Going east!
\end{verbatim}

Now, anyone reading your code knows what \texttt{EAST} means, no
guesswork needed.

\subsubsection{Why It Matters}\label{why-it-matters-66}

Enums turn magic numbers into meaningful names. They make your code
self-explanatory and reduce errors, you'll never mix up \texttt{0} and
\texttt{2} again when they're called \texttt{MONDAY} and
\texttt{WEDNESDAY}.

And with \texttt{typedef}, they become as easy to use as \texttt{int}.

\subsubsection{Try It Yourself}\label{try-it-yourself-66}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create an enum \texttt{TrafficLight} with \texttt{RED},
  \texttt{YELLOW}, \texttt{GREEN}.
\item
  Write a \texttt{switch} that prints what to do for each light.
\item
  Create an enum \texttt{Difficulty} for a game with \texttt{EASY},
  \texttt{MEDIUM}, \texttt{HARD}.
\item
  Use it in a struct \texttt{GameSettings} with a field for difficulty.
\item
  Mix \texttt{\#define} for constants like \texttt{MAX\_SCORE} with
  enums for categories.
\end{enumerate}

Enums help your code tell a story, instead of ``if value == 2,'' you'll
be writing ``if state == GAME\_OVER.''

\subsection{68. Unions and Shared
Memory}\label{unions-and-shared-memory}

So far, every \texttt{struct} you've written keeps all of its fields in
memory at once. But sometimes, you only need one of several possible
fields at a time.

For example, imagine a program that stores either an integer, a float,
or a string, but never more than one at once. You could use a structure
with all three fields, but that would waste space.

To save memory and represent ``one-of-many'' data, C gives you a tool
called a union.

\subsubsection{\texorpdfstring{68.1 What Is a
\texttt{union}}{68.1 What Is a union}}\label{what-is-a-union}

A \texttt{union} looks like a \texttt{struct}, but instead of separate
storage for each field, all fields share the same memory space.

Only one member can hold a value at a time.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{union}\NormalTok{ Data }\OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Here, \texttt{i}, \texttt{f}, and \texttt{str} all start at the same
memory address. If you write to one, you overwrite the others.

\subsubsection{\texorpdfstring{68.2 Declaring and Using a
\texttt{union}}{68.2 Declaring and Using a union}}\label{declaring-and-using-a-union}

You can define and use a union just like a struct:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{union}\NormalTok{ Data d}\OperatorTok{;}

\NormalTok{d}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"i = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}

\NormalTok{d}\OperatorTok{.}\NormalTok{f }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"f = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{f}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

But remember: when you set \texttt{d.f}, it overwrites the value of
\texttt{d.i}. They live in the same space.

\subsubsection{68.3 How Big Is a Union?}\label{how-big-is-a-union}

The size of a union is the size of its largest member. In our example,
\texttt{str{[}20{]}} is the largest (20 bytes), so
\texttt{sizeof(union\ Data)} is 20.

C must make sure there's enough space for the biggest member.

\subsubsection{68.4 Why Use a Union?}\label{why-use-a-union}

Unions are useful when you want one variable that can store multiple
types (but not at the same time).

They're common in:

\begin{itemize}
\tightlist
\item
  Data parsers (like reading binary files)
\item
  Interpreters or expression trees
\item
  Embedded systems, where memory is limited
\end{itemize}

They let you design memory-efficient records.

\subsubsection{\texorpdfstring{68.5 Using \texttt{typedef} with
\texttt{union}}{68.5 Using typedef with union}}\label{using-typedef-with-union}

You can make them easier to use with \texttt{typedef}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{union} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Data}\OperatorTok{;}

\NormalTok{Data value}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can just say \texttt{Data} instead of \texttt{union\ Data}.

\subsubsection{68.6 Example: Tagged Union}\label{example-tagged-union}

Because unions don't remember what type they currently hold, you often
combine them with an \texttt{enum} to track the active field.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ TYPE\_INT}\OperatorTok{,}\NormalTok{ TYPE\_FLOAT}\OperatorTok{,}\NormalTok{ TYPE\_STRING }\OperatorTok{\}}\NormalTok{ DataType}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{union} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ DataValue}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    DataType type}\OperatorTok{;}
\NormalTok{    DataValue value}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Variant}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now you can store any of the three types safely:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Variant v}\OperatorTok{;}
\NormalTok{v}\OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ TYPE\_INT}\OperatorTok{;}
\NormalTok{v}\OperatorTok{.}\NormalTok{value}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{v}\OperatorTok{.}\NormalTok{type }\OperatorTok{==}\NormalTok{ TYPE\_INT}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Integer: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ v}\OperatorTok{.}\NormalTok{value}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This pattern is called a tagged union, it's a safe, structured way to
handle mixed data.

\subsubsection{68.7 Union vs Struct}\label{union-vs-struct}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1231}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4615}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4154}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{struct}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\texttt{union}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Memory & Each member gets its own space & All members share one space \\
Size & Sum of all members & Size of largest member \\
Use case & Many values at once & One value at a time \\
\end{longtable}

\subsubsection{68.8 Real Example: Network
Packet}\label{real-example-network-packet}

Imagine reading data from a network that can be either a number or text:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum} \OperatorTok{\{}\NormalTok{ PACKET\_NUMBER}\OperatorTok{,}\NormalTok{ PACKET\_TEXT }\OperatorTok{\}}\NormalTok{ PacketType}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{union} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ number}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ text}\OperatorTok{[}\DecValTok{64}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ PacketData}\OperatorTok{;}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
\NormalTok{    PacketType type}\OperatorTok{;}
\NormalTok{    PacketData data}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Packet}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

When you read a packet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Packet p}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{type }\OperatorTok{=}\NormalTok{ PACKET\_NUMBER}\OperatorTok{;}
\NormalTok{p}\OperatorTok{.}\NormalTok{data}\OperatorTok{.}\NormalTok{number }\OperatorTok{=} \DecValTok{1001}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Later, you check \texttt{p.type} to know how to interpret
\texttt{p.data}.

\subsubsection{68.9 Tiny Code Example}\label{tiny-code-example-15}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{union} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ i}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ f}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ str}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Data}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Data d}\OperatorTok{;}

\NormalTok{    d}\OperatorTok{.}\NormalTok{i }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"i: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{i}\OperatorTok{);}

\NormalTok{    d}\OperatorTok{.}\NormalTok{f }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"f: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{f}\OperatorTok{);}

\NormalTok{    strcpy}\OperatorTok{(}\NormalTok{d}\OperatorTok{.}\NormalTok{str}\OperatorTok{,} \StringTok{"Hello"}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"str: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ d}\OperatorTok{.}\NormalTok{str}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
i: 42  
f: 3.14  
str: Hello
\end{verbatim}

Note: after writing to \texttt{str}, the values of \texttt{i} and
\texttt{f} are no longer valid, they've been overwritten.

\subsubsection{Why It Matters}\label{why-it-matters-67}

Unions teach you how memory works behind the scenes. They give you
fine-grained control, and save space when you need flexibility without
duplication.

Once you understand unions, you'll have a deeper appreciation for how C
represents data and how systems handle different types efficiently.

\subsubsection{Try It Yourself}\label{try-it-yourself-67}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{union\ Number} with \texttt{int} and \texttt{float}.
\item
  Assign each type in turn and print the value.
\item
  Build a \texttt{typedef} for a \texttt{union\ Value} with
  \texttt{int}, \texttt{float}, and \texttt{char\ text{[}20{]}}.
\item
  Combine it with an \texttt{enum} tag in a \texttt{struct\ Variant} to
  track which one is active.
\item
  Print different outputs based on the tag, just like a small variant
  type.
\end{enumerate}

Unions may seem simple, but they unlock a powerful way of thinking about
shared memory, one space, many possibilities.

\subsection{69. Organizing Code into
Modules}\label{organizing-code-into-modules}

As your C programs grow, putting everything into a single file becomes
messy fast. You'll find yourself scrolling through hundreds of lines,
variables, functions, and structures all tangled together.

That's why professional C programmers split their code into modules.
Each module focuses on one purpose, and C gives you the tools to
organize them cleanly.

\subsubsection{69.1 What Is a Module}\label{what-is-a-module}

A module is simply a pair of files that belong together:

\begin{itemize}
\tightlist
\item
  A header file (\texttt{.h}), contains declarations (what exists)
\item
  A source file (\texttt{.c}), contains definitions (how it works)
\end{itemize}

Together, they define a single logical unit of your program, maybe a
math library, a logger, or a student manager.

Example:

\begin{verbatim}
math_utils.h
math_utils.c
\end{verbatim}

This is the foundation of modular C design.

\subsubsection{69.2 Why Use Modules}\label{why-use-modules}

Modules make your program:

\begin{itemize}
\tightlist
\item
  Easier to read, one file per topic
\item
  Easier to maintain, fix or extend one piece at a time
\item
  Reusable, include the same header in many programs
\item
  Collaborative, different people can work on different parts
\end{itemize}

You don't need to scroll through unrelated code anymore.

\subsubsection{\texorpdfstring{69.3 The Header File
(\texttt{.h})}{69.3 The Header File (.h)}}\label{the-header-file-.h}

A header file declares what the module provides --- the function
prototypes, structures, and constants that others can use.

Example (\texttt{math\_utils.h}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{\#ifndef}, \texttt{\#define}, \texttt{\#endif} prevent double
  inclusion (called a \emph{header guard})
\item
  You only declare functions, not define them
\end{itemize}

\subsubsection{\texorpdfstring{69.4 The Source File
(\texttt{.c})}{69.4 The Source File (.c)}}\label{the-source-file-.c}

The source file implements how those functions actually work.

Example (\texttt{math\_utils.c}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ subtract}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notice you \texttt{\#include} your own header, that way, your function
signatures stay in sync.

\subsubsection{69.5 Using the Module}\label{using-the-module}

Now you can use this module in your main program:

\texttt{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"3 + 4 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"10 {-} 2 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ subtract}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{2}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then compile both files together:

\begin{verbatim}
gcc main.c math_utils.c -o app
\end{verbatim}

Your program now has cleanly separated parts, each focused and easy to
understand.

\subsubsection{69.6 Splitting Structures into
Modules}\label{splitting-structures-into-modules}

You can also keep structure definitions in headers, so other files can
use them:

\texttt{student.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef STUDENT\_H}
\PreprocessorTok{\#define STUDENT\_H}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Student}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\texttt{student.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"student.h"}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ {-} }\SpecialCharTok{\%s}\StringTok{: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{grade}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"student.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Student s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.0}\OperatorTok{\};}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{69.7 Header Guards}\label{header-guards-1}

Always wrap header files in include guards:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef FILE\_NAME\_H}
\PreprocessorTok{\#define FILE\_NAME\_H}
\CommentTok{// content}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

They prevent errors if the header is included more than once.

\subsubsection{69.8 Private vs Public
Functions}\label{private-vs-public-functions}

You can hide helper functions by declaring them static inside
\texttt{.c} files.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ helper}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// only visible inside this file}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This keeps your module's internal details private, only the header's
functions are public.

\subsubsection{69.9 Project Structure
Example}\label{project-structure-example}

Here's how a small project might look:

\begin{verbatim}
project/
├── main.c
├── math_utils.h
├── math_utils.c
├── student.h
├── student.c
\end{verbatim}

Each \texttt{.c} file has its own \texttt{.h} file. You include only
what you need, keeping files focused and clean.

\subsubsection{Tiny Code Example}\label{tiny-code-example-16}

math\_utils.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

math\_utils.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Square of 5: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ square}\OperatorTok{(}\DecValTok{5}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{verbatim}
gcc main.c math_utils.c -o app
\end{verbatim}

Output:

\begin{verbatim}
Square of 5: 25
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-68}

Modules turn your code into small, understandable pieces. Each file does
one job well. You don't need to scroll endlessly, just open the file you
need.

This is how real-world C projects are built, one clean module at a time.

\subsubsection{Try It Yourself}\label{try-it-yourself-68}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{math\_utils} module with \texttt{add},
  \texttt{subtract}, and \texttt{multiply} functions.
\item
  Create a \texttt{student} module with a \texttt{Student} struct and a
  \texttt{print\_student} function.
\item
  Write a \texttt{main.c} file that uses both modules.
\item
  Add include guards to your headers.
\item
  Compile everything together, see how clean your program feels.
\end{enumerate}

Once you learn modular design, your C programs go from ``long scripts''
to organized systems, easy to grow, debug, and share.

\subsection{\texorpdfstring{70. Splitting Code into \texttt{.c} and
\texttt{.h}
Files}{70. Splitting Code into .c and .h Files}}\label{splitting-code-into-.c-and-.h-files}

Now that you understand what modules are, let's look more closely at how
to split your code properly into \texttt{.c} and \texttt{.h} files. This
is one of the most important skills in C programming, it keeps your code
organized, readable, and scalable.

You've already seen examples with small modules. Here, you'll learn a
clear step-by-step process you can follow every time you make a new
module.

\subsubsection{70.1 Why Split Files}\label{why-split-files}

In small programs, you can write everything in one file. But as soon as
your code grows, it becomes confusing, functions get mixed together, and
managing them becomes a headache.

By splitting code:

\begin{itemize}
\tightlist
\item
  You separate logic from declarations
\item
  You avoid repetition (declare once, use everywhere)
\item
  You make your program easier to maintain
\end{itemize}

In short, \texttt{.h} tells the world \emph{what exists}, \texttt{.c}
shows \emph{how it works}.

\subsubsection{\texorpdfstring{70.2 What Goes in a \texttt{.h}
File}{70.2 What Goes in a .h File}}\label{what-goes-in-a-.h-file}

A header file (\texttt{.h}) contains declarations only. These are like
\emph{promises} to the compiler: ``I'll define this somewhere.''

Put in your \texttt{.h} file:

\begin{itemize}
\tightlist
\item
  Function declarations (prototypes)
\item
  \texttt{typedef}s and \texttt{struct}s
\item
  \texttt{\#define} constants
\item
  \texttt{enum} definitions
\item
  External variable declarations (if needed)
\end{itemize}

Never put function definitions or global variables here.

Example (\texttt{math\_utils.h}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

The \texttt{\#ifndef} / \texttt{\#define} / \texttt{\#endif} trio is
called a header guard. It prevents errors if this file is included
multiple times.

\subsubsection{\texorpdfstring{70.3 What Goes in a \texttt{.c}
File}{70.3 What Goes in a .c File}}\label{what-goes-in-a-.c-file}

A \texttt{.c} file contains the definitions, the actual code that does
the work.

Example (\texttt{math\_utils.c}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notice how the \texttt{.c} file includes its own header. That way, if
you change a function's signature in the \texttt{.h} file, the compiler
will catch mismatches immediately.

\subsubsection{\texorpdfstring{70.4 Using the Module in
\texttt{main.c}}{70.4 Using the Module in main.c}}\label{using-the-module-in-main.c}

Your main program includes the header and calls the functions.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{3}\OperatorTok{,}\NormalTok{ y }\OperatorTok{=} \DecValTok{4}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ squared = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x}\OperatorTok{,}\NormalTok{ square}\OperatorTok{(}\NormalTok{x}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now all three files work together.

\subsubsection{70.5 How to Compile Multiple
Files}\label{how-to-compile-multiple-files}

You can compile everything in one step:

\begin{verbatim}
gcc main.c math_utils.c -o app
\end{verbatim}

Or separately:

\begin{verbatim}
gcc -c math_utils.c   // produces math_utils.o
gcc -c main.c         // produces main.o
gcc main.o math_utils.o -o app
\end{verbatim}

The \texttt{.o} files are object files, intermediate steps before
linking.

This approach is helpful for bigger projects, where only changed files
need recompilation.

\subsubsection{70.6 Sharing Structures Between
Files}\label{sharing-structures-between-files}

If multiple files need the same structure, define it in a header so
everyone includes it.

\texttt{student.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef STUDENT\_H}
\PreprocessorTok{\#define STUDENT\_H}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{float}\NormalTok{ grade}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Student}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\texttt{student.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"student.h"}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ {-} }\SpecialCharTok{\%s}\StringTok{ (}\SpecialCharTok{\%.1f}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{name}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{grade}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"student.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Student s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{,} \FloatTok{95.5}\OperatorTok{\};}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{70.7 Keeping Functions
Private}\label{keeping-functions-private}

Not every function needs to be public. If it's only used inside one
file, make it static:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \DataTypeTok{void}\NormalTok{ log\_message}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug info}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Static functions are hidden from other files. This keeps your module's
interface small and clear.

\subsubsection{70.8 Including Headers in the Right
Order}\label{including-headers-in-the-right-order}

A good habit is to include headers in this order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The module's own header (\texttt{"file.h"})
\item
  Other project headers
\item
  Standard library headers (\texttt{\textless{}stdio.h\textgreater{}},
  \texttt{\textless{}stdlib.h\textgreater{}})
\end{enumerate}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\PreprocessorTok{\#include }\ImportTok{"student.h"}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

This helps the compiler catch missing dependencies early.

\subsubsection{70.9 Folder Organization}\label{folder-organization}

For small projects, everything can live in one folder. For larger ones,
separate by purpose:

\begin{verbatim}
/src
    main.c
    math_utils.c
    student.c
/include
    math_utils.h
    student.h
\end{verbatim}

Then compile with include paths:

\begin{verbatim}
gcc src/*.c -I include -o app
\end{verbatim}

The \texttt{-I} flag tells the compiler where to find header files.

\subsubsection{70.10 Tiny Code Example}\label{tiny-code-example-17}

math\_utils.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

math\_utils.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n }\OperatorTok{*}\NormalTok{ n}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ cubed = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,}\NormalTok{ cube}\OperatorTok{(}\NormalTok{n}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{verbatim}
gcc main.c math_utils.c -o app
\end{verbatim}

Output:

\begin{verbatim}
3 cubed = 27
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-69}

Splitting code into \texttt{.c} and \texttt{.h} files is a professional
habit. It makes your code modular, reusable, and easy to scale. Every
serious C project, from operating systems to libraries, follows this
pattern.

Once you get used to it, you'll never want to cram everything into one
file again.

\subsubsection{Try It Yourself}\label{try-it-yourself-69}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a \texttt{geometry.h} and \texttt{geometry.c} with functions
  \texttt{area\_circle} and \texttt{area\_square}.
\item
  Include \texttt{geometry.h} in \texttt{main.c} and print both areas.
\item
  Add a second module \texttt{converter.h} with
  \texttt{to\_fahrenheit()} and \texttt{to\_celsius()}.
\item
  Use both modules together.
\item
  Recompile only the files you change.
\end{enumerate}

You're now building multi-file C programs, a big step toward
professional software development.

\section{Chapter 8. The Power of the
Processor}\label{chapter-8.-the-power-of-the-processor}

\subsection{71. What Is the
Preprocessor}\label{what-is-the-preprocessor}

Before your C code is turned into a program, it passes through a special
stage called the preprocessor. Think of it as a helper that prepares
your code before the compiler starts its real work.

This step might seem invisible, but it's powerful. It can insert code,
replace text, and control which parts of your program are even compiled,
all before a single line is turned into machine instructions.

Let's see how it works.

\subsubsection{71.1 The Compilation
Pipeline}\label{the-compilation-pipeline}

When you compile a C program, it doesn't happen all at once. There are
four stages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Preprocessing, handles \texttt{\#include}, \texttt{\#define}, and
  \texttt{\#if}
\item
  Compilation, translates C into assembly
\item
  Assembly, turns assembly into machine code
\item
  Linking, connects everything into a final executable
\end{enumerate}

The preprocessor is step one, it's like a text editor that edits your
code automatically before compiling.

\subsubsection{71.2 What the Preprocessor
Does}\label{what-the-preprocessor-does}

The preprocessor reads your source file and performs directives,
commands that start with \texttt{\#}. These aren't normal C statements;
they're special instructions to the preprocessor.

Common examples:

\begin{itemize}
\tightlist
\item
  \texttt{\#include}, insert another file's contents
\item
  \texttt{\#define}, create a constant or macro
\item
  \texttt{\#if}, \texttt{\#ifdef}, \texttt{\#endif}, control what code
  is included
\end{itemize}

It's like giving your code a quick makeover before sending it off to the
compiler.

\subsubsection{71.3 Example: Expanding
Includes}\label{example-expanding-includes}

If you write:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

The preprocessor replaces that line with the entire contents of
\texttt{stdio.h}. This is how your program learns about \texttt{printf}
and other standard functions.

That means after preprocessing, your code is much bigger, but you never
see it unless you ask for it.

You can check it by running:

\begin{verbatim}
gcc -E main.c
\end{verbatim}

This shows you the preprocessed output, all macros expanded, all
includes inserted.

\subsubsection{71.4 Example: Using \#define}\label{example-using-define}

With \texttt{\#define}, you can create symbolic names or macros:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\end{Highlighting}
\end{Shaded}

Now, whenever the preprocessor sees \texttt{PI}, it replaces it with
\texttt{3.14159}. It's simple text replacement, not a variable, just a
shortcut.

You'll use \texttt{\#define} for constants, compile-time flags, or small
helper macros (we'll explore more in Section 73).

\subsubsection{71.5 Example: Conditional
Compilation}\label{example-conditional-compilation}

You can also include or skip parts of your program depending on certain
conditions.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DEBUG }\DecValTok{1}

\PreprocessorTok{\#if DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug mode on}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If \texttt{DEBUG} is defined, the code inside runs; if not, it's ignored
entirely. This is useful for debugging or platform-specific code.

\subsubsection{71.6 Preprocessor vs
Compiler}\label{preprocessor-vs-compiler}

It's important to remember: The preprocessor is not the compiler, it
doesn't check syntax, types, or logic.

It only rewrites text. The compiler only sees the \emph{final result}
after preprocessing.

So if you have:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14}
\DataTypeTok{float}\NormalTok{ area }\OperatorTok{=}\NormalTok{ PI }\OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The compiler actually sees:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ area }\OperatorTok{=} \FloatTok{3.14} \OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{71.7 Visual Picture}\label{visual-picture-2}

You can imagine the preprocessor as a ``recipe preparer'':

\begin{itemize}
\tightlist
\item
  It reads your recipe (code)
\item
  Substitutes ingredients (macros)
\item
  Adds missing steps (includes)
\item
  Removes parts you don't need (conditionals)
\end{itemize}

Only after all that does the compiler step in to cook the final dish
(binary).

\subsubsection{71.8 Tiny Code Example}\label{tiny-code-example-18}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define NAME }\StringTok{"Alice"}
\PreprocessorTok{\#define TIMES }\DecValTok{3}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if TIMES \textgreater{} 2}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, }\SpecialCharTok{\%s}\StringTok{! You\textquotesingle{}re learning C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ NAME}\OperatorTok{);}
\PreprocessorTok{\#endif}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello, Alice! You're learning C!
\end{verbatim}

If you changed \texttt{\#define\ TIMES\ 1}, that line wouldn't even be
compiled.

\subsubsection{71.9 Common Mistakes}\label{common-mistakes-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{\#}, directives must start with it.
\item
  Thinking \texttt{\#define} makes a variable, it doesn't! It's just
  text substitution.
\item
  Overusing macros when normal variables or functions would be better.
\item
  Missing \texttt{\#endif} after a conditional block.
\end{enumerate}

We'll explore each in detail soon.

\subsubsection{71.10 Why It Matters}\label{why-it-matters-70}

The preprocessor is your first gatekeeper, it controls what the compiler
actually sees. Once you understand it, you'll know how to:

\begin{itemize}
\tightlist
\item
  Split code into multiple files
\item
  Use constants and macros effectively
\item
  Include only what you need
\item
  Build code that adapts to different systems
\end{itemize}

This gives you flexibility and power, and helps you debug smarter, too.

\subsubsection{Try It Yourself}\label{try-it-yourself-70}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a simple program with \texttt{\#define\ NAME\ "World"} and
  \texttt{printf("Hello,\ \%s!\textbackslash{}n",\ NAME)}.
\item
  Use \texttt{\#if} and \texttt{\#endif} to print a message only when
  \texttt{DEBUG} is defined.
\item
  Add two \texttt{\#include} headers and run \texttt{gcc\ -E} to see
  what preprocessing does.
\item
  Experiment by defining your own constant with \texttt{\#define}.
\item
  Comment out an \texttt{\#include} and see what breaks, you'll learn
  why includes matter!
\end{enumerate}

Once you get comfortable with the preprocessor, you'll see it as your
first teammate in every C project, preparing your code before the
compiler even begins.

\subsection{\texorpdfstring{72. \texttt{\#include} and Header
Guards}{72. \#include and Header Guards}}\label{include-and-header-guards}

You've already seen \texttt{\#include} a few times, it's one of the most
common preprocessor directives in C. It's how you bring code from one
file into another, like borrowing tools from a shared toolbox.

In this section, you'll learn exactly how \texttt{\#include} works, why
we use it, and how header guards keep your code safe from duplication.

\subsubsection{\texorpdfstring{72.1 What \texttt{\#include}
Does}{72.1 What \#include Does}}\label{what-include-does}

The \texttt{\#include} directive literally copies and pastes the content
of another file into your source file, \emph{before} compilation begins.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

When the preprocessor runs, it replaces this line with the entire text
of \texttt{stdio.h}. That's how your program learns about
\texttt{printf}, \texttt{scanf}, and other standard library functions.

It's as if you typed out all the contents of \texttt{stdio.h} yourself,
but thankfully, you don't have to!

\subsubsection{72.2 Two Kinds of Includes}\label{two-kinds-of-includes}

There are two styles of \texttt{\#include}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Angle brackets \texttt{\textless{}...\textgreater{}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

  Used for system headers (from the compiler or standard library). The
  compiler searches system directories for the file.
\item
  Double quotes \texttt{"..."}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\end{Highlighting}
\end{Shaded}

  Used for your own project headers. The compiler looks in the current
  directory first, then system paths.
\end{enumerate}

If your program includes its own files, always use quotes.

\subsubsection{72.3 Why We Use Header
Files}\label{why-we-use-header-files}

Header files (\texttt{.h}) let you share declarations, functions,
structures, constants, across multiple \texttt{.c} files.

Instead of repeating code everywhere, you declare things once in a
header and include it wherever needed.

Example:

\texttt{math\_utils.h}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{math\_utils.c}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

All files share the same declaration from the header, no duplication.

\subsubsection{72.4 The Problem: Multiple
Inclusion}\label{the-problem-multiple-inclusion}

Sometimes the same header can be included more than once, directly or
indirectly. That causes redefinition errors during compilation.

For example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\PreprocessorTok{\#include }\ImportTok{"geometry.h"}\PreprocessorTok{  }\CommentTok{// geometry.h also includes math\_utils.h}
\end{Highlighting}
\end{Shaded}

Now \texttt{math\_utils.h} is included twice, and the compiler
complains.

To fix this, C programmers use header guards.

\subsubsection{72.5 What Are Header
Guards}\label{what-are-header-guards}

A header guard is a simple pattern that prevents a file from being
included more than once.

At the top of your header:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}
\end{Highlighting}
\end{Shaded}

At the bottom:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Together, these lines mean:

\begin{itemize}
\tightlist
\item
  If \texttt{MATH\_UTILS\_H} is not yet defined, define it and include
  this file.
\item
  If it's already defined, skip it, because we've seen this file before.
\end{itemize}

So the full header looks like:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This simple trick prevents duplicate definitions.

\subsubsection{72.6 How It Works}\label{how-it-works-1}

Let's walk through it:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The first time the file is included, \texttt{MATH\_UTILS\_H} is not
  defined → file contents are added.
\item
  The preprocessor defines \texttt{MATH\_UTILS\_H}.
\item
  The second time, \texttt{MATH\_UTILS\_H} is defined → the preprocessor
  skips the file.
\end{enumerate}

So no matter how many times it's included, it's only processed once.

\subsubsection{72.7 Choosing a Guard Name}\label{choosing-a-guard-name}

The name after \texttt{\#ifndef} should be unique, usually based on the
file name:

\begin{itemize}
\tightlist
\item
  \texttt{math\_utils.h} → \texttt{MATH\_UTILS\_H}
\item
  \texttt{student\_record.h} → \texttt{STUDENT\_RECORD\_H}
\end{itemize}

Avoid generic names like \texttt{HEADER\_H}, they might clash with
others.

\subsubsection{72.8 Example with Header
Guard}\label{example-with-header-guard}

\texttt{student.h}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef STUDENT\_H}
\PreprocessorTok{\#define STUDENT\_H}

\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\}}\NormalTok{ Student}\OperatorTok{;}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\texttt{main.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"student.h"}
\PreprocessorTok{\#include }\ImportTok{"student.h"}\PreprocessorTok{  }\CommentTok{// accidentally included twice}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    Student s }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \StringTok{"Alice"}\OperatorTok{\};}
\NormalTok{    print\_student}\OperatorTok{(}\NormalTok{s}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{student.c}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"student.h"}

\DataTypeTok{void}\NormalTok{ print\_student}\OperatorTok{(}\NormalTok{Student s}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ {-} }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ s}\OperatorTok{.}\NormalTok{name}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Even though it's included twice, the header guard protects you.

\subsubsection{72.9 Tiny Code Example}\label{tiny-code-example-19}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"3 + 4 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

math\_utils.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

math\_utils.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile:

\begin{verbatim}
gcc main.c math_utils.c -o app
\end{verbatim}

Output:

\begin{verbatim}
3 + 4 = 7
\end{verbatim}

Safe, simple, and modular.

\subsubsection{72.10 Why It Matters}\label{why-it-matters-71}

\texttt{\#include} and header guards are how C keeps big programs
organized. They let you:

\begin{itemize}
\tightlist
\item
  Share code safely across files
\item
  Avoid redefinition errors
\item
  Manage large projects with confidence
\end{itemize}

Every serious C program, from a simple calculator to a full operating
system, uses header guards. They're part of writing professional,
maintainable C.

\subsubsection{Try It Yourself}\label{try-it-yourself-71}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a header file \texttt{greetings.h} with a function
  \texttt{void\ say\_hello(void);}
\item
  Add a guard called \texttt{GREETINGS\_H}.
\item
  Write \texttt{greetings.c} that defines \texttt{say\_hello}.
\item
  Include it twice in \texttt{main.c}, it should still compile fine.
\item
  Try removing the guard to see what error appears.
\end{enumerate}

Once you see how \texttt{\#include} and header guards work together,
you'll understand how large C programs stay neat, safe, and error-free.

\subsection{\texorpdfstring{73. Defining Macros with
\texttt{\#define}}{73. Defining Macros with \#define}}\label{defining-macros-with-define}

In C, the \texttt{\#define} directive lets you create macros, short,
simple replacements that happen \emph{before} your code is compiled. You
can use them for constants, code shortcuts, and even small function-like
snippets.

They're part of the preprocessor's job: before the compiler ever sees
your code, the preprocessor replaces every macro with what it stands
for.

Think of them as little ``search and replace'' helpers that make your
code more readable and flexible.

\subsubsection{73.1 What Is a Macro}\label{what-is-a-macro}

A macro is a name that stands for something else. It doesn't take up
memory or store a value, it's just text substitution.

Basic form:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define NAME value}
\end{Highlighting}
\end{Shaded}

Whenever the preprocessor sees \texttt{NAME}, it replaces it with
\texttt{value}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\PreprocessorTok{\#define MAX\_SIZE }\DecValTok{100}
\end{Highlighting}
\end{Shaded}

Now \texttt{PI} and \texttt{MAX\_SIZE} are symbolic constants. If you
write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ area }\OperatorTok{=}\NormalTok{ PI }\OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

the preprocessor changes it to:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ area }\OperatorTok{=} \FloatTok{3.14159} \OperatorTok{*}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You don't need semicolons or an equals sign, \texttt{\#define} is not a
statement, it's a directive.

\subsubsection{73.2 Why Use Macros for
Constants}\label{why-use-macros-for-constants}

Macros make code easier to read and maintain.

If you ever want to change a value, you change it once:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define TAX\_RATE }\FloatTok{0.15}
\end{Highlighting}
\end{Shaded}

Then use \texttt{TAX\_RATE} everywhere. No need to hunt down every
\texttt{0.15} in your code.

This also reduces mistakes, it's clear what each constant means.

\subsubsection{73.3 No Semicolon Needed}\label{no-semicolon-needed}

A common beginner mistake is adding a semicolon:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14}\OperatorTok{;}\PreprocessorTok{ }\CommentTok{// ❌ Wrong}
\end{Highlighting}
\end{Shaded}

That semicolon becomes part of the replacement, which breaks your code.

Correct version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14}\PreprocessorTok{  }\CommentTok{// ✅ Right}
\end{Highlighting}
\end{Shaded}

Remember: \texttt{\#define} is a replacement rule, not a statement.

\subsubsection{73.4 Macros Are Not
Variables}\label{macros-are-not-variables}

Macros don't have types or addresses. You can't use \texttt{\&PI} or
\texttt{scanf("\%f",\ \&PI)}, that doesn't make sense.

If you need a modifiable value, use a variable:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ pi }\OperatorTok{=} \FloatTok{3.14}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If it's a fixed constant, \texttt{\#define} is fine, or better yet, use
\texttt{const} (we'll compare soon).

\subsubsection{73.5 Function-like Macros}\label{function-like-macros}

You can also make macros that behave like tiny functions:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

When you write:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=}\NormalTok{ SQUARE}\OperatorTok{(}\DecValTok{5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

the preprocessor turns it into:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \OperatorTok{((}\DecValTok{5}\OperatorTok{)} \OperatorTok{*} \OperatorTok{(}\DecValTok{5}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

This happens before compilation, there's no function call at runtime,
just a direct substitution.

\subsubsection{73.6 Be Careful with
Parentheses}\label{be-careful-with-parentheses}

Macros don't understand math, they're just text substitution. So always
use parentheses to avoid surprises.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DOUBLE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ x }\OperatorTok{+}\PreprocessorTok{ x  }\CommentTok{// ❌ Dangerous}
\DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{3} \OperatorTok{*}\NormalTok{ DOUBLE}\OperatorTok{(}\DecValTok{2}\OperatorTok{);}  \CommentTok{// expands to 3 * 2 + 2 → 8, not 12}
\end{Highlighting}
\end{Shaded}

Fix:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DOUBLE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{+}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}\PreprocessorTok{  }\CommentTok{// ✅ Safe}
\end{Highlighting}
\end{Shaded}

Now it expands to \texttt{3\ *\ ((2)\ +\ (2))\ →\ 12}.

This is one of the most important macro rules: wrap everything in
parentheses.

\subsubsection{73.7 Multi-line Macros}\label{multi-line-macros}

You can write macros that span multiple lines using a backslash
\texttt{\textbackslash{}} at the end of each line:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DEBUG\_LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"Debug: }\SpecialCharTok{\%s}\StringTok{ (line }\SpecialCharTok{\%d}\StringTok{)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This macro prints a message along with the current line number, useful
for quick debugging.

\subsubsection{73.8 Built-in Macro
Helpers}\label{built-in-macro-helpers}

C provides special predefined macros you can use:

\begin{itemize}
\tightlist
\item
  \texttt{\_\_FILE\_\_} → current file name
\item
  \texttt{\_\_LINE\_\_} → current line number
\item
  \texttt{\_\_DATE\_\_} → date of compilation
\item
  \texttt{\_\_TIME\_\_} → time of compilation
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Compiled from }\SpecialCharTok{\%s}\StringTok{ at line }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_FILE\_\_}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

These are great for debugging or logging.

\subsubsection{\texorpdfstring{73.9 Macros vs
\texttt{const}}{73.9 Macros vs const}}\label{macros-vs-const}

In modern C, \texttt{const} variables are often better than macros for
constants:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{const} \DataTypeTok{float}\NormalTok{ PI }\OperatorTok{=} \FloatTok{3.14159}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Why?

\begin{itemize}
\tightlist
\item
  \texttt{const} has a type (safer)
\item
  Errors are easier to debug
\item
  Works with debuggers and type checkers
\end{itemize}

Use \texttt{\#define} when:

\begin{itemize}
\tightlist
\item
  You need conditional compilation
\item
  You want a function-like macro
\item
  You're defining something not tied to a type
\end{itemize}

Otherwise, prefer \texttt{const} for plain constants.

\subsubsection{73.10 Tiny Code Example}\label{tiny-code-example-20}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\PreprocessorTok{\#define AREA\_CIRCLE}\OperatorTok{(}\PreprocessorTok{r}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{PI }\OperatorTok{*}\PreprocessorTok{ SQUARE}\OperatorTok{(}\PreprocessorTok{r}\OperatorTok{))}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Radius: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Area: }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ AREA\_CIRCLE}\OperatorTok{(}\NormalTok{r}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Radius: 2.00  
Area: 12.57
\end{verbatim}

The macros expand before compilation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AREA\_CIRCLE}\OperatorTok{(}\NormalTok{r}\OperatorTok{)}\NormalTok{ → }\OperatorTok{(}\FloatTok{3.14159} \OperatorTok{*} \OperatorTok{((}\NormalTok{r}\OperatorTok{)} \OperatorTok{*} \OperatorTok{(}\NormalTok{r}\OperatorTok{)))}
\end{Highlighting}
\end{Shaded}

No function calls, just substitution.

\subsubsection{Why It Matters}\label{why-it-matters-72}

Macros are like lightweight tools that make your code flexible and
expressive. You can define constants, create shortcuts, and even write
mini-functions, all handled before your code compiles.

But remember, they're text replacements, not smart code. Use
parentheses, keep them simple, and prefer \texttt{const} when you need
real variables.

\subsubsection{Try It Yourself}\label{try-it-yourself-72}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define \texttt{PI} and \texttt{GRAVITY} with \texttt{\#define} and
  print them.
\item
  Write a macro \texttt{CUBE(x)} that calculates \texttt{x\ *\ x\ *\ x}.
\item
  Write a macro \texttt{MAX(a,\ b)} that returns the larger of two
  numbers.
\item
  Add a \texttt{DEBUG\_LOG(msg)} macro using \texttt{\_\_FILE\_\_} and
  \texttt{\_\_LINE\_\_}.
\item
  Compare a \texttt{\#define} constant with a \texttt{const} variable,
  notice the difference.
\end{enumerate}

Once you master \texttt{\#define}, you'll see it everywhere, in headers,
libraries, and your own reusable code.

\subsection{74. Working with Paths and
Filenames}\label{working-with-paths-and-filenames}

Whenever you include a header file or open a file in C, you're dealing
with paths, addresses that tell your program where to look. Getting
paths right is important because your compiler and your program both
need to know exactly where files live.

Let's break it down step by step so it feels simple and natural.

\subsubsection{74.1 What Is a Path}\label{what-is-a-path}

A path is just the \emph{location} of a file in your system. When you
tell C to include or open something, you're really saying,

\begin{quote}
``Go find this file at this address.''
\end{quote}

There are two main kinds of paths:

\begin{itemize}
\tightlist
\item
  Absolute path, starts from the root (like
  \texttt{/home/user/project/math\_utils.h})
\item
  Relative path, starts from where your program is (like
  \texttt{./math\_utils.h} or \texttt{../include/math\_utils.h})
\end{itemize}

Think of it like giving directions:

\begin{itemize}
\tightlist
\item
  Absolute path → the full address.
\item
  Relative path → directions from where you currently are.
\end{itemize}

\subsubsection{\texorpdfstring{74.2 Paths in
\texttt{\#include}}{74.2 Paths in \#include}}\label{paths-in-include}

When you use \texttt{\#include}, you're asking the preprocessor to pull
another file into your source code. C supports two ways to specify paths
here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Angle brackets \texttt{\textless{}...\textgreater{}} for system or
  library headers

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

  This tells the compiler,

  \begin{quote}
  ``Search the system include directories.''
  \end{quote}
\item
  Double quotes \texttt{"..."} for your own files

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\end{Highlighting}
\end{Shaded}

  This tells the compiler,

  \begin{quote}
  ``Look in the current folder first, then in the system directories.''
  \end{quote}
\end{enumerate}

\subsubsection{74.3 Including Files from
Subfolders}\label{including-files-from-subfolders}

If your project grows, you'll likely organize it into folders:

\begin{verbatim}
project/
├── src/
│   └── main.c
└── include/
    └── math_utils.h
\end{verbatim}

From \texttt{main.c}, you can include the header using a relative path:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"../include/math\_utils.h"}
\end{Highlighting}
\end{Shaded}

Or you can add \texttt{include/} to your compiler's search path:

\begin{verbatim}
gcc src/main.c -I include -o app
\end{verbatim}

Now you can simply write:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\end{Highlighting}
\end{Shaded}

The \texttt{-I} option tells the compiler,

\begin{quote}
``Also look inside this directory for headers.''
\end{quote}

\subsubsection{74.4 Why Folder Organization
Matters}\label{why-folder-organization-matters}

Separating headers and source files makes projects easier to manage. A
common layout looks like this:

\begin{verbatim}
/project
    /include    → header files (.h)
    /src        → source files (.c)
    /build      → compiled output
\end{verbatim}

With this setup:

\begin{itemize}
\tightlist
\item
  All your interfaces live in \texttt{/include}
\item
  All your logic lives in \texttt{/src}
\item
  You include headers using \texttt{-I\ include}
\end{itemize}

Clean and predictable, perfect for bigger programs.

\subsubsection{74.5 Common Relative Path
Symbols}\label{common-relative-path-symbols}

In file paths:

\begin{itemize}
\tightlist
\item
  \texttt{.} means ``current directory''
\item
  \texttt{..} means ``one directory up''
\end{itemize}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"../common/util.h"}\PreprocessorTok{  }\CommentTok{// go up one level, then into common/}
\PreprocessorTok{\#include }\ImportTok{"./math\_utils.h"}\PreprocessorTok{    }\CommentTok{// same directory}
\end{Highlighting}
\end{Shaded}

You can use these in both \texttt{\#include} and file I/O.

\subsubsection{74.6 Paths in File I/O}\label{paths-in-file-io}

When you open files in C using \texttt{fopen}, paths matter there too.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This looks for \texttt{data.txt} in the current working directory,
usually where you run your program from, not necessarily where the
source code is.

If your file is elsewhere, use a relative or absolute path:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"../resources/data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If the file can't be found, \texttt{fopen} returns \texttt{NULL}. Always
check before using it:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Could not open file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{74.7 Avoid Hardcoding Absolute
Paths}\label{avoid-hardcoding-absolute-paths}

It's tempting to write something like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fopen}\OperatorTok{(}\StringTok{"/Users/alice/Desktop/data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

But that only works on \emph{your} computer. If someone else runs it,
their path will be different.

Prefer relative paths (like \texttt{"../data.txt"}) or configuration
options so your code is portable.

\subsubsection{74.8 Using Paths in Larger
Projects}\label{using-paths-in-larger-projects}

As projects grow, you'll often:

\begin{itemize}
\tightlist
\item
  Put headers in an \texttt{include/} folder
\item
  Add \texttt{-I\ include} to compiler commands
\item
  Put sources in \texttt{src/}
\item
  Include headers with simple names like \texttt{"math\_utils.h"}
\end{itemize}

You can even have nested includes like:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"geometry/circle.h"}
\end{Highlighting}
\end{Shaded}

if your folder structure is:

\begin{verbatim}
include/
    geometry/
        circle.h
\end{verbatim}

C's preprocessor will treat the \texttt{/} as a path separator, no
special syntax needed.

\subsubsection{74.9 Tiny Code Example}\label{tiny-code-example-21}

\begin{verbatim}
project/
├── include/
│   └── math_utils.h
└── src/
    ├── main.c
    └── math_utils.c
\end{verbatim}

include/math\_utils.h

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef MATH\_UTILS\_H}
\PreprocessorTok{\#define MATH\_UTILS\_H}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}

\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

src/math\_utils.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

src/main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"3 + 4 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile from the project root:

\begin{verbatim}
gcc src/*.c -I include -o app
\end{verbatim}

Output:

\begin{verbatim}
3 + 4 = 7
\end{verbatim}

Your program finds headers correctly and stays neatly organized.

\subsubsection{74.10 Why It Matters}\label{why-it-matters-73}

Working with paths is about clarity and portability. When your project
is well organized and your includes are clean:

\begin{itemize}
\tightlist
\item
  You always know where things live
\item
  The compiler always knows where to look
\item
  Your code runs smoothly on any system
\end{itemize}

Once you start managing multi-file projects, clean paths become a habit,
and your programs start to look truly professional.

\subsubsection{Try It Yourself}\label{try-it-yourself-73}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a folder \texttt{project/} with subfolders \texttt{src/} and
  \texttt{include/}.
\item
  Write \texttt{math\_utils.h} and \texttt{math\_utils.c} and include
  them in \texttt{main.c}.
\item
  Compile using \texttt{-I\ include}.
\item
  Add another folder \texttt{geometry/} inside \texttt{include/} and
  make a \texttt{circle.h}.
\item
  Try including it using \texttt{\#include\ "geometry/circle.h"}.
\end{enumerate}

Once you're comfortable with paths and filenames, you'll never feel lost
in multi-file C programs again.

\subsection{\texorpdfstring{75. Conditional Compilation with
\texttt{\#if} and
\texttt{\#ifdef}}{75. Conditional Compilation with \#if and \#ifdef}}\label{conditional-compilation-with-if-and-ifdef}

Sometimes, you want your program to include or skip certain parts of
code, depending on the situation. Maybe you're adding debugging
messages, or you need to compile differently for Windows vs Linux.

That's where conditional compilation comes in. It lets you control what
gets compiled, all through the preprocessor.

\subsubsection{75.1 What Conditional Compilation
Means}\label{what-conditional-compilation-means}

Normally, the compiler reads every line of your program. But with
conditional compilation, you can tell it:

\begin{quote}
``Only compile this part if a certain condition is true.''
\end{quote}

That's handled by preprocessor directives like:

\begin{itemize}
\tightlist
\item
  \texttt{\#if}
\item
  \texttt{\#ifdef}
\item
  \texttt{\#ifndef}
\item
  \texttt{\#else}
\item
  \texttt{\#elif}
\item
  \texttt{\#endif}
\end{itemize}

Think of them like \texttt{if} statements for the compiler itself,
deciding which lines \emph{exist} in your final program.

\subsubsection{\texorpdfstring{75.2 The Basic
\texttt{\#if}}{75.2 The Basic \#if}}\label{the-basic-if}

You can test simple conditions using \texttt{\#if} and \texttt{\#endif}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DEBUG }\DecValTok{1}

\PreprocessorTok{\#if DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debugging is on!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If \texttt{DEBUG} is defined as \texttt{1} (true), the code inside runs.
If it's \texttt{0}, the preprocessor skips it entirely.

You can also combine conditions:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if DEBUG \&\& VERBOSE}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Extra details...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

The preprocessor understands basic arithmetic and logic:

\begin{itemize}
\tightlist
\item
  \texttt{==}, \texttt{!=}, \texttt{\textless{}},
  \texttt{\textgreater{}}, \texttt{\&\&}, \texttt{\textbar{}\textbar{}},
  \texttt{!}
\item
  Numbers only, not variables or functions
\end{itemize}

\subsubsection{\texorpdfstring{75.3 \texttt{\#ifdef} and
\texttt{\#ifndef}}{75.3 \#ifdef and \#ifndef}}\label{ifdef-and-ifndef}

These two check whether a macro exists, not its value.

\begin{itemize}
\tightlist
\item
  \texttt{\#ifdef} means ``if defined''
\item
  \texttt{\#ifndef} means ``if not defined''
\end{itemize}

Examples:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug mode enabled}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef DEBUG}
    \PreprocessorTok{\#define DEBUG }\DecValTok{1}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

These are great for feature flags or header guards.

\subsubsection{\texorpdfstring{75.4 Combining with \texttt{\#else} and
\texttt{\#elif}}{75.4 Combining with \#else and \#elif}}\label{combining-with-else-and-elif}

You can also give alternatives:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define OS\_WINDOWS }\DecValTok{1}

\PreprocessorTok{\#if OS\_WINDOWS}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on Windows}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on another OS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Or chain conditions:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define OS }\DecValTok{2}

\PreprocessorTok{\#if OS == 1}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Windows}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif OS == 2}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Linux}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Other}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This way, your program adapts automatically depending on what's defined.

\subsubsection{75.5 Example: Debug Mode}\label{example-debug-mode}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define DEBUG }\DecValTok{1}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug info: starting program...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you set \texttt{DEBUG} to \texttt{0}, the debug message disappears
completely from the compiled program. It's as if it never existed.

\subsubsection{75.6 Defining Macros from the Command
Line}\label{defining-macros-from-the-command-line}

You don't even have to edit your code, you can define macros right from
the compiler command:

\begin{verbatim}
gcc main.c -DDEBUG=1 -o app
\end{verbatim}

Now \texttt{DEBUG} is defined for this build. You can toggle features
just by changing the build command, handy for testing or releases.

\subsubsection{75.7 Example: Cross-Platform
Code}\label{example-cross-platform-code}

You can use macros to handle different systems:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#ifdef \_WIN32}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on Windows}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif \_\_linux\_\_}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running on Linux}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Unknown system}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compilers often define platform macros automatically. So your code can
adapt to the environment without manual changes.

\subsubsection{75.8 Conditional Function
Definitions}\label{conditional-function-definitions}

Sometimes, you may want to include different functions for different
cases:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if DEBUG}
\DataTypeTok{void}\NormalTok{ log\_message}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"LOG: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}
\OperatorTok{\}}
\PreprocessorTok{\#else}
\DataTypeTok{void}\NormalTok{ log\_message}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// do nothing in release mode}
\OperatorTok{\}}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This keeps your interface consistent (\texttt{log\_message} always
exists), but its behavior depends on the build.

\subsubsection{75.9 Common Pitfalls}\label{common-pitfalls}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{\#endif}, always close your condition.
\item
  Mixing preprocessor with runtime logic, remember, these are checked
  \emph{before compilation}.
\item
  Overcomplicating, keep conditions clear and short.
\item
  No semicolons, these are not C statements, so don't add \texttt{;}
  after them.
\end{enumerate}

\subsubsection{75.10 Tiny Code Example}\label{tiny-code-example-22}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define DEBUG }\DecValTok{1}
\PreprocessorTok{\#define VERSION }\DecValTok{2}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\PreprocessorTok{\#if DEBUG}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Debug mode active}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}

\PreprocessorTok{\#if VERSION == 1}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Version 1 features}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#elif VERSION == 2}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Version 2 features}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Unknown version}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Change the macro values and recompile, watch how the output changes.

\subsubsection{Why It Matters}\label{why-it-matters-74}

Conditional compilation gives you control. You decide what's built and
what's ignored, all without touching the main logic.

It's essential for:

\begin{itemize}
\tightlist
\item
  Debugging
\item
  Cross-platform builds
\item
  Optional features
\item
  Release vs development modes
\end{itemize}

Once you understand it, you can make one codebase that adapts to many
situations.

\subsubsection{Try It Yourself}\label{try-it-yourself-74}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define \texttt{DEBUG} and print messages only when it's on.
\item
  Create \texttt{VERSION} and switch between ``Lite'' and ``Pro''
  features.
\item
  Use \texttt{\#ifndef} to add a header guard.
\item
  Define a macro from the command line (\texttt{-DDEBUG=1}).
\item
  Build once with \texttt{DEBUG=1} and again with \texttt{DEBUG=0},
  compare outputs.
\end{enumerate}

With these tools, you're now ready to write flexible, configurable C
programs that fit every build and platform.

\subsection{76. Function-like Macros}\label{function-like-macros-1}

So far, you've seen \texttt{\#define} used for simple constants, like

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\end{Highlighting}
\end{Shaded}

But macros can do more than stand in for numbers, they can act like tiny
functions. These are called function-like macros, and they're a powerful
part of C's preprocessor.

They don't actually create a function. Instead, they perform text
substitution, replacing code before compilation. Used carefully, they
can make your programs shorter and more flexible.

\subsubsection{76.1 What Is a Function-like
Macro}\label{what-is-a-function-like-macro}

A function-like macro looks like a function, but it's really just a
shortcut:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

When the preprocessor sees \texttt{SQUARE(5)}, it replaces it with:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{((}\DecValTok{5}\OperatorTok{)} \OperatorTok{*} \OperatorTok{(}\DecValTok{5}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

This happens before the compiler runs, so there's no function call
overhead, just plain code after expansion.

\subsubsection{76.2 Why Use Function-like
Macros}\label{why-use-function-like-macros}

They can:

\begin{itemize}
\tightlist
\item
  Save typing for short, repeated operations
\item
  Make simple inline code clearer
\item
  Avoid runtime overhead
\end{itemize}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define CUBE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

You can now write \texttt{CUBE(n)} instead of \texttt{n\ *\ n\ *\ n}.

But because macros are text substitutions, not real functions, you need
to be careful with how you write them.

\subsubsection{76.3 Always Use
Parentheses}\label{always-use-parentheses}

This is the golden rule of macros. Wrap every parameter and the whole
expression in parentheses.

Without parentheses, operator precedence can break your code.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DOUBLE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ x }\OperatorTok{+}\PreprocessorTok{ x}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{3} \OperatorTok{*}\NormalTok{ DOUBLE}\OperatorTok{(}\DecValTok{2}\OperatorTok{);}  \CommentTok{// expands to 3 * 2 + 2 = 8}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define DOUBLE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{+}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{3} \OperatorTok{*}\NormalTok{ DOUBLE}\OperatorTok{(}\DecValTok{2}\OperatorTok{);}  \CommentTok{// expands to 3 * ((2) + (2)) = 12}
\end{Highlighting}
\end{Shaded}

The parentheses keep operations safe and predictable.

\subsubsection{76.4 Macros with Multiple
Arguments}\label{macros-with-multiple-arguments}

Macros can take more than one argument:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textgreater{}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{?}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{:}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

Now \texttt{MAX(3,\ 5)} becomes
\texttt{((3)\ \textgreater{}\ (5)\ ?\ (3)\ :\ (5))}, which evaluates to
\texttt{5}.

You can use this anywhere a normal expression would fit.

\subsubsection{76.5 Example: Area and
Perimeter}\label{example-area-and-perimeter}

Let's use macros to calculate shapes:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define AREA\_RECT}\OperatorTok{(}\PreprocessorTok{w}\OperatorTok{,}\PreprocessorTok{ h}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{w}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{h}\OperatorTok{))}
\PreprocessorTok{\#define PERIM\_RECT}\OperatorTok{(}\PreprocessorTok{w}\OperatorTok{,}\PreprocessorTok{ h}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{(}\DecValTok{2}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{w}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{+}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{h}\OperatorTok{)))}
\end{Highlighting}
\end{Shaded}

Then:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ w }\OperatorTok{=} \DecValTok{5}\OperatorTok{,}\NormalTok{ h }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Area: }\SpecialCharTok{\%d}\StringTok{, Perimeter: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ AREA\_RECT}\OperatorTok{(}\NormalTok{w}\OperatorTok{,}\NormalTok{ h}\OperatorTok{),}\NormalTok{ PERIM\_RECT}\OperatorTok{(}\NormalTok{w}\OperatorTok{,}\NormalTok{ h}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Area: 15, Perimeter: 16
\end{verbatim}

Simple, readable, and fast.

\subsubsection{76.6 Beware of Side
Effects}\label{beware-of-side-effects}

Because macros duplicate arguments, using them with functions or
increments can cause surprises.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ SQUARE}\OperatorTok{(}\NormalTok{n}\OperatorTok{++);}  \CommentTok{// expands to ((n++) * (n++))}
\end{Highlighting}
\end{Shaded}

This increments \texttt{n} twice, unexpected behavior! Avoid using
macros with expressions that change values (like \texttt{++},
\texttt{-\/-}, or function calls).

If you need safety, write a real function instead.

\subsubsection{76.7 Macro Naming
Conventions}\label{macro-naming-conventions}

To make macros stand out, many programmers use uppercase names:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ABS}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textless{}}\PreprocessorTok{ }\DecValTok{0}\PreprocessorTok{ }\OperatorTok{?}\PreprocessorTok{ }\OperatorTok{{-}(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{:}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

This helps you quickly recognize them in code and avoid naming conflicts
with variables or functions.

\subsubsection{76.8 Debugging Macro
Expansions}\label{debugging-macro-expansions}

You can inspect what macros expand to by using:

\begin{verbatim}
gcc -E file.c
\end{verbatim}

This runs only the preprocessor and shows the expanded source. It's
helpful when something behaves unexpectedly.

\subsubsection{76.9 Tiny Code Example}\label{tiny-code-example-23}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\PreprocessorTok{\#define MAX}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textgreater{}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{?}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{:}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{4}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{6}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"SQUARE(}\SpecialCharTok{\%d}\StringTok{) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ SQUARE}\OperatorTok{(}\NormalTok{a}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"MAX(}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%d}\StringTok{) = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ MAX}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
SQUARE(4) = 16
MAX(4, 6) = 6
\end{verbatim}

Everything happens at compile time, no function calls, just expanded
code.

\subsubsection{76.10 When to Use (and When Not
To)}\label{when-to-use-and-when-not-to}

Use function-like macros for:

\begin{itemize}
\tightlist
\item
  Small, simple, pure expressions
\item
  Operations that won't cause side effects
\item
  Cases where performance matters and inline code helps
\end{itemize}

Avoid them when:

\begin{itemize}
\tightlist
\item
  You need type checking
\item
  You need complex logic
\item
  You're calling functions or using \texttt{++} inside
\end{itemize}

If in doubt, use a \texttt{static\ inline} function instead, safer,
type-checked, and just as fast.

\subsubsection{Why It Matters}\label{why-it-matters-75}

Function-like macros can make your code shorter and faster, but they
also demand care.

With parentheses and caution, they're a handy tool. Once you understand
their behavior, you'll know when a macro is helpful, and when a function
is the better choice.

\subsubsection{Try It Yourself}\label{try-it-yourself-75}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write macros \texttt{CUBE(x)} and \texttt{ABS(x)}, test with negative
  numbers.
\item
  Write \texttt{MAX(a,\ b)} and \texttt{MIN(a,\ b)} and try different
  pairs.
\item
  Experiment with bad parentheses, see what goes wrong!
\item
  Try expanding your code with \texttt{gcc\ -E} to see macro
  replacements.
\item
  Compare a macro and a real function, see which is safer or clearer.
\end{enumerate}

Soon you'll be writing macros like a pro, simple, safe, and easy to
read.

\subsection{\texorpdfstring{77. Debugging with \texttt{\#error} and
\texttt{\#warning}}{77. Debugging with \#error and \#warning}}\label{debugging-with-error-and-warning}

Sometimes, your program might compile when it shouldn't, maybe a setting
is wrong, a platform isn't supported, or a constant is missing. Wouldn't
it be nice if the compiler could stop and tell you exactly what's wrong?

That's exactly what \texttt{\#error} and \texttt{\#warning} do. They're
special preprocessor directives that let you display messages (and even
halt compilation) when conditions aren't met.

Think of them as little safety guards that speak up before the compiler
makes a mistake.

\subsubsection{\texorpdfstring{77.1 What Is
\texttt{\#error}}{77.1 What Is \#error}}\label{what-is-error}

The \texttt{\#error} directive stops compilation immediately and prints
a custom message.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#error "Your message here"}
\end{Highlighting}
\end{Shaded}

When the preprocessor sees this line, it refuses to continue, it shows
your message and exits with an error.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if \_\_STDC\_VERSION\_\_ \textless{} 202000L}
\PreprocessorTok{\#error "This program requires a modern C compiler"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If your compiler doesn't meet that version, you'll get:

\begin{verbatim}
error: This program requires a modern C compiler
\end{verbatim}

The program won't compile until you fix the issue.

\subsubsection{\texorpdfstring{77.2 Why Use
\texttt{\#error}}{77.2 Why Use \#error}}\label{why-use-error}

You can use it to:

\begin{itemize}
\tightlist
\item
  Enforce minimum compiler versions
\item
  Prevent unsupported builds
\item
  Catch missing definitions or bad configurations
\item
  Warn other developers when something's misused
\end{itemize}

It's a friendly way to fail early, better to stop at compile time than
to run broken code.

\subsubsection{77.3 Example: Required
Macro}\label{example-required-macro}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifndef DEBUG}
\PreprocessorTok{\#error "DEBUG must be defined (use {-}DDEBUG=1)"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If you forget to define \texttt{DEBUG}, compilation stops and reminds
you how to fix it.

You can define it like this:

\begin{verbatim}
gcc main.c -DDEBUG=1 -o app
\end{verbatim}

\subsubsection{77.4 Example: Unsupported
Platform}\label{example-unsupported-platform}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if !defined(\_WIN32) \&\& !defined(\_\_linux\_\_)}
\PreprocessorTok{\#error "Unsupported platform: please compile on Windows or Linux"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If someone tries to compile on macOS (or another OS), the preprocessor
politely refuses.

\subsubsection{\texorpdfstring{77.5 What Is
\texttt{\#warning}}{77.5 What Is \#warning}}\label{what-is-warning}

\texttt{\#warning} works like \texttt{\#error}, but it doesn't stop
compilation. It just prints a compiler warning message, useful when you
want to inform, not block.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#warning "This feature is experimental"}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
warning: This feature is experimental
\end{verbatim}

Your program will still compile and run, but you'll see the note.

\subsubsection{77.6 Example: Version
Notice}\label{example-version-notice}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if \_\_STDC\_VERSION\_\_ \textless{} 201112L}
\PreprocessorTok{\#warning "Consider updating to C11 or newer"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This helps nudge users toward better compilers, without stopping their
build.

\subsubsection{77.7 Combining with
Conditions}\label{combining-with-conditions}

You can pair \texttt{\#error} and \texttt{\#warning} with any condition:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define VERSION }\DecValTok{2}

\PreprocessorTok{\#if VERSION == 1}
\PreprocessorTok{\#warning "Version 1 is outdated"}
\PreprocessorTok{\#elif VERSION \textgreater{} 3}
\PreprocessorTok{\#error "Version not supported"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Messages appear depending on what's defined.

\subsubsection{77.8 Example: Safety Checks}\label{example-safety-checks}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX\_USERS }\DecValTok{0}

\PreprocessorTok{\#if MAX\_USERS \textless{}= 0}
\PreprocessorTok{\#error "MAX\_USERS must be greater than zero"}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

If a configuration is invalid, the build fails before it reaches the
compiler.

This is a great habit, let the build process catch mistakes early.

\subsubsection{77.9 Tiny Code Example}\label{tiny-code-example-24}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MODE }\DecValTok{2}

\PreprocessorTok{\#if MODE == 1}
\PreprocessorTok{\#warning "Mode 1 is for testing only"}
\PreprocessorTok{\#elif MODE \textgreater{} 3}
\PreprocessorTok{\#error "Invalid MODE setting"}
\PreprocessorTok{\#endif}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running in mode }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ MODE}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile it and try different \texttt{MODE} values, see how messages
change.

\subsubsection{77.10 Best Practices}\label{best-practices-2}

\begin{itemize}
\tightlist
\item
  Use \texttt{\#error} for serious misconfigurations that must stop the
  build.
\item
  Use \texttt{\#warning} for friendly reminders or temporary notes.
\item
  Always write clear, actionable messages, say \emph{what went wrong}
  and \emph{how to fix it}.
\item
  Avoid spamming warnings; too many messages hide the important ones.
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-76}

\texttt{\#error} and \texttt{\#warning} give your code a voice during
compilation. They turn silent mistakes into visible messages, helping
you and others fix issues early.

In bigger projects, these checks become part of a build safety net ---
so your program never compiles in an unsupported or broken state.

\subsubsection{Try It Yourself}\label{try-it-yourself-76}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{\#error} if \texttt{DEBUG} isn't defined.
\item
  Add a \texttt{\#warning} if you're using an old C version.
\item
  Add a \texttt{\#error} when \texttt{MAX\_SIZE} is over 1000.
\item
  Define macros from the command line (\texttt{-DDEBUG=1}) and test
  again.
\item
  Practice writing helpful messages, imagine another beginner reading
  them.
\end{enumerate}

Once you start using these directives, your compiler becomes more than a
tool --- it becomes a teammate that tells you when something's not
right.

\subsection{\texorpdfstring{78. Built-in Macros: \texttt{\_\_FILE\_\_},
\texttt{\_\_LINE\_\_}, and
Friends}{78. Built-in Macros: \_\_FILE\_\_, \_\_LINE\_\_, and Friends}}\label{built-in-macros-__file__-__line__-and-friends}

C gives you a handful of built-in macros that always exist, no matter
what you write. They're like little bookmarks the compiler fills in
automatically, showing where and when your code was compiled.

You don't define them yourself. They're always there, ready to help with
debugging, logging, and version tracking.

\subsubsection{78.1 What Are Built-in
Macros}\label{what-are-built-in-macros}

Built-in macros are special names that start and end with double
underscores (\texttt{\_\_}). When the preprocessor runs, it replaces
each one with useful information.

They're not variables or constants, they're compile-time values inserted
directly into your code.

\subsubsection{78.2 The Most Common
Built-ins}\label{the-most-common-built-ins}

Here are the ones you'll use most often:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4881}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2976}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Macro
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Expands To
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{\_\_FILE\_\_} & A string with the current filename & Where this
code lives \\
\texttt{\_\_LINE\_\_} & The current line number & Where this code
appears \\
\texttt{\_\_DATE\_\_} & The compilation date & When it was compiled \\
\texttt{\_\_TIME\_\_} & The compilation time & What time it was
compiled \\
\texttt{\_\_STDC\_\_} & \texttt{1} if you're using a standard C compiler
& Confirms compliance \\
\texttt{\_\_STDC\_VERSION\_\_} & Version number (like \texttt{201112L}
for C11) & Which C standard \\
\end{longtable}

\subsubsection{78.3 Example: Printing File and
Line}\label{example-printing-file-and-line}

Here's a simple example that prints where a line comes from:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"This code is from file: }\SpecialCharTok{\%s}\StringTok{, line: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_FILE\_\_}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
This code is from file: main.c, line: 4
\end{verbatim}

If you move the \texttt{printf} to a different line, the number changes
automatically.

\subsubsection{78.4 Example: Compilation
Info}\label{example-compilation-info}

You can show when your program was built:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Compiled on }\SpecialCharTok{\%s}\StringTok{ at }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_DATE\_\_}\OperatorTok{,}\NormalTok{ \_\_TIME\_\_}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output might look like:

\begin{verbatim}
Compiled on Oct 2 2025 at 10:42:15
\end{verbatim}

This is useful for version tracking, you'll always know which build
you're running.

\subsubsection{78.5 Example: Logging
Helper}\label{example-logging-helper}

You can combine these macros to make helpful debug messages:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"[}\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{] }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

Then use it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Starting program"}\OperatorTok{);}
\NormalTok{    LOG}\OperatorTok{(}\StringTok{"Initialization complete"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
[main.c:6] Starting program  
[main.c:7] Initialization complete
\end{verbatim}

Now every log tells you exactly where it came from, no guessing!

\subsubsection{78.6 Checking Compiler
Version}\label{checking-compiler-version}

You can use \texttt{\_\_STDC\_VERSION\_\_} to check which C standard is
being used:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#if \_\_STDC\_VERSION\_\_ \textgreater{}= 201112L}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Using C11 or newer}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#else}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Older C version detected}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

This helps you write portable code that adjusts to the compiler.

\subsubsection{78.7 Using Macros for Debug
Builds}\label{using-macros-for-debug-builds}

You can mix built-ins with \texttt{\#ifdef\ DEBUG} to show info only in
debug mode:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#ifdef DEBUG}
\PreprocessorTok{\#define DEBUG\_LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textbackslash{}}
\PreprocessorTok{    printf}\OperatorTok{(}\StringTok{"[DEBUG] }\SpecialCharTok{\%s}\StringTok{:}\SpecialCharTok{\%d}\StringTok{, }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\PreprocessorTok{ \_\_FILE\_\_}\OperatorTok{,}\PreprocessorTok{ \_\_LINE\_\_}\OperatorTok{,}\PreprocessorTok{ msg}\OperatorTok{)}
\PreprocessorTok{\#else}
\PreprocessorTok{\#define DEBUG\_LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

Now:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    DEBUG\_LOG}\OperatorTok{(}\StringTok{"Running diagnostics..."}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you compile with \texttt{-DDEBUG}, the logs appear; otherwise, they
vanish.

\subsubsection{78.8 Why Double
Underscores}\label{why-double-underscores}

Names like \texttt{\_\_FILE\_\_} and \texttt{\_\_LINE\_\_} are reserved
by the C standard. That's why user-defined macros shouldn't start or end
with underscores, to avoid conflicts with the language itself.

Stick to uppercase names without double underscores for your own macros:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX\_SIZE }\DecValTok{100}
\end{Highlighting}
\end{Shaded}

\subsubsection{78.9 Tiny Code Example}\label{tiny-code-example-25}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"File: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_FILE\_\_}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Line: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_LINE\_\_}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Compiled on: }\SpecialCharTok{\%s}\StringTok{ at }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_DATE\_\_}\OperatorTok{,}\NormalTok{ \_\_TIME\_\_}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"C Standard: }\SpecialCharTok{\%ld\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ \_\_STDC\_VERSION\_\_}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
File: main.c
Line: 5
Compiled on: Oct 2 2025 at 10:42:15
C Standard: 202000
\end{verbatim}

Now your program tells its own story, where, when, and how it was built.

\subsubsection{78.10 Why It Matters}\label{why-it-matters-77}

Built-in macros are small but powerful. They let your code:

\begin{itemize}
\tightlist
\item
  Report its source
\item
  Show compile-time info
\item
  Log helpful debug messages
\item
  Adjust to the compiler version
\end{itemize}

You'll use them most in debugging and logging, especially in bigger
projects.

\subsubsection{Try It Yourself}\label{try-it-yourself-77}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Print \texttt{\_\_FILE\_\_} and \texttt{\_\_LINE\_\_} in your main
  function.
\item
  Add a \texttt{LOG} macro that includes file and line automatically.
\item
  Display \texttt{\_\_DATE\_\_} and \texttt{\_\_TIME\_\_} at program
  startup.
\item
  Use \texttt{\_\_STDC\_VERSION\_\_} to show your C version.
\item
  Try moving your log statements around, watch the line numbers change.
\end{enumerate}

With these macros, your code becomes self-aware, it knows when, where,
and how it was built, and it can tell you too!

\subsection{79. The Compilation Pipeline: Preprocess → Compile →
Link}\label{the-compilation-pipeline-preprocess-compile-link}

Every time you run \texttt{gcc} (or any C compiler), a lot happens
behind the scenes. Your code doesn't jump straight to an executable, it
goes through several distinct stages, each transforming your program
step by step.

Understanding these stages helps you debug build errors, organize large
projects, and control your builds like a pro.

Let's walk through the journey your code takes from \texttt{.c} files to
a working program.

\subsubsection{79.1 The Big Picture}\label{the-big-picture}

Think of compilation as a four-step pipeline:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Preprocessing, expands macros, includes headers, and cleans up code
\item
  Compilation, turns C code into assembly
\item
  Assembly, converts assembly into machine code (object files)
\item
  Linking, combines all object files into a final executable
\end{enumerate}

Every time you type something like:

\begin{verbatim}
gcc main.c -o app
\end{verbatim}

these four steps happen automatically.

We'll unpack each one so you can see exactly what's going on.

\subsubsection{79.2 Step 1: Preprocessing}\label{step-1-preprocessing}

The preprocessor handles all lines starting with \texttt{\#}, like:

\begin{itemize}
\tightlist
\item
  \texttt{\#include}, inserts header files
\item
  \texttt{\#define}, expands macros
\item
  \texttt{\#if}, \texttt{\#ifdef}, includes or skips code conditionally
\end{itemize}

At this stage, your code is pure text manipulation. No syntax checking
yet, it's just assembling the full code.

You can see the result using:

\begin{verbatim}
gcc -E main.c
\end{verbatim}

This outputs the preprocessed source, where all includes and macros have
been expanded.

\subsubsection{79.3 Step 2: Compilation}\label{step-2-compilation}

Next, the compiler translates your C source into assembly language, a
lower-level representation still readable by humans.

It checks for:

\begin{itemize}
\tightlist
\item
  Syntax errors
\item
  Type mismatches
\item
  Undeclared variables
\item
  Invalid expressions
\end{itemize}

You can stop after this step to inspect the assembly code:

\begin{verbatim}
gcc -S main.c
\end{verbatim}

This produces \texttt{main.s}, a plain text file with assembly
instructions.

\subsubsection{79.4 Step 3: Assembly}\label{step-3-assembly}

Now the assembler takes that assembly (\texttt{.s}) file and converts it
into machine code, creating an object file (\texttt{.o} or
\texttt{.obj}).

Command:

\begin{verbatim}
gcc -c main.c
\end{verbatim}

This skips linking and stops at the object file. Object files are
binary, not human-readable, and contain compiled functions waiting to be
linked.

If you have multiple source files, you'll get one \texttt{.o} per
\texttt{.c}:

\begin{verbatim}
main.o
math_utils.o
student.o
\end{verbatim}

\subsubsection{79.5 Step 4: Linking}\label{step-4-linking}

Finally, the linker takes all the object files and glues them together,
along with any needed libraries (like \texttt{libc}), to form one
executable.

For example:

\begin{verbatim}
gcc main.o math_utils.o -o app
\end{verbatim}

The linker checks that:

\begin{itemize}
\tightlist
\item
  Every function call matches a defined function
\item
  External symbols (like \texttt{printf}) are found in libraries
\end{itemize}

If something's missing, you'll see ``undefined reference'' errors, those
come from this stage.

\subsubsection{79.6 Why Separate Steps
Matter}\label{why-separate-steps-matter}

Splitting compilation into steps gives you flexibility:

\begin{itemize}
\tightlist
\item
  Faster builds, only recompile changed files
\item
  Modular design, work on parts independently
\item
  Custom control, inspect or optimize each stage
\end{itemize}

In big projects, tools like \texttt{make} automate this process, only
rebuilding what's necessary.

\subsubsection{79.7 Summary of Commands}\label{summary-of-commands}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1806}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2639}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2361}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Step
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Output
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Preprocess & Expand macros, includes & \texttt{gcc\ -E\ main.c} &
Preprocessed text \\
2. Compile & Translate to assembly & \texttt{gcc\ -S\ main.c} &
\texttt{main.s} \\
3. Assemble & Turn into machine code & \texttt{gcc\ -c\ main.c} &
\texttt{main.o} \\
4. Link & Combine all objects & \texttt{gcc\ main.o\ -o\ app} &
\texttt{app} executable \\
\end{longtable}

Usually, \texttt{gcc\ main.c\ -o\ app} runs all four in one go.

\subsubsection{79.8 Example: Multi-file
Build}\label{example-multi-file-build}

\begin{verbatim}
project/
├── main.c
├── math_utils.c
└── math_utils.h
\end{verbatim}

Compile separately:

\begin{verbatim}
gcc -c main.c       // main.o
gcc -c math_utils.c // math_utils.o
\end{verbatim}

Link together:

\begin{verbatim}
gcc main.o math_utils.o -o app
\end{verbatim}

You now have a clean, modular build, if you change only
\texttt{math\_utils.c}, recompile just that file.

\subsubsection{79.9 Visualizing the
Pipeline}\label{visualizing-the-pipeline}

\begin{verbatim}
 main.c
   │
   ▼
[Preprocess]   → expanded source
   │
   ▼
[Compile]      → main.s (assembly)
   │
   ▼
[Assemble]     → main.o (object file)
   │
   ▼
[Link]         → app (executable)
\end{verbatim}

Each step builds on the last, just like an assembly line.

\subsubsection{79.10 Tiny Code Example}\label{tiny-code-example-26}

main.c

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{"math\_utils.h"}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"3 + 4 = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ add}\OperatorTok{(}\DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

math\_utils.h

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

math\_utils.c

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Build it step by step:

\begin{verbatim}
gcc -c main.c
gcc -c math_utils.c
gcc main.o math_utils.o -o app
\end{verbatim}

Run it:

\begin{verbatim}
./app
\end{verbatim}

Output:

\begin{verbatim}
3 + 4 = 7
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-78}

Understanding the compilation pipeline turns you from a user of the
compiler into a builder who controls it. You'll be able to:

\begin{itemize}
\tightlist
\item
  Debug build errors with confidence
\item
  Rebuild only what's needed
\item
  Organize large projects cleanly
\item
  Appreciate how source code becomes machine code
\end{itemize}

Once you see how it all fits together, you'll never look at \texttt{gcc}
the same way again.

\subsubsection{Try It Yourself}\label{try-it-yourself-78}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run \texttt{gcc\ -E\ main.c\ \textgreater{}\ expanded.c} and inspect
  the result.
\item
  Generate assembly with \texttt{gcc\ -S\ main.c} and open
  \texttt{main.s}.
\item
  Create object files using \texttt{-c} and link them manually.
\item
  Introduce an undefined function, see the linker error.
\item
  Rebuild after changing one file, notice how much faster it is!
\end{enumerate}

By understanding each stage, you gain control over your builds, and
that's a superpower every C programmer needs.

\subsection{80. Balancing Macros and
Functions}\label{balancing-macros-and-functions}

By now, you've seen that macros can act like quick shortcuts, they're
handled by the preprocessor, before the compiler even sees your code.
You've also written functions, which the compiler fully understands and
checks for types and safety.

So when should you use a macro, and when should you use a function? This
section helps you decide the right tool for the job.

\subsubsection{80.1 Macros vs.~Functions: The Core
Difference}\label{macros-vs.-functions-the-core-difference}

Let's start with what makes them different.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Macro (\texttt{\#define}) & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Processed by & Preprocessor & Compiler \\
Type Checking & None & Full type checking \\
Parameters & Just text & Typed arguments \\
Overhead & None (inline code) & Slight (function call) \\
Safety & Risky if misused & Safe and predictable \\
Debugging & Harder & Easier \\
\end{longtable}

Macros are like \emph{smart copy-paste shortcuts}. Functions are
\emph{real code blocks} that the compiler understands.

\subsubsection{80.2 When to Use a Macro}\label{when-to-use-a-macro}

Macros are good for small, simple, type-agnostic operations that don't
cause side effects.

Use them when:

\begin{itemize}
\tightlist
\item
  You want a compile-time substitution
\item
  You need something to work with any type
\item
  You want performance with no function call
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define MAX}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textgreater{}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{?}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{:}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

This works for \texttt{int}, \texttt{float}, or even \texttt{char}, the
compiler just substitutes text.

\subsubsection{80.3 When to Use a
Function}\label{when-to-use-a-function}

Functions are better when:

\begin{itemize}
\tightlist
\item
  You need type safety
\item
  The logic is more than one line
\item
  You want to debug easily
\item
  You use side effects or changing values
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ max\_int}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return} \OperatorTok{(}\NormalTok{a }\OperatorTok{\textgreater{}}\NormalTok{ b}\OperatorTok{)} \OperatorTok{?}\NormalTok{ a }\OperatorTok{:}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you accidentally pass wrong types, the compiler warns you. Functions
are also easier to read and maintain, especially for beginners.

\subsubsection{80.4 Why Macros Can Be
Risky}\label{why-macros-can-be-risky}

Macros don't check types or parentheses. They can expand in surprising
ways.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x }\OperatorTok{*}\PreprocessorTok{ x}\OperatorTok{)}
\DataTypeTok{int}\NormalTok{ n }\OperatorTok{=}\NormalTok{ SQUARE}\OperatorTok{(}\DecValTok{1} \OperatorTok{+} \DecValTok{2}\OperatorTok{);}  \CommentTok{// expands to (1 + 2 * 1 + 2) = 5, not 9}
\end{Highlighting}
\end{Shaded}

Fix with parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define SQUARE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

Still, a function is safer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The compiler won't let you misuse it.

\subsubsection{80.5 Inline Functions: The Best of Both
Worlds}\label{inline-functions-the-best-of-both-worlds}

Modern C lets you mark a function as inline:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This tells the compiler:

\begin{quote}
``Replace this call with the function's code, if it's faster.''
\end{quote}

You get:

\begin{itemize}
\tightlist
\item
  Type checking
\item
  Readable code
\item
  Possible performance gain
\end{itemize}

It's like a safe macro, usually the best choice.

\subsubsection{80.6 Example: Macro vs
Function}\label{example-macro-vs-function}

Macro

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define CUBE}\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{*}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{x}\OperatorTok{))}
\end{Highlighting}
\end{Shaded}

Function

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ cube}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ CUBE}\OperatorTok{(}\DecValTok{2}\OperatorTok{));} \CommentTok{// 8}
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ cube}\OperatorTok{(}\DecValTok{2}\OperatorTok{));} \CommentTok{// 8}
\end{Highlighting}
\end{Shaded}

Both give the same result, but the function is safer and easier to
debug.

\subsubsection{80.7 Mixing Both: Constants and
Helpers}\label{mixing-both-constants-and-helpers}

Macros are still perfect for constants and compile-time options:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define PI }\FloatTok{3.14159}
\PreprocessorTok{\#define DEBUG }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

But for logic, especially if it's more than a single expression, prefer
a function.

\subsubsection{80.8 Example: Logging}\label{example-logging}

Let's say you want a quick logging tool. You can combine a macro and a
function safely:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ log\_message}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{char} \OperatorTok{*}\NormalTok{msg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"[LOG] }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ msg}\OperatorTok{);}
\OperatorTok{\}}

\PreprocessorTok{\#ifdef DEBUG}
\PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}\PreprocessorTok{ log\_message}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}
\PreprocessorTok{\#else}
\PreprocessorTok{\#define LOG}\OperatorTok{(}\PreprocessorTok{msg}\OperatorTok{)}
\PreprocessorTok{\#endif}
\end{Highlighting}
\end{Shaded}

When \texttt{DEBUG} is defined, \texttt{LOG()} calls the real function.
When it's off, the macro removes the call entirely.

That's the balance: macro for control, function for behavior.

\subsubsection{80.9 Tiny Code Example}\label{tiny-code-example-27}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MAX}\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{,}\PreprocessorTok{ b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{((}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{\textgreater{}}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{?}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{a}\OperatorTok{)}\PreprocessorTok{ }\OperatorTok{:}\PreprocessorTok{ }\OperatorTok{(}\PreprocessorTok{b}\OperatorTok{))}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=} \DecValTok{3}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \DecValTok{5}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Max of }\SpecialCharTok{\%d}\StringTok{ and }\SpecialCharTok{\%d}\StringTok{ is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ MAX}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Square of }\SpecialCharTok{\%d}\StringTok{ is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ square}\OperatorTok{(}\NormalTok{a}\OperatorTok{));}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Max of 3 and 5 is 5  
Square of 3 is 9
\end{verbatim}

Here, both macro and function shine in their own way.

\subsubsection{80.10 Quick Guidelines}\label{quick-guidelines}

Use a macro when:

\begin{itemize}
\tightlist
\item
  It's a simple one-line expression
\item
  It works for multiple types
\item
  You need compile-time substitution
\end{itemize}

Use a function when:

\begin{itemize}
\tightlist
\item
  You want type safety
\item
  The code has logic or side effects
\item
  You need to debug or step through it
\end{itemize}

Use \texttt{inline} when:

\begin{itemize}
\tightlist
\item
  You want the speed of macros
\item
  But the safety of functions
\end{itemize}

\subsubsection{Why It Matters}\label{why-it-matters-79}

Choosing between macros and functions is part of learning to write
clean, safe C code. Once you know the trade-offs, you'll make smart
choices automatically, balancing speed, safety, and readability.

\subsubsection{Try It Yourself}\label{try-it-yourself-79}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a macro \texttt{ABS(x)} and a function
  \texttt{abs\_val(int\ x)}, test both.
\item
  Try \texttt{SQUARE(x)} as a macro and as an \texttt{inline} function,
  compare safety.
\item
  Add a \texttt{MAX(a,\ b)} macro, and see if it works with
  \texttt{float} too.
\item
  Intentionally break a macro, then fix it with parentheses.
\item
  Mix both in one program: macros for constants, functions for logic.
\end{enumerate}

Once you practice both sides, you'll feel confident choosing the right
tool every time.

\section{Chapter 9. Files, tools, and
concurrency}\label{chapter-9.-files-tools-and-concurrency-1}

\subsection{\texorpdfstring{81. File I/O Basics: \texttt{fopen} and
\texttt{fclose}}{81. File I/O Basics: fopen and fclose}}\label{file-io-basics-fopen-and-fclose}

So far, everything your programs have done has lived in memory, once
your program ends, all that data disappears. To make your programs more
useful, you need a way to save information permanently. That's where
files come in.

In C, you can read and write files just like you read and write
variables, you just need to open a connection first. This process is
called file I/O (input/output).

Let's start with the basics: opening and closing files.

\subsubsection{81.1 Why Work with Files}\label{why-work-with-files}

Files let you store data between runs, like saving a score, a log, or a
list of names. Once you can read and write files, you can:

\begin{itemize}
\tightlist
\item
  Save user data
\item
  Process large text files
\item
  Read configuration settings
\item
  Generate reports or logs
\end{itemize}

In C, you control all of this manually, which means you get full power
(and full responsibility).

\subsubsection{\texorpdfstring{81.2 The \texttt{FILE*}
Pointer}{81.2 The FILE* Pointer}}\label{the-file-pointer}

C uses a special type called \texttt{FILE} to represent a file. You
don't create one directly, instead, you ask C to open a file for you.

When you open a file, C gives you back a pointer to a \texttt{FILE}
object:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This pointer works like a handle, it represents the open connection to
your file.

\subsubsection{\texorpdfstring{81.3 Opening a File with
\texttt{fopen}}{81.3 Opening a File with fopen}}\label{opening-a-file-with-fopen}

To open a file, call \texttt{fopen}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Here:

\begin{itemize}
\tightlist
\item
  \texttt{"data.txt"} is the file name (path)
\item
  \texttt{"r"} means open for reading
\end{itemize}

If it succeeds, \texttt{fp} will point to the open file. If it fails
(say the file doesn't exist), \texttt{fp} will be \texttt{NULL}.

Always check:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Could not open file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{81.4 File Open Modes}\label{file-open-modes}

The second argument to \texttt{fopen} tells C how to open the file.

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Mode & Meaning & Creates New File? \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{"r"} & Read & No \\
\texttt{"w"} & Write (overwrite existing) & Yes \\
\texttt{"a"} & Append (add to end) & Yes \\
\texttt{"r+"} & Read and write & No \\
\texttt{"w+"} & Read and write (overwrite) & Yes \\
\texttt{"a+"} & Read and write (append) & Yes \\
\end{longtable}

If you open with \texttt{"w"}, be careful, it will erase existing
content.

\subsubsection{\texorpdfstring{81.5 Closing a File with
\texttt{fclose}}{81.5 Closing a File with fclose}}\label{closing-a-file-with-fclose}

Once you're done, close the file to free resources:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you forget to close files, you might lose data or run out of file
handles.

Make it a habit:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Error opening file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// ... use file ...}

\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{81.6 Example: Opening and
Closing}\label{example-opening-and-closing}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"hello.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Failed to open file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File opened successfully!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"File closed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it, and you'll find a new file named \texttt{hello.txt} in your
folder. Even if it's empty, the file was created and closed cleanly.

\subsubsection{81.7 Check Before You Read or
Write}\label{check-before-you-read-or-write}

You should always check the pointer before using it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"input.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Error: cannot open input.txt}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you try to use a \texttt{NULL} pointer, your program will crash. So
this small check saves you a lot of debugging later.

\subsubsection{81.8 File Paths and
Locations}\label{file-paths-and-locations}

When you write \texttt{"data.txt"}, C looks in your current working
directory, usually the same folder where you run your program.

To open a file elsewhere, use a relative or absolute path:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fopen}\OperatorTok{(}\StringTok{"../resources/data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\NormalTok{fopen}\OperatorTok{(}\StringTok{"/home/user/documents/data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use double backslashes on Windows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fopen}\OperatorTok{(}\StringTok{"C:}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{Users}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{Alice}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{Desktop}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{81.9 Common Mistakes}\label{common-mistakes-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting to close the file
\item
  Not checking \texttt{fopen} return value
\item
  Using wrong mode (\texttt{"r"} for reading non-existent file)
\item
  Writing to a read-only file
\item
  Mixing reading and writing modes incorrectly
\end{enumerate}

These small checks make your file I/O safe and predictable.

\subsubsection{81.10 Tiny Code Example}\label{tiny-code-example-28}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{file }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"example.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{file }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Failed to open file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{file}\OperatorTok{,} \StringTok{"Hello, file I/O!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{file}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Done writing!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output in terminal:

\begin{verbatim}
Done writing!
\end{verbatim}

Contents of \texttt{example.txt}:

\begin{verbatim}
Hello, file I/O!
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-80}

Opening and closing files is the first step in persistent programming.
Once you know how to do this, you can start reading input files, saving
logs, and building tools that work with real-world data.

\subsubsection{Try It Yourself}\label{try-it-yourself-80}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open a file called \texttt{notes.txt} in \texttt{"w"} mode and write
  one line.
\item
  Close it, then open it again in \texttt{"r"} mode and read it (coming
  up next).
\item
  Try opening a file that doesn't exist in \texttt{"r"} mode, watch for
  \texttt{NULL}.
\item
  Experiment with \texttt{"a"} mode, write multiple times and see what
  happens.
\item
  Always remember to \texttt{fclose} every opened file.
\end{enumerate}

Once you're comfortable with \texttt{fopen} and \texttt{fclose}, you're
ready to read and write data, and that's coming up next.

\subsection{82. Reading and Writing
Files}\label{reading-and-writing-files}

Now that you know how to open and close files, it's time to learn how to
actually put data into them and read it back out. This is one of the
most powerful skills in C, it's how programs remember things after they
stop running.

Think of a file as a container of text or data. You open it, use special
functions to read or write, and close it when you're done, just like
handling a notebook.

\subsubsection{82.1 Two Directions: Input and
Output}\label{two-directions-input-and-output}

File I/O is really just about two directions:

\begin{itemize}
\tightlist
\item
  Output → writing data \emph{to} a file
\item
  Input → reading data \emph{from} a file
\end{itemize}

Each direction uses its own set of functions, but the workflow is always
the same:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{fopen} the file
\item
  \texttt{fprintf} or \texttt{fscanf} (or similar)
\item
  \texttt{fclose} when finished
\end{enumerate}

\subsubsection{\texorpdfstring{82.2 Writing to a File with
\texttt{fprintf}}{82.2 Writing to a File with fprintf}}\label{writing-to-a-file-with-fprintf}

The simplest way to write text to a file is \texttt{fprintf}. It works
just like \texttt{printf}, but writes to a file instead of the screen.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Could not open file for writing.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\NormalTok{fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"Hello, file!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"The answer is }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,} \DecValTok{42}\OperatorTok{);}

\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

After running this, open \texttt{output.txt}, you'll see:

\begin{verbatim}
Hello, file!
The answer is 42
\end{verbatim}

You can write any format, integers, floats, strings, just like
\texttt{printf}.

\subsubsection{82.3 Appending to a File}\label{appending-to-a-file}

If you open in \texttt{"a"} mode, your file keeps its old content, and
new text is added to the end.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"New log entry}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Each run adds another line, perfect for logs or cumulative data.

\subsubsection{\texorpdfstring{82.4 Reading from a File with
\texttt{fscanf}}{82.4 Reading from a File with fscanf}}\label{reading-from-a-file-with-fscanf}

To read text back, use \texttt{fscanf}. It works like \texttt{scanf},
but reads from a file.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"input.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"File not found!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ number}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ word}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
\NormalTok{fscanf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{number}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Number: }\SpecialCharTok{\%d}\StringTok{, Word: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ number}\OperatorTok{,}\NormalTok{ word}\OperatorTok{);}

\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If \texttt{input.txt} contains:

\begin{verbatim}
42 hello
\end{verbatim}

The program prints:

\begin{verbatim}
Number: 42, Word: hello
\end{verbatim}

\subsubsection{\texorpdfstring{82.5 Reading Lines with
\texttt{fgets}}{82.5 Reading Lines with fgets}}\label{reading-lines-with-fgets}

If you want to read an entire line of text, use \texttt{fgets}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ buffer}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Line: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

It reads up to one line (or until the buffer is full). You'll often use
\texttt{fgets} in loops to process text files line by line.

\subsubsection{82.6 End of File (EOF)}\label{end-of-file-eof}

When reading, you often need to know when to stop. C signals this with a
special value: \texttt{EOF}.

You can loop until you hit the end:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{fscanf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{n}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Read: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or use \texttt{feof(fp)} to check if you've reached the end.

\subsubsection{82.7 Example: Copy Text from One File to
Another}\label{example-copy-text-from-one-file-to-another}

Here's a simple program that copies a file's contents:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{in }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"input.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{in }\OperatorTok{==}\NormalTok{ NULL }\OperatorTok{||}\NormalTok{ out }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error opening files.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ ch}\OperatorTok{;}  \CommentTok{// must be int, not char}
    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{ch }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{in}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fputc}\OperatorTok{(}\NormalTok{ch}\OperatorTok{,}\NormalTok{ out}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{in}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{out}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Copy complete!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try it, you'll create an exact text copy.

\subsubsection{82.8 Common Reading and Writing
Functions}\label{common-reading-and-writing-functions}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Function & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{fprintf} & Write formatted text \\
\texttt{fscanf} & Read formatted text \\
\texttt{fputs} & Write a string \\
\texttt{fgets} & Read a line \\
\texttt{fputc} & Write one character \\
\texttt{fgetc} & Read one character \\
\end{longtable}

In more details,

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2595}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1676}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2649}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3081}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Input Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Output Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{fprintf(FILE\ *stream,\ const\ char\ *format,\ ...)} & Write
formatted text to a file & Values to format (like \texttt{int},
\texttt{double}, \texttt{char\ *}) & \texttt{int} (number of characters
written or negative on error) \\
\texttt{fscanf(FILE\ *stream,\ const\ char\ *format,\ ...)} & Read
formatted text from a file & File stream & Number of items successfully
read \\
\texttt{fputs(const\ char\ *str,\ FILE\ *stream)} & Write a string (no
newline) & \texttt{const\ char\ *} string & \texttt{int} (non-negative
on success, \texttt{EOF} on error) \\
\texttt{fgets(char\ *str,\ int\ size,\ FILE\ *stream)} & Read a line (up
to \texttt{size-1}) & File stream & \texttt{char\ *} (pointer to
\texttt{str} or \texttt{NULL} on error/EOF) \\
\texttt{fputc(int\ ch,\ FILE\ *stream)} & Write one character & Single
character (\texttt{int}) & \texttt{int} (character written or
\texttt{EOF} on error) \\
\texttt{fgetc(FILE\ *stream)} & Read one character & File stream &
\texttt{int} (character read or \texttt{EOF} on end/error) \\
\end{longtable}

These let you work at different levels, line by line, word by word, or
character by character.

\subsubsection{\texorpdfstring{82.9 Don't Forget
\texttt{fclose}}{82.9 Don't Forget fclose}}\label{dont-forget-fclose}

Always close your file when done:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

If you forget, data might not be fully saved, it could still be sitting
in a buffer.

\subsubsection{82.10 Tiny Code Example}\label{tiny-code-example-29}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"greetings.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error opening file for writing.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"Hello from C!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"This is another line.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"greetings.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Error opening file for reading.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{100}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}  \CommentTok{// optional explicit initialization}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File contents:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ fp}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ line}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
File contents:
Hello from C!
This is another line.
\end{verbatim}

Note on \texttt{char\ line{[}100{]}}:

This declares a fixed-size buffer that \texttt{fgets()} uses to store
one line of text at a time. It can hold up to 99 characters plus the
null terminator
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}.
Initializing it with \texttt{\{0\}}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{100}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

ensures all elements start as zero, which is a good habit for safety and
clarity - though \texttt{fgets()} will overwrite the buffer each time it
successfully reads a line.

\subsubsection{Why It Matters}\label{why-it-matters-81}

File I/O lets your programs remember, log, and communicate. It's how
real software saves progress, stores data, and reads configuration
files.

Once you master reading and writing, you can build text analyzers,
loggers, and even small databases.

\subsubsection{Try It Yourself}\label{try-it-yourself-81}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create \texttt{numbers.txt} with some numbers and read them with
  \texttt{fscanf}.
\item
  Write a program that saves names entered by the user.
\item
  Build a logger using \texttt{"a"} mode.
\item
  Write and then read back your own ``quote of the day.''
\item
  Try copying one text file to another, one character at a time.
\end{enumerate}

You've now learned how to talk to files, the foundation of every program
that remembers anything.

\subsection{83. Working with Binary
Files}\label{working-with-binary-files}

So far, you've been working with text files, reading and writing
readable characters like letters and numbers. But sometimes, you'll want
to work with binary files, files that store raw bytes instead of text.

Why does this matter? Because binary files are faster, smaller, and more
precise. They're perfect for saving things like images, game data, or
arrays of numbers exactly as they are in memory.

Let's explore how they work and how to use them safely.

\subsubsection{83.1 What Is a Binary File}\label{what-is-a-binary-file}

A binary file is just a sequence of bytes, no hidden formatting, no line
breaks, no text encoding. It's how computers store information natively.

When you write a number like \texttt{42} to a text file, it saves
\texttt{\textquotesingle{}4\textquotesingle{}} and
\texttt{\textquotesingle{}2\textquotesingle{}}. When you write to a
binary file, it saves the byte representation of the number, the same
bits your CPU uses.

Binary files aren't meant to be opened with a text editor. You'll see
strange characters, that's normal.

\subsubsection{83.2 Opening a Binary File}\label{opening-a-binary-file}

You open binary files just like text files, but add a \texttt{b} to the
mode:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Mode & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{"rb"} & Read binary \\
\texttt{"wb"} & Write binary (overwrite) \\
\texttt{"ab"} & Append binary \\
\texttt{"rb+"} & Read and write \\
\texttt{"wb+"} & Write and read (overwrite) \\
\end{longtable}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{83.3 Writing Binary Data:
\texttt{fwrite}}{83.3 Writing Binary Data: fwrite}}\label{writing-binary-data-fwrite}

To write binary data, use \texttt{fwrite}. It writes a block of memory
directly into the file.

Syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fwrite}\OperatorTok{(}\NormalTok{pointer}\OperatorTok{,}\NormalTok{ size\_of\_each}\OperatorTok{,}\NormalTok{ count}\OperatorTok{,}\NormalTok{ file\_pointer}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{,} \DecValTok{30}\OperatorTok{\};}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This writes all three integers as raw bytes. Each \texttt{int} takes up
4 bytes (on most systems), so the file will be 12 bytes long.

\subsubsection{\texorpdfstring{83.4 Reading Binary Data:
\texttt{fread}}{83.4 Reading Binary Data: fread}}\label{reading-binary-data-fread}

To read binary data back, use \texttt{fread}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ numbers}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
\NormalTok{fread}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now the \texttt{numbers} array contains \texttt{\{10,\ 20,\ 30\}} again,
exactly as before.

\subsubsection{83.5 Checking Results}\label{checking-results}

You can check how many items were read or written, both functions return
that count:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{size\_t}\NormalTok{ written }\OperatorTok{=}\NormalTok{ fwrite}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{written }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Write error!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Same for \texttt{fread}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{size\_t}\NormalTok{ read }\OperatorTok{=}\NormalTok{ fread}\OperatorTok{(}\NormalTok{numbers}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{read }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Read error or early EOF.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This helps you catch incomplete reads or writes.

\subsubsection{83.6 Example: Saving a
Structure}\label{example-saving-a-structure}

You can write and read structs directly, no need to format them as text.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ score}\OperatorTok{;}
\OperatorTok{\}}\NormalTok{ Record}\OperatorTok{;}

\NormalTok{Record r1 }\OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \FloatTok{95.5}\OperatorTok{\};}

\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"record.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(\&}\NormalTok{r1}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Record}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Then read it back:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Record r2}\OperatorTok{;}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"record.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
\NormalTok{fread}\OperatorTok{(\&}\NormalTok{r2}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{Record}\OperatorTok{),} \DecValTok{1}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{printf}\OperatorTok{(}\StringTok{"ID: }\SpecialCharTok{\%d}\StringTok{, Score: }\SpecialCharTok{\%.1f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ r2}\OperatorTok{.}\NormalTok{id}\OperatorTok{,}\NormalTok{ r2}\OperatorTok{.}\NormalTok{score}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
ID: 1, Score: 95.5
\end{verbatim}

Binary I/O makes saving entire structs quick and easy.

\subsubsection{83.7 Example: Reading/Writing
Arrays}\label{example-readingwriting-arrays}

You can save whole arrays in one go:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ data}\OperatorTok{[}\DecValTok{5}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\FloatTok{1.1}\OperatorTok{,} \FloatTok{2.2}\OperatorTok{,} \FloatTok{3.3}\OperatorTok{,} \FloatTok{4.4}\OperatorTok{,} \FloatTok{5.5}\OperatorTok{\};}
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"floats.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
\NormalTok{fwrite}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{),} \DecValTok{5}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\CommentTok{// Reading back}
\DataTypeTok{float}\NormalTok{ readback}\OperatorTok{[}\DecValTok{5}\OperatorTok{];}
\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"floats.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
\NormalTok{fread}\OperatorTok{(}\NormalTok{readback}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{),} \DecValTok{5}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.1f}\StringTok{ "}\OperatorTok{,}\NormalTok{ readback}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
1.1 2.2 3.3 4.4 5.5
\end{verbatim}

All values preserved exactly, no rounding or text formatting errors.

\subsubsection{83.8 Why Use Binary Files}\label{why-use-binary-files}

Binary files are:

\begin{itemize}
\tightlist
\item
  Compact, no wasted space on text formatting
\item
  Fast, read/write blocks directly
\item
  Precise, no rounding or parsing issues
\end{itemize}

But they're not human-readable, so use them when your program, not you,
needs to interpret the data.

\subsubsection{83.9 Common Mistakes}\label{common-mistakes-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{"b"} in mode (\texttt{"w"} instead of
  \texttt{"wb"})
\item
  Mismatched types on \texttt{fread}/\texttt{fwrite}
\item
  Writing structs with pointers (they won't serialize correctly)
\item
  Reading into too-small arrays
\item
  Forgetting to \texttt{fclose}
\end{enumerate}

Always match what you write with what you read, same size, same order.

\subsubsection{83.10 Tiny Code Example}\label{tiny-code-example-30}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{5}\OperatorTok{,} \DecValTok{10}\OperatorTok{,} \DecValTok{15}\OperatorTok{\};}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"nums.bin"}\OperatorTok{,} \StringTok{"wb"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}

\NormalTok{    fwrite}\OperatorTok{(}\NormalTok{nums}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

    \DataTypeTok{int}\NormalTok{ read\_nums}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
\NormalTok{    fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"nums.bin"}\OperatorTok{,} \StringTok{"rb"}\OperatorTok{);}
\NormalTok{    fread}\OperatorTok{(}\NormalTok{read\_nums}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{3}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Numbers read: }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ read\_nums}\OperatorTok{[}\DecValTok{0}\OperatorTok{],}\NormalTok{ read\_nums}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ read\_nums}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Numbers read: 5 10 15
\end{verbatim}

The file looks like gibberish if opened in a text editor, but it's
exactly what your program expects.

\subsubsection{Why It Matters}\label{why-it-matters-82}

Binary files let you store data exactly as it exists in memory, no
conversions, no formatting. They're ideal for performance, precision,
and saving complex data structures.

Once you learn this, you can build fast and efficient storage systems
right inside your programs.

\subsubsection{Try It Yourself}\label{try-it-yourself-82}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Save an array of 10 integers into \texttt{data.bin} and read it back.
\item
  Create a struct \texttt{Person} with \texttt{name} and \texttt{age}
  and save one record.
\item
  Try opening the binary file in a text editor, what do you see?
\item
  Write two structs back-to-back and read them into an array.
\item
  Compare the file sizes of text vs binary, which is smaller?
\end{enumerate}

You now have the power to work with raw data, the language your computer
speaks natively!

\subsection{84. Error Handling in File
Operations}\label{error-handling-in-file-operations}

When you work with files, things can go wrong, a file might not exist, a
disk might be full, or you might not have permission to open it. That's
normal. Every good C program checks for these problems and handles them
gracefully.

In this section, you'll learn how to detect and respond to file errors
so your program never crashes unexpectedly.

\subsubsection{84.1 Why Error Handling
Matters}\label{why-error-handling-matters}

If you try to use a file that didn't open correctly, your program could:

\begin{itemize}
\tightlist
\item
  Crash
\item
  Print garbage
\item
  Corrupt data
\end{itemize}

Instead, you should always check for errors and handle them politely. A
simple check and a friendly message go a long way.

\subsubsection{\texorpdfstring{84.2 Checking
\texttt{fopen}}{84.2 Checking fopen}}\label{checking-fopen}

The most common error happens when a file fails to open. Whenever you
call \texttt{fopen}, it returns \texttt{NULL} if something goes wrong.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Error: could not open file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Maybe the file doesn't exist, or maybe you don't have permission, either
way, \texttt{fp} will be \texttt{NULL}. Always check before using it.

\subsubsection{\texorpdfstring{84.3 Using
\texttt{perror}}{84.3 Using perror}}\label{using-perror}

The function \texttt{perror} prints a system message describing the last
error. It's more helpful than just ``Error opening file''.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"missing.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"fopen"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
fopen: No such file or directory
\end{verbatim}

Now you know exactly what went wrong.

\subsubsection{84.4 Checking Other
Operations}\label{checking-other-operations}

Other file functions also report problems. For example, \texttt{fread}
and \texttt{fwrite} return how many items were processed.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{size\_t}\NormalTok{ written }\OperatorTok{=}\NormalTok{ fwrite}\OperatorTok{(}\NormalTok{data}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{5}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{written }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Write failed!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Similarly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{size\_t}\NormalTok{ read }\OperatorTok{=}\NormalTok{ fread}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\DataTypeTok{int}\OperatorTok{),} \DecValTok{5}\OperatorTok{,}\NormalTok{ fp}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{read }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{feof}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))}\NormalTok{ printf}\OperatorTok{(}\StringTok{"End of file reached.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Read error!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This way you can tell whether you hit the end or a real error occurred.

\subsubsection{\texorpdfstring{84.5 Using \texttt{feof} and
\texttt{ferror}}{84.5 Using feof and ferror}}\label{using-feof-and-ferror}

C gives you two handy helpers:

\begin{itemize}
\tightlist
\item
  \texttt{feof(fp)} returns true if end-of-file reached
\item
  \texttt{ferror(fp)} returns true if a read/write error occurred
\end{itemize}

You can use them after operations:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{feof}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))}\NormalTok{ printf}\OperatorTok{(}\StringTok{"End of file.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{ferror}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))}\NormalTok{ printf}\OperatorTok{(}\StringTok{"A file error occurred.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Together, these cover almost all file problems.

\subsubsection{\texorpdfstring{84.6 Resetting Errors with
\texttt{clearerr}}{84.6 Resetting Errors with clearerr}}\label{resetting-errors-with-clearerr}

If you want to reuse the same file pointer after an error, call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clearerr}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This clears the \texttt{feof} and \texttt{ferror} flags so you can try
again. You don't need this often, but it's useful in loops or retries.

\subsubsection{84.7 Example: Safe File
Open}\label{example-safe-file-open}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Could not open data.txt"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File opened successfully.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{data.txt} doesn't exist, you'll see:

\begin{verbatim}
Could not open data.txt: No such file or directory
\end{verbatim}

If it does, the program runs smoothly.

\subsubsection{84.8 Example: Safe Reading
Loop}\label{example-safe-reading-loop}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"numbers.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ num}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fscanf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{num}\OperatorTok{)} \OperatorTok{==} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Read: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{ferror}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))}\NormalTok{ printf}\OperatorTok{(}\StringTok{"Read error occurred.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{feof}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))}\NormalTok{ printf}\OperatorTok{(}\StringTok{"End of file reached.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This program safely handles every case, missing file, bad data, or
end-of-file.

\subsubsection{84.9 When to Stop and When to
Recover}\label{when-to-stop-and-when-to-recover}

Sometimes the right move is to stop the program (for critical errors).
Other times, you can recover and move on (like skipping bad lines).

Example recovery:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{ferror}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{    clearerr}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Error ignored, continuing...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You get to decide based on the situation.

\subsubsection{84.10 Tiny Code Example}\label{tiny-code-example-31}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"output.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Failed to open file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ result }\OperatorTok{=}\NormalTok{ fprintf}\OperatorTok{(}\NormalTok{fp}\OperatorTok{,} \StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{result }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Write failed"}\OperatorTok{);}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{)} \OperatorTok{==}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error closing file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"All good! File written and closed.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This program checks every step, open, write, close, and handles any
failure.

\subsubsection{Why It Matters}\label{why-it-matters-83}

Error handling makes your programs reliable and professional. Even if
something goes wrong, your program stays calm and explains the problem
clearly.

It's a small habit that makes a big difference.

\subsubsection{Try It Yourself}\label{try-it-yourself-83}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open a file that doesn't exist, print a clear error.
\item
  Try writing to a read-only file, catch and report it.
\item
  Read past the end of a file, detect \texttt{feof}.
\item
  Intentionally trigger \texttt{ferror}, then clear it with
  \texttt{clearerr}.
\item
  Wrap your file code in safety checks, one by one.
\end{enumerate}

Once you handle errors gracefully, you'll feel in full control, your
programs won't just run, they'll respond intelligently when something
goes wrong.

\subsection{85. Command-Line Arguments}\label{command-line-arguments}

Up to now, your programs have always started the same way, no matter
what you type when you run them. But sometimes, you want your program to
behave differently depending on user input from the command line.

That's where command-line arguments come in. They let users pass
information directly to \texttt{main} when starting the program.

This is how real-world programs take options like \texttt{ls\ -l} or
\texttt{gcc\ main.c\ -o\ app}. Let's learn how you can do the same in
your own programs.

\subsubsection{\texorpdfstring{85.1 The Special Form of
\texttt{main}}{85.1 The Special Form of main}}\label{the-special-form-of-main}

Until now, you've written:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)}
\end{Highlighting}
\end{Shaded}

To accept arguments, you'll use:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])}
\end{Highlighting}
\end{Shaded}

Here's what those mean:

\begin{itemize}
\tightlist
\item
  \texttt{argc} = argument count (how many items are on the command
  line)
\item
  \texttt{argv} = argument vector (an array of strings containing each
  argument)
\end{itemize}

Think of \texttt{argv} as a list of words typed after your program's
name.

\subsubsection{85.2 How It Works}\label{how-it-works-2}

Let's look at a simple example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"You passed }\SpecialCharTok{\%d}\StringTok{ arguments.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argc}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"argv[}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If you compile this as \texttt{args}, then run:

\begin{verbatim}
./args hello world 123
\end{verbatim}

You'll see:

\begin{verbatim}
You passed 4 arguments.
argv[0] = ./args
argv[1] = hello
argv[2] = world
argv[3] = 123
\end{verbatim}

Notice how \texttt{argv{[}0{]}} is always your program's name.
Everything after it is user input.

\subsubsection{85.3 Using Arguments}\label{using-arguments}

You can use arguments to make your program flexible.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}filename\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Opening file: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run it like this:

\begin{verbatim}
./program data.txt
\end{verbatim}

If you forget the filename, it shows a friendly usage message.

\subsubsection{85.4 Converting Strings to
Numbers}\label{converting-strings-to-numbers}

Command-line arguments are always strings. If you want numbers, you'll
need to convert them.

Use \texttt{atoi} (ASCII to integer) or \texttt{atof} (to float):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}a\textgreater{} \textless{}b\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ a }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \DataTypeTok{int}\NormalTok{ b }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ + }\SpecialCharTok{\%d}\StringTok{ = }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
./sum 5 7
\end{verbatim}

Output:

\begin{verbatim}
5 + 7 = 12
\end{verbatim}

\subsubsection{85.5 Handling Too Few
Arguments}\label{handling-too-few-arguments}

If users forget to pass arguments, don't crash, explain what to do.

Bad:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);} \CommentTok{// ❌ might crash if argc \textless{} 2}
\end{Highlighting}
\end{Shaded}

Good:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Missing argument!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Always check before accessing \texttt{argv{[}i{]}}.

\subsubsection{85.6 Example: Echo Program}\label{example-echo-program}

Here's a small program that repeats whatever the user types:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ argc}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ "}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}
    \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
./echo Hello from C
\end{verbatim}

Output:

\begin{verbatim}
Hello from C
\end{verbatim}

Simple, clean, and useful.

\subsubsection{85.7 Why It's Useful}\label{why-its-useful}

Command-line arguments let you:

\begin{itemize}
\tightlist
\item
  Pass filenames, numbers, or options
\item
  Build flexible tools
\item
  Run scripts with parameters
\item
  Automate tests or batch jobs
\end{itemize}

You'll use them in almost every real C program you write.

\subsubsection{85.8 Quick Recap}\label{quick-recap}

\begin{itemize}
\tightlist
\item
  \texttt{argc} = how many arguments
\item
  \texttt{argv} = array of strings
\item
  \texttt{argv{[}0{]}} = program name
\item
  Always check \texttt{argc} before using \texttt{argv{[}i{]}}
\item
  Convert strings with \texttt{atoi}, \texttt{atof}, or \texttt{strtol}
\end{itemize}

\subsubsection{85.9 Tiny Code Example}\label{tiny-code-example-32}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{!=} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}num1\textgreater{} \textless{}num2\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
    \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=}\NormalTok{ atoi}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Sum: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try:

\begin{verbatim}
./sum 10 20
\end{verbatim}

Output:

\begin{verbatim}
Sum: 30
\end{verbatim}

\subsubsection{85.10 Why It Matters}\label{why-it-matters-84}

Command-line arguments turn your program into a tool, something that
responds to the user's input. You're no longer limited to hard-coded
data, now, your program listens to what's typed at launch.

\subsubsection{Try It Yourself}\label{try-it-yourself-84}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a program that takes one filename and prints ``Opening file:
  name''.
\item
  Create a calculator that adds two numbers from the command line.
\item
  Make a greeting tool: \texttt{./greet\ Alice} prints ``Hello, Alice!''
\item
  Try running with no arguments, handle the error.
\item
  Print all arguments except \texttt{argv{[}0{]}} on one line.
\end{enumerate}

Once you get used to \texttt{argc} and \texttt{argv}, you'll feel like
you're giving your programs a voice, they can now respond to you right
from the terminal.

\subsection{\texorpdfstring{86. Using \texttt{make} and
Makefiles}{86. Using make and Makefiles}}\label{using-make-and-makefiles}

As your programs grow beyond one file, typing long compile commands
becomes tiring, and easy to mess up. Wouldn't it be nice if you could
just type one simple word, like \texttt{make}, and your whole program
compiled automatically?

That's exactly what the \texttt{make} tool does. It reads a special file
called a Makefile, learns how your project is built, and only recompiles
what has changed. It's one of the most useful tools you'll ever learn.

\subsubsection{\texorpdfstring{86.1 What Is
\texttt{make}}{86.1 What Is make}}\label{what-is-make}

\texttt{make} is a build automation tool. You describe how to build your
program once, and \texttt{make} takes care of the rest.

Instead of typing:

\begin{verbatim}
gcc main.c helper.c math.c -o app
\end{verbatim}

You can just type:

\begin{verbatim}
make
\end{verbatim}

And \texttt{make} will figure out the right commands to run.

\subsubsection{86.2 The Makefile}\label{the-makefile}

A Makefile is a plain text file (named \texttt{Makefile} or
\texttt{makefile}) that lists:

\begin{itemize}
\tightlist
\item
  Targets (what to build)
\item
  Dependencies (what files it needs)
\item
  Commands (how to build it)
\end{itemize}

Each line that starts with a tab is a command.

Here's the simplest example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app: main.c}
\NormalTok{    gcc main.c {-}o app}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
make
\end{verbatim}

and \texttt{make} will compile \texttt{main.c} into \texttt{app}.

\subsubsection{86.3 Targets, Dependencies,
Commands}\label{targets-dependencies-commands}

A rule has three parts:

\begin{verbatim}
target: dependencies
<TAB> command
\end{verbatim}

In our example:

\begin{itemize}
\tightlist
\item
  Target: \texttt{app} (the program you want to build)
\item
  Dependency: \texttt{main.c} (file needed to build it)
\item
  Command: \texttt{gcc\ main.c\ -o\ app} (how to build it)
\end{itemize}

Make sure you use a real tab before the command, not spaces!

\subsubsection{86.4 Adding Multiple Files}\label{adding-multiple-files}

If your program has more than one source file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app: main.c helper.c}
\NormalTok{    gcc main.c helper.c {-}o app}
\end{Highlighting}
\end{Shaded}

Now, if you change only \texttt{helper.c}, \texttt{make} knows to
rebuild \texttt{app}.

You don't need to retype the whole command every time, just run
\texttt{make}.

\subsubsection{86.5 Cleaning Up}\label{cleaning-up}

You can add a special clean target to remove compiled files:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clean:}
\NormalTok{    rm {-}f app}
\end{Highlighting}
\end{Shaded}

Run:

\begin{verbatim}
make clean
\end{verbatim}

and it deletes the program, letting you start fresh.

\subsubsection{86.6 Using Variables}\label{using-variables}

To avoid repeating yourself, define variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CC = gcc}
\NormalTok{CFLAGS = {-}Wall {-}Wextra}

\NormalTok{app: main.c helper.c}
\NormalTok{    $(CC) $(CFLAGS) main.c helper.c {-}o app}
\end{Highlighting}
\end{Shaded}

Now you can change \texttt{CC} or \texttt{CFLAGS} in one place.

\texttt{\$(CC)} means ``insert the value of \texttt{CC}''.

\subsubsection{86.7 Example: Simple
Project}\label{example-simple-project}

Say you have:

\begin{verbatim}
main.c
math.c
math.h
\end{verbatim}

You can write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CC = gcc}
\NormalTok{CFLAGS = {-}Wall {-}Wextra}

\NormalTok{app: main.o math.o}
\NormalTok{    $(CC) $(CFLAGS) main.o math.o {-}o app}

\NormalTok{main.o: main.c math.h}
\NormalTok{    $(CC) $(CFLAGS) {-}c main.c}

\NormalTok{math.o: math.c math.h}
\NormalTok{    $(CC) $(CFLAGS) {-}c math.c}

\NormalTok{clean:}
\NormalTok{    rm {-}f *.o app}
\end{Highlighting}
\end{Shaded}

Then just run:

\begin{verbatim}
make
\end{verbatim}

to build, and:

\begin{verbatim}
make clean
\end{verbatim}

to tidy up.

\subsubsection{86.8 Incremental Builds}\label{incremental-builds}

The best part about \texttt{make} is speed. It checks file timestamps,
only recompiles what's changed, and skips the rest.

So if you edit \texttt{math.c}, only \texttt{math.o} is rebuilt. This
saves time in big projects.

\subsubsection{86.9 Default Target}\label{default-target}

The first rule in your Makefile is the default target. That's what runs
when you type \texttt{make} with no arguments.

You can also specify others:

\begin{verbatim}
make clean
make app
\end{verbatim}

Each target is like a mini command.

\subsubsection{86.10 Tiny Example}\label{tiny-example}

Here's a full Makefile for a two-file program:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{CC = gcc}
\NormalTok{CFLAGS = {-}Wall}

\NormalTok{app: main.o utils.o}
\NormalTok{    $(CC) $(CFLAGS) main.o utils.o {-}o app}

\NormalTok{main.o: main.c utils.h}
\NormalTok{    $(CC) $(CFLAGS) {-}c main.c}

\NormalTok{utils.o: utils.c utils.h}
\NormalTok{    $(CC) $(CFLAGS) {-}c utils.c}

\NormalTok{clean:}
\NormalTok{    rm {-}f *.o app}
\end{Highlighting}
\end{Shaded}

Now run:

\begin{verbatim}
make
\end{verbatim}

to build, and:

\begin{verbatim}
make clean
\end{verbatim}

to remove everything.

\subsubsection{Why It Matters}\label{why-it-matters-85}

Makefiles turn messy compile commands into one simple word:
\texttt{make}. They save you time, prevent errors, and are used in
almost every C project. Learning \texttt{make} is like learning a
superpower for managing your code.

\subsubsection{Try It Yourself}\label{try-it-yourself-85}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a program split into \texttt{main.c} and \texttt{helper.c}.
\item
  Write a simple Makefile to build them into one executable.
\item
  Add a \texttt{clean} target to delete all \texttt{.o} files.
\item
  Use variables \texttt{CC} and \texttt{CFLAGS}.
\item
  Edit one file, see how \texttt{make} rebuilds only what changed.
\end{enumerate}

Once you start using Makefiles, you'll wonder how you ever compiled
without them.

\subsection{\texorpdfstring{87. Debugging with
\texttt{gdb}}{87. Debugging with gdb}}\label{debugging-with-gdb}

Even the best programmers make mistakes, bugs happen. What matters is
how you find and fix them.

Instead of just guessing, you can use a debugger, a tool that lets you
run your program step by step, see variables, and stop exactly where
things go wrong. In C, the most common debugger is \texttt{gdb}, the GNU
Debugger.

Let's learn how to use it to actually \emph{see} what your program is
doing.

\subsubsection{87.1 What Is a Debugger}\label{what-is-a-debugger}

A debugger is like a microscope for your code. You can:

\begin{itemize}
\tightlist
\item
  Run your program one line at a time
\item
  Inspect variable values
\item
  Pause when certain conditions happen
\item
  Jump back and forth through the flow
\end{itemize}

It's one of the most powerful tools for understanding your code.

\subsubsection{87.2 Compile with Debug
Info}\label{compile-with-debug-info}

To debug properly, compile your program with the \texttt{-g} flag:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ main.c }\AttributeTok{{-}o}\NormalTok{ main}
\end{Highlighting}
\end{Shaded}

This tells the compiler to include \emph{debug symbols}, information
about line numbers and variable names, so \texttt{gdb} knows what's
going on.

Without \texttt{-g}, \texttt{gdb} can still run your program, but you
won't see meaningful info.

\subsubsection{\texorpdfstring{87.3 Starting
\texttt{gdb}}{87.3 Starting gdb}}\label{starting-gdb}

Launch your program under the debugger like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gdb}\NormalTok{ ./main}
\end{Highlighting}
\end{Shaded}

This opens the \texttt{gdb} interface. You'll see a prompt that looks
like this:

\begin{verbatim}
(gdb)
\end{verbatim}

From here, you can type commands to control your program.

\subsubsection{87.4 Running the Program}\label{running-the-program-1}

To start the program:

\begin{verbatim}
(gdb) run
\end{verbatim}

Your program executes just like normal. If it crashes, \texttt{gdb}
pauses and shows where.

If your program needs arguments:

\begin{verbatim}
(gdb) run arg1 arg2
\end{verbatim}

This works just like command-line arguments outside the debugger.

\subsubsection{87.5 Setting Breakpoints}\label{setting-breakpoints}

A breakpoint tells \texttt{gdb} where to pause execution. You can then
inspect values before continuing.

Set a breakpoint at a line number:

\begin{verbatim}
(gdb) break 10
\end{verbatim}

or at a function:

\begin{verbatim}
(gdb) break main
(gdb) break compute_sum
\end{verbatim}

When your program hits that line or function, it stops, right before
running it.

\subsubsection{87.6 Running Step by Step}\label{running-step-by-step}

Once paused, you can move through code line by line:

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Command & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{next} & Run next line (skip over function calls) \\
\texttt{step} & Step into a function call \\
\texttt{continue} & Resume execution until next breakpoint \\
\texttt{finish} & Run until current function returns \\
\end{longtable}

This helps you follow exactly what your code does.

\subsubsection{87.7 Inspecting Variables}\label{inspecting-variables}

You can check what's inside any variable with \texttt{print}:

\begin{verbatim}
(gdb) print x
$1 = 42
\end{verbatim}

You can also watch complex expressions:

\begin{verbatim}
(gdb) print a + b
\end{verbatim}

Or list all locals:

\begin{verbatim}
(gdb) info locals
\end{verbatim}

This is great for catching logic errors, when a variable isn't what you
expect.

\subsubsection{87.8 Example Session}\label{example-session}

Imagine this buggy code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ divide}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{10}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ y }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ z }\OperatorTok{=}\NormalTok{ divide}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile with debug info:

\begin{verbatim}
gcc -g main.c -o main
\end{verbatim}

Run under gdb:

\begin{verbatim}
gdb ./main
\end{verbatim}

Then:

\begin{verbatim}
(gdb) break divide
(gdb) run
\end{verbatim}

When it stops:

\begin{verbatim}
Breakpoint 1, divide (a=10, b=0)
\end{verbatim}

Check \texttt{b}:

\begin{verbatim}
(gdb) print b
$1 = 0
\end{verbatim}

You just caught the bug, division by zero, before it crashed!

\subsubsection{\texorpdfstring{87.9 Quitting
\texttt{gdb}}{87.9 Quitting gdb}}\label{quitting-gdb}

When you're done:

\begin{verbatim}
(gdb) quit
\end{verbatim}

Press \texttt{y} if it asks to confirm.

\subsubsection{87.10 Tiny Example}\label{tiny-example-1}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}g}\NormalTok{ bug.c }\AttributeTok{{-}o}\NormalTok{ bug}
\FunctionTok{gdb}\NormalTok{ ./bug}
\end{Highlighting}
\end{Shaded}

Inside \texttt{gdb}:

\begin{verbatim}
(gdb) break main
(gdb) run
(gdb) next
(gdb) print x
(gdb) continue
(gdb) quit
\end{verbatim}

You've just stepped through a program, watched a variable, and exited
cleanly.

\subsubsection{Why It Matters}\label{why-it-matters-86}

A debugger saves you hours of frustration. Instead of printing variables
everywhere with \texttt{printf}, you can pause and look directly at
what's happening inside your program.

Once you learn \texttt{gdb}, you'll debug smarter, not harder.

\subsubsection{Try It Yourself}\label{try-it-yourself-86}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a small program with a bug (like division by zero).
\item
  Compile with \texttt{-g} and open in \texttt{gdb}.
\item
  Set a breakpoint at the function where the bug happens.
\item
  Run, step through, and inspect variables.
\item
  Fix the bug, recompile, and confirm it's gone.
\end{enumerate}

Debugging isn't just for fixing mistakes, it's for \emph{understanding}
your code deeply. Once you get comfortable with \texttt{gdb}, you'll
feel like you can see inside your program's mind.

\subsection{88. Understanding Linking and
Libraries}\label{understanding-linking-and-libraries}

When you write a program in C, you rarely work alone. Your code often
depends on functions from other files or pre-built libraries, like
\texttt{printf}, \texttt{sqrt}, or even your own helper modules.

The process that brings all these pieces together into a single program
is called linking. It's what happens \emph{after} compilation, turning
your \texttt{.o} files into a real executable.

Let's explore how linking works, why it matters, and how to use
libraries with confidence.

\subsubsection{88.1 The Two-Step Build
Process}\label{the-two-step-build-process}

When you compile C code, two main steps happen:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Compilation Each \texttt{.c} file becomes an object file
  (\texttt{.o}):

\begin{verbatim}
gcc -c main.c   →  main.o
\end{verbatim}
\item
  Linking All object files (and libraries) combine into one program:

\begin{verbatim}
gcc main.o math.o -o app
\end{verbatim}
\end{enumerate}

If the linker can't find a function (like \texttt{printf}), you'll see
an undefined reference error. That means you forgot to link in the file
or library that provides it.

\subsubsection{88.2 What Is a Library}\label{what-is-a-library}

A library is a collection of precompiled code, a set of \texttt{.o}
files bundled together. Instead of writing \texttt{printf} yourself, you
just link against the standard library.

There are two main kinds:

\begin{itemize}
\tightlist
\item
  Static libraries (\texttt{.a}), code is copied into your program
\item
  Shared libraries (\texttt{.so} on Linux, \texttt{.dll} on Windows),
  code is loaded at runtime
\end{itemize}

Both let you reuse code without rewriting it.

\subsubsection{88.3 Linking Multiple
Files}\label{linking-multiple-files}

If you split your program across several files:

\begin{verbatim}
main.c  helper.c
\end{verbatim}

You compile them separately:

\begin{verbatim}
gcc -c main.c
gcc -c helper.c
\end{verbatim}

Then link:

\begin{verbatim}
gcc main.o helper.o -o app
\end{verbatim}

If you skip \texttt{helper.o}, you'll get an error:

\begin{verbatim}
undefined reference to 'helper_function'
\end{verbatim}

That's the linker saying: ``I see the call, but where's the
definition?''

\subsubsection{88.4 The Order Matters}\label{the-order-matters-1}

When linking manually, order can be important. The linker reads left to
right, it needs to see object files before libraries that use them.

Example:

\begin{verbatim}
gcc main.o helper.o -o app
\end{verbatim}

works, but

\begin{verbatim}
gcc -o app main.o
\end{verbatim}

without \texttt{helper.o} doesn't.

So always include all needed files and libraries.

\subsubsection{88.5 Using the Math
Library}\label{using-the-math-library}

Some functions, like \texttt{sqrt} or \texttt{pow}, live in special
libraries (like \texttt{libm}). To use them, you need to link with
\texttt{-lm}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ mathdemo.c }\AttributeTok{{-}o}\NormalTok{ mathdemo }\AttributeTok{{-}lm}
\end{Highlighting}
\end{Shaded}

If you forget \texttt{-lm}, you'll see:

\begin{verbatim}
undefined reference to 'sqrt'
\end{verbatim}

Adding \texttt{-lm} fixes it. Think of
\texttt{-l\textless{}name\textgreater{}} as ``link library named
\texttt{\textless{}name\textgreater{}}''.

\subsubsection{88.6 Static vs Shared
Libraries}\label{static-vs-shared-libraries}

\begin{itemize}
\item
  Static (\texttt{.a}): included in your program at build time. Result:
  one big standalone file.
\item
  Shared (\texttt{.so} / \texttt{.dll}): loaded dynamically at runtime.
  Result: smaller executable, but needs the library present on the
  system.
\end{itemize}

For beginners, you don't need to build your own yet, just know that most
system libraries are shared.

\subsubsection{88.7 Example: Your Own
Library}\label{example-your-own-library}

Let's say you have:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// mathutils.c}
\DataTypeTok{int}\NormalTok{ square}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{)} \OperatorTok{\{} \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{;} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile into a library:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ mathutils.c}
\FunctionTok{ar}\NormalTok{ rcs libmathutils.a mathutils.o}
\end{Highlighting}
\end{Shaded}

Now link with it:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc}\NormalTok{ main.c }\AttributeTok{{-}L.} \AttributeTok{{-}lmathutils} \AttributeTok{{-}o}\NormalTok{ app}
\end{Highlighting}
\end{Shaded}

\texttt{-L.} means ``look in current directory'', \texttt{-lmathutils}
means ``use libmathutils.a''.

Now your app uses your own static library!

\subsubsection{88.8 Common Linker Errors}\label{common-linker-errors}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2561}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3537}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3902}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Error
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Meaning
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{undefined\ reference} & Function called but not found & Add
missing \texttt{.o} or \texttt{-l} flag \\
\texttt{cannot\ find\ -lmylib} & Library file missing & Check
\texttt{-L} path \\
\texttt{multiple\ definition} & Same function defined twice & Remove
duplicate or use \texttt{extern} \\
\end{longtable}

The linker doesn't compile, it just matches names. So missing or
duplicated definitions cause trouble.

\subsubsection{88.9 Linking with
Makefiles}\label{linking-with-makefiles}

Makefiles make linking easy. You can describe dependencies once, and
\texttt{make} handles them.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app: main.o helper.o}
\NormalTok{    gcc main.o helper.o {-}o app}
\end{Highlighting}
\end{Shaded}

If \texttt{main.c} or \texttt{helper.c} changes, \texttt{make}
recompiles and relinks automatically.

\subsubsection{88.10 Tiny Code Example}\label{tiny-code-example-33}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// helper.c}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from helper!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// main.c}
\DataTypeTok{void}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{);}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    greet}\OperatorTok{();}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compile and link:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ main.c}
\FunctionTok{gcc} \AttributeTok{{-}c}\NormalTok{ helper.c}
\FunctionTok{gcc}\NormalTok{ main.o helper.o }\AttributeTok{{-}o}\NormalTok{ app}
\ExtensionTok{./app}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello from helper!
\end{verbatim}

Without linking both \texttt{.o} files, the call to \texttt{greet}
wouldn't work.

\subsubsection{Why It Matters}\label{why-it-matters-87}

Linking is the bridge between your code and other code. It's what turns
individual \texttt{.c} files, or entire libraries, into a single working
program. Once you understand it, multi-file projects and libraries stop
being mysterious.

\subsubsection{Try It Yourself}\label{try-it-yourself-87}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Split a program into \texttt{main.c} and \texttt{helper.c}, link them
  together.
\item
  Use \texttt{sqrt}, try compiling without and with \texttt{-lm}.
\item
  Build your own static library with \texttt{ar} and link to it.
\item
  Trigger an ``undefined reference'' error, then fix it.
\item
  Write a Makefile that builds and links everything automatically.
\end{enumerate}

After this, you'll see linking not as magic, but as a simple, logical
final step, connecting all your code into one.

\subsection{\texorpdfstring{89. Simple Threads with
\texttt{\textless{}threads.h\textgreater{}}}{89. Simple Threads with \textless threads.h\textgreater{}}}\label{simple-threads-with-threads.h}

So far, all your programs have done one thing at a time, one main path,
one sequence of instructions. But many real-world programs need to do
multiple things at once: downloading files while updating a progress
bar, handling many connections, or computing parts of a problem in
parallel.

To do that, you use threads, lightweight ``mini-programs'' that run side
by side inside the same process. And starting with modern C, you have a
built-in way to use them through
\texttt{\textless{}threads.h\textgreater{}}.

Let's explore how to create, run, and join threads safely, step by step.

\subsubsection{89.1 What Is a Thread}\label{what-is-a-thread}

A thread is a path of execution inside a program. Every program starts
with one, the main thread. When you create new threads, they share the
same memory but run independently.

You can think of threads like helpers: each one works on a task while
the others do something else.

\subsubsection{89.2 Including the Thread
Library}\label{including-the-thread-library}

To use threads in modern C, include:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

This gives you access to:

\begin{itemize}
\tightlist
\item
  \texttt{thrd\_t} → the thread type
\item
  \texttt{thrd\_create()} → to start a new thread
\item
  \texttt{thrd\_join()} → to wait for it to finish
\end{itemize}

It's simple, portable, and standardized, no special libraries needed.

\subsubsection{89.3 A Thread Function}\label{a-thread-function}

Each thread runs a function. That function must take a single
\texttt{void*} argument and return an \texttt{int}.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ work}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from a thread!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{89.4 Creating a Thread}\label{creating-a-thread}

You create a thread with \texttt{thrd\_create}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{thrd\_t t}\OperatorTok{;}
\NormalTok{thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This starts a new thread that runs \texttt{work(NULL)}.

If you want to pass data, replace \texttt{NULL} with a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{42}\OperatorTok{;}
\NormalTok{thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,} \OperatorTok{\&}\NormalTok{value}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The thread will receive that pointer as its \texttt{arg}.

\subsubsection{89.5 Waiting for a Thread}\label{waiting-for-a-thread}

If you want to wait for a thread to finish before continuing, call
\texttt{thrd\_join}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{thrd\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This blocks the main thread until \texttt{t} completes. Without joining,
your program might end before the thread finishes.

\subsubsection{89.6 Example: One Thread}\label{example-one-thread}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ work}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Running in another thread!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    thrd\_t t}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ work}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Back in main.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Running in another thread!
Back in main.
\end{verbatim}

You just launched your first parallel task!

\subsubsection{89.7 Example: Passing Data}\label{example-passing-data}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ print\_number}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ num }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int} \OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Number: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ num}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ x }\OperatorTok{=} \DecValTok{7}\OperatorTok{;}
\NormalTok{    thrd\_t t}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ print\_number}\OperatorTok{,} \OperatorTok{\&}\NormalTok{x}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This shows how to share simple data. The thread prints whatever number
it's given.

\subsubsection{89.8 Multiple Threads}\label{multiple-threads}

You can launch several threads at once:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ hello}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ id }\OperatorTok{=} \OperatorTok{*(}\DataTypeTok{int} \OperatorTok{*)}\NormalTok{arg}\OperatorTok{;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from thread }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ id}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    thrd\_t threads}\OperatorTok{[}\DecValTok{3}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ ids}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{\};}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        thrd\_create}\OperatorTok{(\&}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ hello}\OperatorTok{,} \OperatorTok{\&}\NormalTok{ids}\OperatorTok{[}\NormalTok{i}\OperatorTok{]);}

    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
\NormalTok{        thrd\_join}\OperatorTok{(}\NormalTok{threads}\OperatorTok{[}\NormalTok{i}\OperatorTok{],}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"All threads finished.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output (order may vary):

\begin{verbatim}
Hello from thread 2
Hello from thread 1
Hello from thread 3
All threads finished.
\end{verbatim}

Threads run concurrently, so order isn't guaranteed.

\subsubsection{89.9 Thread Safety Tips}\label{thread-safety-tips}

Threads share memory, so they can modify the same data at the same time.
That's powerful but dangerous, it can cause race conditions.

Simple rules for now:

\begin{itemize}
\tightlist
\item
  Don't change the same variable from two threads
\item
  Pass separate data to each thread
\item
  Use \texttt{mtx\_t} (mutex) if you need to share (coming next)
\end{itemize}

Keep it simple: one thread per independent task.

\subsubsection{89.10 Tiny Code Example}\label{tiny-code-example-34}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ greet}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Hello from thread!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    thrd\_t t}\OperatorTok{;}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{thrd\_create}\OperatorTok{(\&}\NormalTok{t}\OperatorTok{,}\NormalTok{ greet}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ thrd\_success}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Failed to create thread.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Main finished.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Hello from thread!
Main finished.
\end{verbatim}

\subsubsection{Why It Matters}\label{why-it-matters-88}

Threads let your programs do more than one thing at a time, making them
faster and more responsive. You'll see them everywhere: in servers,
games, data processing, and UI applications.

And with \texttt{\textless{}threads.h\textgreater{}}, you can use them
in clean, standard C.

\subsubsection{Try It Yourself}\label{try-it-yourself-88}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create one thread that prints a message.
\item
  Launch three threads that each print their ID.
\item
  Pass a number to a thread and print its square.
\item
  Try removing \texttt{thrd\_join}, what happens?
\item
  Experiment with random delays to see thread interleaving.
\end{enumerate}

Once you get comfortable, you'll see that threads are just like helpers,
small, independent workers that share your program's memory and time.

\subsection{90. Synchronization and Data
Safety}\label{synchronization-and-data-safety}

Now that you've met threads, you know they can run at the same time and
even share memory. That's powerful, but it can also be dangerous if two
threads try to change the same variable at once.

To keep your data safe and your program stable, you need
synchronization, tools that help threads take turns and avoid stepping
on each other's work.

In this section, you'll learn the basics of synchronization with mutexes
and locks. Don't worry, we'll go slowly and keep it simple.

\subsubsection{90.1 The Problem: Race
Conditions}\label{the-problem-race-conditions}

A race condition happens when two threads try to change shared data at
the same time.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        counter}\OperatorTok{++;}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    thrd\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ add}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ add}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You might expect \texttt{200000}, but you'll often get a smaller number.
That's because the two threads race to update \texttt{counter}, and one
overwrites the other's work.

We need a way to make sure only one thread updates at a time.

\subsubsection{90.2 Meet the Mutex}\label{meet-the-mutex}

A mutex (mutual exclusion) is like a lock on a door, only one thread can
hold it at a time. When one thread locks it, others must wait until it
unlocks.

C provides a mutex type in \texttt{\textless{}threads.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtx\_t lock}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You create it with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtx\_init}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{,}\NormalTok{ mtx\_plain}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

And use it like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtx\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}   \CommentTok{// enter critical section}
\CommentTok{// do safe work}
\NormalTok{mtx\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);} \CommentTok{// leave critical section}
\end{Highlighting}
\end{Shaded}

This guarantees that only one thread at a time runs the protected code.

\subsubsection{90.3 Fixing the Race}\label{fixing-the-race}

Let's fix the counter example with a mutex.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ counter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{mtx\_t lock}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ add}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        mtx\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{        counter}\OperatorTok{++;}
\NormalTok{        mtx\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    mtx\_init}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{,}\NormalTok{ mtx\_plain}\OperatorTok{);}

\NormalTok{    thrd\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ add}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ add}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Counter: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ counter}\OperatorTok{);}

\NormalTok{    mtx\_destroy}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now the program always prints:

\begin{verbatim}
Counter: 200000
\end{verbatim}

The mutex makes the increment atomic, one thread finishes before the
next begins.

\subsubsection{90.4 Critical Sections}\label{critical-sections}

The code between \texttt{mtx\_lock} and \texttt{mtx\_unlock} is called a
critical section. Only one thread may be inside it at a time.

Use critical sections to:

\begin{itemize}
\tightlist
\item
  Update shared variables
\item
  Write to shared files
\item
  Modify shared data structures
\end{itemize}

Keep them short, locking too long can make your program slower.

\subsubsection{90.5 Initializing and
Destroying}\label{initializing-and-destroying}

Always remember to:

\begin{itemize}
\tightlist
\item
  \texttt{mtx\_init} before first use
\item
  \texttt{mtx\_destroy} at the end
\end{itemize}

It's good practice, even for small programs.

\subsubsection{90.6 Example: Bank Account}\label{example-bank-account}

Let's see a practical use. Two threads deposit money into the same
account:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ balance }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{mtx\_t lock}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ deposit}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100000}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        mtx\_lock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
\NormalTok{        balance}\OperatorTok{++;}
\NormalTok{        mtx\_unlock}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \OperatorTok{\}}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    mtx\_init}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{,}\NormalTok{ mtx\_plain}\OperatorTok{);}

\NormalTok{    thrd\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ deposit}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ deposit}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Final balance: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ balance}\OperatorTok{);}

\NormalTok{    mtx\_destroy}\OperatorTok{(\&}\NormalTok{lock}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

No matter how the threads interleave, the balance is correct, thanks to
the mutex.

\subsubsection{90.7 Try Without Lock}\label{try-without-lock}

If you remove the lock/unlock lines, the balance will often be wrong.
Try it once, you'll see how unpredictable shared data can become. That's
why synchronization is essential.

\subsubsection{90.8 Other Synchronization
Tools}\label{other-synchronization-tools}

Mutexes are just the start. C's
\texttt{\textless{}threads.h\textgreater{}} also offers:

\begin{itemize}
\tightlist
\item
  \texttt{cnd\_t} for condition variables (wait/notify)
\item
  \texttt{once\_flag} for one-time initialization
\end{itemize}

But for most beginner programs, mutexes are all you need.

\subsubsection{90.9 Common Mistakes}\label{common-mistakes-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting to \texttt{mtx\_init} → crash
\item
  Forgetting to \texttt{mtx\_destroy} → resource leak
\item
  Locking twice without unlocking → deadlock
\item
  Unlocking from a different thread → undefined behavior
\item
  Holding a lock too long → performance drop
\end{enumerate}

Keep it simple: one lock, one unlock, short critical section.

\subsubsection{90.10 Tiny Code Example}\label{tiny-code-example-35}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}threads.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ value }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{mtx\_t m}\OperatorTok{;}

\DataTypeTok{int}\NormalTok{ increment}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{arg}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    mtx\_lock}\OperatorTok{(\&}\NormalTok{m}\OperatorTok{);}
\NormalTok{    value}\OperatorTok{++;}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Value now: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{    mtx\_unlock}\OperatorTok{(\&}\NormalTok{m}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    mtx\_init}\OperatorTok{(\&}\NormalTok{m}\OperatorTok{,}\NormalTok{ mtx\_plain}\OperatorTok{);}
\NormalTok{    thrd\_t t1}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{;}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t1}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_create}\OperatorTok{(\&}\NormalTok{t2}\OperatorTok{,}\NormalTok{ increment}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t1}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    thrd\_join}\OperatorTok{(}\NormalTok{t2}\OperatorTok{,}\NormalTok{ NULL}\OperatorTok{);}
\NormalTok{    mtx\_destroy}\OperatorTok{(\&}\NormalTok{m}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Output:

\begin{verbatim}
Value now: 1
Value now: 2
\end{verbatim}

Safe, predictable, and fully synchronized.

\subsubsection{Why It Matters}\label{why-it-matters-89}

Without synchronization, multi-threaded programs become unreliable and
hard to debug. With mutexes, you control when and how threads access
shared data, keeping everything consistent and correct.

You've just learned the secret to safe concurrency.

\subsubsection{Try It Yourself}\label{try-it-yourself-89}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Re-run your counter example with and without \texttt{mtx\_lock}.
  Compare results.
\item
  Create a shared array and have two threads fill different halves.
\item
  Add a mutex to protect a shared sum variable.
\item
  Try locking twice in a row, see what happens (then fix it).
\item
  Measure how many iterations per second you get with and without
  locking.
\end{enumerate}

Once you master synchronization, you'll be ready to write safe,
concurrent C programs, fast and correct at the same time.

\section{Chapter 10. Putting it all
together}\label{chapter-10.-putting-it-all-together-1}

\subsection{91. Mini Project 1: Text
Analyzer}\label{mini-project-1-text-analyzer}

Congratulations, you've made it all the way here! Now it's time to bring
everything together.

In this mini project, you'll build a Text Analyzer, a simple tool that
reads a text file and reports basic statistics, like how many lines,
words, and characters it contains.

This project combines everything you've learned: file I/O, loops,
conditionals, functions, and basic data handling. Let's take it step by
step.

\subsubsection{91.1 Project Goal}\label{project-goal}

Write a program that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Takes a filename as a command-line argument.
\item
  Opens the file.
\item
  Reads it line by line.
\item
  Counts:

  \begin{itemize}
  \tightlist
  \item
    Total characters
  \item
    Total words
  \item
    Total lines
  \end{itemize}
\item
  Prints a summary at the end.
\end{enumerate}

This is a classic utility, similar to the Unix \texttt{wc} command (word
count).

\subsubsection{91.2 Planning the Program}\label{planning-the-program}

Let's think before coding. We'll need:

\begin{itemize}
\tightlist
\item
  A function to open the file.
\item
  A loop to read it line by line.
\item
  Logic to count words (detect spaces and newlines).
\item
  A final summary.
\end{itemize}

We'll count words by checking when a sequence of letters starts.

\subsubsection{91.3 Handling Input}\label{handling-input}

Our program takes the filename from the command line:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}filename\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then we'll open it safely:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{91.4 Reading the File}\label{reading-the-file}

We can read one character at a time with \texttt{fgetc()}, this makes
counting easier.

We'll track:

\begin{itemize}
\tightlist
\item
  \texttt{chars} for total characters
\item
  \texttt{words} for total words
\item
  \texttt{lines} for total lines
\item
  \texttt{in\_word} flag to check if we're inside a word
\end{itemize}

\subsubsection{91.5 Core Counting Logic}\label{core-counting-logic}

Here's the main counting loop:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ chars }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ words }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ lines }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ c}\OperatorTok{,}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\ControlFlowTok{while} \OperatorTok{((}\NormalTok{c }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    chars}\OperatorTok{++;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{)}
\NormalTok{        lines}\OperatorTok{++;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}} \OperatorTok{||}\NormalTok{ c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}} \OperatorTok{||}\NormalTok{ c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}t}\CharTok{\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{in\_word}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        in\_word }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{        words}\OperatorTok{++;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This loop goes through each character, tracks lines when it sees
\texttt{\textquotesingle{}\textbackslash{}n\textquotesingle{}}, and
increments \texttt{words} each time a new word starts.

\subsubsection{91.6 Displaying the
Results}\label{displaying-the-results}

When done, print the summary:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Lines: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ lines}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Words: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ words}\OperatorTok{);}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Characters: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ chars}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Finally, don't forget to close the file:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{91.7 Full Program}\label{full-program}

Here's the complete version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}filename\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{fp }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{fp }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ chars }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ words }\OperatorTok{=} \DecValTok{0}\OperatorTok{,}\NormalTok{ lines }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ c}\OperatorTok{,}\NormalTok{ in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{c }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{fp}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        chars}\OperatorTok{++;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\OperatorTok{)}
\NormalTok{            lines}\OperatorTok{++;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{c }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}} \OperatorTok{||}\NormalTok{ c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}} \OperatorTok{||}\NormalTok{ c }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}t}\CharTok{\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            in\_word }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(!}\NormalTok{in\_word}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            in\_word }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{            words}\OperatorTok{++;}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{fp}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{]);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Lines: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ lines}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Words: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ words}\OperatorTok{);}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Characters: }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ chars}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{91.8 Example Run}\label{example-run}

Say you have a file called \texttt{sample.txt}:

\begin{verbatim}
Hello world!
This is a test.
\end{verbatim}

Run:

\begin{verbatim}
./textanalyzer sample.txt
\end{verbatim}

Output:

\begin{verbatim}
File: sample.txt
Lines: 2
Words: 5
Characters: 27
\end{verbatim}

\subsubsection{91.9 Tiny Improvements}\label{tiny-improvements}

You can enhance it later:

\begin{itemize}
\tightlist
\item
  Add error messages for empty files.
\item
  Support reading from standard input (\texttt{stdin}).
\item
  Print average word length.
\item
  Use \texttt{fgets()} instead of \texttt{fgetc()} for performance.
\end{itemize}

Each improvement builds on what you know.

\subsubsection{91.10 Why It Matters}\label{why-it-matters-90}

This project ties together files, loops, and logic in one useful tool.
It shows how simple building blocks can become a real program.

You're not just learning C, you're learning how to think like a software
builder.

\subsubsection{Try It Yourself}\label{try-it-yourself-90}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the program on different text files.
\item
  Add a counter for blank lines.
\item
  Modify it to count digits or punctuation marks.
\item
  Use \texttt{fgets()} and \texttt{strlen()} instead of
  \texttt{fgetc()}.
\item
  Print a summary table for multiple files (bonus).
\end{enumerate}

You've just written your first utility, a small but mighty C program
that reads real data and analyzes it like a pro.

\subsection{92. Mini Project 2: Guessing
Game}\label{mini-project-2-guessing-game}

Let's take a break from files and build something fun, a Guessing Game!
This little project will help you practice loops, conditionals, random
numbers, and user input.

Your program will pick a secret number, and you'll try to guess it.
After each guess, it tells you if you're too high, too low, or exactly
right.

This is one of the best beginner projects, simple, interactive, and
great for mastering logic.

\subsubsection{92.1 Project Goal}\label{project-goal-1}

Write a program that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Chooses a random number between 1 and 100.
\item
  Prompts the user to guess the number.
\item
  Tells the user if the guess is too high, too low, or correct.
\item
  Counts how many guesses it took.
\item
  Ends when the user guesses correctly.
\end{enumerate}

\subsubsection{92.2 What You'll Learn}\label{what-youll-learn}

This project helps you practice:

\begin{itemize}
\tightlist
\item
  Generating random numbers
\item
  Reading user input safely
\item
  Using loops and conditionals
\item
  Giving clear feedback to the user
\end{itemize}

You'll also get to see how programs can interact, almost like a game.

\subsubsection{92.3 Setting Up Random
Numbers}\label{setting-up-random-numbers}

C provides random numbers with \texttt{rand()}, but to make it different
each time, you seed it with the current time.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\NormalTok{srand}\OperatorTok{(}\NormalTok{time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{));} \CommentTok{// set the seed}
\DataTypeTok{int}\NormalTok{ secret }\OperatorTok{=}\NormalTok{ rand}\OperatorTok{()} \OperatorTok{\%} \DecValTok{100} \OperatorTok{+} \DecValTok{1}\OperatorTok{;} \CommentTok{// number from 1 to 100}
\end{Highlighting}
\end{Shaded}

\texttt{rand()\ \%\ 100} gives a value between 0 and 99, so we add 1 to
shift it into 1--100.

\subsubsection{92.4 Getting the User's
Guess}\label{getting-the-users-guess}

We'll use \texttt{scanf} to get the user's guess:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ guess}\OperatorTok{;}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter your guess: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{guess}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Always check the input is valid, but for now, we'll keep it simple.

\subsubsection{92.5 The Game Loop}\label{the-game-loop}

We'll keep asking until the user guesses correctly. A \texttt{while}
loop is perfect:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ guess }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ tries }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\ControlFlowTok{while} \OperatorTok{(}\NormalTok{guess }\OperatorTok{!=}\NormalTok{ secret}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter your guess: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{guess}\OperatorTok{);}
\NormalTok{    tries}\OperatorTok{++;}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{guess }\OperatorTok{\textless{}}\NormalTok{ secret}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Too low! Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{guess }\OperatorTok{\textgreater{}}\NormalTok{ secret}\OperatorTok{)}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Too high! Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{else}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Correct! You guessed it in }\SpecialCharTok{\%d}\StringTok{ tries.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ tries}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{92.6 Putting It Together}\label{putting-it-together}

Here's the complete program:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    srand}\OperatorTok{(}\NormalTok{time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{));}
    \DataTypeTok{int}\NormalTok{ secret }\OperatorTok{=}\NormalTok{ rand}\OperatorTok{()} \OperatorTok{\%} \DecValTok{100} \OperatorTok{+} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ guess }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ tries }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"I\textquotesingle{}m thinking of a number between 1 and 100.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{guess }\OperatorTok{!=}\NormalTok{ secret}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter your guess: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{guess}\OperatorTok{);}
\NormalTok{        tries}\OperatorTok{++;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{guess }\OperatorTok{\textless{}}\NormalTok{ secret}\OperatorTok{)}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Too low! Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{guess }\OperatorTok{\textgreater{}}\NormalTok{ secret}\OperatorTok{)}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Too high! Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{else}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Correct! You guessed it in }\SpecialCharTok{\%d}\StringTok{ tries.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ tries}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{92.7 Example Run}\label{example-run-1}

\begin{verbatim}
I'm thinking of a number between 1 and 100.
Enter your guess: 50
Too low! Try again.
Enter your guess: 75
Too high! Try again.
Enter your guess: 63
Too low! Try again.
Enter your guess: 69
Correct! You guessed it in 4 tries.
\end{verbatim}

Every run is different because of the random seed.

\subsubsection{92.8 Tiny Improvements}\label{tiny-improvements-1}

Once you've got it working, you can make it more fun:

\begin{itemize}
\tightlist
\item
  Add input validation
  (\texttt{if\ (guess\ \textless{}\ 1\ \textbar{}\textbar{}\ guess\ \textgreater{}\ 100)})
\item
  Show a ``hint'' if the guess is very close
\item
  Let the user choose the range (1--50, 1--1000, etc.)
\item
  Ask if they want to play again
\end{itemize}

Each of these adds a little more logic and creativity.

\subsubsection{92.9 Common Mistakes}\label{common-mistakes-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{srand(time(NULL))}, the number will be the same
  every run.
\item
  Using \texttt{rand()\ \%\ 100} but forgetting \texttt{+\ 1} (you'll
  never guess 100).
\item
  Not updating \texttt{tries} each loop.
\item
  Using \texttt{=} instead of \texttt{==} in comparisons.
\item
  Forgetting to handle invalid input (try entering a letter!).
\end{enumerate}

Don't worry, these are easy to fix once you know them.

\subsubsection{92.10 Why It Matters}\label{why-it-matters-91}

This project blends logic and interaction, a perfect match for
beginners. It's simple enough to build in minutes, but rich enough to
teach important ideas like loops, conditionals, and randomness.

You're not just printing text anymore, you're creating a tiny game!

\subsubsection{Try It Yourself}\label{try-it-yourself-91}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Change the range to 1--50.
\item
  Add a ``hint'' if the user is within 10 of the secret.
\item
  Keep track of best score (fewest guesses).
\item
  Ask if the user wants to play again.
\item
  Use a \texttt{for} loop with a max number of guesses (like 10).
\end{enumerate}

You've now built your first interactive game, one that listens, thinks,
and responds. This is where programming really starts to feel magical.

\subsection{93. Mini Project 3:
Calculator}\label{mini-project-3-calculator}

It's time to build something every programmer tries at least once, a
Calculator! This project gives you great practice with user input,
operators, switch statements, and functions.

You'll create a small program that reads two numbers and an operator,
performs the calculation, and prints the result. It's simple, useful,
and a perfect way to pull together what you've learned so far.

\subsubsection{93.1 Project Goal}\label{project-goal-2}

Build a calculator that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Asks the user for two numbers.
\item
  Asks what operation to perform (+, -, *, /).
\item
  Performs that operation.
\item
  Prints the result.
\item
  Handles invalid operators gracefully.
\end{enumerate}

This is a classic practice project for learning input, branching, and
math.

\subsubsection{93.2 Plan the Steps}\label{plan-the-steps}

Let's outline what the program will do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask for first number.
\item
  Ask for second number.
\item
  Ask for operator (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}).
\item
  Use a \texttt{switch} to decide which math to do.
\item
  Display the result.
\item
  Handle division by zero or invalid inputs.
\end{enumerate}

This clear sequence keeps your program simple and readable.

\subsubsection{93.3 Getting User Input}\label{getting-user-input}

We'll use \texttt{scanf} to read the values:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
\DataTypeTok{char}\NormalTok{ op}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter first number: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{a}\OperatorTok{);}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter an operator (+, {-}, *, /): "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{" }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{op}\OperatorTok{);} \CommentTok{// note the space before \%c}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter second number: "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{b}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The space before \texttt{\%c} makes sure we skip leftover newlines from
earlier input.

\subsubsection{93.4 Deciding What to Do}\label{deciding-what-to-do}

We'll use a \texttt{switch} on the operator:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{switch} \OperatorTok{(}\NormalTok{op}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ + }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ {-} }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ * }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{case} \CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{:}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{!=} \DecValTok{0}\OperatorTok{)}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ / }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}
        \ControlFlowTok{else}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Error: division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \ControlFlowTok{break}\OperatorTok{;}
    \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Unknown operator: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ op}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This structure makes it easy to add more operations later.

\subsubsection{93.5 Full Program}\label{full-program-1}

Here's your complete calculator:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{double}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{;}
    \DataTypeTok{char}\NormalTok{ op}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter first number: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{a}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter an operator (+, {-}, *, /): "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{" }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{op}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter second number: "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%lf}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{b}\OperatorTok{);}

    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{op}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ + }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ {-} }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ * }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{:}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{b }\OperatorTok{!=} \DecValTok{0}\OperatorTok{)}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%.2f}\StringTok{ / }\SpecialCharTok{\%.2f}\StringTok{ = }\SpecialCharTok{\%.2f\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}\OperatorTok{);}
            \ControlFlowTok{else}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Error: division by zero!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Unknown operator: }\SpecialCharTok{\%c\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ op}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{93.6 Example Run}\label{example-run-2}

\begin{verbatim}
Enter first number: 10
Enter an operator (+, -, *, /): *
Enter second number: 5
10.00 * 5.00 = 50.00
\end{verbatim}

Another run:

\begin{verbatim}
Enter first number: 7
Enter an operator (+, -, *, /): /
Enter second number: 0
Error: division by zero!
\end{verbatim}

Perfect, your program reacts exactly as it should.

\subsubsection{93.7 Improving It with a
Loop}\label{improving-it-with-a-loop}

Want to keep calculating until the user quits? Add a loop:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ cont }\OperatorTok{=} \CharTok{\textquotesingle{}y\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{while} \OperatorTok{(}\NormalTok{cont }\OperatorTok{==} \CharTok{\textquotesingle{}y\textquotesingle{}} \OperatorTok{||}\NormalTok{ cont }\OperatorTok{==} \CharTok{\textquotesingle{}Y\textquotesingle{}}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// (all calculator code here)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Do another calculation? (y/n): "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{" }\SpecialCharTok{\%c}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{cont}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now it's a reusable calculator!

\subsubsection{93.8 Moving to Functions}\label{moving-to-functions}

You can move the math logic into a function:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ calculate}\OperatorTok{(}\DataTypeTok{double}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{double}\NormalTok{ b}\OperatorTok{,} \DataTypeTok{char}\NormalTok{ op}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{switch} \OperatorTok{(}\NormalTok{op}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}+\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}{-}\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}*\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return}\NormalTok{ a }\OperatorTok{*}\NormalTok{ b}\OperatorTok{;}
        \ControlFlowTok{case} \CharTok{\textquotesingle{}/\textquotesingle{}}\OperatorTok{:} \ControlFlowTok{return} \OperatorTok{(}\NormalTok{b }\OperatorTok{!=} \DecValTok{0}\OperatorTok{)} \OperatorTok{?}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b }\OperatorTok{:} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{default}\OperatorTok{:} \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This makes your code modular and easier to extend.

\subsubsection{93.9 Common Mistakes}\label{common-mistakes-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting space before \texttt{\%c} in \texttt{scanf} → operator
  input is skipped.
\item
  Division by zero not handled → crash or \texttt{inf}.
\item
  Mixing up \texttt{\%d} and \texttt{\%lf} → wrong output for doubles.
\item
  No \texttt{break} in \texttt{switch} → falls through to next case.
\item
  Forgetting \texttt{default:} → unknown operators go unhandled.
\end{enumerate}

Pay attention to these, and your calculator will be solid.

\subsubsection{93.10 Why It Matters}\label{why-it-matters-92}

This project shows how small, clear logic can build something genuinely
useful. It's an excellent exercise in control flow, input validation,
and user interaction.

You've built your own math tool, one you fully understand.

\subsubsection{Try It Yourself}\label{try-it-yourself-92}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add support for modulus (\texttt{\%}) with integers.
\item
  Add exponentiation (use \texttt{pow()} from
  \texttt{\textless{}math.h\textgreater{}}).
\item
  Display all operations in one loop until user quits.
\item
  Use a function \texttt{calculate(a,\ b,\ op)} for cleaner structure.
\item
  Add error messages for invalid input or bad operators.
\end{enumerate}

With each improvement, you'll turn your simple calculator into a more
polished tool, one step closer to real-world software.

\subsection{94. Mini Project 4: File Copy
Utility}\label{mini-project-4-file-copy-utility}

Now that you're comfortable reading and writing files, let's build
something truly practical, a File Copy Utility.

This program copies the contents of one file into another, just like the
\texttt{cp} command on Linux or the ``Copy → Paste'' action in your file
explorer.

It's simple, yet powerful: you'll learn how to read from one file, write
to another, and handle errors safely.

\subsubsection{94.1 Project Goal}\label{project-goal-3}

Your program should:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take two filenames from the command line, the source and the
  destination.
\item
  Open the source file for reading.
\item
  Open (or create) the destination file for writing.
\item
  Copy all the contents from source to destination.
\item
  Close both files and confirm success.
\end{enumerate}

\subsubsection{94.2 Why This Project
Matters}\label{why-this-project-matters}

File copying is one of the most common tasks in programming. It combines
everything you've learned about file I/O, error handling, loops, and
command-line arguments, all in one program.

And best of all, it's a real, useful tool!

\subsubsection{94.3 Plan the Steps}\label{plan-the-steps-1}

Let's break it down step by step:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Check that the user provided two filenames.
\item
  Open the source file (\texttt{"r"}) and the destination file
  (\texttt{"w"}).
\item
  Read the source file one character at a time using \texttt{fgetc}.
\item
  Write each character to the destination using \texttt{fputc}.
\item
  Close both files and print a success message.
\end{enumerate}

Simple, right?

\subsubsection{94.4 Handling Input}\label{handling-input-1}

We'll start with checking command-line arguments:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}source\textgreater{} \textless{}destination\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

That ensures we always have both filenames ready.

\subsubsection{94.5 Opening Files Safely}\label{opening-files-safely}

Next, open both files carefully:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{src }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{src }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening source file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{dst }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{],} \StringTok{"w"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{dst }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening destination file"}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Always check for errors, missing files, wrong permissions, etc. If
opening the destination fails, remember to close the source file first.

\subsubsection{94.6 Copying Data}\label{copying-data}

Now, let's copy the contents character by character:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ ch}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{((}\NormalTok{ch }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{src}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    fputc}\OperatorTok{(}\NormalTok{ch}\OperatorTok{,}\NormalTok{ dst}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This reads one byte at a time and writes it immediately. It works for
any text file, and even small binary files.

\subsubsection{94.7 Closing and
Confirming}\label{closing-and-confirming}

Once copying is done, close both files:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
\NormalTok{fclose}\OperatorTok{(}\NormalTok{dst}\OperatorTok{);}

\NormalTok{printf}\OperatorTok{(}\StringTok{"File copied successfully from }\SpecialCharTok{\%s}\StringTok{ to }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}
\end{Highlighting}
\end{Shaded}

That's it, your copy utility is complete!

\subsubsection{94.8 Full Program}\label{full-program-2}

Here's the full code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ argc}\OperatorTok{,} \DataTypeTok{char} \OperatorTok{*}\NormalTok{argv}\OperatorTok{[])} \OperatorTok{\{}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{argc }\OperatorTok{\textless{}} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Usage: }\SpecialCharTok{\%s}\StringTok{ \textless{}source\textgreater{} \textless{}destination\textgreater{}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{0}\OperatorTok{]);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{src }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{src }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening source file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{dst }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\NormalTok{argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{],} \StringTok{"w"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{dst }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening destination file"}\OperatorTok{);}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{int}\NormalTok{ ch}\OperatorTok{;}
    \ControlFlowTok{while} \OperatorTok{((}\NormalTok{ch }\OperatorTok{=}\NormalTok{ fgetc}\OperatorTok{(}\NormalTok{src}\OperatorTok{))} \OperatorTok{!=}\NormalTok{ EOF}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        fputc}\OperatorTok{(}\NormalTok{ch}\OperatorTok{,}\NormalTok{ dst}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{src}\OperatorTok{);}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{dst}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"File copied successfully from }\SpecialCharTok{\%s}\StringTok{ to }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ argv}\OperatorTok{[}\DecValTok{1}\OperatorTok{],}\NormalTok{ argv}\OperatorTok{[}\DecValTok{2}\OperatorTok{]);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{94.9 Example Run}\label{example-run-3}

\begin{verbatim}
$ ./filecopy input.txt output.txt
File copied successfully from input.txt to output.txt
\end{verbatim}

If \texttt{input.txt} contains:

\begin{verbatim}
Hello world!
\end{verbatim}

Then \texttt{output.txt} will now have exactly the same contents.

\subsubsection{94.10 Tiny Improvements}\label{tiny-improvements-2}

Once your basic version works, you can make it more robust:

\begin{itemize}
\tightlist
\item
  Copy binary files too → use \texttt{"rb"} and \texttt{"wb"} modes.
\item
  Show progress by counting bytes copied.
\item
  Print file sizes before and after copying.
\item
  Add error messages if read or write fails.
\item
  Ask before overwriting an existing file.
\end{itemize}

Each small upgrade makes it closer to a real utility.

\subsubsection{Why It Matters}\label{why-it-matters-93}

This project gives you hands-on experience with file manipulation, one
of the most common real-world programming tasks. You're building
something every operating system depends on: safe, reliable file
operations.

\subsubsection{Try It Yourself}\label{try-it-yourself-93}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Copy a small text file and compare contents.
\item
  Add a byte counter (\texttt{int\ bytes\ =\ 0;}) and print how many
  were copied.
\item
  Modify the program to handle binary files using \texttt{"rb"} and
  \texttt{"wb"}.
\item
  Test with a large file, see how fast it runs!
\item
  Try error cases, missing file, no permissions, etc.
\end{enumerate}

Once you've done this, you'll know exactly how a copy command works
behind the scenes, because you built one yourself!

\subsection{95. Mini Project 5: Simple
Logger}\label{mini-project-5-simple-logger}

Let's build another handy tool, a Simple Logger.

Logging is one of the most common patterns in programming. It's how
programs record what happened, messages, errors, or progress, into a
file so you can review them later.

In this project, you'll create a small program that appends messages to
a log file with timestamps. You'll learn how to open files in append
mode, work with time, and handle repeated writes safely.

\subsubsection{95.1 Project Goal}\label{project-goal-4}

Your logger will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask the user for a message.
\item
  Add the message to a log file (\texttt{log.txt}).
\item
  Prepend a timestamp to each message.
\item
  Keep all previous entries (append, not overwrite).
\item
  Allow multiple entries in one run.
\end{enumerate}

You'll end up with a file full of useful logs, like a little notebook
for your program.

\subsubsection{95.2 What You'll Practice}\label{what-youll-practice}

\begin{itemize}
\tightlist
\item
  File I/O (open, write, close)
\item
  Append mode (\texttt{"a"})
\item
  Time functions from \texttt{\textless{}time.h\textgreater{}}
\item
  Loops and user input
\end{itemize}

You've already seen all of these before, now we'll combine them into
something practical.

\subsubsection{95.3 Opening the Log File}\label{opening-the-log-file}

We'll open the file in append mode, which means new lines are added to
the end without erasing the old ones.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{log }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{log }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening log file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If the file doesn't exist, \texttt{"a"} mode creates it automatically.

\subsubsection{95.4 Getting the Current
Time}\label{getting-the-current-time}

We'll add a timestamp for each entry using
\texttt{\textless{}time.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
\KeywordTok{struct}\NormalTok{ tm }\OperatorTok{*}\NormalTok{t }\OperatorTok{=}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{);}
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{log}\OperatorTok{,} \StringTok{"[}\SpecialCharTok{\%04d}\StringTok{{-}}\SpecialCharTok{\%02d}\StringTok{{-}}\SpecialCharTok{\%02d}\StringTok{ }\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d}\StringTok{] "}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_year }\OperatorTok{+} \DecValTok{1900}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mon }\OperatorTok{+} \DecValTok{1}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mday}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_hour}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_min}\OperatorTok{,}
\NormalTok{        t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_sec}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This prints the date and time in a readable format, like:

\begin{verbatim}
[2025-10-02 09:15:30]
\end{verbatim}

Perfect for a log entry.

\subsubsection{95.5 Reading a Message}\label{reading-a-message}

We'll use \texttt{fgets()} to read the message (it handles spaces too):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ message}\OperatorTok{[}\DecValTok{256}\OperatorTok{];}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter a log message (or \textquotesingle{}quit\textquotesingle{} to stop): "}\OperatorTok{);}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{message}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{message}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{95.6 Writing to the Log}\label{writing-to-the-log}

Once we have the timestamp and message, we just write them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fprintf}\OperatorTok{(}\NormalTok{log}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{,}\NormalTok{ message}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You can add a newline if needed, \texttt{fgets} usually includes it.

Then, close the file at the end:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fclose}\OperatorTok{(}\NormalTok{log}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{95.7 Putting It All
Together}\label{putting-it-all-together}

Here's the full logger:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}time.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ message}\OperatorTok{[}\DecValTok{256}\OperatorTok{];}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Enter a log message (or \textquotesingle{}quit\textquotesingle{} to stop): "}\OperatorTok{);}
\NormalTok{        fgets}\OperatorTok{(}\NormalTok{message}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{message}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}

        \CommentTok{// Remove trailing newline}
\NormalTok{        message}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{message}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{message}\OperatorTok{,} \StringTok{"quit"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{break}\OperatorTok{;}

        \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{log }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"log.txt"}\OperatorTok{,} \StringTok{"a"}\OperatorTok{);}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{log }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            perror}\OperatorTok{(}\StringTok{"Error opening log file"}\OperatorTok{);}
            \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
        \OperatorTok{\}}

        \DataTypeTok{time\_t}\NormalTok{ now }\OperatorTok{=}\NormalTok{ time}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{);}
        \KeywordTok{struct}\NormalTok{ tm }\OperatorTok{*}\NormalTok{t }\OperatorTok{=}\NormalTok{ localtime}\OperatorTok{(\&}\NormalTok{now}\OperatorTok{);}

\NormalTok{        fprintf}\OperatorTok{(}\NormalTok{log}\OperatorTok{,} \StringTok{"[}\SpecialCharTok{\%04d}\StringTok{{-}}\SpecialCharTok{\%02d}\StringTok{{-}}\SpecialCharTok{\%02d}\StringTok{ }\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d}\StringTok{:}\SpecialCharTok{\%02d}\StringTok{] }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_year }\OperatorTok{+} \DecValTok{1900}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mon }\OperatorTok{+} \DecValTok{1}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_mday}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_hour}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_min}\OperatorTok{,}
\NormalTok{                t}\OperatorTok{{-}\textgreater{}}\NormalTok{tm\_sec}\OperatorTok{,}
\NormalTok{                message}\OperatorTok{);}

\NormalTok{        fclose}\OperatorTok{(}\NormalTok{log}\OperatorTok{);}

\NormalTok{        printf}\OperatorTok{(}\StringTok{"Logged: }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ message}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye! Check log.txt for your messages.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{95.8 Example Run}\label{example-run-4}

\begin{verbatim}
Enter a log message (or 'quit' to stop): Program started
Logged: Program started
Enter a log message (or 'quit' to stop): Something went wrong
Logged: Something went wrong
Enter a log message (or 'quit' to stop): quit
Goodbye! Check log.txt for your messages.
\end{verbatim}

log.txt now contains:

\begin{verbatim}
[2025-10-02 09:15:30] Program started
[2025-10-02 09:15:45] Something went wrong
\end{verbatim}

\subsubsection{95.9 Tiny Improvements}\label{tiny-improvements-3}

Try adding:

\begin{itemize}
\tightlist
\item
  A custom filename (\texttt{./logger\ mylog.txt})
\item
  Levels like INFO, WARNING, ERROR
\item
  Session header when program starts
\item
  Log rotation (create new file if too large)
\end{itemize}

Each idea helps you learn how real-world loggers evolve.

\subsubsection{95.10 Common Mistakes}\label{common-mistakes-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Forgetting \texttt{"a"} mode, \texttt{"w"} will erase your log!
\item
  Not closing the file after each write, data may not be saved.
\item
  Forgetting to strip the newline from \texttt{fgets()}.
\item
  Not handling \texttt{quit}, infinite loop!
\end{enumerate}

Watch out for these, and your logger will be reliable and clean.

\subsubsection{Why It Matters}\label{why-it-matters-94}

Logging turns a silent program into one that tells its story. It's how
developers track what's happening inside, for debugging, monitoring, and
auditing.

With this simple tool, you can record events, errors, or notes, a small
step toward professional software design.

\subsubsection{Try It Yourself}\label{try-it-yourself-94}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run the logger and add a few entries.
\item
  Open \texttt{log.txt} and confirm the format.
\item
  Add a \texttt{{[}INFO{]}}, \texttt{{[}WARN{]}}, or
  \texttt{{[}ERROR{]}} tag before the message.
\item
  Ask the user for a custom filename.
\item
  Combine this with earlier projects, e.g., log game results or file
  copies.
\end{enumerate}

You've just built your own logging system, simple, safe, and endlessly
useful.

\subsection{96. Mini Project 6: Contact
Book}\label{mini-project-6-contact-book}

Let's build something a bit more like an application, a Contact Book.

This project teaches you how to store, search, and display structured
data, a list of names, phone numbers, and emails, using structures,
arrays, and file storage.

By the end, you'll have a small program that can add, list, and save
contacts to a file. Think of it as a simple digital notebook built
entirely in C.

\subsubsection{96.1 Project Goal}\label{project-goal-5}

Your Contact Book will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Store a list of contacts (name, phone, email).
\item
  Let the user add new contacts.
\item
  List all saved contacts.
\item
  Save contacts to a file.
\item
  Load contacts when the program starts.
\end{enumerate}

This combines structs, arrays, files, and menus, everything you've
learned so far.

\subsubsection{96.2 Designing the
Structure}\label{designing-the-structure}

Each contact has three pieces of data: a name, a phone number, and an
email. Let's define a structure to hold them:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Contact }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ phone}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ email}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

We'll keep an array of contacts in memory, like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Contact contacts}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This gives space for up to 100 entries, enough for a starter project.

\subsubsection{96.3 Showing the Menu}\label{showing-the-menu}

The user will see a simple text menu:

\begin{verbatim}
1. Add new contact
2. List contacts
3. Save and exit
\end{verbatim}

We'll use a loop and a \texttt{switch} to handle choices.

\subsubsection{96.4 Adding a Contact}\label{adding-a-contact}

Here's how we'll gather info:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter name: "}\OperatorTok{);}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter phone: "}\OperatorTok{);}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter email: "}\OperatorTok{);}
\NormalTok{fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{count}\OperatorTok{++;}
\end{Highlighting}
\end{Shaded}

We remove the trailing newline from \texttt{fgets} so the strings are
clean.

\subsubsection{96.5 Listing Contacts}\label{listing-contacts}

A simple loop prints all contacts:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{. }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{,}
\NormalTok{           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{email}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If there are none yet, show a friendly message:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{count }\OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"No contacts found.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{96.6 Saving to File}\label{saving-to-file}

We'll save the contacts to a text file called \texttt{contacts.txt}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"contacts.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error saving file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    fprintf}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%s}\StringTok{;}\SpecialCharTok{\%s}\StringTok{;}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{email}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

We use \texttt{;} to separate fields so they're easy to parse later.

\subsubsection{96.7 Loading from File}\label{loading-from-file}

When the program starts, it can read back previous contacts:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"contacts.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fscanf}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \StringTok{"\%49[\^{};];\%19[\^{};];\%49[\^{}}\SpecialCharTok{\textbackslash{}n}\StringTok{]}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{                  contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{                  contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{                  contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{)} \OperatorTok{==} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        count}\OperatorTok{++;}
    \OperatorTok{\}}
\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This reads each line and fills your array again, simple persistence!

\subsubsection{96.8 Full Program}\label{full-program-3}

Here's the complete version:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Contact }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ name}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ phone}\OperatorTok{[}\DecValTok{20}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ email}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Contact contacts}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ choice}\OperatorTok{;}

    \CommentTok{// Load contacts}
    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"contacts.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
        \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fscanf}\OperatorTok{(}\NormalTok{f}\OperatorTok{,} \StringTok{"\%49[\^{};];\%19[\^{};];\%49[\^{}}\SpecialCharTok{\textbackslash{}n}\StringTok{]}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{                      contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{                      contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{                      contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{)} \OperatorTok{==} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            count}\OperatorTok{++;}
        \OperatorTok{\}}
\NormalTok{        fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{{-}{-}{-} Contact Book {-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"1. Add new contact}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"2. List contacts}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"3. Save and exit}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"Choose an option: "}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{choice}\OperatorTok{);}
\NormalTok{        getchar}\OperatorTok{();} \CommentTok{// clear newline}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{choice }\OperatorTok{==} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{count }\OperatorTok{\textgreater{}=} \DecValTok{100}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"Contact list full!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
                \ControlFlowTok{continue}\OperatorTok{;}
            \OperatorTok{\}}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Enter name: "}\OperatorTok{);}
\NormalTok{            fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{name}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{            printf}\OperatorTok{(}\StringTok{"Enter phone: "}\OperatorTok{);}
\NormalTok{            fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{            printf}\OperatorTok{(}\StringTok{"Enter email: "}\OperatorTok{);}
\NormalTok{            fgets}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{            contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{contacts}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{email}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

\NormalTok{            count}\OperatorTok{++;}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Contact added!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{choice }\OperatorTok{==} \DecValTok{2}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{count }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"No contacts found.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{                printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{{-}{-}{-} Contact List {-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
                \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{                    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{. }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s}\StringTok{ | }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{,}
\NormalTok{                           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{                           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{                           contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{email}\OperatorTok{);}
                \OperatorTok{\}}
            \OperatorTok{\}}
        \OperatorTok{\}} \ControlFlowTok{else} \ControlFlowTok{if} \OperatorTok{(}\NormalTok{choice }\OperatorTok{==} \DecValTok{3}\OperatorTok{)} \OperatorTok{\{}
            \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{out }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"contacts.txt"}\OperatorTok{,} \StringTok{"w"}\OperatorTok{);}
            \ControlFlowTok{if} \OperatorTok{(}\NormalTok{out }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{                perror}\OperatorTok{(}\StringTok{"Error saving file"}\OperatorTok{);}
                \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
            \OperatorTok{\}}
            \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{                fprintf}\OperatorTok{(}\NormalTok{out}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\%s}\StringTok{;}\SpecialCharTok{\%s}\StringTok{;}\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}
\NormalTok{                        contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{name}\OperatorTok{,}
\NormalTok{                        contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{phone}\OperatorTok{,}
\NormalTok{                        contacts}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{email}\OperatorTok{);}
            \OperatorTok{\}}
\NormalTok{            fclose}\OperatorTok{(}\NormalTok{out}\OperatorTok{);}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Contacts saved. Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
            \ControlFlowTok{break}\OperatorTok{;}
        \OperatorTok{\}} \ControlFlowTok{else} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"Invalid option. Try again.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{96.9 Example Run}\label{example-run-5}

\begin{verbatim}
--- Contact Book ---
1. Add new contact
2. List contacts
3. Save and exit
Choose an option: 1
Enter name: Alice
Enter phone: 123-456
Enter email: alice@example.com
Contact added!

--- Contact Book ---
1. Add new contact
2. List contacts
3. Save and exit
Choose an option: 2
--- Contact List ---
1. Alice | 123-456 | alice@example.com
\end{verbatim}

\subsubsection{96.10 Tiny Improvements}\label{tiny-improvements-4}

You can make your Contact Book even better:

\begin{itemize}
\tightlist
\item
  Add a search function (by name).
\item
  Allow deleting contacts.
\item
  Save in CSV or JSON format.
\item
  Store more fields (address, notes).
\item
  Sort by name before listing.
\end{itemize}

Each small step makes it closer to a real app.

\subsubsection{Why It Matters}\label{why-it-matters-95}

You've now built your first data-driven program, one that reads, stores,
and saves real information. This is the heart of all database systems,
from phone apps to contact managers.

You're not just coding anymore, you're building software that remembers.

\subsubsection{Try It Yourself}\label{try-it-yourself-95}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a search option to find contacts by name.
\item
  Add a delete option using an index number.
\item
  Sort the list alphabetically before displaying.
\item
  Save to a custom filename entered by the user.
\item
  Limit contact names to unique entries (no duplicates).
\end{enumerate}

This project is a big leap, a true foundation for working with
structured data and files.

\subsection{97. Mini Project 7: Matrix
Operations}\label{mini-project-7-matrix-operations}

Time to step into the world of mathematical programming, let's build a
Matrix Operations tool.

In this project, you'll create a small program that performs basic
operations on 2D matrices: addition, subtraction, and multiplication.

It's a great exercise to practice arrays, loops, and functions, and to
see how math comes alive through code.

\subsubsection{97.1 Project Goal}\label{project-goal-6}

Your program will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Ask for the size of the matrices (rows and columns).
\item
  Ask the user to input two matrices.
\item
  Perform operations (add, subtract, multiply).
\item
  Display the results neatly.
\end{enumerate}

You'll get to see how code can work just like a calculator for grids of
numbers.

\subsubsection{97.2 What's a Matrix?}\label{whats-a-matrix}

A matrix is a rectangular array of numbers. Example (2 × 3 matrix):

\begin{verbatim}
1 2 3
4 5 6
\end{verbatim}

You can think of it like a 2D array:
\texttt{matrix{[}row{]}{[}column{]}}

C handles these easily with nested arrays.

\subsubsection{97.3 Declaring Matrices}\label{declaring-matrices}

Let's set up some matrices. For simplicity, we'll limit them to size 10
× 10:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ A}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],}\NormalTok{ B}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],}\NormalTok{ C}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{];}
\DataTypeTok{int}\NormalTok{ rows}\OperatorTok{,}\NormalTok{ cols}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Then ask the user for the size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter rows and columns (max 10): "}\OperatorTok{);}
\NormalTok{scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{rows}\OperatorTok{,} \OperatorTok{\&}\NormalTok{cols}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{97.4 Inputting Matrix
Values}\label{inputting-matrix-values}

Use nested loops to read each element:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter elements of Matrix A:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"A[}\SpecialCharTok{\%d}\StringTok{][}\SpecialCharTok{\%d}\StringTok{]: "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
    \OperatorTok{\}}
\OperatorTok{\}}

\NormalTok{printf}\OperatorTok{(}\StringTok{"Enter elements of Matrix B:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"B[}\SpecialCharTok{\%d}\StringTok{][}\SpecialCharTok{\%d}\StringTok{]: "}\OperatorTok{,}\NormalTok{ i}\OperatorTok{,}\NormalTok{ j}\OperatorTok{);}
\NormalTok{        scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{B}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This gives you two matrices filled with user input.

\subsubsection{97.5 Displaying a Matrix}\label{displaying-a-matrix}

Let's write a helper function to print any matrix:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ printMatrix}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ M}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],} \DataTypeTok{int}\NormalTok{ rows}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ cols}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%4d}\StringTok{"}\OperatorTok{,}\NormalTok{ M}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
        \OperatorTok{\}}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now you can call \texttt{printMatrix(A,\ rows,\ cols)} whenever you want
to show results.

\subsubsection{97.6 Adding and
Subtracting}\label{adding-and-subtracting}

Addition and subtraction are element-wise:

\begin{verbatim}
C[i][j] = A[i][j] + B[i][j];
C[i][j] = A[i][j] - B[i][j];
\end{verbatim}

Code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{+}\NormalTok{ B}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{];}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You can wrap this in a function like \texttt{addMatrices()}.

\subsubsection{97.7 Multiplying Matrices}\label{multiplying-matrices}

Matrix multiplication is trickier. For multiplication, the columns of A
must equal the rows of B. If A is (m × n), B must be (n × p), and result
C is (m × p).

Formula:

\begin{verbatim}
C[i][j] = sum(A[i][k] * B[k][j]) for k = 0..n-1
\end{verbatim}

Code:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ k }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ k }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ k}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{+=}\NormalTok{ A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{k}\OperatorTok{]} \OperatorTok{*}\NormalTok{ B}\OperatorTok{[}\NormalTok{k}\OperatorTok{][}\NormalTok{j}\OperatorTok{];}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{97.8 Full Program}\label{full-program-4}

Here's a simple version that performs addition, subtraction, and
multiplication:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{void}\NormalTok{ printMatrix}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ M}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],} \DataTypeTok{int}\NormalTok{ rows}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ cols}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%4d}\StringTok{"}\OperatorTok{,}\NormalTok{ M}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}
        \OperatorTok{\}}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ A}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],}\NormalTok{ B}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{],}\NormalTok{ C}\OperatorTok{[}\DecValTok{10}\OperatorTok{][}\DecValTok{10}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ rows}\OperatorTok{,}\NormalTok{ cols}\OperatorTok{;}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter rows and columns (max 10): "}\OperatorTok{);}
\NormalTok{    scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{rows}\OperatorTok{,} \OperatorTok{\&}\NormalTok{cols}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter elements of Matrix A:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)}
\NormalTok{            scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Enter elements of Matrix B:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)}
\NormalTok{            scanf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{,} \OperatorTok{\&}\NormalTok{B}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]);}

    \CommentTok{// Addition}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)}
\NormalTok{            C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{+}\NormalTok{ B}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Matrix Addition:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printMatrix}\OperatorTok{(}\NormalTok{C}\OperatorTok{,}\NormalTok{ rows}\OperatorTok{,}\NormalTok{ cols}\OperatorTok{);}

    \CommentTok{// Subtraction}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)}
\NormalTok{            C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{=}\NormalTok{ A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{{-}}\NormalTok{ B}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Matrix Subtraction:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printMatrix}\OperatorTok{(}\NormalTok{C}\OperatorTok{,}\NormalTok{ rows}\OperatorTok{,}\NormalTok{ cols}\OperatorTok{);}

    \CommentTok{// Multiplication}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ rows}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
        \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ j }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ j }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ j}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{            C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}
            \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ k }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ k }\OperatorTok{\textless{}}\NormalTok{ cols}\OperatorTok{;}\NormalTok{ k}\OperatorTok{++)}
\NormalTok{                C}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{j}\OperatorTok{]} \OperatorTok{+=}\NormalTok{ A}\OperatorTok{[}\NormalTok{i}\OperatorTok{][}\NormalTok{k}\OperatorTok{]} \OperatorTok{*}\NormalTok{ B}\OperatorTok{[}\NormalTok{k}\OperatorTok{][}\NormalTok{j}\OperatorTok{];}
        \OperatorTok{\}}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Matrix Multiplication:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\NormalTok{    printMatrix}\OperatorTok{(}\NormalTok{C}\OperatorTok{,}\NormalTok{ rows}\OperatorTok{,}\NormalTok{ cols}\OperatorTok{);}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{97.9 Example Run}\label{example-run-6}

\begin{verbatim}
Enter rows and columns (max 10): 2 2
Enter elements of Matrix A:
1 2
3 4
Enter elements of Matrix B:
5 6
7 8

Matrix Addition:
   6   8
  10  12

Matrix Subtraction:
  -4  -4
  -4  -4

Matrix Multiplication:
  19  22
  43  50
\end{verbatim}

\subsubsection{97.10 Tiny Improvements}\label{tiny-improvements-5}

\begin{itemize}
\tightlist
\item
  Add menu options for which operation to perform.
\item
  Save results to a file.
\item
  Handle rectangular (non-square) matrices.
\item
  Support scalar multiplication (multiply by a number).
\item
  Display formatted output (row by row).
\end{itemize}

Each upgrade helps you understand both math and memory layout in C.

\subsubsection{Why It Matters}\label{why-it-matters-96}

This project shows how data structures, loops, and logic combine to
solve real math problems. You're building a mini tool that's part of the
foundation of scientific computing, graphics, and machine learning.

\subsubsection{Try It Yourself}\label{try-it-yourself-96}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a menu to choose between add, subtract, multiply.
\item
  Add a function \texttt{inputMatrix()} to reduce repeated code.
\item
  Support matrices of different shapes for multiplication.
\item
  Save results into a file called \texttt{matrix\_output.txt}.
\item
  Try extending to floating-point matrices (\texttt{double} instead of
  \texttt{int}).
\end{enumerate}

With this project, you're not just manipulating numbers, you're building
a tiny math engine of your own!

\subsection{98. Mini Project 8: JSON-like
Parser}\label{mini-project-8-json-like-parser}

Let's take a small step into parsing, the process of reading structured
text and turning it into data a program can use.

In this project, you'll build a simple JSON-like parser. It won't handle
every detail of JSON, but it will read key--value pairs from a file and
store them in memory.

By the end, you'll have a program that can load a configuration-style
file like this:

\begin{verbatim}
name: Alice
age: 25
language: C
\end{verbatim}

\ldots and print out the keys and values neatly.

This is your first taste of how real programs read settings, configs,
and even APIs!

\subsubsection{98.1 Project Goal}\label{project-goal-7}

You'll build a parser that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reads a text file line by line.
\item
  Splits each line into a key and value at \texttt{:}.
\item
  Stores them in an array of structs.
\item
  Prints all key--value pairs.
\end{enumerate}

This is a simple, human-readable data format, perfect for beginners to
parsing.

\subsubsection{98.2 Why JSON-like}\label{why-json-like}

Real JSON uses braces and quotes, like
\texttt{\{\ "name":\ "Alice"\ \}}. But parsing JSON fully is a big job.
So we'll start simpler, one \texttt{key:\ value} per line, then later
you can extend it.

\subsubsection{98.3 Data Structure}\label{data-structure}

We'll store each key--value pair in a struct:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ key}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ value}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Then keep them in an array:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Entry entries}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{98.4 Input File Example}\label{input-file-example}

Save this to a file called \texttt{data.txt}:

\begin{verbatim}
name: Alice
age: 25
language: C
editor: vim
\end{verbatim}

Your program will read it, store each pair, and print them out.

\subsubsection{98.5 Reading the File}\label{reading-the-file-1}

Open it safely:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can read each line with \texttt{fgets}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{200}\OperatorTok{];}
\ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// process each line}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{98.6 Splitting Key and
Value}\label{splitting-key-and-value}

Each line has \texttt{key:\ value}. We can use \texttt{strtok} to split:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{key }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \StringTok{":"}\OperatorTok{);}
\DataTypeTok{char} \OperatorTok{*}\NormalTok{value }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

We'll clean up extra spaces:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{key}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(*}\NormalTok{key }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ key}\OperatorTok{++;} \CommentTok{// skip spaces}
\OperatorTok{\}}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{value}\OperatorTok{)} \OperatorTok{\{}
    \ControlFlowTok{while} \OperatorTok{(*}\NormalTok{value }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ value}\OperatorTok{++;} \CommentTok{// skip spaces}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then store:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{entries}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{key}\OperatorTok{,}\NormalTok{ key}\OperatorTok{);}
\NormalTok{strcpy}\OperatorTok{(}\NormalTok{entries}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{value}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{count}\OperatorTok{++;}
\end{Highlighting}
\end{Shaded}

\subsubsection{98.7 Printing Results}\label{printing-results}

After reading all lines:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Parsed key–value pairs:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ entries}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{key}\OperatorTok{,}\NormalTok{ entries}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{value}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

That's it, a simple parser!

\subsubsection{98.8 Full Program}\label{full-program-5}

Here's the complete code:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\KeywordTok{struct}\NormalTok{ Entry }\OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ key}\OperatorTok{[}\DecValTok{50}\OperatorTok{];}
    \DataTypeTok{char}\NormalTok{ value}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\OperatorTok{\};}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{struct}\NormalTok{ Entry entries}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
    \DataTypeTok{int}\NormalTok{ count }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}

    \DataTypeTok{FILE} \OperatorTok{*}\NormalTok{f }\OperatorTok{=}\NormalTok{ fopen}\OperatorTok{(}\StringTok{"data.txt"}\OperatorTok{,} \StringTok{"r"}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{==}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"Error opening file"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \DataTypeTok{char}\NormalTok{ line}\OperatorTok{[}\DecValTok{200}\OperatorTok{];}
    \ControlFlowTok{while} \OperatorTok{(}\NormalTok{fgets}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{line}\OperatorTok{),}\NormalTok{ f}\OperatorTok{)} \OperatorTok{!=}\NormalTok{ NULL}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{key }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{line}\OperatorTok{,} \StringTok{":"}\OperatorTok{);}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{value }\OperatorTok{=}\NormalTok{ strtok}\OperatorTok{(}\NormalTok{NULL}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{key }\OperatorTok{\&\&}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}
            \ControlFlowTok{while} \OperatorTok{(*}\NormalTok{key }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ key}\OperatorTok{++;}
            \ControlFlowTok{while} \OperatorTok{(*}\NormalTok{value }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ value}\OperatorTok{++;}
\NormalTok{            strcpy}\OperatorTok{(}\NormalTok{entries}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{key}\OperatorTok{,}\NormalTok{ key}\OperatorTok{);}
\NormalTok{            strcpy}\OperatorTok{(}\NormalTok{entries}\OperatorTok{[}\NormalTok{count}\OperatorTok{].}\NormalTok{value}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{            count}\OperatorTok{++;}
        \OperatorTok{\}}
    \OperatorTok{\}}

\NormalTok{    fclose}\OperatorTok{(}\NormalTok{f}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Parsed key–value pairs:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ = }\SpecialCharTok{\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ entries}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{key}\OperatorTok{,}\NormalTok{ entries}\OperatorTok{[}\NormalTok{i}\OperatorTok{].}\NormalTok{value}\OperatorTok{);}
    \OperatorTok{\}}

    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{98.9 Example Run}\label{example-run-7}

If \texttt{data.txt} contains:

\begin{verbatim}
name: Alice
age: 25
language: C
\end{verbatim}

You'll see:

\begin{verbatim}
Parsed key–value pairs:
name = Alice
age = 25
language = C
\end{verbatim}

\subsubsection{98.10 Tiny Improvements}\label{tiny-improvements-6}

Once your parser works, try these upgrades:

\begin{itemize}
\tightlist
\item
  Ask for a filename (\texttt{./parser\ settings.txt})
\item
  Ignore empty lines or comments starting with \texttt{\#}
\item
  Save parsed entries to another file
\item
  Let users search by key
\item
  Trim whitespace more carefully
\end{itemize}

Each feature brings you closer to a real-world config reader.

\subsubsection{Why It Matters}\label{why-it-matters-97}

Parsing is how programs understand text. From config files to JSON APIs,
the same core idea applies, read, split, store, and use.

You're now building a foundation for handling structured data, one of
the most important skills in programming.

\subsubsection{Try It Yourself}\label{try-it-yourself-97}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add support for comments starting with \texttt{\#}.
\item
  Skip blank lines.
\item
  Ask for a key and print its value if found.
\item
  Add error handling for malformed lines.
\item
  Save results to a \texttt{parsed.txt} file.
\end{enumerate}

You've just built your first parser, simple, useful, and a great step
toward working with real-world data formats.

\subsection{99. Mini Project 9: Mini
Shell}\label{mini-project-9-mini-shell}

Now it's time to make something that feels truly interactive, a Mini
Shell.

A shell is a program that takes user commands, runs them, and shows the
results. You've already been using one every time you type commands like
\texttt{gcc\ main.c} or \texttt{ls} in your terminal.

In this project, you'll build a small version of that, a program that
reads commands from the user and executes them using C's system calls.

It's a fantastic way to practice loops, strings, and system interaction.

\subsubsection{99.1 Project Goal}\label{project-goal-8}

Your mini shell will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Display a prompt (like \texttt{\$}).
\item
  Read a command from the user.
\item
  Run the command using the system.
\item
  Repeat until the user types \texttt{exit}.
\end{enumerate}

It's simple, powerful, and gives you a peek behind the curtain of how
real shells like bash or zsh work.

\subsubsection{99.2 What You'll Practice}\label{what-youll-practice-1}

\begin{itemize}
\tightlist
\item
  Working with strings and \texttt{fgets}
\item
  Using the system() function
\item
  Building a command loop
\item
  Handling special commands like \texttt{exit}
\end{itemize}

This project shows how a small program can act as a gateway to the whole
operating system.

\subsubsection{99.3 Starting with the
Prompt}\label{starting-with-the-prompt}

Let's start with a friendly prompt and input loop:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ command}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"$ "}\OperatorTok{);}                    \CommentTok{// prompt}
\NormalTok{        fgets}\OperatorTok{(}\NormalTok{command}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{command}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}

        \CommentTok{// remove newline at end}
\NormalTok{        command}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{command}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

        \CommentTok{// check for exit}
        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{command}\OperatorTok{,} \StringTok{"exit"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{break}\OperatorTok{;}

        \CommentTok{// execute the command}
\NormalTok{        system}\OperatorTok{(}\NormalTok{command}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

That's already a working mini shell!

\subsubsection{99.4 Example Run}\label{example-run-8}

\begin{verbatim}
$ ls
main.c  notes.txt  program
$ date
Thu Oct  2 10:30:21 2025
$ echo Hello World
Hello World
$ exit
Goodbye!
\end{verbatim}

Every line you type is passed to your operating system's shell via
\texttt{system()}, your program is acting as a middleman.

\subsubsection{\texorpdfstring{99.5 Understanding
\texttt{system()}}{99.5 Understanding system()}}\label{understanding-system}

The \texttt{system()} function runs any command exactly as if you'd
typed it in a normal terminal.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{system}\OperatorTok{(}\StringTok{"ls"}\OperatorTok{);}
\NormalTok{system}\OperatorTok{(}\StringTok{"gcc main.c {-}o main"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

It's great for quick experiments, but always be careful with untrusted
input in real-world apps.

\subsubsection{99.6 Adding a Welcome
Message}\label{adding-a-welcome-message}

Let's greet the user:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf}\OperatorTok{(}\StringTok{"Welcome to MiniShell! Type \textquotesingle{}exit\textquotesingle{} to quit.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

So the program feels more complete.

\subsubsection{99.7 Handling Empty Input}\label{handling-empty-input}

If the user presses Enter without typing anything, we don't need to run
a command. Add a quick check:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{strlen}\OperatorTok{(}\NormalTok{command}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
    \ControlFlowTok{continue}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This avoids running blank lines.

\subsubsection{99.8 Ignoring Leading
Spaces}\label{ignoring-leading-spaces}

We can also skip leading spaces:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char} \OperatorTok{*}\NormalTok{cmd }\OperatorTok{=}\NormalTok{ command}\OperatorTok{;}
\ControlFlowTok{while} \OperatorTok{(*}\NormalTok{cmd }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ cmd}\OperatorTok{++;}
\ControlFlowTok{if} \OperatorTok{(*}\NormalTok{cmd }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{)} \ControlFlowTok{continue}\OperatorTok{;}
\NormalTok{system}\OperatorTok{(}\NormalTok{cmd}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This small fix makes your shell a bit smarter.

\subsubsection{99.9 Full Program}\label{full-program-6}

Here's your improved Mini Shell:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{char}\NormalTok{ command}\OperatorTok{[}\DecValTok{100}\OperatorTok{];}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Welcome to MiniShell! Type \textquotesingle{}exit\textquotesingle{} to quit.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \ControlFlowTok{while} \OperatorTok{(}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        printf}\OperatorTok{(}\StringTok{"$ "}\OperatorTok{);}
\NormalTok{        fgets}\OperatorTok{(}\NormalTok{command}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{command}\OperatorTok{),}\NormalTok{ stdin}\OperatorTok{);}
\NormalTok{        command}\OperatorTok{[}\NormalTok{strcspn}\OperatorTok{(}\NormalTok{command}\OperatorTok{,} \StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{)]} \OperatorTok{=} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{;}

        \CommentTok{// Skip empty input}
        \DataTypeTok{char} \OperatorTok{*}\NormalTok{cmd }\OperatorTok{=}\NormalTok{ command}\OperatorTok{;}
        \ControlFlowTok{while} \OperatorTok{(*}\NormalTok{cmd }\OperatorTok{==} \CharTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{)}\NormalTok{ cmd}\OperatorTok{++;}
        \ControlFlowTok{if} \OperatorTok{(*}\NormalTok{cmd }\OperatorTok{==} \CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\OperatorTok{)}
            \ControlFlowTok{continue}\OperatorTok{;}

        \ControlFlowTok{if} \OperatorTok{(}\NormalTok{strcmp}\OperatorTok{(}\NormalTok{cmd}\OperatorTok{,} \StringTok{"exit"}\OperatorTok{)} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
            \ControlFlowTok{break}\OperatorTok{;}

\NormalTok{        system}\OperatorTok{(}\NormalTok{cmd}\OperatorTok{);}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{99.10 Tiny Improvements}\label{tiny-improvements-7}

Try enhancing your shell with new features:

\begin{itemize}
\tightlist
\item
  Built-in commands: implement \texttt{help}, \texttt{clear}, or
  \texttt{version}.
\item
  History: store recent commands in an array.
\item
  Custom prompt: show username or path.
\item
  Error handling: check \texttt{system()} return values.
\item
  Chaining: allow \texttt{;} to run multiple commands.
\end{itemize}

Each addition teaches you more about how real shells are built.

\subsubsection{Why It Matters}\label{why-it-matters-98}

This project connects C with your operating system. You're using C not
just for math or data, but to talk directly to the machine.

This is the essence of systems programming, giving you control over how
software and the OS interact.

\subsubsection{Try It Yourself}\label{try-it-yourself-98}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{help} command that lists built-in features.
\item
  Create a \texttt{clear} command that runs \texttt{system("clear")}.
\item
  Count how many commands the user has run.
\item
  Print the current working directory in the prompt.
\item
  Combine commands like \texttt{echo\ hi;\ date}.
\end{enumerate}

You've just built your first interactive shell, small but mighty. Every
line you type goes straight from your code to your computer, and that's
a powerful feeling.

\subsection{100. Mini Project 10: Tiny HTTP
Server}\label{mini-project-10-tiny-http-server}

You've come a long way, now let's finish with something truly exciting:
a Tiny HTTP Server.

This project will show you how to make your computer respond to web
requests, just like a real website does! You'll learn how servers listen
on a port, accept connections, and send back responses, all using plain
C.

Don't worry, we'll keep it simple. By the end, you'll be able to open
your browser, type \texttt{http://localhost:8080}, and see a message
served by your C program.

\subsubsection{100.1 Project Goal}\label{project-goal-9}

Your tiny server will:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Open a network socket on port 8080.
\item
  Wait for a browser (or client) to connect.
\item
  Read the incoming request.
\item
  Send a simple HTTP response.
\item
  Close the connection.
\end{enumerate}

It's a small step into network programming, and your first taste of
backend development.

\subsubsection{100.2 What You'll Learn}\label{what-youll-learn-1}

\begin{itemize}
\tightlist
\item
  How sockets let programs talk over the network
\item
  How to read and write data between server and client
\item
  What an HTTP request and response look like
\item
  How to test your server with a browser
\end{itemize}

You'll see how low-level code powers every web request.

\subsubsection{100.3 What Is HTTP?}\label{what-is-http}

HTTP (HyperText Transfer Protocol) is the language of the web.

When you visit a page, your browser sends a request:

\begin{verbatim}
GET / HTTP/1.1
Host: localhost
\end{verbatim}

And the server replies with a response:

\begin{verbatim}
HTTP/1.1 200 OK
Content-Type: text/plain

Hello, world!
\end{verbatim}

We'll build the simplest possible server that does exactly this.

\subsubsection{100.4 Including the Right
Headers}\label{including-the-right-headers}

Networking in C uses \texttt{\textless{}sys/socket.h\textgreater{}} and
\texttt{\textless{}netinet/in.h\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}
\end{Highlighting}
\end{Shaded}

You'll need these to open sockets and handle connections.

\subsubsection{100.5 Setting Up the Server
Socket}\label{setting-up-the-server-socket}

Let's start a server on port 8080:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ server\_fd }\OperatorTok{=}\NormalTok{ socket}\OperatorTok{(}\NormalTok{AF\_INET}\OperatorTok{,}\NormalTok{ SOCK\_STREAM}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{server\_fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"socket failed"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then set up the server address:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ sockaddr\_in address}\OperatorTok{;}
\NormalTok{address}\OperatorTok{.}\NormalTok{sin\_family }\OperatorTok{=}\NormalTok{ AF\_INET}\OperatorTok{;}
\NormalTok{address}\OperatorTok{.}\NormalTok{sin\_addr}\OperatorTok{.}\NormalTok{s\_addr }\OperatorTok{=}\NormalTok{ INADDR\_ANY}\OperatorTok{;}
\NormalTok{address}\OperatorTok{.}\NormalTok{sin\_port }\OperatorTok{=}\NormalTok{ htons}\OperatorTok{(}\DecValTok{8080}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Bind the socket and start listening:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{bind}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr}\OperatorTok{*)\&}\NormalTok{address}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{address}\OperatorTok{))} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"bind failed"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}

\ControlFlowTok{if} \OperatorTok{(}\NormalTok{listen}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \DecValTok{3}\OperatorTok{)} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"listen failed"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{100.6 Accepting a
Connection}\label{accepting-a-connection}

Once a client connects (like your browser), accept it:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ addrlen }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{address}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ new\_socket }\OperatorTok{=}\NormalTok{ accept}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr}\OperatorTok{*)\&}\NormalTok{address}\OperatorTok{,} \OperatorTok{(}\NormalTok{socklen\_t}\OperatorTok{*)\&}\NormalTok{addrlen}\OperatorTok{);}
\ControlFlowTok{if} \OperatorTok{(}\NormalTok{new\_socket }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    perror}\OperatorTok{(}\StringTok{"accept failed"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now you can read what the client sent!

\subsubsection{100.7 Reading the Request}\label{reading-the-request}

We'll store the request in a buffer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ buffer}\OperatorTok{[}\DecValTok{1024}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{read}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{));}
\NormalTok{printf}\OperatorTok{(}\StringTok{"Request:}\SpecialCharTok{\textbackslash{}n\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This shows the raw HTTP request from your browser, a great learning
moment.

\subsubsection{100.8 Sending the Response}\label{sending-the-response}

Now send a minimal HTTP reply:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ response}\OperatorTok{[]} \OperatorTok{=}
    \StringTok{"HTTP/1.1 200 OK}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
    \StringTok{"Content{-}Type: text/plain}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
    \StringTok{"Content{-}Length: 14}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
    \StringTok{"}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
    \StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{;}

\NormalTok{write}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{,}\NormalTok{ response}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{response}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Then close the connection:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{close}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

And keep listening for the next client if you want.

\subsubsection{100.9 Full Program}\label{full-program-7}

Here's the complete tiny HTTP server:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdlib.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}unistd.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}arpa/inet.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main}\OperatorTok{(}\DataTypeTok{void}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ server\_fd}\OperatorTok{,}\NormalTok{ new\_socket}\OperatorTok{;}
    \KeywordTok{struct}\NormalTok{ sockaddr\_in address}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ addrlen }\OperatorTok{=} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{address}\OperatorTok{);}

    \CommentTok{// 1. Create socket}
\NormalTok{    server\_fd }\OperatorTok{=}\NormalTok{ socket}\OperatorTok{(}\NormalTok{AF\_INET}\OperatorTok{,}\NormalTok{ SOCK\_STREAM}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{server\_fd }\OperatorTok{==} \OperatorTok{{-}}\DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"socket failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \CommentTok{// 2. Bind to port 8080}
\NormalTok{    address}\OperatorTok{.}\NormalTok{sin\_family }\OperatorTok{=}\NormalTok{ AF\_INET}\OperatorTok{;}
\NormalTok{    address}\OperatorTok{.}\NormalTok{sin\_addr}\OperatorTok{.}\NormalTok{s\_addr }\OperatorTok{=}\NormalTok{ INADDR\_ANY}\OperatorTok{;}
\NormalTok{    address}\OperatorTok{.}\NormalTok{sin\_port }\OperatorTok{=}\NormalTok{ htons}\OperatorTok{(}\DecValTok{8080}\OperatorTok{);}

    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{bind}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr}\OperatorTok{*)\&}\NormalTok{address}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{address}\OperatorTok{))} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"bind failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \CommentTok{// 3. Start listening}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{listen}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \DecValTok{3}\OperatorTok{)} \OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"listen failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Tiny HTTP Server running on http://localhost:8080}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}

    \CommentTok{// 4. Accept a single connection}
\NormalTok{    new\_socket }\OperatorTok{=}\NormalTok{ accept}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{,} \OperatorTok{(}\KeywordTok{struct}\NormalTok{ sockaddr}\OperatorTok{*)\&}\NormalTok{address}\OperatorTok{,} \OperatorTok{(}\NormalTok{socklen\_t}\OperatorTok{*)\&}\NormalTok{addrlen}\OperatorTok{);}
    \ControlFlowTok{if} \OperatorTok{(}\NormalTok{new\_socket }\OperatorTok{\textless{}} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        perror}\OperatorTok{(}\StringTok{"accept failed"}\OperatorTok{);}
        \ControlFlowTok{return} \DecValTok{1}\OperatorTok{;}
    \OperatorTok{\}}

    \CommentTok{// 5. Read the request}
    \DataTypeTok{char}\NormalTok{ buffer}\OperatorTok{[}\DecValTok{1024}\OperatorTok{]} \OperatorTok{=} \OperatorTok{\{}\DecValTok{0}\OperatorTok{\};}
\NormalTok{    read}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{,} \KeywordTok{sizeof}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{));}
\NormalTok{    printf}\OperatorTok{(}\StringTok{"Request received:}\SpecialCharTok{\textbackslash{}n\%s\textbackslash{}n}\StringTok{"}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{);}

    \CommentTok{// 6. Send a response}
    \DataTypeTok{char}\NormalTok{ response}\OperatorTok{[]} \OperatorTok{=}
        \StringTok{"HTTP/1.1 200 OK}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Content{-}Type: text/plain}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Content{-}Length: 14}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"}\SpecialCharTok{\textbackslash{}r\textbackslash{}n}\StringTok{"}
        \StringTok{"Hello, world!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{;}
\NormalTok{    write}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{,}\NormalTok{ response}\OperatorTok{,}\NormalTok{ strlen}\OperatorTok{(}\NormalTok{response}\OperatorTok{));}

    \CommentTok{// 7. Close sockets}
\NormalTok{    close}\OperatorTok{(}\NormalTok{new\_socket}\OperatorTok{);}
\NormalTok{    close}\OperatorTok{(}\NormalTok{server\_fd}\OperatorTok{);}

\NormalTok{    printf}\OperatorTok{(}\StringTok{"Response sent. Goodbye!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
    \ControlFlowTok{return} \DecValTok{0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{100.10 Example Run}\label{example-run-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compile it:
\end{enumerate}

\begin{verbatim}
gcc tiny_http.c -o tiny_http
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Run it:
\end{enumerate}

\begin{verbatim}
./tiny_http
Tiny HTTP Server running on http://localhost:8080
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Open your browser and go to:
\end{enumerate}

\begin{verbatim}
http://localhost:8080
\end{verbatim}

You'll see:

\begin{verbatim}
Hello, world!
\end{verbatim}

\subsubsection{Tiny Improvements}\label{tiny-improvements-8}

\begin{itemize}
\tightlist
\item
  Serve an HTML file instead of plain text.
\item
  Handle multiple requests in a loop.
\item
  Add a log message for each connection.
\item
  Serve different responses for different URLs.
\item
  Experiment with ports (e.g.~3000, 5000).
\end{itemize}

Each change brings you closer to a real web server.

\subsubsection{Why It Matters}\label{why-it-matters-99}

This is a huge milestone, your code just talked to a browser! You've
stepped into network programming, the world of servers, APIs, and the
internet itself.

Everything from simple websites to large cloud systems starts here.

\subsubsection{Try It Yourself}\label{try-it-yourself-99}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace the text with a short HTML page.
\item
  Print the client's IP address.
\item
  Add a loop to handle more than one request.
\item
  Save each request into a log file.
\item
  Return different messages for \texttt{/hello} and \texttt{/bye}.
\end{enumerate}

With this tiny server, you've closed the loop: from your terminal to the
web. You've built software that listens, responds, and communicates, the
heart of modern computing.




\end{document}
